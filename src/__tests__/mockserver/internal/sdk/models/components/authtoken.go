// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type TypeTeam string

const (
	TypeTeamTeam TypeTeam = "team"
)

func (e TypeTeam) ToPointer() *TypeTeam {
	return &e
}
func (e *TypeTeam) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		*e = TypeTeam(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeTeam: %v", v)
	}
}

type AuthTokenOrigin2 string

const (
	AuthTokenOrigin2Saml      AuthTokenOrigin2 = "saml"
	AuthTokenOrigin2Github    AuthTokenOrigin2 = "github"
	AuthTokenOrigin2Gitlab    AuthTokenOrigin2 = "gitlab"
	AuthTokenOrigin2Bitbucket AuthTokenOrigin2 = "bitbucket"
	AuthTokenOrigin2Email     AuthTokenOrigin2 = "email"
	AuthTokenOrigin2Manual    AuthTokenOrigin2 = "manual"
	AuthTokenOrigin2Passkey   AuthTokenOrigin2 = "passkey"
	AuthTokenOrigin2Otp       AuthTokenOrigin2 = "otp"
	AuthTokenOrigin2Sms       AuthTokenOrigin2 = "sms"
	AuthTokenOrigin2Invite    AuthTokenOrigin2 = "invite"
	AuthTokenOrigin2Google    AuthTokenOrigin2 = "google"
	AuthTokenOrigin2Apple     AuthTokenOrigin2 = "apple"
	AuthTokenOrigin2App       AuthTokenOrigin2 = "app"
)

func (e AuthTokenOrigin2) ToPointer() *AuthTokenOrigin2 {
	return &e
}
func (e *AuthTokenOrigin2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "saml":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "email":
		fallthrough
	case "manual":
		fallthrough
	case "passkey":
		fallthrough
	case "otp":
		fallthrough
	case "sms":
		fallthrough
	case "invite":
		fallthrough
	case "google":
		fallthrough
	case "apple":
		fallthrough
	case "app":
		*e = AuthTokenOrigin2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AuthTokenOrigin2: %v", v)
	}
}

// ScopeTeam - The access scopes granted to the token.
type ScopeTeam struct {
	Type      TypeTeam          `json:"type"`
	TeamID    string            `json:"teamId"`
	Origin    *AuthTokenOrigin2 `json:"origin,omitempty"`
	CreatedAt float64           `json:"createdAt"`
	ExpiresAt *float64          `json:"expiresAt,omitempty"`
}

func (s ScopeTeam) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScopeTeam) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "teamId", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ScopeTeam) GetType() TypeTeam {
	if o == nil {
		return TypeTeam("")
	}
	return o.Type
}

func (o *ScopeTeam) GetTeamID() string {
	if o == nil {
		return ""
	}
	return o.TeamID
}

func (o *ScopeTeam) GetOrigin() *AuthTokenOrigin2 {
	if o == nil {
		return nil
	}
	return o.Origin
}

func (o *ScopeTeam) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ScopeTeam) GetExpiresAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

type AuthTokenTypeUser string

const (
	AuthTokenTypeUserUser AuthTokenTypeUser = "user"
)

func (e AuthTokenTypeUser) ToPointer() *AuthTokenTypeUser {
	return &e
}
func (e *AuthTokenTypeUser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = AuthTokenTypeUser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AuthTokenTypeUser: %v", v)
	}
}

// SudoOrigin - Possible multi-factor origins
type SudoOrigin string

const (
	SudoOriginTotp         SudoOrigin = "totp"
	SudoOriginWebauthn     SudoOrigin = "webauthn"
	SudoOriginRecoveryCode SudoOrigin = "recovery-code"
)

func (e SudoOrigin) ToPointer() *SudoOrigin {
	return &e
}
func (e *SudoOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "totp":
		fallthrough
	case "webauthn":
		fallthrough
	case "recovery-code":
		*e = SudoOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SudoOrigin: %v", v)
	}
}

type Sudo struct {
	// Possible multi-factor origins
	Origin    SudoOrigin `json:"origin"`
	ExpiresAt float64    `json:"expiresAt"`
}

func (s Sudo) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Sudo) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"origin", "expiresAt"}); err != nil {
		return err
	}
	return nil
}

func (o *Sudo) GetOrigin() SudoOrigin {
	if o == nil {
		return SudoOrigin("")
	}
	return o.Origin
}

func (o *Sudo) GetExpiresAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ExpiresAt
}

type AuthTokenOrigin1 string

const (
	AuthTokenOrigin1Saml      AuthTokenOrigin1 = "saml"
	AuthTokenOrigin1Github    AuthTokenOrigin1 = "github"
	AuthTokenOrigin1Gitlab    AuthTokenOrigin1 = "gitlab"
	AuthTokenOrigin1Bitbucket AuthTokenOrigin1 = "bitbucket"
	AuthTokenOrigin1Email     AuthTokenOrigin1 = "email"
	AuthTokenOrigin1Manual    AuthTokenOrigin1 = "manual"
	AuthTokenOrigin1Passkey   AuthTokenOrigin1 = "passkey"
	AuthTokenOrigin1Otp       AuthTokenOrigin1 = "otp"
	AuthTokenOrigin1Sms       AuthTokenOrigin1 = "sms"
	AuthTokenOrigin1Invite    AuthTokenOrigin1 = "invite"
	AuthTokenOrigin1Google    AuthTokenOrigin1 = "google"
	AuthTokenOrigin1Apple     AuthTokenOrigin1 = "apple"
	AuthTokenOrigin1App       AuthTokenOrigin1 = "app"
)

func (e AuthTokenOrigin1) ToPointer() *AuthTokenOrigin1 {
	return &e
}
func (e *AuthTokenOrigin1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "saml":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "email":
		fallthrough
	case "manual":
		fallthrough
	case "passkey":
		fallthrough
	case "otp":
		fallthrough
	case "sms":
		fallthrough
	case "invite":
		fallthrough
	case "google":
		fallthrough
	case "apple":
		fallthrough
	case "app":
		*e = AuthTokenOrigin1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AuthTokenOrigin1: %v", v)
	}
}

// ScopeUser - The access scopes granted to the token.
type ScopeUser struct {
	Type      AuthTokenTypeUser `json:"type"`
	Sudo      *Sudo             `json:"sudo,omitempty"`
	Origin    *AuthTokenOrigin1 `json:"origin,omitempty"`
	CreatedAt float64           `json:"createdAt"`
	ExpiresAt *float64          `json:"expiresAt,omitempty"`
}

func (s ScopeUser) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *ScopeUser) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ScopeUser) GetType() AuthTokenTypeUser {
	if o == nil {
		return AuthTokenTypeUser("")
	}
	return o.Type
}

func (o *ScopeUser) GetSudo() *Sudo {
	if o == nil {
		return nil
	}
	return o.Sudo
}

func (o *ScopeUser) GetOrigin() *AuthTokenOrigin1 {
	if o == nil {
		return nil
	}
	return o.Origin
}

func (o *ScopeUser) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ScopeUser) GetExpiresAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

type ScopeType string

const (
	ScopeTypeScopeUser ScopeType = "scope_User"
	ScopeTypeScopeTeam ScopeType = "scope_Team"
)

type Scope struct {
	ScopeUser *ScopeUser `queryParam:"inline"`
	ScopeTeam *ScopeTeam `queryParam:"inline"`

	Type ScopeType
}

func CreateScopeScopeUser(scopeUser ScopeUser) Scope {
	typ := ScopeTypeScopeUser

	return Scope{
		ScopeUser: &scopeUser,
		Type:      typ,
	}
}

func CreateScopeScopeTeam(scopeTeam ScopeTeam) Scope {
	typ := ScopeTypeScopeTeam

	return Scope{
		ScopeTeam: &scopeTeam,
		Type:      typ,
	}
}

func (u *Scope) UnmarshalJSON(data []byte) error {

	var scopeTeam ScopeTeam = ScopeTeam{}
	if err := utils.UnmarshalJSON(data, &scopeTeam, "", true, nil); err == nil {
		u.ScopeTeam = &scopeTeam
		u.Type = ScopeTypeScopeTeam
		return nil
	}

	var scopeUser ScopeUser = ScopeUser{}
	if err := utils.UnmarshalJSON(data, &scopeUser, "", true, nil); err == nil {
		u.ScopeUser = &scopeUser
		u.Type = ScopeTypeScopeUser
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Scope", string(data))
}

func (u Scope) MarshalJSON() ([]byte, error) {
	if u.ScopeUser != nil {
		return utils.MarshalJSON(u.ScopeUser, "", true)
	}

	if u.ScopeTeam != nil {
		return utils.MarshalJSON(u.ScopeTeam, "", true)
	}

	return nil, errors.New("could not marshal union type Scope: all fields are null")
}

// AuthToken - Authentication token metadata.
type AuthToken struct {
	// The unique identifier of the token.
	ID string `json:"id"`
	// The human-readable name of the token.
	Name string `json:"name"`
	// The type of the token.
	Type string `json:"type"`
	// The origin of how the token was created.
	Origin *string `json:"origin,omitempty"`
	// The access scopes granted to the token.
	Scopes []Scope `json:"scopes,omitempty"`
	// Timestamp (in milliseconds) of when the token expires.
	ExpiresAt *float64 `json:"expiresAt,omitempty"`
	// Timestamp (in milliseconds) of when the token was most recently used.
	ActiveAt float64 `json:"activeAt"`
	// Timestamp (in milliseconds) of when the token was created.
	CreatedAt float64 `json:"createdAt"`
}

func (o *AuthToken) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *AuthToken) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *AuthToken) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *AuthToken) GetOrigin() *string {
	if o == nil {
		return nil
	}
	return o.Origin
}

func (o *AuthToken) GetScopes() []Scope {
	if o == nil {
		return nil
	}
	return o.Scopes
}

func (o *AuthToken) GetExpiresAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

func (o *AuthToken) GetActiveAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ActiveAt
}

func (o *AuthToken) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}
