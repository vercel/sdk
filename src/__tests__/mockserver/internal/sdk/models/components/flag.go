// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type ValueType string

const (
	ValueTypeStr     ValueType = "str"
	ValueTypeNumber  ValueType = "number"
	ValueTypeBoolean ValueType = "boolean"
)

type Value struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ValueType
}

func CreateValueStr(str string) Value {
	typ := ValueTypeStr

	return Value{
		Str:  &str,
		Type: typ,
	}
}

func CreateValueNumber(number float64) Value {
	typ := ValueTypeNumber

	return Value{
		Number: &number,
		Type:   typ,
	}
}

func CreateValueBoolean(boolean bool) Value {
	typ := ValueTypeBoolean

	return Value{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *Value) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ValueTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ValueTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ValueTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Value", string(data))
}

func (u Value) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type Value: all fields are null")
}

type Variant struct {
	Description *string `json:"description,omitempty"`
	Label       *string `json:"label,omitempty"`
	Value       Value   `json:"value"`
	ID          string  `json:"id"`
}

func (o *Variant) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Variant) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *Variant) GetValue() Value {
	if o == nil {
		return Value{}
	}
	return o.Value
}

func (o *Variant) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type Reuse struct {
	Active      bool   `json:"active"`
	Environment string `json:"environment"`
}

func (o *Reuse) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *Reuse) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type FlagTarget struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *FlagTarget) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *FlagTarget) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type TypeVariant string

const (
	TypeVariantVariant TypeVariant = "variant"
)

func (e TypeVariant) ToPointer() *TypeVariant {
	return &e
}
func (e *TypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = TypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeVariant: %v", v)
	}
}

type PausedOutcome struct {
	Type      TypeVariant `json:"type"`
	VariantID string      `json:"variantId"`
}

func (o *PausedOutcome) GetType() TypeVariant {
	if o == nil {
		return TypeVariant("")
	}
	return o.Type
}

func (o *PausedOutcome) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type FallthroughTypeSplit string

const (
	FallthroughTypeSplitSplit FallthroughTypeSplit = "split"
)

func (e FallthroughTypeSplit) ToPointer() *FallthroughTypeSplit {
	return &e
}
func (e *FallthroughTypeSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = FallthroughTypeSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeSplit: %v", v)
	}
}

type FallthroughTypeEntity string

const (
	FallthroughTypeEntityEntity FallthroughTypeEntity = "entity"
)

func (e FallthroughTypeEntity) ToPointer() *FallthroughTypeEntity {
	return &e
}
func (e *FallthroughTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = FallthroughTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeEntity: %v", v)
	}
}

type FallthroughBase struct {
	Type      FallthroughTypeEntity `json:"type"`
	Kind      string                `json:"kind"`
	Attribute string                `json:"attribute"`
}

func (f FallthroughBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughBase) GetType() FallthroughTypeEntity {
	if o == nil {
		return FallthroughTypeEntity("")
	}
	return o.Type
}

func (o *FallthroughBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *FallthroughBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type FallthroughSplit struct {
	Type             FallthroughTypeSplit `json:"type"`
	Base             FallthroughBase      `json:"base"`
	Weights          map[string]float64   `json:"weights"`
	DefaultVariantID string               `json:"defaultVariantId"`
}

func (f FallthroughSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughSplit) GetType() FallthroughTypeSplit {
	if o == nil {
		return FallthroughTypeSplit("")
	}
	return o.Type
}

func (o *FallthroughSplit) GetBase() FallthroughBase {
	if o == nil {
		return FallthroughBase{}
	}
	return o.Base
}

func (o *FallthroughSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *FallthroughSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type FallthroughTypeVariant string

const (
	FallthroughTypeVariantVariant FallthroughTypeVariant = "variant"
)

func (e FallthroughTypeVariant) ToPointer() *FallthroughTypeVariant {
	return &e
}
func (e *FallthroughTypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = FallthroughTypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeVariant: %v", v)
	}
}

type FallthroughVariant struct {
	Type      FallthroughTypeVariant `json:"type"`
	VariantID string                 `json:"variantId"`
}

func (f FallthroughVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughVariant) GetType() FallthroughTypeVariant {
	if o == nil {
		return FallthroughTypeVariant("")
	}
	return o.Type
}

func (o *FallthroughVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type FallthroughType string

const (
	FallthroughTypeVariantValue FallthroughType = "variant"
	FallthroughTypeSplitValue   FallthroughType = "split"
)

type Fallthrough struct {
	FallthroughVariant *FallthroughVariant `queryParam:"inline"`
	FallthroughSplit   *FallthroughSplit   `queryParam:"inline"`

	Type FallthroughType
}

func CreateFallthroughVariant(variant FallthroughVariant) Fallthrough {
	typ := FallthroughTypeVariantValue

	typStr := FallthroughTypeVariant(typ)
	variant.Type = typStr

	return Fallthrough{
		FallthroughVariant: &variant,
		Type:               typ,
	}
}

func CreateFallthroughSplit(split FallthroughSplit) Fallthrough {
	typ := FallthroughTypeSplitValue

	typStr := FallthroughTypeSplit(typ)
	split.Type = typStr

	return Fallthrough{
		FallthroughSplit: &split,
		Type:             typ,
	}
}

func (u *Fallthrough) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		fallthroughVariant := new(FallthroughVariant)
		if err := utils.UnmarshalJSON(data, &fallthroughVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type FallthroughVariant within Fallthrough: %w", string(data), err)
		}

		u.FallthroughVariant = fallthroughVariant
		u.Type = FallthroughTypeVariantValue
		return nil
	case "split":
		fallthroughSplit := new(FallthroughSplit)
		if err := utils.UnmarshalJSON(data, &fallthroughSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type FallthroughSplit within Fallthrough: %w", string(data), err)
		}

		u.FallthroughSplit = fallthroughSplit
		u.Type = FallthroughTypeSplitValue
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Fallthrough", string(data))
}

func (u Fallthrough) MarshalJSON() ([]byte, error) {
	if u.FallthroughVariant != nil {
		return utils.MarshalJSON(u.FallthroughVariant, "", true)
	}

	if u.FallthroughSplit != nil {
		return utils.MarshalJSON(u.FallthroughSplit, "", true)
	}

	return nil, errors.New("could not marshal union type Fallthrough: all fields are null")
}

type FlagOutcomeTypeSplit string

const (
	FlagOutcomeTypeSplitSplit FlagOutcomeTypeSplit = "split"
)

func (e FlagOutcomeTypeSplit) ToPointer() *FlagOutcomeTypeSplit {
	return &e
}
func (e *FlagOutcomeTypeSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = FlagOutcomeTypeSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagOutcomeTypeSplit: %v", v)
	}
}

type FlagOutcomeTypeEntity string

const (
	FlagOutcomeTypeEntityEntity FlagOutcomeTypeEntity = "entity"
)

func (e FlagOutcomeTypeEntity) ToPointer() *FlagOutcomeTypeEntity {
	return &e
}
func (e *FlagOutcomeTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = FlagOutcomeTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagOutcomeTypeEntity: %v", v)
	}
}

type FlagOutcomeBase struct {
	Type      FlagOutcomeTypeEntity `json:"type"`
	Kind      string                `json:"kind"`
	Attribute string                `json:"attribute"`
}

func (f FlagOutcomeBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagOutcomeBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagOutcomeBase) GetType() FlagOutcomeTypeEntity {
	if o == nil {
		return FlagOutcomeTypeEntity("")
	}
	return o.Type
}

func (o *FlagOutcomeBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *FlagOutcomeBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type FlagOutcomeSplit struct {
	Type             FlagOutcomeTypeSplit `json:"type"`
	Base             FlagOutcomeBase      `json:"base"`
	Weights          map[string]float64   `json:"weights"`
	DefaultVariantID string               `json:"defaultVariantId"`
}

func (f FlagOutcomeSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagOutcomeSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagOutcomeSplit) GetType() FlagOutcomeTypeSplit {
	if o == nil {
		return FlagOutcomeTypeSplit("")
	}
	return o.Type
}

func (o *FlagOutcomeSplit) GetBase() FlagOutcomeBase {
	if o == nil {
		return FlagOutcomeBase{}
	}
	return o.Base
}

func (o *FlagOutcomeSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *FlagOutcomeSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type OutcomeTypeVariant string

const (
	OutcomeTypeVariantVariant OutcomeTypeVariant = "variant"
)

func (e OutcomeTypeVariant) ToPointer() *OutcomeTypeVariant {
	return &e
}
func (e *OutcomeTypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = OutcomeTypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutcomeTypeVariant: %v", v)
	}
}

type OutcomeVariant struct {
	Type      OutcomeTypeVariant `json:"type"`
	VariantID string             `json:"variantId"`
}

func (o OutcomeVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutcomeVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *OutcomeVariant) GetType() OutcomeTypeVariant {
	if o == nil {
		return OutcomeTypeVariant("")
	}
	return o.Type
}

func (o *OutcomeVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type FlagOutcomeUnionType string

const (
	FlagOutcomeUnionTypeVariant FlagOutcomeUnionType = "variant"
	FlagOutcomeUnionTypeSplit   FlagOutcomeUnionType = "split"
)

type FlagOutcomeUnion struct {
	OutcomeVariant   *OutcomeVariant   `queryParam:"inline"`
	FlagOutcomeSplit *FlagOutcomeSplit `queryParam:"inline"`

	Type FlagOutcomeUnionType
}

func CreateFlagOutcomeUnionVariant(variant OutcomeVariant) FlagOutcomeUnion {
	typ := FlagOutcomeUnionTypeVariant

	typStr := OutcomeTypeVariant(typ)
	variant.Type = typStr

	return FlagOutcomeUnion{
		OutcomeVariant: &variant,
		Type:           typ,
	}
}

func CreateFlagOutcomeUnionSplit(split FlagOutcomeSplit) FlagOutcomeUnion {
	typ := FlagOutcomeUnionTypeSplit

	typStr := FlagOutcomeTypeSplit(typ)
	split.Type = typStr

	return FlagOutcomeUnion{
		FlagOutcomeSplit: &split,
		Type:             typ,
	}
}

func (u *FlagOutcomeUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		outcomeVariant := new(OutcomeVariant)
		if err := utils.UnmarshalJSON(data, &outcomeVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type OutcomeVariant within FlagOutcomeUnion: %w", string(data), err)
		}

		u.OutcomeVariant = outcomeVariant
		u.Type = FlagOutcomeUnionTypeVariant
		return nil
	case "split":
		flagOutcomeSplit := new(FlagOutcomeSplit)
		if err := utils.UnmarshalJSON(data, &flagOutcomeSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type FlagOutcomeSplit within FlagOutcomeUnion: %w", string(data), err)
		}

		u.FlagOutcomeSplit = flagOutcomeSplit
		u.Type = FlagOutcomeUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FlagOutcomeUnion", string(data))
}

func (u FlagOutcomeUnion) MarshalJSON() ([]byte, error) {
	if u.OutcomeVariant != nil {
		return utils.MarshalJSON(u.OutcomeVariant, "", true)
	}

	if u.FlagOutcomeSplit != nil {
		return utils.MarshalJSON(u.FlagOutcomeSplit, "", true)
	}

	return nil, errors.New("could not marshal union type FlagOutcomeUnion: all fields are null")
}

type FlagTypeRegex string

const (
	FlagTypeRegexRegex FlagTypeRegex = "regex"
)

func (e FlagTypeRegex) ToPointer() *FlagTypeRegex {
	return &e
}
func (e *FlagTypeRegex) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		*e = FlagTypeRegex(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagTypeRegex: %v", v)
	}
}

type FlagRHSRegex struct {
	Type    FlagTypeRegex `json:"type"`
	Pattern string        `json:"pattern"`
	Flags   string        `json:"flags"`
}

func (f FlagRHSRegex) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagRHSRegex) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagRHSRegex) GetType() FlagTypeRegex {
	if o == nil {
		return FlagTypeRegex("")
	}
	return o.Type
}

func (o *FlagRHSRegex) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *FlagRHSRegex) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type FlagRHSType string

const (
	FlagRHSTypeListInline FlagRHSType = "list/inline"
	FlagRHSTypeList       FlagRHSType = "list"
)

func (e FlagRHSType) ToPointer() *FlagRHSType {
	return &e
}
func (e *FlagRHSType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = FlagRHSType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagRHSType: %v", v)
	}
}

type FlagItem2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (f FlagItem2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagItem2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagItem2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FlagItem2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *FlagItem2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type FlagItem1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (f FlagItem1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagItem1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagItem1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *FlagItem1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *FlagItem1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type FlagItemUnionType string

const (
	FlagItemUnionTypeFlagItem1 FlagItemUnionType = "Flag_item_1"
	FlagItemUnionTypeFlagItem2 FlagItemUnionType = "Flag_item_2"
)

type FlagItemUnion struct {
	FlagItem1 *FlagItem1 `queryParam:"inline"`
	FlagItem2 *FlagItem2 `queryParam:"inline"`

	Type FlagItemUnionType
}

func CreateFlagItemUnionFlagItem1(flagItem1 FlagItem1) FlagItemUnion {
	typ := FlagItemUnionTypeFlagItem1

	return FlagItemUnion{
		FlagItem1: &flagItem1,
		Type:      typ,
	}
}

func CreateFlagItemUnionFlagItem2(flagItem2 FlagItem2) FlagItemUnion {
	typ := FlagItemUnionTypeFlagItem2

	return FlagItemUnion{
		FlagItem2: &flagItem2,
		Type:      typ,
	}
}

func (u *FlagItemUnion) UnmarshalJSON(data []byte) error {

	var flagItem1 FlagItem1 = FlagItem1{}
	if err := utils.UnmarshalJSON(data, &flagItem1, "", true, nil); err == nil {
		u.FlagItem1 = &flagItem1
		u.Type = FlagItemUnionTypeFlagItem1
		return nil
	}

	var flagItem2 FlagItem2 = FlagItem2{}
	if err := utils.UnmarshalJSON(data, &flagItem2, "", true, nil); err == nil {
		u.FlagItem2 = &flagItem2
		u.Type = FlagItemUnionTypeFlagItem2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FlagItemUnion", string(data))
}

func (u FlagItemUnion) MarshalJSON() ([]byte, error) {
	if u.FlagItem1 != nil {
		return utils.MarshalJSON(u.FlagItem1, "", true)
	}

	if u.FlagItem2 != nil {
		return utils.MarshalJSON(u.FlagItem2, "", true)
	}

	return nil, errors.New("could not marshal union type FlagItemUnion: all fields are null")
}

type FlagRHS struct {
	Type  FlagRHSType     `json:"type"`
	Items []FlagItemUnion `json:"items"`
}

func (f FlagRHS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagRHS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagRHS) GetType() FlagRHSType {
	if o == nil {
		return FlagRHSType("")
	}
	return o.Type
}

func (o *FlagRHS) GetItems() []FlagItemUnion {
	if o == nil {
		return []FlagItemUnion{}
	}
	return o.Items
}

type FlagRHSUnionType string

const (
	FlagRHSUnionTypeStr          FlagRHSUnionType = "str"
	FlagRHSUnionTypeNumber       FlagRHSUnionType = "number"
	FlagRHSUnionTypeFlagRHS      FlagRHSUnionType = "Flag_rhs"
	FlagRHSUnionTypeFlagRHSRegex FlagRHSUnionType = "Flag_rhs_Regex"
	FlagRHSUnionTypeBoolean      FlagRHSUnionType = "boolean"
)

type FlagRHSUnion struct {
	Str          *string       `queryParam:"inline"`
	Number       *float64      `queryParam:"inline"`
	FlagRHS      *FlagRHS      `queryParam:"inline"`
	FlagRHSRegex *FlagRHSRegex `queryParam:"inline"`
	Boolean      *bool         `queryParam:"inline"`

	Type FlagRHSUnionType
}

func CreateFlagRHSUnionStr(str string) FlagRHSUnion {
	typ := FlagRHSUnionTypeStr

	return FlagRHSUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateFlagRHSUnionNumber(number float64) FlagRHSUnion {
	typ := FlagRHSUnionTypeNumber

	return FlagRHSUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateFlagRHSUnionFlagRHS(flagRHS FlagRHS) FlagRHSUnion {
	typ := FlagRHSUnionTypeFlagRHS

	return FlagRHSUnion{
		FlagRHS: &flagRHS,
		Type:    typ,
	}
}

func CreateFlagRHSUnionFlagRHSRegex(flagRHSRegex FlagRHSRegex) FlagRHSUnion {
	typ := FlagRHSUnionTypeFlagRHSRegex

	return FlagRHSUnion{
		FlagRHSRegex: &flagRHSRegex,
		Type:         typ,
	}
}

func CreateFlagRHSUnionBoolean(boolean bool) FlagRHSUnion {
	typ := FlagRHSUnionTypeBoolean

	return FlagRHSUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *FlagRHSUnion) UnmarshalJSON(data []byte) error {

	var flagRHSRegex FlagRHSRegex = FlagRHSRegex{}
	if err := utils.UnmarshalJSON(data, &flagRHSRegex, "", true, nil); err == nil {
		u.FlagRHSRegex = &flagRHSRegex
		u.Type = FlagRHSUnionTypeFlagRHSRegex
		return nil
	}

	var flagRHS FlagRHS = FlagRHS{}
	if err := utils.UnmarshalJSON(data, &flagRHS, "", true, nil); err == nil {
		u.FlagRHS = &flagRHS
		u.Type = FlagRHSUnionTypeFlagRHS
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = FlagRHSUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = FlagRHSUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = FlagRHSUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FlagRHSUnion", string(data))
}

func (u FlagRHSUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.FlagRHS != nil {
		return utils.MarshalJSON(u.FlagRHS, "", true)
	}

	if u.FlagRHSRegex != nil {
		return utils.MarshalJSON(u.FlagRHSRegex, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type FlagRHSUnion: all fields are null")
}

type FlagLHSTypeEntity string

const (
	FlagLHSTypeEntityEntity FlagLHSTypeEntity = "entity"
)

func (e FlagLHSTypeEntity) ToPointer() *FlagLHSTypeEntity {
	return &e
}
func (e *FlagLHSTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = FlagLHSTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagLHSTypeEntity: %v", v)
	}
}

type FlagLHSEntity struct {
	Type      FlagLHSTypeEntity `json:"type"`
	Kind      string            `json:"kind"`
	Attribute string            `json:"attribute"`
}

func (f FlagLHSEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagLHSEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagLHSEntity) GetType() FlagLHSTypeEntity {
	if o == nil {
		return FlagLHSTypeEntity("")
	}
	return o.Type
}

func (o *FlagLHSEntity) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *FlagLHSEntity) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type FlagTypeSegment string

const (
	FlagTypeSegmentSegment FlagTypeSegment = "segment"
)

func (e FlagTypeSegment) ToPointer() *FlagTypeSegment {
	return &e
}
func (e *FlagTypeSegment) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "segment":
		*e = FlagTypeSegment(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagTypeSegment: %v", v)
	}
}

type FlagLHSSegment struct {
	Type FlagTypeSegment `json:"type"`
}

func (f FlagLHSSegment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FlagLHSSegment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *FlagLHSSegment) GetType() FlagTypeSegment {
	if o == nil {
		return FlagTypeSegment("")
	}
	return o.Type
}

type FlagLHSUnionType string

const (
	FlagLHSUnionTypeSegment FlagLHSUnionType = "segment"
	FlagLHSUnionTypeEntity  FlagLHSUnionType = "entity"
)

type FlagLHSUnion struct {
	FlagLHSSegment *FlagLHSSegment `queryParam:"inline"`
	FlagLHSEntity  *FlagLHSEntity  `queryParam:"inline"`

	Type FlagLHSUnionType
}

func CreateFlagLHSUnionSegment(segment FlagLHSSegment) FlagLHSUnion {
	typ := FlagLHSUnionTypeSegment

	typStr := FlagTypeSegment(typ)
	segment.Type = typStr

	return FlagLHSUnion{
		FlagLHSSegment: &segment,
		Type:           typ,
	}
}

func CreateFlagLHSUnionEntity(entity FlagLHSEntity) FlagLHSUnion {
	typ := FlagLHSUnionTypeEntity

	typStr := FlagLHSTypeEntity(typ)
	entity.Type = typStr

	return FlagLHSUnion{
		FlagLHSEntity: &entity,
		Type:          typ,
	}
}

func (u *FlagLHSUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "segment":
		flagLHSSegment := new(FlagLHSSegment)
		if err := utils.UnmarshalJSON(data, &flagLHSSegment, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == segment) type FlagLHSSegment within FlagLHSUnion: %w", string(data), err)
		}

		u.FlagLHSSegment = flagLHSSegment
		u.Type = FlagLHSUnionTypeSegment
		return nil
	case "entity":
		flagLHSEntity := new(FlagLHSEntity)
		if err := utils.UnmarshalJSON(data, &flagLHSEntity, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == entity) type FlagLHSEntity within FlagLHSUnion: %w", string(data), err)
		}

		u.FlagLHSEntity = flagLHSEntity
		u.Type = FlagLHSUnionTypeEntity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FlagLHSUnion", string(data))
}

func (u FlagLHSUnion) MarshalJSON() ([]byte, error) {
	if u.FlagLHSSegment != nil {
		return utils.MarshalJSON(u.FlagLHSSegment, "", true)
	}

	if u.FlagLHSEntity != nil {
		return utils.MarshalJSON(u.FlagLHSEntity, "", true)
	}

	return nil, errors.New("could not marshal union type FlagLHSUnion: all fields are null")
}

type FlagCmp string

const (
	FlagCmpEq             FlagCmp = "eq"
	FlagCmpNotEq          FlagCmp = "!eq"
	FlagCmpOneOf          FlagCmp = "oneOf"
	FlagCmpNotOneOf       FlagCmp = "!oneOf"
	FlagCmpContainsAllOf  FlagCmp = "containsAllOf"
	FlagCmpContainsAnyOf  FlagCmp = "containsAnyOf"
	FlagCmpContainsNoneOf FlagCmp = "containsNoneOf"
	FlagCmpStartsWith     FlagCmp = "startsWith"
	FlagCmpNotStartsWith  FlagCmp = "!startsWith"
	FlagCmpEndsWith       FlagCmp = "endsWith"
	FlagCmpNotEndsWith    FlagCmp = "!endsWith"
	FlagCmpEx             FlagCmp = "ex"
	FlagCmpNotEx          FlagCmp = "!ex"
	FlagCmpGt             FlagCmp = "gt"
	FlagCmpGte            FlagCmp = "gte"
	FlagCmpLt             FlagCmp = "lt"
	FlagCmpLte            FlagCmp = "lte"
	FlagCmpRegex          FlagCmp = "regex"
	FlagCmpNotRegex       FlagCmp = "!regex"
	FlagCmpBefore         FlagCmp = "before"
	FlagCmpAfter          FlagCmp = "after"
)

func (e FlagCmp) ToPointer() *FlagCmp {
	return &e
}
func (e *FlagCmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = FlagCmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagCmp: %v", v)
	}
}

type FlagCondition struct {
	RHS *FlagRHSUnion `json:"rhs,omitempty"`
	LHS FlagLHSUnion  `json:"lhs"`
	Cmp FlagCmp       `json:"cmp"`
}

func (o *FlagCondition) GetRHS() *FlagRHSUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

func (o *FlagCondition) GetLHS() FlagLHSUnion {
	if o == nil {
		return FlagLHSUnion{}
	}
	return o.LHS
}

func (o *FlagCondition) GetLHSSegment() *FlagLHSSegment {
	return o.GetLHS().FlagLHSSegment
}

func (o *FlagCondition) GetLHSEntity() *FlagLHSEntity {
	return o.GetLHS().FlagLHSEntity
}

func (o *FlagCondition) GetCmp() FlagCmp {
	if o == nil {
		return FlagCmp("")
	}
	return o.Cmp
}

type FlagRule struct {
	ID         string           `json:"id"`
	Outcome    FlagOutcomeUnion `json:"outcome"`
	Conditions []FlagCondition  `json:"conditions"`
}

func (o *FlagRule) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *FlagRule) GetOutcome() FlagOutcomeUnion {
	if o == nil {
		return FlagOutcomeUnion{}
	}
	return o.Outcome
}

func (o *FlagRule) GetOutcomeVariant() *OutcomeVariant {
	return o.GetOutcome().OutcomeVariant
}

func (o *FlagRule) GetOutcomeSplit() *FlagOutcomeSplit {
	return o.GetOutcome().FlagOutcomeSplit
}

func (o *FlagRule) GetConditions() []FlagCondition {
	if o == nil {
		return []FlagCondition{}
	}
	return o.Conditions
}

type Environments struct {
	Reuse         *Reuse                                        `json:"reuse,omitempty"`
	Targets       map[string]map[string]map[string][]FlagTarget `json:"targets,omitempty"`
	Revision      *float64                                      `json:"revision,omitempty"`
	PausedOutcome PausedOutcome                                 `json:"pausedOutcome"`
	Fallthrough   Fallthrough                                   `json:"fallthrough"`
	Active        bool                                          `json:"active"`
	Rules         []FlagRule                                    `json:"rules"`
}

func (o *Environments) GetReuse() *Reuse {
	if o == nil {
		return nil
	}
	return o.Reuse
}

func (o *Environments) GetTargets() map[string]map[string]map[string][]FlagTarget {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *Environments) GetRevision() *float64 {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *Environments) GetPausedOutcome() PausedOutcome {
	if o == nil {
		return PausedOutcome{}
	}
	return o.PausedOutcome
}

func (o *Environments) GetFallthrough() Fallthrough {
	if o == nil {
		return Fallthrough{}
	}
	return o.Fallthrough
}

func (o *Environments) GetFallthroughVariant() *FallthroughVariant {
	return o.GetFallthrough().FallthroughVariant
}

func (o *Environments) GetFallthroughSplit() *FallthroughSplit {
	return o.GetFallthrough().FallthroughSplit
}

func (o *Environments) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *Environments) GetRules() []FlagRule {
	if o == nil {
		return []FlagRule{}
	}
	return o.Rules
}

type Kind string

const (
	KindString  Kind = "string"
	KindNumber  Kind = "number"
	KindBoolean Kind = "boolean"
)

func (e Kind) ToPointer() *Kind {
	return &e
}
func (e *Kind) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "string":
		fallthrough
	case "number":
		fallthrough
	case "boolean":
		*e = Kind(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Kind: %v", v)
	}
}

type State string

const (
	StateActive   State = "active"
	StateArchived State = "archived"
)

func (e State) ToPointer() *State {
	return &e
}
func (e *State) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "archived":
		*e = State(v)
		return nil
	default:
		return fmt.Errorf("invalid value for State: %v", v)
	}
}

type FlagTypeName string

const (
	FlagTypeNameFlag FlagTypeName = "flag"
)

func (e FlagTypeName) ToPointer() *FlagTypeName {
	return &e
}
func (e *FlagTypeName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flag":
		*e = FlagTypeName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FlagTypeName: %v", v)
	}
}

type FlagCreator struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (o *FlagCreator) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *FlagCreator) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

type FlagMetadata struct {
	Creator *FlagCreator `json:"creator,omitempty"`
}

func (o *FlagMetadata) GetCreator() *FlagCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

type Flag struct {
	Description  *string                 `json:"description,omitempty"`
	Variants     []Variant               `json:"variants"`
	ID           string                  `json:"id"`
	Environments map[string]Environments `json:"environments"`
	Kind         Kind                    `json:"kind"`
	Revision     float64                 `json:"revision"`
	Seed         float64                 `json:"seed"`
	State        State                   `json:"state"`
	Slug         string                  `json:"slug"`
	CreatedAt    float64                 `json:"createdAt"`
	UpdatedAt    float64                 `json:"updatedAt"`
	CreatedBy    string                  `json:"createdBy"`
	OwnerID      string                  `json:"ownerId"`
	ProjectID    string                  `json:"projectId"`
	TypeName     FlagTypeName            `json:"typeName"`
	Metadata     *FlagMetadata           `json:"metadata,omitempty"`
}

func (o *Flag) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Flag) GetVariants() []Variant {
	if o == nil {
		return []Variant{}
	}
	return o.Variants
}

func (o *Flag) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Flag) GetEnvironments() map[string]Environments {
	if o == nil {
		return map[string]Environments{}
	}
	return o.Environments
}

func (o *Flag) GetKind() Kind {
	if o == nil {
		return Kind("")
	}
	return o.Kind
}

func (o *Flag) GetRevision() float64 {
	if o == nil {
		return 0.0
	}
	return o.Revision
}

func (o *Flag) GetSeed() float64 {
	if o == nil {
		return 0.0
	}
	return o.Seed
}

func (o *Flag) GetState() State {
	if o == nil {
		return State("")
	}
	return o.State
}

func (o *Flag) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Flag) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *Flag) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *Flag) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *Flag) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *Flag) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *Flag) GetTypeName() FlagTypeName {
	if o == nil {
		return FlagTypeName("")
	}
	return o.TypeName
}

func (o *Flag) GetMetadata() *FlagMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}
