// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type SegmentTypeName string

const (
	SegmentTypeNameSegment SegmentTypeName = "segment"
)

func (e SegmentTypeName) ToPointer() *SegmentTypeName {
	return &e
}
func (e *SegmentTypeName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "segment":
		*e = SegmentTypeName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SegmentTypeName: %v", v)
	}
}

type DataTypeSplit string

const (
	DataTypeSplitSplit DataTypeSplit = "split"
)

func (e DataTypeSplit) ToPointer() *DataTypeSplit {
	return &e
}
func (e *DataTypeSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = DataTypeSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DataTypeSplit: %v", v)
	}
}

type OutcomeDataTypeEntity string

const (
	OutcomeDataTypeEntityEntity OutcomeDataTypeEntity = "entity"
)

func (e OutcomeDataTypeEntity) ToPointer() *OutcomeDataTypeEntity {
	return &e
}
func (e *OutcomeDataTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = OutcomeDataTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutcomeDataTypeEntity: %v", v)
	}
}

type SegmentBase struct {
	Type      OutcomeDataTypeEntity `json:"type"`
	Kind      string                `json:"kind"`
	Attribute string                `json:"attribute"`
}

func (s SegmentBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentBase) GetType() OutcomeDataTypeEntity {
	if o == nil {
		return OutcomeDataTypeEntity("")
	}
	return o.Type
}

func (o *SegmentBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *SegmentBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type SegmentOutcomeSplit struct {
	Type         DataTypeSplit `json:"type"`
	Base         SegmentBase   `json:"base"`
	PassPromille float64       `json:"passPromille"`
}

func (s SegmentOutcomeSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentOutcomeSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "base", "passPromille"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentOutcomeSplit) GetType() DataTypeSplit {
	if o == nil {
		return DataTypeSplit("")
	}
	return o.Type
}

func (o *SegmentOutcomeSplit) GetBase() SegmentBase {
	if o == nil {
		return SegmentBase{}
	}
	return o.Base
}

func (o *SegmentOutcomeSplit) GetPassPromille() float64 {
	if o == nil {
		return 0.0
	}
	return o.PassPromille
}

type TypeAll string

const (
	TypeAllAll TypeAll = "all"
)

func (e TypeAll) ToPointer() *TypeAll {
	return &e
}
func (e *TypeAll) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		*e = TypeAll(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeAll: %v", v)
	}
}

type OutcomeAll struct {
	Type TypeAll `json:"type"`
}

func (o OutcomeAll) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutcomeAll) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *OutcomeAll) GetType() TypeAll {
	if o == nil {
		return TypeAll("")
	}
	return o.Type
}

type SegmentOutcomeUnionType string

const (
	SegmentOutcomeUnionTypeAll   SegmentOutcomeUnionType = "all"
	SegmentOutcomeUnionTypeSplit SegmentOutcomeUnionType = "split"
)

type SegmentOutcomeUnion struct {
	OutcomeAll          *OutcomeAll          `queryParam:"inline"`
	SegmentOutcomeSplit *SegmentOutcomeSplit `queryParam:"inline"`

	Type SegmentOutcomeUnionType
}

func CreateSegmentOutcomeUnionAll(all OutcomeAll) SegmentOutcomeUnion {
	typ := SegmentOutcomeUnionTypeAll

	typStr := TypeAll(typ)
	all.Type = typStr

	return SegmentOutcomeUnion{
		OutcomeAll: &all,
		Type:       typ,
	}
}

func CreateSegmentOutcomeUnionSplit(split SegmentOutcomeSplit) SegmentOutcomeUnion {
	typ := SegmentOutcomeUnionTypeSplit

	typStr := DataTypeSplit(typ)
	split.Type = typStr

	return SegmentOutcomeUnion{
		SegmentOutcomeSplit: &split,
		Type:                typ,
	}
}

func (u *SegmentOutcomeUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "all":
		outcomeAll := new(OutcomeAll)
		if err := utils.UnmarshalJSON(data, &outcomeAll, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == all) type OutcomeAll within SegmentOutcomeUnion: %w", string(data), err)
		}

		u.OutcomeAll = outcomeAll
		u.Type = SegmentOutcomeUnionTypeAll
		return nil
	case "split":
		segmentOutcomeSplit := new(SegmentOutcomeSplit)
		if err := utils.UnmarshalJSON(data, &segmentOutcomeSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type SegmentOutcomeSplit within SegmentOutcomeUnion: %w", string(data), err)
		}

		u.SegmentOutcomeSplit = segmentOutcomeSplit
		u.Type = SegmentOutcomeUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SegmentOutcomeUnion", string(data))
}

func (u SegmentOutcomeUnion) MarshalJSON() ([]byte, error) {
	if u.OutcomeAll != nil {
		return utils.MarshalJSON(u.OutcomeAll, "", true)
	}

	if u.SegmentOutcomeSplit != nil {
		return utils.MarshalJSON(u.SegmentOutcomeSplit, "", true)
	}

	return nil, errors.New("could not marshal union type SegmentOutcomeUnion: all fields are null")
}

type DataTypeRegex string

const (
	DataTypeRegexRegex DataTypeRegex = "regex"
)

func (e DataTypeRegex) ToPointer() *DataTypeRegex {
	return &e
}
func (e *DataTypeRegex) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		*e = DataTypeRegex(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DataTypeRegex: %v", v)
	}
}

type SegmentRHSRegex struct {
	Type    DataTypeRegex `json:"type"`
	Pattern string        `json:"pattern"`
	Flags   string        `json:"flags"`
}

func (s SegmentRHSRegex) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentRHSRegex) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentRHSRegex) GetType() DataTypeRegex {
	if o == nil {
		return DataTypeRegex("")
	}
	return o.Type
}

func (o *SegmentRHSRegex) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *SegmentRHSRegex) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type RHSDataType string

const (
	RHSDataTypeListInline RHSDataType = "list/inline"
	RHSDataTypeList       RHSDataType = "list"
)

func (e RHSDataType) ToPointer() *RHSDataType {
	return &e
}
func (e *RHSDataType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = RHSDataType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RHSDataType: %v", v)
	}
}

type SegmentItem2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (s SegmentItem2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentItem2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentItem2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *SegmentItem2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *SegmentItem2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type SegmentItem1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (s SegmentItem1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentItem1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentItem1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *SegmentItem1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *SegmentItem1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type SegmentItemUnionType string

const (
	SegmentItemUnionTypeSegmentItem1 SegmentItemUnionType = "Segment_item_1"
	SegmentItemUnionTypeSegmentItem2 SegmentItemUnionType = "Segment_item_2"
)

type SegmentItemUnion struct {
	SegmentItem1 *SegmentItem1 `queryParam:"inline"`
	SegmentItem2 *SegmentItem2 `queryParam:"inline"`

	Type SegmentItemUnionType
}

func CreateSegmentItemUnionSegmentItem1(segmentItem1 SegmentItem1) SegmentItemUnion {
	typ := SegmentItemUnionTypeSegmentItem1

	return SegmentItemUnion{
		SegmentItem1: &segmentItem1,
		Type:         typ,
	}
}

func CreateSegmentItemUnionSegmentItem2(segmentItem2 SegmentItem2) SegmentItemUnion {
	typ := SegmentItemUnionTypeSegmentItem2

	return SegmentItemUnion{
		SegmentItem2: &segmentItem2,
		Type:         typ,
	}
}

func (u *SegmentItemUnion) UnmarshalJSON(data []byte) error {

	var segmentItem1 SegmentItem1 = SegmentItem1{}
	if err := utils.UnmarshalJSON(data, &segmentItem1, "", true, nil); err == nil {
		u.SegmentItem1 = &segmentItem1
		u.Type = SegmentItemUnionTypeSegmentItem1
		return nil
	}

	var segmentItem2 SegmentItem2 = SegmentItem2{}
	if err := utils.UnmarshalJSON(data, &segmentItem2, "", true, nil); err == nil {
		u.SegmentItem2 = &segmentItem2
		u.Type = SegmentItemUnionTypeSegmentItem2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SegmentItemUnion", string(data))
}

func (u SegmentItemUnion) MarshalJSON() ([]byte, error) {
	if u.SegmentItem1 != nil {
		return utils.MarshalJSON(u.SegmentItem1, "", true)
	}

	if u.SegmentItem2 != nil {
		return utils.MarshalJSON(u.SegmentItem2, "", true)
	}

	return nil, errors.New("could not marshal union type SegmentItemUnion: all fields are null")
}

type SegmentRHS struct {
	Type  RHSDataType        `json:"type"`
	Items []SegmentItemUnion `json:"items"`
}

func (s SegmentRHS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SegmentRHS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *SegmentRHS) GetType() RHSDataType {
	if o == nil {
		return RHSDataType("")
	}
	return o.Type
}

func (o *SegmentRHS) GetItems() []SegmentItemUnion {
	if o == nil {
		return []SegmentItemUnion{}
	}
	return o.Items
}

type SegmentRHSUnionType string

const (
	SegmentRHSUnionTypeStr             SegmentRHSUnionType = "str"
	SegmentRHSUnionTypeNumber          SegmentRHSUnionType = "number"
	SegmentRHSUnionTypeSegmentRHS      SegmentRHSUnionType = "Segment_rhs"
	SegmentRHSUnionTypeSegmentRHSRegex SegmentRHSUnionType = "Segment_rhs_Regex"
	SegmentRHSUnionTypeBoolean         SegmentRHSUnionType = "boolean"
)

type SegmentRHSUnion struct {
	Str             *string          `queryParam:"inline"`
	Number          *float64         `queryParam:"inline"`
	SegmentRHS      *SegmentRHS      `queryParam:"inline"`
	SegmentRHSRegex *SegmentRHSRegex `queryParam:"inline"`
	Boolean         *bool            `queryParam:"inline"`

	Type SegmentRHSUnionType
}

func CreateSegmentRHSUnionStr(str string) SegmentRHSUnion {
	typ := SegmentRHSUnionTypeStr

	return SegmentRHSUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateSegmentRHSUnionNumber(number float64) SegmentRHSUnion {
	typ := SegmentRHSUnionTypeNumber

	return SegmentRHSUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateSegmentRHSUnionSegmentRHS(segmentRHS SegmentRHS) SegmentRHSUnion {
	typ := SegmentRHSUnionTypeSegmentRHS

	return SegmentRHSUnion{
		SegmentRHS: &segmentRHS,
		Type:       typ,
	}
}

func CreateSegmentRHSUnionSegmentRHSRegex(segmentRHSRegex SegmentRHSRegex) SegmentRHSUnion {
	typ := SegmentRHSUnionTypeSegmentRHSRegex

	return SegmentRHSUnion{
		SegmentRHSRegex: &segmentRHSRegex,
		Type:            typ,
	}
}

func CreateSegmentRHSUnionBoolean(boolean bool) SegmentRHSUnion {
	typ := SegmentRHSUnionTypeBoolean

	return SegmentRHSUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *SegmentRHSUnion) UnmarshalJSON(data []byte) error {

	var segmentRHSRegex SegmentRHSRegex = SegmentRHSRegex{}
	if err := utils.UnmarshalJSON(data, &segmentRHSRegex, "", true, nil); err == nil {
		u.SegmentRHSRegex = &segmentRHSRegex
		u.Type = SegmentRHSUnionTypeSegmentRHSRegex
		return nil
	}

	var segmentRHS SegmentRHS = SegmentRHS{}
	if err := utils.UnmarshalJSON(data, &segmentRHS, "", true, nil); err == nil {
		u.SegmentRHS = &segmentRHS
		u.Type = SegmentRHSUnionTypeSegmentRHS
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SegmentRHSUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = SegmentRHSUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = SegmentRHSUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SegmentRHSUnion", string(data))
}

func (u SegmentRHSUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.SegmentRHS != nil {
		return utils.MarshalJSON(u.SegmentRHS, "", true)
	}

	if u.SegmentRHSRegex != nil {
		return utils.MarshalJSON(u.SegmentRHSRegex, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type SegmentRHSUnion: all fields are null")
}

type LHSDataTypeEntity string

const (
	LHSDataTypeEntityEntity LHSDataTypeEntity = "entity"
)

func (e LHSDataTypeEntity) ToPointer() *LHSDataTypeEntity {
	return &e
}
func (e *LHSDataTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = LHSDataTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LHSDataTypeEntity: %v", v)
	}
}

type LHSDataEntity struct {
	Type      LHSDataTypeEntity `json:"type"`
	Kind      string            `json:"kind"`
	Attribute string            `json:"attribute"`
}

func (l LHSDataEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LHSDataEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *LHSDataEntity) GetType() LHSDataTypeEntity {
	if o == nil {
		return LHSDataTypeEntity("")
	}
	return o.Type
}

func (o *LHSDataEntity) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *LHSDataEntity) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type LHSDataType string

const (
	LHSDataTypeSegment LHSDataType = "segment"
)

func (e LHSDataType) ToPointer() *LHSDataType {
	return &e
}
func (e *LHSDataType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "segment":
		*e = LHSDataType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LHSDataType: %v", v)
	}
}

type LHSData struct {
	Type LHSDataType `json:"type"`
}

func (l LHSData) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LHSData) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *LHSData) GetType() LHSDataType {
	if o == nil {
		return LHSDataType("")
	}
	return o.Type
}

type DataLHSUnionType string

const (
	DataLHSUnionTypeSegment DataLHSUnionType = "segment"
	DataLHSUnionTypeEntity  DataLHSUnionType = "entity"
)

type DataLHSUnion struct {
	LHSData       *LHSData       `queryParam:"inline"`
	LHSDataEntity *LHSDataEntity `queryParam:"inline"`

	Type DataLHSUnionType
}

func CreateDataLHSUnionSegment(segment LHSData) DataLHSUnion {
	typ := DataLHSUnionTypeSegment

	typStr := LHSDataType(typ)
	segment.Type = typStr

	return DataLHSUnion{
		LHSData: &segment,
		Type:    typ,
	}
}

func CreateDataLHSUnionEntity(entity LHSDataEntity) DataLHSUnion {
	typ := DataLHSUnionTypeEntity

	typStr := LHSDataTypeEntity(typ)
	entity.Type = typStr

	return DataLHSUnion{
		LHSDataEntity: &entity,
		Type:          typ,
	}
}

func (u *DataLHSUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "segment":
		lhsData := new(LHSData)
		if err := utils.UnmarshalJSON(data, &lhsData, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == segment) type LHSData within DataLHSUnion: %w", string(data), err)
		}

		u.LHSData = lhsData
		u.Type = DataLHSUnionTypeSegment
		return nil
	case "entity":
		lhsDataEntity := new(LHSDataEntity)
		if err := utils.UnmarshalJSON(data, &lhsDataEntity, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == entity) type LHSDataEntity within DataLHSUnion: %w", string(data), err)
		}

		u.LHSDataEntity = lhsDataEntity
		u.Type = DataLHSUnionTypeEntity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DataLHSUnion", string(data))
}

func (u DataLHSUnion) MarshalJSON() ([]byte, error) {
	if u.LHSData != nil {
		return utils.MarshalJSON(u.LHSData, "", true)
	}

	if u.LHSDataEntity != nil {
		return utils.MarshalJSON(u.LHSDataEntity, "", true)
	}

	return nil, errors.New("could not marshal union type DataLHSUnion: all fields are null")
}

type SegmentCmp string

const (
	SegmentCmpEq             SegmentCmp = "eq"
	SegmentCmpNotEq          SegmentCmp = "!eq"
	SegmentCmpOneOf          SegmentCmp = "oneOf"
	SegmentCmpNotOneOf       SegmentCmp = "!oneOf"
	SegmentCmpContainsAllOf  SegmentCmp = "containsAllOf"
	SegmentCmpContainsAnyOf  SegmentCmp = "containsAnyOf"
	SegmentCmpContainsNoneOf SegmentCmp = "containsNoneOf"
	SegmentCmpStartsWith     SegmentCmp = "startsWith"
	SegmentCmpNotStartsWith  SegmentCmp = "!startsWith"
	SegmentCmpEndsWith       SegmentCmp = "endsWith"
	SegmentCmpNotEndsWith    SegmentCmp = "!endsWith"
	SegmentCmpEx             SegmentCmp = "ex"
	SegmentCmpNotEx          SegmentCmp = "!ex"
	SegmentCmpGt             SegmentCmp = "gt"
	SegmentCmpGte            SegmentCmp = "gte"
	SegmentCmpLt             SegmentCmp = "lt"
	SegmentCmpLte            SegmentCmp = "lte"
	SegmentCmpRegex          SegmentCmp = "regex"
	SegmentCmpNotRegex       SegmentCmp = "!regex"
	SegmentCmpBefore         SegmentCmp = "before"
	SegmentCmpAfter          SegmentCmp = "after"
)

func (e SegmentCmp) ToPointer() *SegmentCmp {
	return &e
}
func (e *SegmentCmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = SegmentCmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SegmentCmp: %v", v)
	}
}

type SegmentCondition struct {
	RHS *SegmentRHSUnion `json:"rhs,omitempty"`
	LHS DataLHSUnion     `json:"lhs"`
	Cmp SegmentCmp       `json:"cmp"`
}

func (o *SegmentCondition) GetRHS() *SegmentRHSUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

func (o *SegmentCondition) GetLHS() DataLHSUnion {
	if o == nil {
		return DataLHSUnion{}
	}
	return o.LHS
}

func (o *SegmentCondition) GetLHSSegment() *LHSData {
	return o.GetLHS().LHSData
}

func (o *SegmentCondition) GetLHSEntity() *LHSDataEntity {
	return o.GetLHS().LHSDataEntity
}

func (o *SegmentCondition) GetCmp() SegmentCmp {
	if o == nil {
		return SegmentCmp("")
	}
	return o.Cmp
}

type SegmentRule struct {
	ID         string              `json:"id"`
	Outcome    SegmentOutcomeUnion `json:"outcome"`
	Conditions []SegmentCondition  `json:"conditions"`
}

func (o *SegmentRule) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *SegmentRule) GetOutcome() SegmentOutcomeUnion {
	if o == nil {
		return SegmentOutcomeUnion{}
	}
	return o.Outcome
}

func (o *SegmentRule) GetOutcomeAll() *OutcomeAll {
	return o.GetOutcome().OutcomeAll
}

func (o *SegmentRule) GetOutcomeSplit() *SegmentOutcomeSplit {
	return o.GetOutcome().SegmentOutcomeSplit
}

func (o *SegmentRule) GetConditions() []SegmentCondition {
	if o == nil {
		return []SegmentCondition{}
	}
	return o.Conditions
}

type Include struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *Include) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *Include) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type Exclude struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *Exclude) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *Exclude) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type SegmentData struct {
	Rules   []SegmentRule                   `json:"rules,omitempty"`
	Include map[string]map[string][]Include `json:"include,omitempty"`
	Exclude map[string]map[string][]Exclude `json:"exclude,omitempty"`
}

func (o *SegmentData) GetRules() []SegmentRule {
	if o == nil {
		return nil
	}
	return o.Rules
}

func (o *SegmentData) GetInclude() map[string]map[string][]Include {
	if o == nil {
		return nil
	}
	return o.Include
}

func (o *SegmentData) GetExclude() map[string]map[string][]Exclude {
	if o == nil {
		return nil
	}
	return o.Exclude
}

type SegmentCreator struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (o *SegmentCreator) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *SegmentCreator) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

type SegmentMetadata struct {
	Creator *SegmentCreator `json:"creator,omitempty"`
}

func (o *SegmentMetadata) GetCreator() *SegmentCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

type Segment struct {
	Description    *string          `json:"description,omitempty"`
	CreatedBy      *string          `json:"createdBy,omitempty"`
	UsedByFlags    []string         `json:"usedByFlags,omitempty"`
	UsedBySegments []string         `json:"usedBySegments,omitempty"`
	ID             string           `json:"id"`
	Label          string           `json:"label"`
	Slug           string           `json:"slug"`
	CreatedAt      float64          `json:"createdAt"`
	UpdatedAt      float64          `json:"updatedAt"`
	ProjectID      string           `json:"projectId"`
	TypeName       SegmentTypeName  `json:"typeName"`
	Data           SegmentData      `json:"data"`
	Hint           string           `json:"hint"`
	Metadata       *SegmentMetadata `json:"metadata,omitempty"`
}

func (o *Segment) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Segment) GetCreatedBy() *string {
	if o == nil {
		return nil
	}
	return o.CreatedBy
}

func (o *Segment) GetUsedByFlags() []string {
	if o == nil {
		return nil
	}
	return o.UsedByFlags
}

func (o *Segment) GetUsedBySegments() []string {
	if o == nil {
		return nil
	}
	return o.UsedBySegments
}

func (o *Segment) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Segment) GetLabel() string {
	if o == nil {
		return ""
	}
	return o.Label
}

func (o *Segment) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Segment) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *Segment) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *Segment) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *Segment) GetTypeName() SegmentTypeName {
	if o == nil {
		return SegmentTypeName("")
	}
	return o.TypeName
}

func (o *Segment) GetData() SegmentData {
	if o == nil {
		return SegmentData{}
	}
	return o.Data
}

func (o *Segment) GetHint() string {
	if o == nil {
		return ""
	}
	return o.Hint
}

func (o *Segment) GetMetadata() *SegmentMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}
