// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type Connect struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (c Connect) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *Connect) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Connect) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

// TeamConnectionSyncState - Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
type TeamConnectionSyncState string

const (
	TeamConnectionSyncStateSetup  TeamConnectionSyncState = "SETUP"
	TeamConnectionSyncStateActive TeamConnectionSyncState = "ACTIVE"
)

func (e TeamConnectionSyncState) ToPointer() *TeamConnectionSyncState {
	return &e
}
func (e *TeamConnectionSyncState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SETUP":
		fallthrough
	case "ACTIVE":
		*e = TeamConnectionSyncState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamConnectionSyncState: %v", v)
	}
}

// TeamConnection - Information for the SAML Single Sign-On configuration.
type TeamConnection struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current status of the connection.
	Status string `json:"status"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Timestamp (in milliseconds) of when the last directory sync was performed.
	LastSyncedAt *float64 `json:"lastSyncedAt,omitempty"`
	// Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
	SyncState *TeamConnectionSyncState `json:"syncState,omitempty"`
}

func (t TeamConnection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamConnection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "status", "state", "connectedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamConnection) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamConnection) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *TeamConnection) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamConnection) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamConnection) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

func (o *TeamConnection) GetLastSyncedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSyncedAt
}

func (o *TeamConnection) GetSyncState() *TeamConnectionSyncState {
	if o == nil {
		return nil
	}
	return o.SyncState
}

// TeamDirectorySyncState - Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
type TeamDirectorySyncState string

const (
	TeamDirectorySyncStateSetup  TeamDirectorySyncState = "SETUP"
	TeamDirectorySyncStateActive TeamDirectorySyncState = "ACTIVE"
)

func (e TeamDirectorySyncState) ToPointer() *TeamDirectorySyncState {
	return &e
}
func (e *TeamDirectorySyncState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SETUP":
		fallthrough
	case "ACTIVE":
		*e = TeamDirectorySyncState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamDirectorySyncState: %v", v)
	}
}

// TeamDirectory - Information for the Directory Sync configuration.
type TeamDirectory struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Timestamp (in milliseconds) of when the last directory sync was performed.
	LastSyncedAt *float64 `json:"lastSyncedAt,omitempty"`
	// Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
	SyncState *TeamDirectorySyncState `json:"syncState,omitempty"`
}

func (t TeamDirectory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamDirectory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "state", "connectedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamDirectory) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamDirectory) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamDirectory) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamDirectory) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

func (o *TeamDirectory) GetLastSyncedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSyncedAt
}

func (o *TeamDirectory) GetSyncState() *TeamDirectorySyncState {
	if o == nil {
		return nil
	}
	return o.SyncState
}

// DefaultRedirectURI - The default redirect URI to use after successful SAML authentication.
type DefaultRedirectURI string

const (
	DefaultRedirectURIVercelCom DefaultRedirectURI = "vercel.com"
	DefaultRedirectURIV0Dev     DefaultRedirectURI = "v0.dev"
	DefaultRedirectURIV0App     DefaultRedirectURI = "v0.app"
)

func (e DefaultRedirectURI) ToPointer() *DefaultRedirectURI {
	return &e
}
func (e *DefaultRedirectURI) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "vercel.com":
		fallthrough
	case "v0.dev":
		fallthrough
	case "v0.app":
		*e = DefaultRedirectURI(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultRedirectURI: %v", v)
	}
}

type RolesEnum string

const (
	RolesEnumOwner         RolesEnum = "OWNER"
	RolesEnumMember        RolesEnum = "MEMBER"
	RolesEnumDeveloper     RolesEnum = "DEVELOPER"
	RolesEnumSecurity      RolesEnum = "SECURITY"
	RolesEnumBilling       RolesEnum = "BILLING"
	RolesEnumViewer        RolesEnum = "VIEWER"
	RolesEnumViewerForPlus RolesEnum = "VIEWER_FOR_PLUS"
	RolesEnumContributor   RolesEnum = "CONTRIBUTOR"
)

func (e RolesEnum) ToPointer() *RolesEnum {
	return &e
}
func (e *RolesEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = RolesEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RolesEnum: %v", v)
	}
}

// Roles - When "Directory Sync" is configured, this object contains a mapping of which Directory Group (by ID) should be assigned to which Vercel Team "role".
type Roles struct {
	AccessGroupID string `json:"accessGroupId"`
}

func (r Roles) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Roles) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"accessGroupId"}); err != nil {
		return err
	}
	return nil
}

func (o *Roles) GetAccessGroupID() string {
	if o == nil {
		return ""
	}
	return o.AccessGroupID
}

type RolesUnionType string

const (
	RolesUnionTypeRoles     RolesUnionType = "roles"
	RolesUnionTypeRolesEnum RolesUnionType = "roles_enum"
)

type RolesUnion struct {
	Roles     *Roles     `queryParam:"inline"`
	RolesEnum *RolesEnum `queryParam:"inline"`

	Type RolesUnionType
}

func CreateRolesUnionRoles(roles Roles) RolesUnion {
	typ := RolesUnionTypeRoles

	return RolesUnion{
		Roles: &roles,
		Type:  typ,
	}
}

func CreateRolesUnionRolesEnum(rolesEnum RolesEnum) RolesUnion {
	typ := RolesUnionTypeRolesEnum

	return RolesUnion{
		RolesEnum: &rolesEnum,
		Type:      typ,
	}
}

func (u *RolesUnion) UnmarshalJSON(data []byte) error {

	var roles Roles = Roles{}
	if err := utils.UnmarshalJSON(data, &roles, "", true, nil); err == nil {
		u.Roles = &roles
		u.Type = RolesUnionTypeRoles
		return nil
	}

	var rolesEnum RolesEnum = RolesEnum("")
	if err := utils.UnmarshalJSON(data, &rolesEnum, "", true, nil); err == nil {
		u.RolesEnum = &rolesEnum
		u.Type = RolesUnionTypeRolesEnum
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RolesUnion", string(data))
}

func (u RolesUnion) MarshalJSON() ([]byte, error) {
	if u.Roles != nil {
		return utils.MarshalJSON(u.Roles, "", true)
	}

	if u.RolesEnum != nil {
		return utils.MarshalJSON(u.RolesEnum, "", true)
	}

	return nil, errors.New("could not marshal union type RolesUnion: all fields are null")
}

// TeamSaml - When "Single Sign-On (SAML)" is configured, this object contains information regarding the configuration of the Identity Provider (IdP).
type TeamSaml struct {
	// Information for the SAML Single Sign-On configuration.
	Connection *TeamConnection `json:"connection,omitempty"`
	// Information for the Directory Sync configuration.
	Directory *TeamDirectory `json:"directory,omitempty"`
	// When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
	Enforced bool `json:"enforced"`
	// The default redirect URI to use after successful SAML authentication.
	DefaultRedirectURI *DefaultRedirectURI `json:"defaultRedirectUri,omitempty"`
	// When "Directory Sync" is configured, this object contains a mapping of which Directory Group (by ID) should be assigned to which Vercel Team "role".
	Roles map[string]RolesUnion `json:"roles,omitempty"`
}

func (t TeamSaml) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamSaml) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"enforced"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamSaml) GetConnection() *TeamConnection {
	if o == nil {
		return nil
	}
	return o.Connection
}

func (o *TeamSaml) GetDirectory() *TeamDirectory {
	if o == nil {
		return nil
	}
	return o.Directory
}

func (o *TeamSaml) GetEnforced() bool {
	if o == nil {
		return false
	}
	return o.Enforced
}

func (o *TeamSaml) GetDefaultRedirectURI() *DefaultRedirectURI {
	if o == nil {
		return nil
	}
	return o.DefaultRedirectURI
}

func (o *TeamSaml) GetRoles() map[string]RolesUnion {
	if o == nil {
		return nil
	}
	return o.Roles
}

type DefaultRolesTeamRole string

const (
	DefaultRolesTeamRoleOwner         DefaultRolesTeamRole = "OWNER"
	DefaultRolesTeamRoleMember        DefaultRolesTeamRole = "MEMBER"
	DefaultRolesTeamRoleDeveloper     DefaultRolesTeamRole = "DEVELOPER"
	DefaultRolesTeamRoleSecurity      DefaultRolesTeamRole = "SECURITY"
	DefaultRolesTeamRoleBilling       DefaultRolesTeamRole = "BILLING"
	DefaultRolesTeamRoleViewer        DefaultRolesTeamRole = "VIEWER"
	DefaultRolesTeamRoleViewerForPlus DefaultRolesTeamRole = "VIEWER_FOR_PLUS"
	DefaultRolesTeamRoleContributor   DefaultRolesTeamRole = "CONTRIBUTOR"
)

func (e DefaultRolesTeamRole) ToPointer() *DefaultRolesTeamRole {
	return &e
}
func (e *DefaultRolesTeamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = DefaultRolesTeamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultRolesTeamRole: %v", v)
	}
}

type DefaultRolesTeamPermission string

const (
	DefaultRolesTeamPermissionIntegrationManager       DefaultRolesTeamPermission = "IntegrationManager"
	DefaultRolesTeamPermissionCreateProject            DefaultRolesTeamPermission = "CreateProject"
	DefaultRolesTeamPermissionFullProductionDeployment DefaultRolesTeamPermission = "FullProductionDeployment"
	DefaultRolesTeamPermissionUsageViewer              DefaultRolesTeamPermission = "UsageViewer"
	DefaultRolesTeamPermissionEnvVariableManager       DefaultRolesTeamPermission = "EnvVariableManager"
	DefaultRolesTeamPermissionEnvironmentManager       DefaultRolesTeamPermission = "EnvironmentManager"
	DefaultRolesTeamPermissionV0Builder                DefaultRolesTeamPermission = "V0Builder"
	DefaultRolesTeamPermissionV0Chatter                DefaultRolesTeamPermission = "V0Chatter"
	DefaultRolesTeamPermissionV0Viewer                 DefaultRolesTeamPermission = "V0Viewer"
)

func (e DefaultRolesTeamPermission) ToPointer() *DefaultRolesTeamPermission {
	return &e
}
func (e *DefaultRolesTeamPermission) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IntegrationManager":
		fallthrough
	case "CreateProject":
		fallthrough
	case "FullProductionDeployment":
		fallthrough
	case "UsageViewer":
		fallthrough
	case "EnvVariableManager":
		fallthrough
	case "EnvironmentManager":
		fallthrough
	case "V0Builder":
		fallthrough
	case "V0Chatter":
		fallthrough
	case "V0Viewer":
		*e = DefaultRolesTeamPermission(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DefaultRolesTeamPermission: %v", v)
	}
}

// DefaultRoles - Default roles for the team.
type DefaultRoles struct {
	TeamRoles       []DefaultRolesTeamRole       `json:"teamRoles,omitempty"`
	TeamPermissions []DefaultRolesTeamPermission `json:"teamPermissions,omitempty"`
}

func (d DefaultRoles) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DefaultRoles) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *DefaultRoles) GetTeamRoles() []DefaultRolesTeamRole {
	if o == nil {
		return nil
	}
	return o.TeamRoles
}

func (o *DefaultRoles) GetTeamPermissions() []DefaultRolesTeamPermission {
	if o == nil {
		return nil
	}
	return o.TeamPermissions
}

type TeamBuildEntitlements struct {
	EnhancedBuilds *bool `json:"enhancedBuilds,omitempty"`
}

func (t TeamBuildEntitlements) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamBuildEntitlements) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TeamBuildEntitlements) GetEnhancedBuilds() *bool {
	if o == nil {
		return nil
	}
	return o.EnhancedBuilds
}

// TeamDefault - Default build machine type for new builds
type TeamDefault string

const (
	TeamDefaultStandard TeamDefault = "standard"
	TeamDefaultEnhanced TeamDefault = "enhanced"
	TeamDefaultTurbo    TeamDefault = "turbo"
)

func (e TeamDefault) ToPointer() *TeamDefault {
	return &e
}
func (e *TeamDefault) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "enhanced":
		fallthrough
	case "turbo":
		*e = TeamDefault(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamDefault: %v", v)
	}
}

// TeamBuildMachine - Build machine configuration
type TeamBuildMachine struct {
	// Default build machine type for new builds
	Default *TeamDefault `json:"default,omitempty"`
}

func (t TeamBuildMachine) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamBuildMachine) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TeamBuildMachine) GetDefault() *TeamDefault {
	if o == nil {
		return nil
	}
	return o.Default
}

type TeamResourceConfig struct {
	// The total amount of concurrent builds that can be used.
	ConcurrentBuilds *float64 `json:"concurrentBuilds,omitempty"`
	// Whether every build for this team / user has elastic concurrency enabled automatically.
	ElasticConcurrencyEnabled *bool `json:"elasticConcurrencyEnabled,omitempty"`
	// The maximum size in kilobytes of an Edge Config. Only specified if a custom limit is set.
	EdgeConfigSize *float64 `json:"edgeConfigSize,omitempty"`
	// The maximum number of edge configs an account can create.
	EdgeConfigs *float64 `json:"edgeConfigs,omitempty"`
	// The maximum number of kv databases an account can create.
	KvDatabases *float64 `json:"kvDatabases,omitempty"`
	// The maximum number of blob stores an account can create.
	BlobStores *float64 `json:"blobStores,omitempty"`
	// The maximum number of postgres databases an account can create.
	PostgresDatabases *float64               `json:"postgresDatabases,omitempty"`
	BuildEntitlements *TeamBuildEntitlements `json:"buildEntitlements,omitempty"`
	// Build machine configuration
	BuildMachine *TeamBuildMachine `json:"buildMachine,omitempty"`
}

func (t TeamResourceConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamResourceConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TeamResourceConfig) GetConcurrentBuilds() *float64 {
	if o == nil {
		return nil
	}
	return o.ConcurrentBuilds
}

func (o *TeamResourceConfig) GetElasticConcurrencyEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ElasticConcurrencyEnabled
}

func (o *TeamResourceConfig) GetEdgeConfigSize() *float64 {
	if o == nil {
		return nil
	}
	return o.EdgeConfigSize
}

func (o *TeamResourceConfig) GetEdgeConfigs() *float64 {
	if o == nil {
		return nil
	}
	return o.EdgeConfigs
}

func (o *TeamResourceConfig) GetKvDatabases() *float64 {
	if o == nil {
		return nil
	}
	return o.KvDatabases
}

func (o *TeamResourceConfig) GetBlobStores() *float64 {
	if o == nil {
		return nil
	}
	return o.BlobStores
}

func (o *TeamResourceConfig) GetPostgresDatabases() *float64 {
	if o == nil {
		return nil
	}
	return o.PostgresDatabases
}

func (o *TeamResourceConfig) GetBuildEntitlements() *TeamBuildEntitlements {
	if o == nil {
		return nil
	}
	return o.BuildEntitlements
}

func (o *TeamResourceConfig) GetBuildMachine() *TeamBuildMachine {
	if o == nil {
		return nil
	}
	return o.BuildMachine
}

type DisableHardAutoBlocksType string

const (
	DisableHardAutoBlocksTypeNumber  DisableHardAutoBlocksType = "number"
	DisableHardAutoBlocksTypeBoolean DisableHardAutoBlocksType = "boolean"
)

type DisableHardAutoBlocks struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type DisableHardAutoBlocksType
}

func CreateDisableHardAutoBlocksNumber(number float64) DisableHardAutoBlocks {
	typ := DisableHardAutoBlocksTypeNumber

	return DisableHardAutoBlocks{
		Number: &number,
		Type:   typ,
	}
}

func CreateDisableHardAutoBlocksBoolean(boolean bool) DisableHardAutoBlocks {
	typ := DisableHardAutoBlocksTypeBoolean

	return DisableHardAutoBlocks{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *DisableHardAutoBlocks) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = DisableHardAutoBlocksTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = DisableHardAutoBlocksTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DisableHardAutoBlocks", string(data))
}

func (u DisableHardAutoBlocks) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type DisableHardAutoBlocks: all fields are null")
}

// TeamRemoteCaching - Is remote caching enabled for this team
type TeamRemoteCaching struct {
	Enabled *bool `json:"enabled,omitempty"`
}

func (t TeamRemoteCaching) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamRemoteCaching) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *TeamRemoteCaching) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

type TeamPasswordProtection struct {
	DeploymentType string `json:"deploymentType"`
}

func (t TeamPasswordProtection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamPasswordProtection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"deploymentType"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamPasswordProtection) GetDeploymentType() string {
	if o == nil {
		return ""
	}
	return o.DeploymentType
}

type TeamSsoProtection struct {
	DeploymentType string `json:"deploymentType"`
}

func (t TeamSsoProtection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamSsoProtection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"deploymentType"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamSsoProtection) GetDeploymentType() string {
	if o == nil {
		return ""
	}
	return o.DeploymentType
}

// DefaultDeploymentProtection - Default deployment protection for this team null indicates protection is disabled
type DefaultDeploymentProtection struct {
	PasswordProtection *TeamPasswordProtection `json:"passwordProtection,omitempty"`
	SsoProtection      *TeamSsoProtection      `json:"ssoProtection,omitempty"`
}

func (d DefaultDeploymentProtection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DefaultDeploymentProtection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *DefaultDeploymentProtection) GetPasswordProtection() *TeamPasswordProtection {
	if o == nil {
		return nil
	}
	return o.PasswordProtection
}

func (o *DefaultDeploymentProtection) GetSsoProtection() *TeamSsoProtection {
	if o == nil {
		return nil
	}
	return o.SsoProtection
}

// DefaultExpirationSettings - Default deployment expiration settings for this team
type DefaultExpirationSettings struct {
	// Number of days to keep non-production deployments (mostly preview deployments) before soft deletion.
	ExpirationDays *float64 `json:"expirationDays,omitempty"`
	// Number of days to keep production deployments before soft deletion.
	ExpirationDaysProduction *float64 `json:"expirationDaysProduction,omitempty"`
	// Number of days to keep canceled deployments before soft deletion.
	ExpirationDaysCanceled *float64 `json:"expirationDaysCanceled,omitempty"`
	// Number of days to keep errored deployments before soft deletion.
	ExpirationDaysErrored *float64 `json:"expirationDaysErrored,omitempty"`
	// Minimum number of production deployments to keep for this project, even if they are over the production expiration limit.
	DeploymentsToKeep *float64 `json:"deploymentsToKeep,omitempty"`
}

func (d DefaultExpirationSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DefaultExpirationSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *DefaultExpirationSettings) GetExpirationDays() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDays
}

func (o *DefaultExpirationSettings) GetExpirationDaysProduction() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysProduction
}

func (o *DefaultExpirationSettings) GetExpirationDaysCanceled() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysCanceled
}

func (o *DefaultExpirationSettings) GetExpirationDaysErrored() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysErrored
}

func (o *DefaultExpirationSettings) GetDeploymentsToKeep() *float64 {
	if o == nil {
		return nil
	}
	return o.DeploymentsToKeep
}

// TeamEnablePreviewFeedback - Whether toolbar is enabled on preview deployments
type TeamEnablePreviewFeedback string

const (
	TeamEnablePreviewFeedbackDefault      TeamEnablePreviewFeedback = "default"
	TeamEnablePreviewFeedbackOn           TeamEnablePreviewFeedback = "on"
	TeamEnablePreviewFeedbackOff          TeamEnablePreviewFeedback = "off"
	TeamEnablePreviewFeedbackOnForce      TeamEnablePreviewFeedback = "on-force"
	TeamEnablePreviewFeedbackOffForce     TeamEnablePreviewFeedback = "off-force"
	TeamEnablePreviewFeedbackDefaultForce TeamEnablePreviewFeedback = "default-force"
)

func (e TeamEnablePreviewFeedback) ToPointer() *TeamEnablePreviewFeedback {
	return &e
}
func (e *TeamEnablePreviewFeedback) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "on":
		fallthrough
	case "off":
		fallthrough
	case "on-force":
		fallthrough
	case "off-force":
		fallthrough
	case "default-force":
		*e = TeamEnablePreviewFeedback(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamEnablePreviewFeedback: %v", v)
	}
}

// EnableProductionFeedback - Whether toolbar is enabled on production deployments
type EnableProductionFeedback string

const (
	EnableProductionFeedbackDefault      EnableProductionFeedback = "default"
	EnableProductionFeedbackOn           EnableProductionFeedback = "on"
	EnableProductionFeedbackOff          EnableProductionFeedback = "off"
	EnableProductionFeedbackOnForce      EnableProductionFeedback = "on-force"
	EnableProductionFeedbackOffForce     EnableProductionFeedback = "off-force"
	EnableProductionFeedbackDefaultForce EnableProductionFeedback = "default-force"
)

func (e EnableProductionFeedback) ToPointer() *EnableProductionFeedback {
	return &e
}
func (e *EnableProductionFeedback) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "on":
		fallthrough
	case "off":
		fallthrough
	case "on-force":
		fallthrough
	case "off-force":
		fallthrough
	case "default-force":
		*e = EnableProductionFeedback(v)
		return nil
	default:
		return fmt.Errorf("invalid value for EnableProductionFeedback: %v", v)
	}
}

// SensitiveEnvironmentVariablePolicy - Sensitive environment variable policy for this team
type SensitiveEnvironmentVariablePolicy string

const (
	SensitiveEnvironmentVariablePolicyDefault SensitiveEnvironmentVariablePolicy = "default"
	SensitiveEnvironmentVariablePolicyOn      SensitiveEnvironmentVariablePolicy = "on"
	SensitiveEnvironmentVariablePolicyOff     SensitiveEnvironmentVariablePolicy = "off"
)

func (e SensitiveEnvironmentVariablePolicy) ToPointer() *SensitiveEnvironmentVariablePolicy {
	return &e
}
func (e *SensitiveEnvironmentVariablePolicy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "default":
		fallthrough
	case "on":
		fallthrough
	case "off":
		*e = SensitiveEnvironmentVariablePolicy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SensitiveEnvironmentVariablePolicy: %v", v)
	}
}

type IPBucket struct {
	Bucket       string   `json:"bucket"`
	SupportUntil *float64 `json:"supportUntil,omitempty"`
}

func (i IPBucket) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *IPBucket) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (o *IPBucket) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *IPBucket) GetSupportUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.SupportUntil
}

// StrictDeploymentProtectionSettings - When enabled, deployment protection settings require stricter permissions (owner-only).
type StrictDeploymentProtectionSettings struct {
	Enabled   bool    `json:"enabled"`
	UpdatedAt float64 `json:"updatedAt"`
}

func (s StrictDeploymentProtectionSettings) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *StrictDeploymentProtectionSettings) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"enabled", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *StrictDeploymentProtectionSettings) GetEnabled() bool {
	if o == nil {
		return false
	}
	return o.Enabled
}

func (o *StrictDeploymentProtectionSettings) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

type Preference string

const (
	PreferenceAutoApproval   Preference = "auto-approval"
	PreferenceManualApproval Preference = "manual-approval"
	PreferenceBlock          Preference = "block"
)

func (e Preference) ToPointer() *Preference {
	return &e
}
func (e *Preference) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "auto-approval":
		fallthrough
	case "manual-approval":
		fallthrough
	case "block":
		*e = Preference(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Preference: %v", v)
	}
}

// NsnbConfig - NSNB configuration for the team.
type NsnbConfig struct {
	Preference Preference `json:"preference"`
}

func (n NsnbConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NsnbConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"preference"}); err != nil {
		return err
	}
	return nil
}

func (o *NsnbConfig) GetPreference() Preference {
	if o == nil {
		return Preference("")
	}
	return o.Preference
}

type TeamEntitlement struct {
	Entitlement string `json:"entitlement"`
}

func (t TeamEntitlement) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamEntitlement) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"entitlement"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamEntitlement) GetEntitlement() string {
	if o == nil {
		return ""
	}
	return o.Entitlement
}

type TeamRole2 string

const (
	TeamRole2Owner         TeamRole2 = "OWNER"
	TeamRole2Member        TeamRole2 = "MEMBER"
	TeamRole2Developer     TeamRole2 = "DEVELOPER"
	TeamRole2Security      TeamRole2 = "SECURITY"
	TeamRole2Billing       TeamRole2 = "BILLING"
	TeamRole2Viewer        TeamRole2 = "VIEWER"
	TeamRole2ViewerForPlus TeamRole2 = "VIEWER_FOR_PLUS"
	TeamRole2Contributor   TeamRole2 = "CONTRIBUTOR"
)

func (e TeamRole2) ToPointer() *TeamRole2 {
	return &e
}
func (e *TeamRole2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamRole2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamRole2: %v", v)
	}
}

type TeamMembershipTeamRole string

const (
	TeamMembershipTeamRoleOwner         TeamMembershipTeamRole = "OWNER"
	TeamMembershipTeamRoleMember        TeamMembershipTeamRole = "MEMBER"
	TeamMembershipTeamRoleDeveloper     TeamMembershipTeamRole = "DEVELOPER"
	TeamMembershipTeamRoleSecurity      TeamMembershipTeamRole = "SECURITY"
	TeamMembershipTeamRoleBilling       TeamMembershipTeamRole = "BILLING"
	TeamMembershipTeamRoleViewer        TeamMembershipTeamRole = "VIEWER"
	TeamMembershipTeamRoleViewerForPlus TeamMembershipTeamRole = "VIEWER_FOR_PLUS"
	TeamMembershipTeamRoleContributor   TeamMembershipTeamRole = "CONTRIBUTOR"
)

func (e TeamMembershipTeamRole) ToPointer() *TeamMembershipTeamRole {
	return &e
}
func (e *TeamMembershipTeamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamMembershipTeamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamMembershipTeamRole: %v", v)
	}
}

type TeamMembershipTeamPermission string

const (
	TeamMembershipTeamPermissionIntegrationManager       TeamMembershipTeamPermission = "IntegrationManager"
	TeamMembershipTeamPermissionCreateProject            TeamMembershipTeamPermission = "CreateProject"
	TeamMembershipTeamPermissionFullProductionDeployment TeamMembershipTeamPermission = "FullProductionDeployment"
	TeamMembershipTeamPermissionUsageViewer              TeamMembershipTeamPermission = "UsageViewer"
	TeamMembershipTeamPermissionEnvVariableManager       TeamMembershipTeamPermission = "EnvVariableManager"
	TeamMembershipTeamPermissionEnvironmentManager       TeamMembershipTeamPermission = "EnvironmentManager"
	TeamMembershipTeamPermissionV0Builder                TeamMembershipTeamPermission = "V0Builder"
	TeamMembershipTeamPermissionV0Chatter                TeamMembershipTeamPermission = "V0Chatter"
	TeamMembershipTeamPermissionV0Viewer                 TeamMembershipTeamPermission = "V0Viewer"
)

func (e TeamMembershipTeamPermission) ToPointer() *TeamMembershipTeamPermission {
	return &e
}
func (e *TeamMembershipTeamPermission) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IntegrationManager":
		fallthrough
	case "CreateProject":
		fallthrough
	case "FullProductionDeployment":
		fallthrough
	case "UsageViewer":
		fallthrough
	case "EnvVariableManager":
		fallthrough
	case "EnvironmentManager":
		fallthrough
	case "V0Builder":
		fallthrough
	case "V0Chatter":
		fallthrough
	case "V0Viewer":
		*e = TeamMembershipTeamPermission(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamMembershipTeamPermission: %v", v)
	}
}

type TeamOrigin2 string

const (
	TeamOrigin2Link              TeamOrigin2 = "link"
	TeamOrigin2Saml              TeamOrigin2 = "saml"
	TeamOrigin2Mail              TeamOrigin2 = "mail"
	TeamOrigin2Import            TeamOrigin2 = "import"
	TeamOrigin2Teams             TeamOrigin2 = "teams"
	TeamOrigin2Github            TeamOrigin2 = "github"
	TeamOrigin2Gitlab            TeamOrigin2 = "gitlab"
	TeamOrigin2Bitbucket         TeamOrigin2 = "bitbucket"
	TeamOrigin2Dsync             TeamOrigin2 = "dsync"
	TeamOrigin2Feedback          TeamOrigin2 = "feedback"
	TeamOrigin2OrganizationTeams TeamOrigin2 = "organization-teams"
	TeamOrigin2NsnbAutoApprove   TeamOrigin2 = "nsnb-auto-approve"
	TeamOrigin2NsnbRequestAccess TeamOrigin2 = "nsnb-request-access"
	TeamOrigin2NsnbViewerUpgrade TeamOrigin2 = "nsnb-viewer-upgrade"
	TeamOrigin2NsnbInvite        TeamOrigin2 = "nsnb-invite"
	TeamOrigin2NsnbRedeploy      TeamOrigin2 = "nsnb-redeploy"
)

func (e TeamOrigin2) ToPointer() *TeamOrigin2 {
	return &e
}
func (e *TeamOrigin2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "link":
		fallthrough
	case "saml":
		fallthrough
	case "mail":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		fallthrough
	case "nsnb-auto-approve":
		fallthrough
	case "nsnb-request-access":
		fallthrough
	case "nsnb-viewer-upgrade":
		fallthrough
	case "nsnb-invite":
		fallthrough
	case "nsnb-redeploy":
		*e = TeamOrigin2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamOrigin2: %v", v)
	}
}

type TeamGitUserID2Type string

const (
	TeamGitUserID2TypeStr    TeamGitUserID2Type = "str"
	TeamGitUserID2TypeNumber TeamGitUserID2Type = "number"
)

type TeamGitUserID2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type TeamGitUserID2Type
}

func CreateTeamGitUserID2Str(str string) TeamGitUserID2 {
	typ := TeamGitUserID2TypeStr

	return TeamGitUserID2{
		Str:  &str,
		Type: typ,
	}
}

func CreateTeamGitUserID2Number(number float64) TeamGitUserID2 {
	typ := TeamGitUserID2TypeNumber

	return TeamGitUserID2{
		Number: &number,
		Type:   typ,
	}
}

func (u *TeamGitUserID2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = TeamGitUserID2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = TeamGitUserID2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TeamGitUserID2", string(data))
}

func (u TeamGitUserID2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type TeamGitUserID2: all fields are null")
}

type TeamJoinedFrom2 struct {
	Origin           TeamOrigin2     `json:"origin"`
	CommitID         *string         `json:"commitId,omitempty"`
	RepoID           *string         `json:"repoId,omitempty"`
	RepoPath         *string         `json:"repoPath,omitempty"`
	GitUserID        *TeamGitUserID2 `json:"gitUserId,omitempty"`
	GitUserLogin     *string         `json:"gitUserLogin,omitempty"`
	SsoUserID        *string         `json:"ssoUserId,omitempty"`
	SsoConnectedAt   *float64        `json:"ssoConnectedAt,omitempty"`
	IdpUserID        *string         `json:"idpUserId,omitempty"`
	DsyncUserID      *string         `json:"dsyncUserId,omitempty"`
	DsyncConnectedAt *float64        `json:"dsyncConnectedAt,omitempty"`
}

func (t TeamJoinedFrom2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamJoinedFrom2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"origin"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamJoinedFrom2) GetOrigin() TeamOrigin2 {
	if o == nil {
		return TeamOrigin2("")
	}
	return o.Origin
}

func (o *TeamJoinedFrom2) GetCommitID() *string {
	if o == nil {
		return nil
	}
	return o.CommitID
}

func (o *TeamJoinedFrom2) GetRepoID() *string {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *TeamJoinedFrom2) GetRepoPath() *string {
	if o == nil {
		return nil
	}
	return o.RepoPath
}

func (o *TeamJoinedFrom2) GetGitUserID() *TeamGitUserID2 {
	if o == nil {
		return nil
	}
	return o.GitUserID
}

func (o *TeamJoinedFrom2) GetGitUserLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitUserLogin
}

func (o *TeamJoinedFrom2) GetSsoUserID() *string {
	if o == nil {
		return nil
	}
	return o.SsoUserID
}

func (o *TeamJoinedFrom2) GetSsoConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SsoConnectedAt
}

func (o *TeamJoinedFrom2) GetIdpUserID() *string {
	if o == nil {
		return nil
	}
	return o.IdpUserID
}

func (o *TeamJoinedFrom2) GetDsyncUserID() *string {
	if o == nil {
		return nil
	}
	return o.DsyncUserID
}

func (o *TeamJoinedFrom2) GetDsyncConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DsyncConnectedAt
}

// TeamMembership - The membership of the authenticated User in relation to the Team.
type TeamMembership struct {
	UID               *string                        `json:"uid,omitempty"`
	Entitlements      []TeamEntitlement              `json:"entitlements,omitempty"`
	TeamID            *string                        `json:"teamId,omitempty"`
	Confirmed         bool                           `json:"confirmed"`
	AccessRequestedAt *float64                       `json:"accessRequestedAt,omitempty"`
	Role              TeamRole2                      `json:"role"`
	TeamRoles         []TeamMembershipTeamRole       `json:"teamRoles,omitempty"`
	TeamPermissions   []TeamMembershipTeamPermission `json:"teamPermissions,omitempty"`
	CreatedAt         float64                        `json:"createdAt"`
	Created           float64                        `json:"created"`
	JoinedFrom        *TeamJoinedFrom2               `json:"joinedFrom,omitempty"`
}

func (t TeamMembership) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamMembership) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"confirmed", "role", "createdAt", "created"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamMembership) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *TeamMembership) GetEntitlements() []TeamEntitlement {
	if o == nil {
		return nil
	}
	return o.Entitlements
}

func (o *TeamMembership) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *TeamMembership) GetConfirmed() bool {
	if o == nil {
		return false
	}
	return o.Confirmed
}

func (o *TeamMembership) GetAccessRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessRequestedAt
}

func (o *TeamMembership) GetRole() TeamRole2 {
	if o == nil {
		return TeamRole2("")
	}
	return o.Role
}

func (o *TeamMembership) GetTeamRoles() []TeamMembershipTeamRole {
	if o == nil {
		return nil
	}
	return o.TeamRoles
}

func (o *TeamMembership) GetTeamPermissions() []TeamMembershipTeamPermission {
	if o == nil {
		return nil
	}
	return o.TeamPermissions
}

func (o *TeamMembership) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *TeamMembership) GetCreated() float64 {
	if o == nil {
		return 0.0
	}
	return o.Created
}

func (o *TeamMembership) GetJoinedFrom() *TeamJoinedFrom2 {
	if o == nil {
		return nil
	}
	return o.JoinedFrom
}

// Team - Data representing a Team.
type Team struct {
	Connect *Connect `json:"connect,omitempty"`
	// The ID of the user who created the Team.
	CreatorID string `json:"creatorId"`
	// Timestamp (in milliseconds) of when the Team was last updated.
	UpdatedAt float64 `json:"updatedAt"`
	// Hostname that'll be matched with emails on sign-up to automatically join the Team.
	EmailDomain *string `json:"emailDomain,omitempty"`
	// When "Single Sign-On (SAML)" is configured, this object contains information regarding the configuration of the Identity Provider (IdP).
	Saml *TeamSaml `json:"saml,omitempty"`
	// Code that can be used to join this Team. Only visible to Team owners.
	InviteCode *string `json:"inviteCode,omitempty"`
	// A short description of the Team.
	Description *string `json:"description"`
	// Default roles for the team.
	DefaultRoles *DefaultRoles `json:"defaultRoles,omitempty"`
	// The prefix that is prepended to automatic aliases.
	StagingPrefix  string              `json:"stagingPrefix"`
	ResourceConfig *TeamResourceConfig `json:"resourceConfig,omitempty"`
	// The hostname that is current set as preview deployment suffix.
	PreviewDeploymentSuffix *string `json:"previewDeploymentSuffix,omitempty"`
	// Whether the team is a platform team.
	Platform              *bool                  `json:"platform,omitempty"`
	DisableHardAutoBlocks *DisableHardAutoBlocks `json:"disableHardAutoBlocks,omitempty"`
	// Is remote caching enabled for this team
	RemoteCaching *TeamRemoteCaching `json:"remoteCaching,omitempty"`
	// Default deployment protection for this team null indicates protection is disabled
	DefaultDeploymentProtection *DefaultDeploymentProtection `json:"defaultDeploymentProtection,omitempty"`
	// Default deployment expiration settings for this team
	DefaultExpirationSettings *DefaultExpirationSettings `json:"defaultExpirationSettings,omitempty"`
	// Whether toolbar is enabled on preview deployments
	EnablePreviewFeedback *TeamEnablePreviewFeedback `json:"enablePreviewFeedback,omitempty"`
	// Whether toolbar is enabled on production deployments
	EnableProductionFeedback *EnableProductionFeedback `json:"enableProductionFeedback,omitempty"`
	// Sensitive environment variable policy for this team
	SensitiveEnvironmentVariablePolicy *SensitiveEnvironmentVariablePolicy `json:"sensitiveEnvironmentVariablePolicy,omitempty"`
	// Indicates if IP addresses should be accessible in observability (o11y) tooling
	HideIPAddresses *bool `json:"hideIpAddresses,omitempty"`
	// Indicates if IP addresses should be accessible in log drains
	HideIPAddressesInLogDrains *bool      `json:"hideIpAddressesInLogDrains,omitempty"`
	IPBuckets                  []IPBucket `json:"ipBuckets,omitempty"`
	// When enabled, deployment protection settings require stricter permissions (owner-only).
	StrictDeploymentProtectionSettings *StrictDeploymentProtectionSettings `json:"strictDeploymentProtectionSettings,omitempty"`
	// NSNB configuration for the team.
	NsnbConfig *NsnbConfig `json:"nsnbConfig,omitempty"`
	// The Team's unique identifier.
	ID string `json:"id"`
	// The Team's slug, which is unique across the Vercel platform.
	Slug string `json:"slug"`
	// Name associated with the Team account, or `null` if none has been provided.
	Name *string `json:"name"`
	// The ID of the file used as avatar for this Team.
	Avatar *string `json:"avatar"`
	// The membership of the authenticated User in relation to the Team.
	Membership TeamMembership `json:"membership"`
	// UNIX timestamp (in milliseconds) when the Team was created.
	CreatedAt            float64        `json:"createdAt"`
	AdditionalProperties map[string]any `additionalProperties:"true" json:"-"`
}

func (t Team) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Team) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"creatorId", "updatedAt", "description", "stagingPrefix", "id", "slug", "name", "avatar", "membership", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *Team) GetConnect() *Connect {
	if o == nil {
		return nil
	}
	return o.Connect
}

func (o *Team) GetCreatorID() string {
	if o == nil {
		return ""
	}
	return o.CreatorID
}

func (o *Team) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *Team) GetEmailDomain() *string {
	if o == nil {
		return nil
	}
	return o.EmailDomain
}

func (o *Team) GetSaml() *TeamSaml {
	if o == nil {
		return nil
	}
	return o.Saml
}

func (o *Team) GetInviteCode() *string {
	if o == nil {
		return nil
	}
	return o.InviteCode
}

func (o *Team) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Team) GetDefaultRoles() *DefaultRoles {
	if o == nil {
		return nil
	}
	return o.DefaultRoles
}

func (o *Team) GetStagingPrefix() string {
	if o == nil {
		return ""
	}
	return o.StagingPrefix
}

func (o *Team) GetResourceConfig() *TeamResourceConfig {
	if o == nil {
		return nil
	}
	return o.ResourceConfig
}

func (o *Team) GetPreviewDeploymentSuffix() *string {
	if o == nil {
		return nil
	}
	return o.PreviewDeploymentSuffix
}

func (o *Team) GetPlatform() *bool {
	if o == nil {
		return nil
	}
	return o.Platform
}

func (o *Team) GetDisableHardAutoBlocks() *DisableHardAutoBlocks {
	if o == nil {
		return nil
	}
	return o.DisableHardAutoBlocks
}

func (o *Team) GetRemoteCaching() *TeamRemoteCaching {
	if o == nil {
		return nil
	}
	return o.RemoteCaching
}

func (o *Team) GetDefaultDeploymentProtection() *DefaultDeploymentProtection {
	if o == nil {
		return nil
	}
	return o.DefaultDeploymentProtection
}

func (o *Team) GetDefaultExpirationSettings() *DefaultExpirationSettings {
	if o == nil {
		return nil
	}
	return o.DefaultExpirationSettings
}

func (o *Team) GetEnablePreviewFeedback() *TeamEnablePreviewFeedback {
	if o == nil {
		return nil
	}
	return o.EnablePreviewFeedback
}

func (o *Team) GetEnableProductionFeedback() *EnableProductionFeedback {
	if o == nil {
		return nil
	}
	return o.EnableProductionFeedback
}

func (o *Team) GetSensitiveEnvironmentVariablePolicy() *SensitiveEnvironmentVariablePolicy {
	if o == nil {
		return nil
	}
	return o.SensitiveEnvironmentVariablePolicy
}

func (o *Team) GetHideIPAddresses() *bool {
	if o == nil {
		return nil
	}
	return o.HideIPAddresses
}

func (o *Team) GetHideIPAddressesInLogDrains() *bool {
	if o == nil {
		return nil
	}
	return o.HideIPAddressesInLogDrains
}

func (o *Team) GetIPBuckets() []IPBucket {
	if o == nil {
		return nil
	}
	return o.IPBuckets
}

func (o *Team) GetStrictDeploymentProtectionSettings() *StrictDeploymentProtectionSettings {
	if o == nil {
		return nil
	}
	return o.StrictDeploymentProtectionSettings
}

func (o *Team) GetNsnbConfig() *NsnbConfig {
	if o == nil {
		return nil
	}
	return o.NsnbConfig
}

func (o *Team) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Team) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Team) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *Team) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

func (o *Team) GetMembership() TeamMembership {
	if o == nil {
		return TeamMembership{}
	}
	return o.Membership
}

func (o *Team) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *Team) GetAdditionalProperties() map[string]any {
	if o == nil {
		return nil
	}
	return o.AdditionalProperties
}
