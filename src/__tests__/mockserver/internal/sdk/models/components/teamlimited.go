// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type LimitedBy string

const (
	LimitedByScope LimitedBy = "scope"
	LimitedByMfa   LimitedBy = "mfa"
)

func (e LimitedBy) ToPointer() *LimitedBy {
	return &e
}
func (e *LimitedBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "scope":
		fallthrough
	case "mfa":
		*e = LimitedBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LimitedBy: %v", v)
	}
}

// TeamLimitedConnection - Information for the SAML Single Sign-On configuration.
type TeamLimitedConnection struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current status of the connection.
	Status string `json:"status"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
}

func (o *TeamLimitedConnection) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamLimitedConnection) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *TeamLimitedConnection) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamLimitedConnection) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamLimitedConnection) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

// TeamLimitedDirectory - Information for the Directory Sync configuration.
type TeamLimitedDirectory struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
}

func (o *TeamLimitedDirectory) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamLimitedDirectory) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamLimitedDirectory) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamLimitedDirectory) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

// TeamLimitedSaml - When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
type TeamLimitedSaml struct {
	// Information for the SAML Single Sign-On configuration.
	Connection *TeamLimitedConnection `json:"connection,omitempty"`
	// Information for the Directory Sync configuration.
	Directory *TeamLimitedDirectory `json:"directory,omitempty"`
	// When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
	Enforced bool `json:"enforced"`
}

func (o *TeamLimitedSaml) GetConnection() *TeamLimitedConnection {
	if o == nil {
		return nil
	}
	return o.Connection
}

func (o *TeamLimitedSaml) GetDirectory() *TeamLimitedDirectory {
	if o == nil {
		return nil
	}
	return o.Directory
}

func (o *TeamLimitedSaml) GetEnforced() bool {
	if o == nil {
		return false
	}
	return o.Enforced
}

type TeamLimitedEntitlement struct {
	Entitlement string `json:"entitlement"`
}

func (o *TeamLimitedEntitlement) GetEntitlement() string {
	if o == nil {
		return ""
	}
	return o.Entitlement
}

type TeamLimitedRole string

const (
	TeamLimitedRoleOwner       TeamLimitedRole = "OWNER"
	TeamLimitedRoleMember      TeamLimitedRole = "MEMBER"
	TeamLimitedRoleDeveloper   TeamLimitedRole = "DEVELOPER"
	TeamLimitedRoleSecurity    TeamLimitedRole = "SECURITY"
	TeamLimitedRoleBilling     TeamLimitedRole = "BILLING"
	TeamLimitedRoleViewer      TeamLimitedRole = "VIEWER"
	TeamLimitedRoleContributor TeamLimitedRole = "CONTRIBUTOR"
)

func (e TeamLimitedRole) ToPointer() *TeamLimitedRole {
	return &e
}
func (e *TeamLimitedRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedRole: %v", v)
	}
}

type TeamLimitedTeamRole string

const (
	TeamLimitedTeamRoleOwner       TeamLimitedTeamRole = "OWNER"
	TeamLimitedTeamRoleMember      TeamLimitedTeamRole = "MEMBER"
	TeamLimitedTeamRoleDeveloper   TeamLimitedTeamRole = "DEVELOPER"
	TeamLimitedTeamRoleSecurity    TeamLimitedTeamRole = "SECURITY"
	TeamLimitedTeamRoleBilling     TeamLimitedTeamRole = "BILLING"
	TeamLimitedTeamRoleViewer      TeamLimitedTeamRole = "VIEWER"
	TeamLimitedTeamRoleContributor TeamLimitedTeamRole = "CONTRIBUTOR"
)

func (e TeamLimitedTeamRole) ToPointer() *TeamLimitedTeamRole {
	return &e
}
func (e *TeamLimitedTeamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedTeamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedTeamRole: %v", v)
	}
}

type TeamLimitedTeamPermission string

const (
	TeamLimitedTeamPermissionCreateProject            TeamLimitedTeamPermission = "CreateProject"
	TeamLimitedTeamPermissionFullProductionDeployment TeamLimitedTeamPermission = "FullProductionDeployment"
	TeamLimitedTeamPermissionUsageViewer              TeamLimitedTeamPermission = "UsageViewer"
	TeamLimitedTeamPermissionEnvVariableManager       TeamLimitedTeamPermission = "EnvVariableManager"
	TeamLimitedTeamPermissionEnvironmentManager       TeamLimitedTeamPermission = "EnvironmentManager"
)

func (e TeamLimitedTeamPermission) ToPointer() *TeamLimitedTeamPermission {
	return &e
}
func (e *TeamLimitedTeamPermission) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CreateProject":
		fallthrough
	case "FullProductionDeployment":
		fallthrough
	case "UsageViewer":
		fallthrough
	case "EnvVariableManager":
		fallthrough
	case "EnvironmentManager":
		*e = TeamLimitedTeamPermission(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedTeamPermission: %v", v)
	}
}

type TeamLimitedOrigin string

const (
	TeamLimitedOriginSaml              TeamLimitedOrigin = "saml"
	TeamLimitedOriginMail              TeamLimitedOrigin = "mail"
	TeamLimitedOriginLink              TeamLimitedOrigin = "link"
	TeamLimitedOriginImport            TeamLimitedOrigin = "import"
	TeamLimitedOriginTeams             TeamLimitedOrigin = "teams"
	TeamLimitedOriginGithub            TeamLimitedOrigin = "github"
	TeamLimitedOriginGitlab            TeamLimitedOrigin = "gitlab"
	TeamLimitedOriginBitbucket         TeamLimitedOrigin = "bitbucket"
	TeamLimitedOriginDsync             TeamLimitedOrigin = "dsync"
	TeamLimitedOriginFeedback          TeamLimitedOrigin = "feedback"
	TeamLimitedOriginOrganizationTeams TeamLimitedOrigin = "organization-teams"
)

func (e TeamLimitedOrigin) ToPointer() *TeamLimitedOrigin {
	return &e
}
func (e *TeamLimitedOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "saml":
		fallthrough
	case "mail":
		fallthrough
	case "link":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		*e = TeamLimitedOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedOrigin: %v", v)
	}
}

type TeamLimitedGitUserIDType string

const (
	TeamLimitedGitUserIDTypeStr    TeamLimitedGitUserIDType = "str"
	TeamLimitedGitUserIDTypeNumber TeamLimitedGitUserIDType = "number"
)

type TeamLimitedGitUserID struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type TeamLimitedGitUserIDType
}

func CreateTeamLimitedGitUserIDStr(str string) TeamLimitedGitUserID {
	typ := TeamLimitedGitUserIDTypeStr

	return TeamLimitedGitUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateTeamLimitedGitUserIDNumber(number float64) TeamLimitedGitUserID {
	typ := TeamLimitedGitUserIDTypeNumber

	return TeamLimitedGitUserID{
		Number: &number,
		Type:   typ,
	}
}

func (u *TeamLimitedGitUserID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = TeamLimitedGitUserIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, true); err == nil {
		u.Number = &number
		u.Type = TeamLimitedGitUserIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TeamLimitedGitUserID", string(data))
}

func (u TeamLimitedGitUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type TeamLimitedGitUserID: all fields are null")
}

type TeamLimitedJoinedFrom struct {
	Origin           TeamLimitedOrigin     `json:"origin"`
	CommitID         *string               `json:"commitId,omitempty"`
	RepoID           *string               `json:"repoId,omitempty"`
	RepoPath         *string               `json:"repoPath,omitempty"`
	GitUserID        *TeamLimitedGitUserID `json:"gitUserId,omitempty"`
	GitUserLogin     *string               `json:"gitUserLogin,omitempty"`
	SsoUserID        *string               `json:"ssoUserId,omitempty"`
	SsoConnectedAt   *float64              `json:"ssoConnectedAt,omitempty"`
	IdpUserID        *string               `json:"idpUserId,omitempty"`
	DsyncUserID      *string               `json:"dsyncUserId,omitempty"`
	DsyncConnectedAt *float64              `json:"dsyncConnectedAt,omitempty"`
}

func (o *TeamLimitedJoinedFrom) GetOrigin() TeamLimitedOrigin {
	if o == nil {
		return TeamLimitedOrigin("")
	}
	return o.Origin
}

func (o *TeamLimitedJoinedFrom) GetCommitID() *string {
	if o == nil {
		return nil
	}
	return o.CommitID
}

func (o *TeamLimitedJoinedFrom) GetRepoID() *string {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *TeamLimitedJoinedFrom) GetRepoPath() *string {
	if o == nil {
		return nil
	}
	return o.RepoPath
}

func (o *TeamLimitedJoinedFrom) GetGitUserID() *TeamLimitedGitUserID {
	if o == nil {
		return nil
	}
	return o.GitUserID
}

func (o *TeamLimitedJoinedFrom) GetGitUserLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitUserLogin
}

func (o *TeamLimitedJoinedFrom) GetSsoUserID() *string {
	if o == nil {
		return nil
	}
	return o.SsoUserID
}

func (o *TeamLimitedJoinedFrom) GetSsoConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SsoConnectedAt
}

func (o *TeamLimitedJoinedFrom) GetIdpUserID() *string {
	if o == nil {
		return nil
	}
	return o.IdpUserID
}

func (o *TeamLimitedJoinedFrom) GetDsyncUserID() *string {
	if o == nil {
		return nil
	}
	return o.DsyncUserID
}

func (o *TeamLimitedJoinedFrom) GetDsyncConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DsyncConnectedAt
}

// TeamLimitedMembership - The membership of the authenticated User in relation to the Team.
type TeamLimitedMembership struct {
	UID               *string                     `json:"uid,omitempty"`
	Entitlements      []TeamLimitedEntitlement    `json:"entitlements,omitempty"`
	TeamID            *string                     `json:"teamId,omitempty"`
	Confirmed         bool                        `json:"confirmed"`
	ConfirmedAt       float64                     `json:"confirmedAt"`
	AccessRequestedAt *float64                    `json:"accessRequestedAt,omitempty"`
	Role              TeamLimitedRole             `json:"role"`
	TeamRoles         []TeamLimitedTeamRole       `json:"teamRoles,omitempty"`
	TeamPermissions   []TeamLimitedTeamPermission `json:"teamPermissions,omitempty"`
	CreatedAt         float64                     `json:"createdAt"`
	Created           float64                     `json:"created"`
	JoinedFrom        *TeamLimitedJoinedFrom      `json:"joinedFrom,omitempty"`
}

func (o *TeamLimitedMembership) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *TeamLimitedMembership) GetEntitlements() []TeamLimitedEntitlement {
	if o == nil {
		return nil
	}
	return o.Entitlements
}

func (o *TeamLimitedMembership) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *TeamLimitedMembership) GetConfirmed() bool {
	if o == nil {
		return false
	}
	return o.Confirmed
}

func (o *TeamLimitedMembership) GetConfirmedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConfirmedAt
}

func (o *TeamLimitedMembership) GetAccessRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessRequestedAt
}

func (o *TeamLimitedMembership) GetRole() TeamLimitedRole {
	if o == nil {
		return TeamLimitedRole("")
	}
	return o.Role
}

func (o *TeamLimitedMembership) GetTeamRoles() []TeamLimitedTeamRole {
	if o == nil {
		return nil
	}
	return o.TeamRoles
}

func (o *TeamLimitedMembership) GetTeamPermissions() []TeamLimitedTeamPermission {
	if o == nil {
		return nil
	}
	return o.TeamPermissions
}

func (o *TeamLimitedMembership) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *TeamLimitedMembership) GetCreated() float64 {
	if o == nil {
		return 0.0
	}
	return o.Created
}

func (o *TeamLimitedMembership) GetJoinedFrom() *TeamLimitedJoinedFrom {
	if o == nil {
		return nil
	}
	return o.JoinedFrom
}

// TeamLimited - A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
type TeamLimited struct {
	// Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data or due to team having MFA enforced and the user not having MFA enabled. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
	Limited   bool        `json:"limited"`
	LimitedBy []LimitedBy `json:"limitedBy"`
	// When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
	Saml *TeamLimitedSaml `json:"saml,omitempty"`
	// The Team's unique identifier.
	ID string `json:"id"`
	// The Team's slug, which is unique across the Vercel platform.
	Slug string `json:"slug"`
	// Name associated with the Team account, or `null` if none has been provided.
	Name *string `json:"name"`
	// The ID of the file used as avatar for this Team.
	Avatar *string `json:"avatar"`
	// The membership of the authenticated User in relation to the Team.
	Membership TeamLimitedMembership `json:"membership"`
	// UNIX timestamp (in milliseconds) when the Team was created.
	CreatedAt float64 `json:"createdAt"`
}

func (o *TeamLimited) GetLimited() bool {
	if o == nil {
		return false
	}
	return o.Limited
}

func (o *TeamLimited) GetLimitedBy() []LimitedBy {
	if o == nil {
		return []LimitedBy{}
	}
	return o.LimitedBy
}

func (o *TeamLimited) GetSaml() *TeamLimitedSaml {
	if o == nil {
		return nil
	}
	return o.Saml
}

func (o *TeamLimited) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *TeamLimited) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *TeamLimited) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *TeamLimited) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

func (o *TeamLimited) GetMembership() TeamLimitedMembership {
	if o == nil {
		return TeamLimitedMembership{}
	}
	return o.Membership
}

func (o *TeamLimited) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}
