// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package components

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/utils"
)

type LimitedBy string

const (
	LimitedByMfa   LimitedBy = "mfa"
	LimitedByScope LimitedBy = "scope"
)

func (e LimitedBy) ToPointer() *LimitedBy {
	return &e
}
func (e *LimitedBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "mfa":
		fallthrough
	case "scope":
		*e = LimitedBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LimitedBy: %v", v)
	}
}

// TeamLimitedConnectionSyncState - Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
type TeamLimitedConnectionSyncState string

const (
	TeamLimitedConnectionSyncStateSetup  TeamLimitedConnectionSyncState = "SETUP"
	TeamLimitedConnectionSyncStateActive TeamLimitedConnectionSyncState = "ACTIVE"
)

func (e TeamLimitedConnectionSyncState) ToPointer() *TeamLimitedConnectionSyncState {
	return &e
}
func (e *TeamLimitedConnectionSyncState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SETUP":
		fallthrough
	case "ACTIVE":
		*e = TeamLimitedConnectionSyncState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedConnectionSyncState: %v", v)
	}
}

// TeamLimitedConnection - Information for the SAML Single Sign-On configuration.
type TeamLimitedConnection struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current status of the connection.
	Status string `json:"status"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Timestamp (in milliseconds) of when the last directory sync was performed.
	LastSyncedAt *float64 `json:"lastSyncedAt,omitempty"`
	// Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
	SyncState *TeamLimitedConnectionSyncState `json:"syncState,omitempty"`
}

func (t TeamLimitedConnection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedConnection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "status", "state", "connectedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedConnection) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamLimitedConnection) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *TeamLimitedConnection) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamLimitedConnection) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamLimitedConnection) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

func (o *TeamLimitedConnection) GetLastSyncedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSyncedAt
}

func (o *TeamLimitedConnection) GetSyncState() *TeamLimitedConnectionSyncState {
	if o == nil {
		return nil
	}
	return o.SyncState
}

// TeamLimitedDirectorySyncState - Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
type TeamLimitedDirectorySyncState string

const (
	TeamLimitedDirectorySyncStateSetup  TeamLimitedDirectorySyncState = "SETUP"
	TeamLimitedDirectorySyncStateActive TeamLimitedDirectorySyncState = "ACTIVE"
)

func (e TeamLimitedDirectorySyncState) ToPointer() *TeamLimitedDirectorySyncState {
	return &e
}
func (e *TeamLimitedDirectorySyncState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SETUP":
		fallthrough
	case "ACTIVE":
		*e = TeamLimitedDirectorySyncState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedDirectorySyncState: %v", v)
	}
}

// TeamLimitedDirectory - Information for the Directory Sync configuration.
type TeamLimitedDirectory struct {
	// The Identity Provider "type", for example Okta.
	Type string `json:"type"`
	// Current state of the connection.
	State string `json:"state"`
	// Timestamp (in milliseconds) of when the configuration was connected.
	ConnectedAt float64 `json:"connectedAt"`
	// Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
	LastReceivedWebhookEvent *float64 `json:"lastReceivedWebhookEvent,omitempty"`
	// Timestamp (in milliseconds) of when the last directory sync was performed.
	LastSyncedAt *float64 `json:"lastSyncedAt,omitempty"`
	// Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
	SyncState *TeamLimitedDirectorySyncState `json:"syncState,omitempty"`
}

func (t TeamLimitedDirectory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedDirectory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "state", "connectedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedDirectory) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TeamLimitedDirectory) GetState() string {
	if o == nil {
		return ""
	}
	return o.State
}

func (o *TeamLimitedDirectory) GetConnectedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.ConnectedAt
}

func (o *TeamLimitedDirectory) GetLastReceivedWebhookEvent() *float64 {
	if o == nil {
		return nil
	}
	return o.LastReceivedWebhookEvent
}

func (o *TeamLimitedDirectory) GetLastSyncedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.LastSyncedAt
}

func (o *TeamLimitedDirectory) GetSyncState() *TeamLimitedDirectorySyncState {
	if o == nil {
		return nil
	}
	return o.SyncState
}

// TeamLimitedSaml - When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
type TeamLimitedSaml struct {
	// Information for the SAML Single Sign-On configuration.
	Connection *TeamLimitedConnection `json:"connection,omitempty"`
	// Information for the Directory Sync configuration.
	Directory *TeamLimitedDirectory `json:"directory,omitempty"`
	// When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
	Enforced bool `json:"enforced"`
}

func (t TeamLimitedSaml) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedSaml) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"enforced"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedSaml) GetConnection() *TeamLimitedConnection {
	if o == nil {
		return nil
	}
	return o.Connection
}

func (o *TeamLimitedSaml) GetDirectory() *TeamLimitedDirectory {
	if o == nil {
		return nil
	}
	return o.Directory
}

func (o *TeamLimitedSaml) GetEnforced() bool {
	if o == nil {
		return false
	}
	return o.Enforced
}

type TeamLimitedEntitlement struct {
	Entitlement string `json:"entitlement"`
}

func (t TeamLimitedEntitlement) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedEntitlement) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"entitlement"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedEntitlement) GetEntitlement() string {
	if o == nil {
		return ""
	}
	return o.Entitlement
}

type TeamLimitedRole string

const (
	TeamLimitedRoleOwner         TeamLimitedRole = "OWNER"
	TeamLimitedRoleMember        TeamLimitedRole = "MEMBER"
	TeamLimitedRoleDeveloper     TeamLimitedRole = "DEVELOPER"
	TeamLimitedRoleSecurity      TeamLimitedRole = "SECURITY"
	TeamLimitedRoleBilling       TeamLimitedRole = "BILLING"
	TeamLimitedRoleViewer        TeamLimitedRole = "VIEWER"
	TeamLimitedRoleViewerForPlus TeamLimitedRole = "VIEWER_FOR_PLUS"
	TeamLimitedRoleContributor   TeamLimitedRole = "CONTRIBUTOR"
)

func (e TeamLimitedRole) ToPointer() *TeamLimitedRole {
	return &e
}
func (e *TeamLimitedRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedRole: %v", v)
	}
}

type TeamLimitedTeamRole string

const (
	TeamLimitedTeamRoleOwner         TeamLimitedTeamRole = "OWNER"
	TeamLimitedTeamRoleMember        TeamLimitedTeamRole = "MEMBER"
	TeamLimitedTeamRoleDeveloper     TeamLimitedTeamRole = "DEVELOPER"
	TeamLimitedTeamRoleSecurity      TeamLimitedTeamRole = "SECURITY"
	TeamLimitedTeamRoleBilling       TeamLimitedTeamRole = "BILLING"
	TeamLimitedTeamRoleViewer        TeamLimitedTeamRole = "VIEWER"
	TeamLimitedTeamRoleViewerForPlus TeamLimitedTeamRole = "VIEWER_FOR_PLUS"
	TeamLimitedTeamRoleContributor   TeamLimitedTeamRole = "CONTRIBUTOR"
)

func (e TeamLimitedTeamRole) ToPointer() *TeamLimitedTeamRole {
	return &e
}
func (e *TeamLimitedTeamRole) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "OWNER":
		fallthrough
	case "MEMBER":
		fallthrough
	case "DEVELOPER":
		fallthrough
	case "SECURITY":
		fallthrough
	case "BILLING":
		fallthrough
	case "VIEWER":
		fallthrough
	case "VIEWER_FOR_PLUS":
		fallthrough
	case "CONTRIBUTOR":
		*e = TeamLimitedTeamRole(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedTeamRole: %v", v)
	}
}

type TeamLimitedTeamPermission string

const (
	TeamLimitedTeamPermissionIntegrationManager       TeamLimitedTeamPermission = "IntegrationManager"
	TeamLimitedTeamPermissionCreateProject            TeamLimitedTeamPermission = "CreateProject"
	TeamLimitedTeamPermissionFullProductionDeployment TeamLimitedTeamPermission = "FullProductionDeployment"
	TeamLimitedTeamPermissionUsageViewer              TeamLimitedTeamPermission = "UsageViewer"
	TeamLimitedTeamPermissionEnvVariableManager       TeamLimitedTeamPermission = "EnvVariableManager"
	TeamLimitedTeamPermissionEnvironmentManager       TeamLimitedTeamPermission = "EnvironmentManager"
	TeamLimitedTeamPermissionV0Builder                TeamLimitedTeamPermission = "V0Builder"
	TeamLimitedTeamPermissionV0Chatter                TeamLimitedTeamPermission = "V0Chatter"
	TeamLimitedTeamPermissionV0Viewer                 TeamLimitedTeamPermission = "V0Viewer"
)

func (e TeamLimitedTeamPermission) ToPointer() *TeamLimitedTeamPermission {
	return &e
}
func (e *TeamLimitedTeamPermission) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "IntegrationManager":
		fallthrough
	case "CreateProject":
		fallthrough
	case "FullProductionDeployment":
		fallthrough
	case "UsageViewer":
		fallthrough
	case "EnvVariableManager":
		fallthrough
	case "EnvironmentManager":
		fallthrough
	case "V0Builder":
		fallthrough
	case "V0Chatter":
		fallthrough
	case "V0Viewer":
		*e = TeamLimitedTeamPermission(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedTeamPermission: %v", v)
	}
}

type TeamLimitedOrigin string

const (
	TeamLimitedOriginLink              TeamLimitedOrigin = "link"
	TeamLimitedOriginSaml              TeamLimitedOrigin = "saml"
	TeamLimitedOriginMail              TeamLimitedOrigin = "mail"
	TeamLimitedOriginImport            TeamLimitedOrigin = "import"
	TeamLimitedOriginTeams             TeamLimitedOrigin = "teams"
	TeamLimitedOriginGithub            TeamLimitedOrigin = "github"
	TeamLimitedOriginGitlab            TeamLimitedOrigin = "gitlab"
	TeamLimitedOriginBitbucket         TeamLimitedOrigin = "bitbucket"
	TeamLimitedOriginDsync             TeamLimitedOrigin = "dsync"
	TeamLimitedOriginFeedback          TeamLimitedOrigin = "feedback"
	TeamLimitedOriginOrganizationTeams TeamLimitedOrigin = "organization-teams"
	TeamLimitedOriginNsnbAutoApprove   TeamLimitedOrigin = "nsnb-auto-approve"
	TeamLimitedOriginNsnbRequestAccess TeamLimitedOrigin = "nsnb-request-access"
	TeamLimitedOriginNsnbViewerUpgrade TeamLimitedOrigin = "nsnb-viewer-upgrade"
	TeamLimitedOriginNsnbInvite        TeamLimitedOrigin = "nsnb-invite"
	TeamLimitedOriginNsnbRedeploy      TeamLimitedOrigin = "nsnb-redeploy"
)

func (e TeamLimitedOrigin) ToPointer() *TeamLimitedOrigin {
	return &e
}
func (e *TeamLimitedOrigin) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "link":
		fallthrough
	case "saml":
		fallthrough
	case "mail":
		fallthrough
	case "import":
		fallthrough
	case "teams":
		fallthrough
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		fallthrough
	case "dsync":
		fallthrough
	case "feedback":
		fallthrough
	case "organization-teams":
		fallthrough
	case "nsnb-auto-approve":
		fallthrough
	case "nsnb-request-access":
		fallthrough
	case "nsnb-viewer-upgrade":
		fallthrough
	case "nsnb-invite":
		fallthrough
	case "nsnb-redeploy":
		*e = TeamLimitedOrigin(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TeamLimitedOrigin: %v", v)
	}
}

type TeamLimitedGitUserIDType string

const (
	TeamLimitedGitUserIDTypeStr    TeamLimitedGitUserIDType = "str"
	TeamLimitedGitUserIDTypeNumber TeamLimitedGitUserIDType = "number"
)

type TeamLimitedGitUserID struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type TeamLimitedGitUserIDType
}

func CreateTeamLimitedGitUserIDStr(str string) TeamLimitedGitUserID {
	typ := TeamLimitedGitUserIDTypeStr

	return TeamLimitedGitUserID{
		Str:  &str,
		Type: typ,
	}
}

func CreateTeamLimitedGitUserIDNumber(number float64) TeamLimitedGitUserID {
	typ := TeamLimitedGitUserIDTypeNumber

	return TeamLimitedGitUserID{
		Number: &number,
		Type:   typ,
	}
}

func (u *TeamLimitedGitUserID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = TeamLimitedGitUserIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = TeamLimitedGitUserIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TeamLimitedGitUserID", string(data))
}

func (u TeamLimitedGitUserID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type TeamLimitedGitUserID: all fields are null")
}

type TeamLimitedJoinedFrom struct {
	Origin           TeamLimitedOrigin     `json:"origin"`
	CommitID         *string               `json:"commitId,omitempty"`
	RepoID           *string               `json:"repoId,omitempty"`
	RepoPath         *string               `json:"repoPath,omitempty"`
	GitUserID        *TeamLimitedGitUserID `json:"gitUserId,omitempty"`
	GitUserLogin     *string               `json:"gitUserLogin,omitempty"`
	SsoUserID        *string               `json:"ssoUserId,omitempty"`
	SsoConnectedAt   *float64              `json:"ssoConnectedAt,omitempty"`
	IdpUserID        *string               `json:"idpUserId,omitempty"`
	DsyncUserID      *string               `json:"dsyncUserId,omitempty"`
	DsyncConnectedAt *float64              `json:"dsyncConnectedAt,omitempty"`
}

func (t TeamLimitedJoinedFrom) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedJoinedFrom) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"origin"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedJoinedFrom) GetOrigin() TeamLimitedOrigin {
	if o == nil {
		return TeamLimitedOrigin("")
	}
	return o.Origin
}

func (o *TeamLimitedJoinedFrom) GetCommitID() *string {
	if o == nil {
		return nil
	}
	return o.CommitID
}

func (o *TeamLimitedJoinedFrom) GetRepoID() *string {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *TeamLimitedJoinedFrom) GetRepoPath() *string {
	if o == nil {
		return nil
	}
	return o.RepoPath
}

func (o *TeamLimitedJoinedFrom) GetGitUserID() *TeamLimitedGitUserID {
	if o == nil {
		return nil
	}
	return o.GitUserID
}

func (o *TeamLimitedJoinedFrom) GetGitUserLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitUserLogin
}

func (o *TeamLimitedJoinedFrom) GetSsoUserID() *string {
	if o == nil {
		return nil
	}
	return o.SsoUserID
}

func (o *TeamLimitedJoinedFrom) GetSsoConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SsoConnectedAt
}

func (o *TeamLimitedJoinedFrom) GetIdpUserID() *string {
	if o == nil {
		return nil
	}
	return o.IdpUserID
}

func (o *TeamLimitedJoinedFrom) GetDsyncUserID() *string {
	if o == nil {
		return nil
	}
	return o.DsyncUserID
}

func (o *TeamLimitedJoinedFrom) GetDsyncConnectedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DsyncConnectedAt
}

// TeamLimitedMembership - The membership of the authenticated User in relation to the Team.
type TeamLimitedMembership struct {
	UID               *string                     `json:"uid,omitempty"`
	Entitlements      []TeamLimitedEntitlement    `json:"entitlements,omitempty"`
	TeamID            *string                     `json:"teamId,omitempty"`
	Confirmed         bool                        `json:"confirmed"`
	AccessRequestedAt *float64                    `json:"accessRequestedAt,omitempty"`
	Role              TeamLimitedRole             `json:"role"`
	TeamRoles         []TeamLimitedTeamRole       `json:"teamRoles,omitempty"`
	TeamPermissions   []TeamLimitedTeamPermission `json:"teamPermissions,omitempty"`
	CreatedAt         float64                     `json:"createdAt"`
	Created           float64                     `json:"created"`
	JoinedFrom        *TeamLimitedJoinedFrom      `json:"joinedFrom,omitempty"`
}

func (t TeamLimitedMembership) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimitedMembership) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"confirmed", "role", "createdAt", "created"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimitedMembership) GetUID() *string {
	if o == nil {
		return nil
	}
	return o.UID
}

func (o *TeamLimitedMembership) GetEntitlements() []TeamLimitedEntitlement {
	if o == nil {
		return nil
	}
	return o.Entitlements
}

func (o *TeamLimitedMembership) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *TeamLimitedMembership) GetConfirmed() bool {
	if o == nil {
		return false
	}
	return o.Confirmed
}

func (o *TeamLimitedMembership) GetAccessRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AccessRequestedAt
}

func (o *TeamLimitedMembership) GetRole() TeamLimitedRole {
	if o == nil {
		return TeamLimitedRole("")
	}
	return o.Role
}

func (o *TeamLimitedMembership) GetTeamRoles() []TeamLimitedTeamRole {
	if o == nil {
		return nil
	}
	return o.TeamRoles
}

func (o *TeamLimitedMembership) GetTeamPermissions() []TeamLimitedTeamPermission {
	if o == nil {
		return nil
	}
	return o.TeamPermissions
}

func (o *TeamLimitedMembership) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *TeamLimitedMembership) GetCreated() float64 {
	if o == nil {
		return 0.0
	}
	return o.Created
}

func (o *TeamLimitedMembership) GetJoinedFrom() *TeamLimitedJoinedFrom {
	if o == nil {
		return nil
	}
	return o.JoinedFrom
}

// TeamLimited - A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
type TeamLimited struct {
	// Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data or due to team having MFA enforced and the user not having MFA enabled. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
	Limited   bool        `json:"limited"`
	LimitedBy []LimitedBy `json:"limitedBy"`
	// When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
	Saml *TeamLimitedSaml `json:"saml,omitempty"`
	// The Team's unique identifier.
	ID string `json:"id"`
	// The Team's slug, which is unique across the Vercel platform.
	Slug string `json:"slug"`
	// Name associated with the Team account, or `null` if none has been provided.
	Name *string `json:"name"`
	// The ID of the file used as avatar for this Team.
	Avatar *string `json:"avatar"`
	// The membership of the authenticated User in relation to the Team.
	Membership TeamLimitedMembership `json:"membership"`
	// UNIX timestamp (in milliseconds) when the Team was created.
	CreatedAt float64 `json:"createdAt"`
}

func (t TeamLimited) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TeamLimited) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"limited", "limitedBy", "id", "slug", "name", "avatar", "membership", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *TeamLimited) GetLimited() bool {
	if o == nil {
		return false
	}
	return o.Limited
}

func (o *TeamLimited) GetLimitedBy() []LimitedBy {
	if o == nil {
		return []LimitedBy{}
	}
	return o.LimitedBy
}

func (o *TeamLimited) GetSaml() *TeamLimitedSaml {
	if o == nil {
		return nil
	}
	return o.Saml
}

func (o *TeamLimited) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *TeamLimited) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *TeamLimited) GetName() *string {
	if o == nil {
		return nil
	}
	return o.Name
}

func (o *TeamLimited) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

func (o *TeamLimited) GetMembership() TeamLimitedMembership {
	if o == nil {
		return TeamLimitedMembership{}
	}
	return o.Membership
}

func (o *TeamLimited) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}
