// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type AddBypassIPRequestBody2 struct {
	Domain *string `json:"domain,omitempty"`
	// If the specified bypass will apply to all domains for a project.
	ProjectScope bool    `json:"projectScope"`
	SourceIP     *string `json:"sourceIp,omitempty"`
	AllSources   *bool   `json:"allSources,omitempty"`
	// Time to live in milliseconds
	TTL  *float64 `json:"ttl,omitempty"`
	Note *string  `json:"note,omitempty"`
}

func (a AddBypassIPRequestBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPRequestBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"projectScope"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPRequestBody2) GetDomain() *string {
	if o == nil {
		return nil
	}
	return o.Domain
}

func (o *AddBypassIPRequestBody2) GetProjectScope() bool {
	if o == nil {
		return false
	}
	return o.ProjectScope
}

func (o *AddBypassIPRequestBody2) GetSourceIP() *string {
	if o == nil {
		return nil
	}
	return o.SourceIP
}

func (o *AddBypassIPRequestBody2) GetAllSources() *bool {
	if o == nil {
		return nil
	}
	return o.AllSources
}

func (o *AddBypassIPRequestBody2) GetTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.TTL
}

func (o *AddBypassIPRequestBody2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

type AddBypassIPRequestBody1 struct {
	Domain string `json:"domain"`
	// If the specified bypass will apply to all domains for a project.
	ProjectScope *bool   `json:"projectScope,omitempty"`
	SourceIP     *string `json:"sourceIp,omitempty"`
	AllSources   *bool   `json:"allSources,omitempty"`
	// Time to live in milliseconds
	TTL  *float64 `json:"ttl,omitempty"`
	Note *string  `json:"note,omitempty"`
}

func (a AddBypassIPRequestBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPRequestBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"domain"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPRequestBody1) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *AddBypassIPRequestBody1) GetProjectScope() *bool {
	if o == nil {
		return nil
	}
	return o.ProjectScope
}

func (o *AddBypassIPRequestBody1) GetSourceIP() *string {
	if o == nil {
		return nil
	}
	return o.SourceIP
}

func (o *AddBypassIPRequestBody1) GetAllSources() *bool {
	if o == nil {
		return nil
	}
	return o.AllSources
}

func (o *AddBypassIPRequestBody1) GetTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.TTL
}

func (o *AddBypassIPRequestBody1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

type AddBypassIPRequestBodyType string

const (
	AddBypassIPRequestBodyTypeAddBypassIPRequestBody1 AddBypassIPRequestBodyType = "addBypassIp_RequestBody_1"
	AddBypassIPRequestBodyTypeAddBypassIPRequestBody2 AddBypassIPRequestBodyType = "addBypassIp_RequestBody_2"
)

type AddBypassIPRequestBody struct {
	AddBypassIPRequestBody1 *AddBypassIPRequestBody1 `queryParam:"inline"`
	AddBypassIPRequestBody2 *AddBypassIPRequestBody2 `queryParam:"inline"`

	Type AddBypassIPRequestBodyType
}

func CreateAddBypassIPRequestBodyAddBypassIPRequestBody1(addBypassIPRequestBody1 AddBypassIPRequestBody1) AddBypassIPRequestBody {
	typ := AddBypassIPRequestBodyTypeAddBypassIPRequestBody1

	return AddBypassIPRequestBody{
		AddBypassIPRequestBody1: &addBypassIPRequestBody1,
		Type:                    typ,
	}
}

func CreateAddBypassIPRequestBodyAddBypassIPRequestBody2(addBypassIPRequestBody2 AddBypassIPRequestBody2) AddBypassIPRequestBody {
	typ := AddBypassIPRequestBodyTypeAddBypassIPRequestBody2

	return AddBypassIPRequestBody{
		AddBypassIPRequestBody2: &addBypassIPRequestBody2,
		Type:                    typ,
	}
}

func (u *AddBypassIPRequestBody) UnmarshalJSON(data []byte) error {

	var addBypassIPRequestBody1 AddBypassIPRequestBody1 = AddBypassIPRequestBody1{}
	if err := utils.UnmarshalJSON(data, &addBypassIPRequestBody1, "", true, nil); err == nil {
		u.AddBypassIPRequestBody1 = &addBypassIPRequestBody1
		u.Type = AddBypassIPRequestBodyTypeAddBypassIPRequestBody1
		return nil
	}

	var addBypassIPRequestBody2 AddBypassIPRequestBody2 = AddBypassIPRequestBody2{}
	if err := utils.UnmarshalJSON(data, &addBypassIPRequestBody2, "", true, nil); err == nil {
		u.AddBypassIPRequestBody2 = &addBypassIPRequestBody2
		u.Type = AddBypassIPRequestBodyTypeAddBypassIPRequestBody2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AddBypassIPRequestBody", string(data))
}

func (u AddBypassIPRequestBody) MarshalJSON() ([]byte, error) {
	if u.AddBypassIPRequestBody1 != nil {
		return utils.MarshalJSON(u.AddBypassIPRequestBody1, "", true)
	}

	if u.AddBypassIPRequestBody2 != nil {
		return utils.MarshalJSON(u.AddBypassIPRequestBody2, "", true)
	}

	return nil, errors.New("could not marshal union type AddBypassIPRequestBody: all fields are null")
}

type AddBypassIPRequest struct {
	ProjectID string `queryParam:"style=form,explode=true,name=projectId"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string                 `queryParam:"style=form,explode=true,name=slug"`
	Body *AddBypassIPRequestBody `request:"mediaType=application/json"`
}

func (o *AddBypassIPRequest) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *AddBypassIPRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *AddBypassIPRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *AddBypassIPRequest) GetBody() *AddBypassIPRequestBody {
	if o == nil {
		return nil
	}
	return o.Body
}

type AddBypassIPAction string

const (
	AddBypassIPActionBlock  AddBypassIPAction = "block"
	AddBypassIPActionBypass AddBypassIPAction = "bypass"
)

func (e AddBypassIPAction) ToPointer() *AddBypassIPAction {
	return &e
}
func (e *AddBypassIPAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block":
		fallthrough
	case "bypass":
		*e = AddBypassIPAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AddBypassIPAction: %v", v)
	}
}

type AddBypassIPResult2 struct {
	OwnerID       string             `json:"OwnerId"`
	ID            string             `json:"Id"`
	Domain        string             `json:"Domain"`
	IP            string             `json:"Ip"`
	Action        *AddBypassIPAction `json:"Action,omitempty"`
	ProjectID     *string            `json:"ProjectId,omitempty"`
	IsProjectRule *bool              `json:"IsProjectRule,omitempty"`
	Note          *string            `json:"Note,omitempty"`
	CreatedAt     string             `json:"CreatedAt"`
	ActorID       *string            `json:"ActorId,omitempty"`
	UpdatedAt     string             `json:"UpdatedAt"`
	UpdatedAtHour string             `json:"UpdatedAtHour"`
	DeletedAt     *string            `json:"DeletedAt,omitempty"`
	ExpiresAt     *float64           `json:"ExpiresAt,omitempty"`
}

func (a AddBypassIPResult2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPResult2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"OwnerId", "Id", "Domain", "Ip", "CreatedAt", "UpdatedAt", "UpdatedAtHour"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPResult2) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *AddBypassIPResult2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *AddBypassIPResult2) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *AddBypassIPResult2) GetIP() string {
	if o == nil {
		return ""
	}
	return o.IP
}

func (o *AddBypassIPResult2) GetAction() *AddBypassIPAction {
	if o == nil {
		return nil
	}
	return o.Action
}

func (o *AddBypassIPResult2) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *AddBypassIPResult2) GetIsProjectRule() *bool {
	if o == nil {
		return nil
	}
	return o.IsProjectRule
}

func (o *AddBypassIPResult2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *AddBypassIPResult2) GetCreatedAt() string {
	if o == nil {
		return ""
	}
	return o.CreatedAt
}

func (o *AddBypassIPResult2) GetActorID() *string {
	if o == nil {
		return nil
	}
	return o.ActorID
}

func (o *AddBypassIPResult2) GetUpdatedAt() string {
	if o == nil {
		return ""
	}
	return o.UpdatedAt
}

func (o *AddBypassIPResult2) GetUpdatedAtHour() string {
	if o == nil {
		return ""
	}
	return o.UpdatedAtHour
}

func (o *AddBypassIPResult2) GetDeletedAt() *string {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *AddBypassIPResult2) GetExpiresAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpiresAt
}

type AddBypassIPResponseBody2 struct {
	Ok     bool                 `json:"ok"`
	Result []AddBypassIPResult2 `json:"result,omitempty"`
}

func (a AddBypassIPResponseBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPResponseBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"ok"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPResponseBody2) GetOk() bool {
	if o == nil {
		return false
	}
	return o.Ok
}

func (o *AddBypassIPResponseBody2) GetResult() []AddBypassIPResult2 {
	if o == nil {
		return nil
	}
	return o.Result
}

type AddBypassIPResult1 struct {
	OwnerID       string  `json:"OwnerId"`
	ID            string  `json:"Id"`
	Domain        string  `json:"Domain"`
	IP            *string `json:"Ip,omitempty"`
	ProjectID     string  `json:"ProjectId"`
	Note          string  `json:"Note"`
	IsProjectRule bool    `json:"IsProjectRule"`
}

func (a AddBypassIPResult1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPResult1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"OwnerId", "Id", "Domain", "ProjectId", "Note", "IsProjectRule"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPResult1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *AddBypassIPResult1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *AddBypassIPResult1) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *AddBypassIPResult1) GetIP() *string {
	if o == nil {
		return nil
	}
	return o.IP
}

func (o *AddBypassIPResult1) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *AddBypassIPResult1) GetNote() string {
	if o == nil {
		return ""
	}
	return o.Note
}

func (o *AddBypassIPResult1) GetIsProjectRule() bool {
	if o == nil {
		return false
	}
	return o.IsProjectRule
}

type AddBypassIPResponseBody1 struct {
	Ok         bool                 `json:"ok"`
	Result     []AddBypassIPResult1 `json:"result"`
	Pagination any                  `json:"pagination"`
}

func (a AddBypassIPResponseBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AddBypassIPResponseBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"ok", "result", "pagination"}); err != nil {
		return err
	}
	return nil
}

func (o *AddBypassIPResponseBody1) GetOk() bool {
	if o == nil {
		return false
	}
	return o.Ok
}

func (o *AddBypassIPResponseBody1) GetResult() []AddBypassIPResult1 {
	if o == nil {
		return []AddBypassIPResult1{}
	}
	return o.Result
}

func (o *AddBypassIPResponseBody1) GetPagination() any {
	if o == nil {
		return nil
	}
	return o.Pagination
}

type AddBypassIPResponseBodyType string

const (
	AddBypassIPResponseBodyTypeAddBypassIPResponseBody1 AddBypassIPResponseBodyType = "addBypassIp_ResponseBody_1"
	AddBypassIPResponseBodyTypeAddBypassIPResponseBody2 AddBypassIPResponseBodyType = "addBypassIp_ResponseBody_2"
)

type AddBypassIPResponseBody struct {
	AddBypassIPResponseBody1 *AddBypassIPResponseBody1 `queryParam:"inline"`
	AddBypassIPResponseBody2 *AddBypassIPResponseBody2 `queryParam:"inline"`

	Type AddBypassIPResponseBodyType
}

func CreateAddBypassIPResponseBodyAddBypassIPResponseBody1(addBypassIPResponseBody1 AddBypassIPResponseBody1) AddBypassIPResponseBody {
	typ := AddBypassIPResponseBodyTypeAddBypassIPResponseBody1

	return AddBypassIPResponseBody{
		AddBypassIPResponseBody1: &addBypassIPResponseBody1,
		Type:                     typ,
	}
}

func CreateAddBypassIPResponseBodyAddBypassIPResponseBody2(addBypassIPResponseBody2 AddBypassIPResponseBody2) AddBypassIPResponseBody {
	typ := AddBypassIPResponseBodyTypeAddBypassIPResponseBody2

	return AddBypassIPResponseBody{
		AddBypassIPResponseBody2: &addBypassIPResponseBody2,
		Type:                     typ,
	}
}

func (u *AddBypassIPResponseBody) UnmarshalJSON(data []byte) error {

	var addBypassIPResponseBody1 AddBypassIPResponseBody1 = AddBypassIPResponseBody1{}
	if err := utils.UnmarshalJSON(data, &addBypassIPResponseBody1, "", true, nil); err == nil {
		u.AddBypassIPResponseBody1 = &addBypassIPResponseBody1
		u.Type = AddBypassIPResponseBodyTypeAddBypassIPResponseBody1
		return nil
	}

	var addBypassIPResponseBody2 AddBypassIPResponseBody2 = AddBypassIPResponseBody2{}
	if err := utils.UnmarshalJSON(data, &addBypassIPResponseBody2, "", true, nil); err == nil {
		u.AddBypassIPResponseBody2 = &addBypassIPResponseBody2
		u.Type = AddBypassIPResponseBodyTypeAddBypassIPResponseBody2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for AddBypassIPResponseBody", string(data))
}

func (u AddBypassIPResponseBody) MarshalJSON() ([]byte, error) {
	if u.AddBypassIPResponseBody1 != nil {
		return utils.MarshalJSON(u.AddBypassIPResponseBody1, "", true)
	}

	if u.AddBypassIPResponseBody2 != nil {
		return utils.MarshalJSON(u.AddBypassIPResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type AddBypassIPResponseBody: all fields are null")
}

type AddBypassIPResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *AddBypassIPResponseBody
}

func (o *AddBypassIPResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *AddBypassIPResponse) GetOneOf() *AddBypassIPResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
