// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

// ForceNew - Forces a new deployment even if there is a previous similar deployment
type ForceNew string

const (
	ForceNewZero ForceNew = "0"
	ForceNewOne  ForceNew = "1"
)

func (e ForceNew) ToPointer() *ForceNew {
	return &e
}
func (e *ForceNew) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = ForceNew(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ForceNew: %v", v)
	}
}

// SkipAutoDetectionConfirmation - Allows to skip framework detection so the API would not fail to ask for confirmation
type SkipAutoDetectionConfirmation string

const (
	SkipAutoDetectionConfirmationZero SkipAutoDetectionConfirmation = "0"
	SkipAutoDetectionConfirmationOne  SkipAutoDetectionConfirmation = "1"
)

func (e SkipAutoDetectionConfirmation) ToPointer() *SkipAutoDetectionConfirmation {
	return &e
}
func (e *SkipAutoDetectionConfirmation) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "0":
		fallthrough
	case "1":
		*e = SkipAutoDetectionConfirmation(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SkipAutoDetectionConfirmation: %v", v)
	}
}

// UploadedFile - Used in the case you want to reference a file that was already uploaded
type UploadedFile struct {
	// The file path relative to the project root
	File string `json:"file"`
	// The file contents hashed with SHA1, used to check the integrity
	Sha *string `json:"sha,omitempty"`
	// The file size in bytes
	Size *int64 `json:"size,omitempty"`
}

func (u UploadedFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UploadedFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"file"}); err != nil {
		return err
	}
	return nil
}

func (o *UploadedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

func (o *UploadedFile) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *UploadedFile) GetSize() *int64 {
	if o == nil {
		return nil
	}
	return o.Size
}

// CreateDeploymentEncoding - The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
type CreateDeploymentEncoding string

const (
	CreateDeploymentEncodingBase64 CreateDeploymentEncoding = "base64"
	CreateDeploymentEncodingUTF8   CreateDeploymentEncoding = "utf-8"
)

func (e CreateDeploymentEncoding) ToPointer() *CreateDeploymentEncoding {
	return &e
}
func (e *CreateDeploymentEncoding) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "base64":
		fallthrough
	case "utf-8":
		*e = CreateDeploymentEncoding(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentEncoding: %v", v)
	}
}

// InlinedFile - Used in the case you want to inline a file inside the request
type InlinedFile struct {
	// The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
	Data string `json:"data"`
	// The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
	Encoding *CreateDeploymentEncoding `json:"encoding,omitempty"`
	// The file name including the whole path
	File string `json:"file"`
}

func (i InlinedFile) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InlinedFile) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"data", "file"}); err != nil {
		return err
	}
	return nil
}

func (o *InlinedFile) GetData() string {
	if o == nil {
		return ""
	}
	return o.Data
}

func (o *InlinedFile) GetEncoding() *CreateDeploymentEncoding {
	if o == nil {
		return nil
	}
	return o.Encoding
}

func (o *InlinedFile) GetFile() string {
	if o == nil {
		return ""
	}
	return o.File
}

type FileType string

const (
	FileTypeInlinedFile  FileType = "InlinedFile"
	FileTypeUploadedFile FileType = "UploadedFile"
)

type File struct {
	InlinedFile  *InlinedFile  `queryParam:"inline"`
	UploadedFile *UploadedFile `queryParam:"inline"`

	Type FileType
}

func CreateFileInlinedFile(inlinedFile InlinedFile) File {
	typ := FileTypeInlinedFile

	return File{
		InlinedFile: &inlinedFile,
		Type:        typ,
	}
}

func CreateFileUploadedFile(uploadedFile UploadedFile) File {
	typ := FileTypeUploadedFile

	return File{
		UploadedFile: &uploadedFile,
		Type:         typ,
	}
}

func (u *File) UnmarshalJSON(data []byte) error {

	var inlinedFile InlinedFile = InlinedFile{}
	if err := utils.UnmarshalJSON(data, &inlinedFile, "", true, nil); err == nil {
		u.InlinedFile = &inlinedFile
		u.Type = FileTypeInlinedFile
		return nil
	}

	var uploadedFile UploadedFile = UploadedFile{}
	if err := utils.UnmarshalJSON(data, &uploadedFile, "", true, nil); err == nil {
		u.UploadedFile = &uploadedFile
		u.Type = FileTypeUploadedFile
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for File", string(data))
}

func (u File) MarshalJSON() ([]byte, error) {
	if u.InlinedFile != nil {
		return utils.MarshalJSON(u.InlinedFile, "", true)
	}

	if u.UploadedFile != nil {
		return utils.MarshalJSON(u.UploadedFile, "", true)
	}

	return nil, errors.New("could not marshal union type File: all fields are null")
}

// GitMetadata - Populates initial git metadata for different git providers.
type GitMetadata struct {
	// The git repository's remote origin url
	RemoteURL *string `json:"remoteUrl,omitempty"`
	// The name of the author of the commit
	CommitAuthorName *string `json:"commitAuthorName,omitempty"`
	// The email of the author of the commit
	CommitAuthorEmail *string `json:"commitAuthorEmail,omitempty"`
	// The commit message
	CommitMessage *string `json:"commitMessage,omitempty"`
	// The branch on which the commit was made
	CommitRef *string `json:"commitRef,omitempty"`
	// The hash of the commit
	CommitSha *string `json:"commitSha,omitempty"`
	// Whether or not there have been modifications to the working tree since the latest commit
	Dirty *bool `json:"dirty,omitempty"`
	// True if process.env.CI was set when deploying
	Ci *bool `json:"ci,omitempty"`
	// The type of CI system used
	CiType *string `json:"ciType,omitempty"`
	// The username used for the Git Provider (e.g. GitHub) if their CI (e.g. GitHub Actions) was used, if available
	CiGitProviderUsername *string `json:"ciGitProviderUsername,omitempty"`
	// The visibility of the Git repository if their CI (e.g. GitHub Actions) was used, if available
	CiGitRepoVisibility *string `json:"ciGitRepoVisibility,omitempty"`
}

func (o *GitMetadata) GetRemoteURL() *string {
	if o == nil {
		return nil
	}
	return o.RemoteURL
}

func (o *GitMetadata) GetCommitAuthorName() *string {
	if o == nil {
		return nil
	}
	return o.CommitAuthorName
}

func (o *GitMetadata) GetCommitAuthorEmail() *string {
	if o == nil {
		return nil
	}
	return o.CommitAuthorEmail
}

func (o *GitMetadata) GetCommitMessage() *string {
	if o == nil {
		return nil
	}
	return o.CommitMessage
}

func (o *GitMetadata) GetCommitRef() *string {
	if o == nil {
		return nil
	}
	return o.CommitRef
}

func (o *GitMetadata) GetCommitSha() *string {
	if o == nil {
		return nil
	}
	return o.CommitSha
}

func (o *GitMetadata) GetDirty() *bool {
	if o == nil {
		return nil
	}
	return o.Dirty
}

func (o *GitMetadata) GetCi() *bool {
	if o == nil {
		return nil
	}
	return o.Ci
}

func (o *GitMetadata) GetCiType() *string {
	if o == nil {
		return nil
	}
	return o.CiType
}

func (o *GitMetadata) GetCiGitProviderUsername() *string {
	if o == nil {
		return nil
	}
	return o.CiGitProviderUsername
}

func (o *GitMetadata) GetCiGitRepoVisibility() *string {
	if o == nil {
		return nil
	}
	return o.CiGitRepoVisibility
}

type TypeBitbucketRequest2 string

const (
	TypeBitbucketRequest2Bitbucket TypeBitbucketRequest2 = "bitbucket"
)

func (e TypeBitbucketRequest2) ToPointer() *TypeBitbucketRequest2 {
	return &e
}
func (e *TypeBitbucketRequest2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = TypeBitbucketRequest2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeBitbucketRequest2: %v", v)
	}
}

type GitSourceBitbucketRequest2 struct {
	Owner string                `json:"owner"`
	Ref   string                `json:"ref"`
	Sha   *string               `json:"sha,omitempty"`
	Slug  string                `json:"slug"`
	Type  TypeBitbucketRequest2 `json:"type"`
}

func (g GitSourceBitbucketRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceBitbucketRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"owner", "ref", "slug", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceBitbucketRequest2) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GitSourceBitbucketRequest2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceBitbucketRequest2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceBitbucketRequest2) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GitSourceBitbucketRequest2) GetType() TypeBitbucketRequest2 {
	if o == nil {
		return TypeBitbucketRequest2("")
	}
	return o.Type
}

type TypeBitbucketRequest1 string

const (
	TypeBitbucketRequest1Bitbucket TypeBitbucketRequest1 = "bitbucket"
)

func (e TypeBitbucketRequest1) ToPointer() *TypeBitbucketRequest1 {
	return &e
}
func (e *TypeBitbucketRequest1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = TypeBitbucketRequest1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeBitbucketRequest1: %v", v)
	}
}

type GitSourceBitbucketRequest1 struct {
	Ref           string                `json:"ref"`
	RepoUUID      string                `json:"repoUuid"`
	Sha           *string               `json:"sha,omitempty"`
	Type          TypeBitbucketRequest1 `json:"type"`
	WorkspaceUUID *string               `json:"workspaceUuid,omitempty"`
}

func (g GitSourceBitbucketRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceBitbucketRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"ref", "repoUuid", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceBitbucketRequest1) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceBitbucketRequest1) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GitSourceBitbucketRequest1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceBitbucketRequest1) GetType() TypeBitbucketRequest1 {
	if o == nil {
		return TypeBitbucketRequest1("")
	}
	return o.Type
}

func (o *GitSourceBitbucketRequest1) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

type ProjectIDRequestType string

const (
	ProjectIDRequestTypeNumber ProjectIDRequestType = "number"
	ProjectIDRequestTypeStr    ProjectIDRequestType = "str"
)

type ProjectIDRequest struct {
	Number *float64 `queryParam:"inline"`
	Str    *string  `queryParam:"inline"`

	Type ProjectIDRequestType
}

func CreateProjectIDRequestNumber(number float64) ProjectIDRequest {
	typ := ProjectIDRequestTypeNumber

	return ProjectIDRequest{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectIDRequestStr(str string) ProjectIDRequest {
	typ := ProjectIDRequestTypeStr

	return ProjectIDRequest{
		Str:  &str,
		Type: typ,
	}
}

func (u *ProjectIDRequest) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ProjectIDRequestTypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ProjectIDRequestTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectIDRequest", string(data))
}

func (u ProjectIDRequest) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectIDRequest: all fields are null")
}

type TypeGitlabRequest string

const (
	TypeGitlabRequestGitlab TypeGitlabRequest = "gitlab"
)

func (e TypeGitlabRequest) ToPointer() *TypeGitlabRequest {
	return &e
}
func (e *TypeGitlabRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = TypeGitlabRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeGitlabRequest: %v", v)
	}
}

type GitSourceGitlabRequest struct {
	ProjectID ProjectIDRequest  `json:"projectId"`
	Ref       string            `json:"ref"`
	Sha       *string           `json:"sha,omitempty"`
	Type      TypeGitlabRequest `json:"type"`
}

func (g GitSourceGitlabRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceGitlabRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"projectId", "ref", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceGitlabRequest) GetProjectID() ProjectIDRequest {
	if o == nil {
		return ProjectIDRequest{}
	}
	return o.ProjectID
}

func (o *GitSourceGitlabRequest) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceGitlabRequest) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceGitlabRequest) GetType() TypeGitlabRequest {
	if o == nil {
		return TypeGitlabRequest("")
	}
	return o.Type
}

type TypeGithubLimitedRequest2 string

const (
	TypeGithubLimitedRequest2GithubLimited TypeGithubLimitedRequest2 = "github-limited"
)

func (e TypeGithubLimitedRequest2) ToPointer() *TypeGithubLimitedRequest2 {
	return &e
}
func (e *TypeGithubLimitedRequest2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = TypeGithubLimitedRequest2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeGithubLimitedRequest2: %v", v)
	}
}

type GitSourceGithubLimitedRequest2 struct {
	Org  string                    `json:"org"`
	Ref  string                    `json:"ref"`
	Repo string                    `json:"repo"`
	Sha  *string                   `json:"sha,omitempty"`
	Type TypeGithubLimitedRequest2 `json:"type"`
}

func (g GitSourceGithubLimitedRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceGithubLimitedRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"org", "ref", "repo", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceGithubLimitedRequest2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitSourceGithubLimitedRequest2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceGithubLimitedRequest2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitSourceGithubLimitedRequest2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceGithubLimitedRequest2) GetType() TypeGithubLimitedRequest2 {
	if o == nil {
		return TypeGithubLimitedRequest2("")
	}
	return o.Type
}

type RepoIDRequest2Type string

const (
	RepoIDRequest2TypeNumber RepoIDRequest2Type = "number"
	RepoIDRequest2TypeStr    RepoIDRequest2Type = "str"
)

type RepoIDRequest2 struct {
	Number *float64 `queryParam:"inline"`
	Str    *string  `queryParam:"inline"`

	Type RepoIDRequest2Type
}

func CreateRepoIDRequest2Number(number float64) RepoIDRequest2 {
	typ := RepoIDRequest2TypeNumber

	return RepoIDRequest2{
		Number: &number,
		Type:   typ,
	}
}

func CreateRepoIDRequest2Str(str string) RepoIDRequest2 {
	typ := RepoIDRequest2TypeStr

	return RepoIDRequest2{
		Str:  &str,
		Type: typ,
	}
}

func (u *RepoIDRequest2) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = RepoIDRequest2TypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = RepoIDRequest2TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RepoIDRequest2", string(data))
}

func (u RepoIDRequest2) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type RepoIDRequest2: all fields are null")
}

type TypeGithubLimitedRequest1 string

const (
	TypeGithubLimitedRequest1GithubLimited TypeGithubLimitedRequest1 = "github-limited"
)

func (e TypeGithubLimitedRequest1) ToPointer() *TypeGithubLimitedRequest1 {
	return &e
}
func (e *TypeGithubLimitedRequest1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = TypeGithubLimitedRequest1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeGithubLimitedRequest1: %v", v)
	}
}

type GitSourceGithubLimitedRequest1 struct {
	Ref    string                    `json:"ref"`
	RepoID RepoIDRequest2            `json:"repoId"`
	Sha    *string                   `json:"sha,omitempty"`
	Type   TypeGithubLimitedRequest1 `json:"type"`
}

func (g GitSourceGithubLimitedRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceGithubLimitedRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"ref", "repoId", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceGithubLimitedRequest1) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceGithubLimitedRequest1) GetRepoID() RepoIDRequest2 {
	if o == nil {
		return RepoIDRequest2{}
	}
	return o.RepoID
}

func (o *GitSourceGithubLimitedRequest1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceGithubLimitedRequest1) GetType() TypeGithubLimitedRequest1 {
	if o == nil {
		return TypeGithubLimitedRequest1("")
	}
	return o.Type
}

type TypeGithubRequest2 string

const (
	TypeGithubRequest2Github TypeGithubRequest2 = "github"
)

func (e TypeGithubRequest2) ToPointer() *TypeGithubRequest2 {
	return &e
}
func (e *TypeGithubRequest2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = TypeGithubRequest2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeGithubRequest2: %v", v)
	}
}

type GitSourceGithubRequest2 struct {
	Org  string             `json:"org"`
	Ref  string             `json:"ref"`
	Repo string             `json:"repo"`
	Sha  *string            `json:"sha,omitempty"`
	Type TypeGithubRequest2 `json:"type"`
}

func (g GitSourceGithubRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceGithubRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"org", "ref", "repo", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceGithubRequest2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GitSourceGithubRequest2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceGithubRequest2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GitSourceGithubRequest2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceGithubRequest2) GetType() TypeGithubRequest2 {
	if o == nil {
		return TypeGithubRequest2("")
	}
	return o.Type
}

type RepoIDRequest1Type string

const (
	RepoIDRequest1TypeNumber RepoIDRequest1Type = "number"
	RepoIDRequest1TypeStr    RepoIDRequest1Type = "str"
)

type RepoIDRequest1 struct {
	Number *float64 `queryParam:"inline"`
	Str    *string  `queryParam:"inline"`

	Type RepoIDRequest1Type
}

func CreateRepoIDRequest1Number(number float64) RepoIDRequest1 {
	typ := RepoIDRequest1TypeNumber

	return RepoIDRequest1{
		Number: &number,
		Type:   typ,
	}
}

func CreateRepoIDRequest1Str(str string) RepoIDRequest1 {
	typ := RepoIDRequest1TypeStr

	return RepoIDRequest1{
		Str:  &str,
		Type: typ,
	}
}

func (u *RepoIDRequest1) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = RepoIDRequest1TypeNumber
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = RepoIDRequest1TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RepoIDRequest1", string(data))
}

func (u RepoIDRequest1) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type RepoIDRequest1: all fields are null")
}

type TypeGithubRequest1 string

const (
	TypeGithubRequest1Github TypeGithubRequest1 = "github"
)

func (e TypeGithubRequest1) ToPointer() *TypeGithubRequest1 {
	return &e
}
func (e *TypeGithubRequest1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = TypeGithubRequest1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeGithubRequest1: %v", v)
	}
}

type GitSourceGithubRequest1 struct {
	Ref    string             `json:"ref"`
	RepoID RepoIDRequest1     `json:"repoId"`
	Sha    *string            `json:"sha,omitempty"`
	Type   TypeGithubRequest1 `json:"type"`
}

func (g GitSourceGithubRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitSourceGithubRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"ref", "repoId", "type"}); err != nil {
		return err
	}
	return nil
}

func (o *GitSourceGithubRequest1) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GitSourceGithubRequest1) GetRepoID() RepoIDRequest1 {
	if o == nil {
		return RepoIDRequest1{}
	}
	return o.RepoID
}

func (o *GitSourceGithubRequest1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *GitSourceGithubRequest1) GetType() TypeGithubRequest1 {
	if o == nil {
		return TypeGithubRequest1("")
	}
	return o.Type
}

type GitSourceRequestUnionType string

const (
	GitSourceRequestUnionTypeGitSourceGithubRequest1        GitSourceRequestUnionType = "gitSource_Github_request_1"
	GitSourceRequestUnionTypeGitSourceGithubRequest2        GitSourceRequestUnionType = "gitSource_Github_request_2"
	GitSourceRequestUnionTypeGitSourceGithubLimitedRequest1 GitSourceRequestUnionType = "gitSource_GithubLimited_request_1"
	GitSourceRequestUnionTypeGitSourceGithubLimitedRequest2 GitSourceRequestUnionType = "gitSource_GithubLimited_request_2"
	GitSourceRequestUnionTypeGitSourceGitlabRequest         GitSourceRequestUnionType = "gitSource_Gitlab_request"
	GitSourceRequestUnionTypeGitSourceBitbucketRequest1     GitSourceRequestUnionType = "gitSource_Bitbucket_request_1"
	GitSourceRequestUnionTypeGitSourceBitbucketRequest2     GitSourceRequestUnionType = "gitSource_Bitbucket_request_2"
)

// GitSourceRequestUnion - Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
type GitSourceRequestUnion struct {
	GitSourceGithubRequest1        *GitSourceGithubRequest1        `queryParam:"inline"`
	GitSourceGithubRequest2        *GitSourceGithubRequest2        `queryParam:"inline"`
	GitSourceGithubLimitedRequest1 *GitSourceGithubLimitedRequest1 `queryParam:"inline"`
	GitSourceGithubLimitedRequest2 *GitSourceGithubLimitedRequest2 `queryParam:"inline"`
	GitSourceGitlabRequest         *GitSourceGitlabRequest         `queryParam:"inline"`
	GitSourceBitbucketRequest1     *GitSourceBitbucketRequest1     `queryParam:"inline"`
	GitSourceBitbucketRequest2     *GitSourceBitbucketRequest2     `queryParam:"inline"`

	Type GitSourceRequestUnionType
}

func CreateGitSourceRequestUnionGitSourceGithubRequest1(gitSourceGithubRequest1 GitSourceGithubRequest1) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceGithubRequest1

	return GitSourceRequestUnion{
		GitSourceGithubRequest1: &gitSourceGithubRequest1,
		Type:                    typ,
	}
}

func CreateGitSourceRequestUnionGitSourceGithubRequest2(gitSourceGithubRequest2 GitSourceGithubRequest2) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceGithubRequest2

	return GitSourceRequestUnion{
		GitSourceGithubRequest2: &gitSourceGithubRequest2,
		Type:                    typ,
	}
}

func CreateGitSourceRequestUnionGitSourceGithubLimitedRequest1(gitSourceGithubLimitedRequest1 GitSourceGithubLimitedRequest1) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceGithubLimitedRequest1

	return GitSourceRequestUnion{
		GitSourceGithubLimitedRequest1: &gitSourceGithubLimitedRequest1,
		Type:                           typ,
	}
}

func CreateGitSourceRequestUnionGitSourceGithubLimitedRequest2(gitSourceGithubLimitedRequest2 GitSourceGithubLimitedRequest2) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceGithubLimitedRequest2

	return GitSourceRequestUnion{
		GitSourceGithubLimitedRequest2: &gitSourceGithubLimitedRequest2,
		Type:                           typ,
	}
}

func CreateGitSourceRequestUnionGitSourceGitlabRequest(gitSourceGitlabRequest GitSourceGitlabRequest) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceGitlabRequest

	return GitSourceRequestUnion{
		GitSourceGitlabRequest: &gitSourceGitlabRequest,
		Type:                   typ,
	}
}

func CreateGitSourceRequestUnionGitSourceBitbucketRequest1(gitSourceBitbucketRequest1 GitSourceBitbucketRequest1) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceBitbucketRequest1

	return GitSourceRequestUnion{
		GitSourceBitbucketRequest1: &gitSourceBitbucketRequest1,
		Type:                       typ,
	}
}

func CreateGitSourceRequestUnionGitSourceBitbucketRequest2(gitSourceBitbucketRequest2 GitSourceBitbucketRequest2) GitSourceRequestUnion {
	typ := GitSourceRequestUnionTypeGitSourceBitbucketRequest2

	return GitSourceRequestUnion{
		GitSourceBitbucketRequest2: &gitSourceBitbucketRequest2,
		Type:                       typ,
	}
}

func (u *GitSourceRequestUnion) UnmarshalJSON(data []byte) error {

	var gitSourceGithubRequest2 GitSourceGithubRequest2 = GitSourceGithubRequest2{}
	if err := utils.UnmarshalJSON(data, &gitSourceGithubRequest2, "", true, nil); err == nil {
		u.GitSourceGithubRequest2 = &gitSourceGithubRequest2
		u.Type = GitSourceRequestUnionTypeGitSourceGithubRequest2
		return nil
	}

	var gitSourceGithubLimitedRequest2 GitSourceGithubLimitedRequest2 = GitSourceGithubLimitedRequest2{}
	if err := utils.UnmarshalJSON(data, &gitSourceGithubLimitedRequest2, "", true, nil); err == nil {
		u.GitSourceGithubLimitedRequest2 = &gitSourceGithubLimitedRequest2
		u.Type = GitSourceRequestUnionTypeGitSourceGithubLimitedRequest2
		return nil
	}

	var gitSourceBitbucketRequest2 GitSourceBitbucketRequest2 = GitSourceBitbucketRequest2{}
	if err := utils.UnmarshalJSON(data, &gitSourceBitbucketRequest2, "", true, nil); err == nil {
		u.GitSourceBitbucketRequest2 = &gitSourceBitbucketRequest2
		u.Type = GitSourceRequestUnionTypeGitSourceBitbucketRequest2
		return nil
	}

	var gitSourceGithubRequest1 GitSourceGithubRequest1 = GitSourceGithubRequest1{}
	if err := utils.UnmarshalJSON(data, &gitSourceGithubRequest1, "", true, nil); err == nil {
		u.GitSourceGithubRequest1 = &gitSourceGithubRequest1
		u.Type = GitSourceRequestUnionTypeGitSourceGithubRequest1
		return nil
	}

	var gitSourceGithubLimitedRequest1 GitSourceGithubLimitedRequest1 = GitSourceGithubLimitedRequest1{}
	if err := utils.UnmarshalJSON(data, &gitSourceGithubLimitedRequest1, "", true, nil); err == nil {
		u.GitSourceGithubLimitedRequest1 = &gitSourceGithubLimitedRequest1
		u.Type = GitSourceRequestUnionTypeGitSourceGithubLimitedRequest1
		return nil
	}

	var gitSourceGitlabRequest GitSourceGitlabRequest = GitSourceGitlabRequest{}
	if err := utils.UnmarshalJSON(data, &gitSourceGitlabRequest, "", true, nil); err == nil {
		u.GitSourceGitlabRequest = &gitSourceGitlabRequest
		u.Type = GitSourceRequestUnionTypeGitSourceGitlabRequest
		return nil
	}

	var gitSourceBitbucketRequest1 GitSourceBitbucketRequest1 = GitSourceBitbucketRequest1{}
	if err := utils.UnmarshalJSON(data, &gitSourceBitbucketRequest1, "", true, nil); err == nil {
		u.GitSourceBitbucketRequest1 = &gitSourceBitbucketRequest1
		u.Type = GitSourceRequestUnionTypeGitSourceBitbucketRequest1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GitSourceRequestUnion", string(data))
}

func (u GitSourceRequestUnion) MarshalJSON() ([]byte, error) {
	if u.GitSourceGithubRequest1 != nil {
		return utils.MarshalJSON(u.GitSourceGithubRequest1, "", true)
	}

	if u.GitSourceGithubRequest2 != nil {
		return utils.MarshalJSON(u.GitSourceGithubRequest2, "", true)
	}

	if u.GitSourceGithubLimitedRequest1 != nil {
		return utils.MarshalJSON(u.GitSourceGithubLimitedRequest1, "", true)
	}

	if u.GitSourceGithubLimitedRequest2 != nil {
		return utils.MarshalJSON(u.GitSourceGithubLimitedRequest2, "", true)
	}

	if u.GitSourceGitlabRequest != nil {
		return utils.MarshalJSON(u.GitSourceGitlabRequest, "", true)
	}

	if u.GitSourceBitbucketRequest1 != nil {
		return utils.MarshalJSON(u.GitSourceBitbucketRequest1, "", true)
	}

	if u.GitSourceBitbucketRequest2 != nil {
		return utils.MarshalJSON(u.GitSourceBitbucketRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type GitSourceRequestUnion: all fields are null")
}

// CreateDeploymentFrameworkRequest - The framework that is being used for this project. When `null` is used no framework is selected
type CreateDeploymentFrameworkRequest string

const (
	CreateDeploymentFrameworkRequestBlitzjs        CreateDeploymentFrameworkRequest = "blitzjs"
	CreateDeploymentFrameworkRequestNextjs         CreateDeploymentFrameworkRequest = "nextjs"
	CreateDeploymentFrameworkRequestGatsby         CreateDeploymentFrameworkRequest = "gatsby"
	CreateDeploymentFrameworkRequestRemix          CreateDeploymentFrameworkRequest = "remix"
	CreateDeploymentFrameworkRequestReactRouter    CreateDeploymentFrameworkRequest = "react-router"
	CreateDeploymentFrameworkRequestAstro          CreateDeploymentFrameworkRequest = "astro"
	CreateDeploymentFrameworkRequestHexo           CreateDeploymentFrameworkRequest = "hexo"
	CreateDeploymentFrameworkRequestEleventy       CreateDeploymentFrameworkRequest = "eleventy"
	CreateDeploymentFrameworkRequestDocusaurus2    CreateDeploymentFrameworkRequest = "docusaurus-2"
	CreateDeploymentFrameworkRequestDocusaurus     CreateDeploymentFrameworkRequest = "docusaurus"
	CreateDeploymentFrameworkRequestPreact         CreateDeploymentFrameworkRequest = "preact"
	CreateDeploymentFrameworkRequestSolidstart1    CreateDeploymentFrameworkRequest = "solidstart-1"
	CreateDeploymentFrameworkRequestSolidstart     CreateDeploymentFrameworkRequest = "solidstart"
	CreateDeploymentFrameworkRequestDojo           CreateDeploymentFrameworkRequest = "dojo"
	CreateDeploymentFrameworkRequestEmber          CreateDeploymentFrameworkRequest = "ember"
	CreateDeploymentFrameworkRequestVue            CreateDeploymentFrameworkRequest = "vue"
	CreateDeploymentFrameworkRequestScully         CreateDeploymentFrameworkRequest = "scully"
	CreateDeploymentFrameworkRequestIonicAngular   CreateDeploymentFrameworkRequest = "ionic-angular"
	CreateDeploymentFrameworkRequestAngular        CreateDeploymentFrameworkRequest = "angular"
	CreateDeploymentFrameworkRequestPolymer        CreateDeploymentFrameworkRequest = "polymer"
	CreateDeploymentFrameworkRequestSvelte         CreateDeploymentFrameworkRequest = "svelte"
	CreateDeploymentFrameworkRequestSveltekit      CreateDeploymentFrameworkRequest = "sveltekit"
	CreateDeploymentFrameworkRequestSveltekit1     CreateDeploymentFrameworkRequest = "sveltekit-1"
	CreateDeploymentFrameworkRequestIonicReact     CreateDeploymentFrameworkRequest = "ionic-react"
	CreateDeploymentFrameworkRequestCreateReactApp CreateDeploymentFrameworkRequest = "create-react-app"
	CreateDeploymentFrameworkRequestGridsome       CreateDeploymentFrameworkRequest = "gridsome"
	CreateDeploymentFrameworkRequestUmijs          CreateDeploymentFrameworkRequest = "umijs"
	CreateDeploymentFrameworkRequestSapper         CreateDeploymentFrameworkRequest = "sapper"
	CreateDeploymentFrameworkRequestSaber          CreateDeploymentFrameworkRequest = "saber"
	CreateDeploymentFrameworkRequestStencil        CreateDeploymentFrameworkRequest = "stencil"
	CreateDeploymentFrameworkRequestNuxtjs         CreateDeploymentFrameworkRequest = "nuxtjs"
	CreateDeploymentFrameworkRequestRedwoodjs      CreateDeploymentFrameworkRequest = "redwoodjs"
	CreateDeploymentFrameworkRequestHugo           CreateDeploymentFrameworkRequest = "hugo"
	CreateDeploymentFrameworkRequestJekyll         CreateDeploymentFrameworkRequest = "jekyll"
	CreateDeploymentFrameworkRequestBrunch         CreateDeploymentFrameworkRequest = "brunch"
	CreateDeploymentFrameworkRequestMiddleman      CreateDeploymentFrameworkRequest = "middleman"
	CreateDeploymentFrameworkRequestZola           CreateDeploymentFrameworkRequest = "zola"
	CreateDeploymentFrameworkRequestHydrogen       CreateDeploymentFrameworkRequest = "hydrogen"
	CreateDeploymentFrameworkRequestVite           CreateDeploymentFrameworkRequest = "vite"
	CreateDeploymentFrameworkRequestVitepress      CreateDeploymentFrameworkRequest = "vitepress"
	CreateDeploymentFrameworkRequestVuepress       CreateDeploymentFrameworkRequest = "vuepress"
	CreateDeploymentFrameworkRequestParcel         CreateDeploymentFrameworkRequest = "parcel"
	CreateDeploymentFrameworkRequestFastapi        CreateDeploymentFrameworkRequest = "fastapi"
	CreateDeploymentFrameworkRequestFlask          CreateDeploymentFrameworkRequest = "flask"
	CreateDeploymentFrameworkRequestFasthtml       CreateDeploymentFrameworkRequest = "fasthtml"
	CreateDeploymentFrameworkRequestSanityV3       CreateDeploymentFrameworkRequest = "sanity-v3"
	CreateDeploymentFrameworkRequestSanity         CreateDeploymentFrameworkRequest = "sanity"
	CreateDeploymentFrameworkRequestStorybook      CreateDeploymentFrameworkRequest = "storybook"
	CreateDeploymentFrameworkRequestNitro          CreateDeploymentFrameworkRequest = "nitro"
	CreateDeploymentFrameworkRequestHono           CreateDeploymentFrameworkRequest = "hono"
	CreateDeploymentFrameworkRequestExpress        CreateDeploymentFrameworkRequest = "express"
	CreateDeploymentFrameworkRequestH3             CreateDeploymentFrameworkRequest = "h3"
	CreateDeploymentFrameworkRequestNestjs         CreateDeploymentFrameworkRequest = "nestjs"
	CreateDeploymentFrameworkRequestFastify        CreateDeploymentFrameworkRequest = "fastify"
	CreateDeploymentFrameworkRequestXmcp           CreateDeploymentFrameworkRequest = "xmcp"
)

func (e CreateDeploymentFrameworkRequest) ToPointer() *CreateDeploymentFrameworkRequest {
	return &e
}
func (e *CreateDeploymentFrameworkRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "react-router":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fastapi":
		fallthrough
	case "flask":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		fallthrough
	case "nitro":
		fallthrough
	case "hono":
		fallthrough
	case "express":
		fallthrough
	case "h3":
		fallthrough
	case "nestjs":
		fallthrough
	case "fastify":
		fallthrough
	case "xmcp":
		*e = CreateDeploymentFrameworkRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFrameworkRequest: %v", v)
	}
}

// CreateDeploymentNodeVersionRequest - Override the Node.js version that should be used for this deployment
type CreateDeploymentNodeVersionRequest string

const (
	CreateDeploymentNodeVersionRequestTwentyFourDotX CreateDeploymentNodeVersionRequest = "24.x"
	CreateDeploymentNodeVersionRequestTwentyTwoDotX  CreateDeploymentNodeVersionRequest = "22.x"
	CreateDeploymentNodeVersionRequestTwentyDotX     CreateDeploymentNodeVersionRequest = "20.x"
	CreateDeploymentNodeVersionRequestEighteenDotX   CreateDeploymentNodeVersionRequest = "18.x"
	CreateDeploymentNodeVersionRequestSixteenDotX    CreateDeploymentNodeVersionRequest = "16.x"
	CreateDeploymentNodeVersionRequestFourteenDotX   CreateDeploymentNodeVersionRequest = "14.x"
	CreateDeploymentNodeVersionRequestTwelveDotX     CreateDeploymentNodeVersionRequest = "12.x"
	CreateDeploymentNodeVersionRequestTenDotX        CreateDeploymentNodeVersionRequest = "10.x"
	CreateDeploymentNodeVersionRequestEightDot10DotX CreateDeploymentNodeVersionRequest = "8.10.x"
)

func (e CreateDeploymentNodeVersionRequest) ToPointer() *CreateDeploymentNodeVersionRequest {
	return &e
}
func (e *CreateDeploymentNodeVersionRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "24.x":
		fallthrough
	case "22.x":
		fallthrough
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		fallthrough
	case "14.x":
		fallthrough
	case "12.x":
		fallthrough
	case "10.x":
		fallthrough
	case "8.10.x":
		*e = CreateDeploymentNodeVersionRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentNodeVersionRequest: %v", v)
	}
}

// ProjectSettingsRequest - Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
type ProjectSettingsRequest struct {
	// The build command for this project. When `null` is used this value will be automatically detected
	BuildCommand                *string `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep *string `json:"commandForIgnoringBuildStep,omitempty"`
	// The dev command for this project. When `null` is used this value will be automatically detected
	DevCommand *string `json:"devCommand,omitempty"`
	// The framework that is being used for this project. When `null` is used no framework is selected
	Framework *CreateDeploymentFrameworkRequest `json:"framework,omitempty"`
	// The install command for this project. When `null` is used this value will be automatically detected
	InstallCommand *string `json:"installCommand,omitempty"`
	// Override the Node.js version that should be used for this deployment
	NodeVersion *CreateDeploymentNodeVersionRequest `json:"nodeVersion,omitempty"`
	// The output directory of the project. When `null` is used this value will be automatically detected
	OutputDirectory *string `json:"outputDirectory,omitempty"`
	// The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
	RootDirectory *string `json:"rootDirectory,omitempty"`
	// The region to deploy Serverless Functions in this project
	ServerlessFunctionRegion *string `json:"serverlessFunctionRegion,omitempty"`
	// Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
	//
	// Deprecated: This will be removed in a future release, please migrate away from it as soon as possible.
	SkipGitConnectDuringLink *bool `json:"skipGitConnectDuringLink,omitempty"`
	// Indicates if there are source files outside of the root directory, typically used for monorepos
	SourceFilesOutsideRootDirectory *bool `json:"sourceFilesOutsideRootDirectory,omitempty"`
}

func (o *ProjectSettingsRequest) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *ProjectSettingsRequest) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *ProjectSettingsRequest) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *ProjectSettingsRequest) GetFramework() *CreateDeploymentFrameworkRequest {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *ProjectSettingsRequest) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *ProjectSettingsRequest) GetNodeVersion() *CreateDeploymentNodeVersionRequest {
	if o == nil {
		return nil
	}
	return o.NodeVersion
}

func (o *ProjectSettingsRequest) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *ProjectSettingsRequest) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *ProjectSettingsRequest) GetServerlessFunctionRegion() *string {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionRegion
}

func (o *ProjectSettingsRequest) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *ProjectSettingsRequest) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

type CreateDeploymentRequestBody struct {
	// Deploy to a custom environment, which will override the default environment
	CustomEnvironmentSlugOrID *string `json:"customEnvironmentSlugOrId,omitempty"`
	// An deployment id for an existing deployment to redeploy
	DeploymentID *string `json:"deploymentId,omitempty"`
	// A list of objects with the files to be deployed
	Files []File `json:"files,omitempty"`
	// Populates initial git metadata for different git providers.
	GitMetadata *GitMetadata `json:"gitMetadata,omitempty"`
	// Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
	GitSource *GitSourceRequestUnion `json:"gitSource,omitempty"`
	// An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
	Meta map[string]string `json:"meta,omitempty"`
	// The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
	MonorepoManager *string `json:"monorepoManager,omitempty"`
	// A string with the project name used in the deployment URL
	Name string `json:"name"`
	// The target project identifier in which the deployment will be created. When defined, this parameter overrides name
	Project *string `json:"project,omitempty"`
	// Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
	ProjectSettings *ProjectSettingsRequest `json:"projectSettings,omitempty"`
	// Either not defined, `staging`, `production`, or a custom environment identifier. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`.
	Target *string `json:"target,omitempty"`
	// When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
	WithLatestCommit *bool `json:"withLatestCommit,omitempty"`
}

func (o *CreateDeploymentRequestBody) GetCustomEnvironmentSlugOrID() *string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentSlugOrID
}

func (o *CreateDeploymentRequestBody) GetDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentID
}

func (o *CreateDeploymentRequestBody) GetFiles() []File {
	if o == nil {
		return nil
	}
	return o.Files
}

func (o *CreateDeploymentRequestBody) GetGitMetadata() *GitMetadata {
	if o == nil {
		return nil
	}
	return o.GitMetadata
}

func (o *CreateDeploymentRequestBody) GetGitSource() *GitSourceRequestUnion {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentRequestBody) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *CreateDeploymentRequestBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentRequestBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentRequestBody) GetProject() *string {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *CreateDeploymentRequestBody) GetProjectSettings() *ProjectSettingsRequest {
	if o == nil {
		return nil
	}
	return o.ProjectSettings
}

func (o *CreateDeploymentRequestBody) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentRequestBody) GetWithLatestCommit() *bool {
	if o == nil {
		return nil
	}
	return o.WithLatestCommit
}

type CreateDeploymentRequest struct {
	// Forces a new deployment even if there is a previous similar deployment
	ForceNew *ForceNew `queryParam:"style=form,explode=true,name=forceNew"`
	// Allows to skip framework detection so the API would not fail to ask for confirmation
	SkipAutoDetectionConfirmation *SkipAutoDetectionConfirmation `queryParam:"style=form,explode=true,name=skipAutoDetectionConfirmation"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string                     `queryParam:"style=form,explode=true,name=slug"`
	RequestBody CreateDeploymentRequestBody `request:"mediaType=application/json"`
}

func (o *CreateDeploymentRequest) GetForceNew() *ForceNew {
	if o == nil {
		return nil
	}
	return o.ForceNew
}

func (o *CreateDeploymentRequest) GetSkipAutoDetectionConfirmation() *SkipAutoDetectionConfirmation {
	if o == nil {
		return nil
	}
	return o.SkipAutoDetectionConfirmation
}

func (o *CreateDeploymentRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *CreateDeploymentRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentRequest) GetRequestBody() CreateDeploymentRequestBody {
	if o == nil {
		return CreateDeploymentRequestBody{}
	}
	return o.RequestBody
}

type CreateDeploymentAliasAssignedAtType string

const (
	CreateDeploymentAliasAssignedAtTypeNumber  CreateDeploymentAliasAssignedAtType = "number"
	CreateDeploymentAliasAssignedAtTypeBoolean CreateDeploymentAliasAssignedAtType = "boolean"
)

type CreateDeploymentAliasAssignedAt struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type CreateDeploymentAliasAssignedAtType
}

func CreateCreateDeploymentAliasAssignedAtNumber(number float64) CreateDeploymentAliasAssignedAt {
	typ := CreateDeploymentAliasAssignedAtTypeNumber

	return CreateDeploymentAliasAssignedAt{
		Number: &number,
		Type:   typ,
	}
}

func CreateCreateDeploymentAliasAssignedAtBoolean(boolean bool) CreateDeploymentAliasAssignedAt {
	typ := CreateDeploymentAliasAssignedAtTypeBoolean

	return CreateDeploymentAliasAssignedAt{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *CreateDeploymentAliasAssignedAt) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentAliasAssignedAtTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = CreateDeploymentAliasAssignedAtTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentAliasAssignedAt", string(data))
}

func (u CreateDeploymentAliasAssignedAt) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentAliasAssignedAt: all fields are null")
}

type CreateDeploymentBuild1 struct {
	Env []string `json:"env"`
}

func (o *CreateDeploymentBuild1) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

type CreateDeploymentBuild2 struct {
	Use    string         `json:"use"`
	Src    *string        `json:"src,omitempty"`
	Config map[string]any `json:"config,omitempty"`
}

func (o *CreateDeploymentBuild2) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *CreateDeploymentBuild2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *CreateDeploymentBuild2) GetConfig() map[string]any {
	if o == nil {
		return nil
	}
	return o.Config
}

type CreateDeploymentFrameworkLambdas string

const (
	CreateDeploymentFrameworkLambdasBlitzjs        CreateDeploymentFrameworkLambdas = "blitzjs"
	CreateDeploymentFrameworkLambdasNextjs         CreateDeploymentFrameworkLambdas = "nextjs"
	CreateDeploymentFrameworkLambdasGatsby         CreateDeploymentFrameworkLambdas = "gatsby"
	CreateDeploymentFrameworkLambdasRemix          CreateDeploymentFrameworkLambdas = "remix"
	CreateDeploymentFrameworkLambdasReactRouter    CreateDeploymentFrameworkLambdas = "react-router"
	CreateDeploymentFrameworkLambdasAstro          CreateDeploymentFrameworkLambdas = "astro"
	CreateDeploymentFrameworkLambdasHexo           CreateDeploymentFrameworkLambdas = "hexo"
	CreateDeploymentFrameworkLambdasEleventy       CreateDeploymentFrameworkLambdas = "eleventy"
	CreateDeploymentFrameworkLambdasDocusaurus2    CreateDeploymentFrameworkLambdas = "docusaurus-2"
	CreateDeploymentFrameworkLambdasDocusaurus     CreateDeploymentFrameworkLambdas = "docusaurus"
	CreateDeploymentFrameworkLambdasPreact         CreateDeploymentFrameworkLambdas = "preact"
	CreateDeploymentFrameworkLambdasSolidstart1    CreateDeploymentFrameworkLambdas = "solidstart-1"
	CreateDeploymentFrameworkLambdasSolidstart     CreateDeploymentFrameworkLambdas = "solidstart"
	CreateDeploymentFrameworkLambdasDojo           CreateDeploymentFrameworkLambdas = "dojo"
	CreateDeploymentFrameworkLambdasEmber          CreateDeploymentFrameworkLambdas = "ember"
	CreateDeploymentFrameworkLambdasVue            CreateDeploymentFrameworkLambdas = "vue"
	CreateDeploymentFrameworkLambdasScully         CreateDeploymentFrameworkLambdas = "scully"
	CreateDeploymentFrameworkLambdasIonicAngular   CreateDeploymentFrameworkLambdas = "ionic-angular"
	CreateDeploymentFrameworkLambdasAngular        CreateDeploymentFrameworkLambdas = "angular"
	CreateDeploymentFrameworkLambdasPolymer        CreateDeploymentFrameworkLambdas = "polymer"
	CreateDeploymentFrameworkLambdasSvelte         CreateDeploymentFrameworkLambdas = "svelte"
	CreateDeploymentFrameworkLambdasSveltekit      CreateDeploymentFrameworkLambdas = "sveltekit"
	CreateDeploymentFrameworkLambdasSveltekit1     CreateDeploymentFrameworkLambdas = "sveltekit-1"
	CreateDeploymentFrameworkLambdasIonicReact     CreateDeploymentFrameworkLambdas = "ionic-react"
	CreateDeploymentFrameworkLambdasCreateReactApp CreateDeploymentFrameworkLambdas = "create-react-app"
	CreateDeploymentFrameworkLambdasGridsome       CreateDeploymentFrameworkLambdas = "gridsome"
	CreateDeploymentFrameworkLambdasUmijs          CreateDeploymentFrameworkLambdas = "umijs"
	CreateDeploymentFrameworkLambdasSapper         CreateDeploymentFrameworkLambdas = "sapper"
	CreateDeploymentFrameworkLambdasSaber          CreateDeploymentFrameworkLambdas = "saber"
	CreateDeploymentFrameworkLambdasStencil        CreateDeploymentFrameworkLambdas = "stencil"
	CreateDeploymentFrameworkLambdasNuxtjs         CreateDeploymentFrameworkLambdas = "nuxtjs"
	CreateDeploymentFrameworkLambdasRedwoodjs      CreateDeploymentFrameworkLambdas = "redwoodjs"
	CreateDeploymentFrameworkLambdasHugo           CreateDeploymentFrameworkLambdas = "hugo"
	CreateDeploymentFrameworkLambdasJekyll         CreateDeploymentFrameworkLambdas = "jekyll"
	CreateDeploymentFrameworkLambdasBrunch         CreateDeploymentFrameworkLambdas = "brunch"
	CreateDeploymentFrameworkLambdasMiddleman      CreateDeploymentFrameworkLambdas = "middleman"
	CreateDeploymentFrameworkLambdasZola           CreateDeploymentFrameworkLambdas = "zola"
	CreateDeploymentFrameworkLambdasHydrogen       CreateDeploymentFrameworkLambdas = "hydrogen"
	CreateDeploymentFrameworkLambdasVite           CreateDeploymentFrameworkLambdas = "vite"
	CreateDeploymentFrameworkLambdasVitepress      CreateDeploymentFrameworkLambdas = "vitepress"
	CreateDeploymentFrameworkLambdasVuepress       CreateDeploymentFrameworkLambdas = "vuepress"
	CreateDeploymentFrameworkLambdasParcel         CreateDeploymentFrameworkLambdas = "parcel"
	CreateDeploymentFrameworkLambdasFastapi        CreateDeploymentFrameworkLambdas = "fastapi"
	CreateDeploymentFrameworkLambdasFlask          CreateDeploymentFrameworkLambdas = "flask"
	CreateDeploymentFrameworkLambdasFasthtml       CreateDeploymentFrameworkLambdas = "fasthtml"
	CreateDeploymentFrameworkLambdasSanityV3       CreateDeploymentFrameworkLambdas = "sanity-v3"
	CreateDeploymentFrameworkLambdasSanity         CreateDeploymentFrameworkLambdas = "sanity"
	CreateDeploymentFrameworkLambdasStorybook      CreateDeploymentFrameworkLambdas = "storybook"
	CreateDeploymentFrameworkLambdasNitro          CreateDeploymentFrameworkLambdas = "nitro"
	CreateDeploymentFrameworkLambdasHono           CreateDeploymentFrameworkLambdas = "hono"
	CreateDeploymentFrameworkLambdasExpress        CreateDeploymentFrameworkLambdas = "express"
	CreateDeploymentFrameworkLambdasH3             CreateDeploymentFrameworkLambdas = "h3"
	CreateDeploymentFrameworkLambdasNestjs         CreateDeploymentFrameworkLambdas = "nestjs"
	CreateDeploymentFrameworkLambdasFastify        CreateDeploymentFrameworkLambdas = "fastify"
	CreateDeploymentFrameworkLambdasXmcp           CreateDeploymentFrameworkLambdas = "xmcp"
)

func (e CreateDeploymentFrameworkLambdas) ToPointer() *CreateDeploymentFrameworkLambdas {
	return &e
}
func (e *CreateDeploymentFrameworkLambdas) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "react-router":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fastapi":
		fallthrough
	case "flask":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		fallthrough
	case "nitro":
		fallthrough
	case "hono":
		fallthrough
	case "express":
		fallthrough
	case "h3":
		fallthrough
	case "nestjs":
		fallthrough
	case "fastify":
		fallthrough
	case "xmcp":
		*e = CreateDeploymentFrameworkLambdas(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFrameworkLambdas: %v", v)
	}
}

type CreateDeploymentSpeedInsights struct {
	ID         string   `json:"id"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
	PaidAt     *float64 `json:"paidAt,omitempty"`
}

func (o *CreateDeploymentSpeedInsights) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentSpeedInsights) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *CreateDeploymentSpeedInsights) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *CreateDeploymentSpeedInsights) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentSpeedInsights) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

func (o *CreateDeploymentSpeedInsights) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

type CreateDeploymentWebAnalytics struct {
	ID         string   `json:"id"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
}

func (o *CreateDeploymentWebAnalytics) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentWebAnalytics) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *CreateDeploymentWebAnalytics) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentWebAnalytics) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *CreateDeploymentWebAnalytics) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

type CreateDeploymentProjectSettingsLambdas struct {
	BuildCommand                *string                           `json:"buildCommand,omitempty"`
	DevCommand                  *string                           `json:"devCommand,omitempty"`
	Framework                   *CreateDeploymentFrameworkLambdas `json:"framework,omitempty"`
	CommandForIgnoringBuildStep *string                           `json:"commandForIgnoringBuildStep,omitempty"`
	InstallCommand              *string                           `json:"installCommand,omitempty"`
	OutputDirectory             *string                           `json:"outputDirectory,omitempty"`
	SpeedInsights               *CreateDeploymentSpeedInsights    `json:"speedInsights,omitempty"`
	WebAnalytics                *CreateDeploymentWebAnalytics     `json:"webAnalytics,omitempty"`
}

func (o *CreateDeploymentProjectSettingsLambdas) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *CreateDeploymentProjectSettingsLambdas) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *CreateDeploymentProjectSettingsLambdas) GetFramework() *CreateDeploymentFrameworkLambdas {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *CreateDeploymentProjectSettingsLambdas) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *CreateDeploymentProjectSettingsLambdas) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *CreateDeploymentProjectSettingsLambdas) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *CreateDeploymentProjectSettingsLambdas) GetSpeedInsights() *CreateDeploymentSpeedInsights {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

func (o *CreateDeploymentProjectSettingsLambdas) GetWebAnalytics() *CreateDeploymentWebAnalytics {
	if o == nil {
		return nil
	}
	return o.WebAnalytics
}

type CreateDeploymentIntegrationsStatus string

const (
	CreateDeploymentIntegrationsStatusSkipped CreateDeploymentIntegrationsStatus = "skipped"
	CreateDeploymentIntegrationsStatusPending CreateDeploymentIntegrationsStatus = "pending"
	CreateDeploymentIntegrationsStatusReady   CreateDeploymentIntegrationsStatus = "ready"
	CreateDeploymentIntegrationsStatusError   CreateDeploymentIntegrationsStatus = "error"
	CreateDeploymentIntegrationsStatusTimeout CreateDeploymentIntegrationsStatus = "timeout"
)

func (e CreateDeploymentIntegrationsStatus) ToPointer() *CreateDeploymentIntegrationsStatus {
	return &e
}
func (e *CreateDeploymentIntegrationsStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "skipped":
		fallthrough
	case "pending":
		fallthrough
	case "ready":
		fallthrough
	case "error":
		fallthrough
	case "timeout":
		*e = CreateDeploymentIntegrationsStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentIntegrationsStatus: %v", v)
	}
}

type CreateDeploymentIntegrations struct {
	Status      CreateDeploymentIntegrationsStatus `json:"status"`
	StartedAt   float64                            `json:"startedAt"`
	CompletedAt *float64                           `json:"completedAt,omitempty"`
	SkippedAt   *float64                           `json:"skippedAt,omitempty"`
	SkippedBy   *string                            `json:"skippedBy,omitempty"`
}

func (o *CreateDeploymentIntegrations) GetStatus() CreateDeploymentIntegrationsStatus {
	if o == nil {
		return CreateDeploymentIntegrationsStatus("")
	}
	return o.Status
}

func (o *CreateDeploymentIntegrations) GetStartedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.StartedAt
}

func (o *CreateDeploymentIntegrations) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

func (o *CreateDeploymentIntegrations) GetSkippedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SkippedAt
}

func (o *CreateDeploymentIntegrations) GetSkippedBy() *string {
	if o == nil {
		return nil
	}
	return o.SkippedBy
}

// CreateDeploymentProtocol - Must be `http` or `https`.
type CreateDeploymentProtocol string

const (
	CreateDeploymentProtocolHTTP  CreateDeploymentProtocol = "http"
	CreateDeploymentProtocolHTTPS CreateDeploymentProtocol = "https"
)

func (e CreateDeploymentProtocol) ToPointer() *CreateDeploymentProtocol {
	return &e
}
func (e *CreateDeploymentProtocol) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		fallthrough
	case "https":
		*e = CreateDeploymentProtocol(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentProtocol: %v", v)
	}
}

type CreateDeploymentRemotePattern struct {
	// Must be `http` or `https`.
	Protocol *CreateDeploymentProtocol `json:"protocol,omitempty"`
	// Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.
	Hostname string `json:"hostname"`
	// Can be literal port such as `8080` or empty string meaning no port.
	Port *string `json:"port,omitempty"`
	// Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
	Pathname *string `json:"pathname,omitempty"`
	// Can be literal query string such as `?v=1` or empty string meaning no query string.
	Search *string `json:"search,omitempty"`
}

func (o *CreateDeploymentRemotePattern) GetProtocol() *CreateDeploymentProtocol {
	if o == nil {
		return nil
	}
	return o.Protocol
}

func (o *CreateDeploymentRemotePattern) GetHostname() string {
	if o == nil {
		return ""
	}
	return o.Hostname
}

func (o *CreateDeploymentRemotePattern) GetPort() *string {
	if o == nil {
		return nil
	}
	return o.Port
}

func (o *CreateDeploymentRemotePattern) GetPathname() *string {
	if o == nil {
		return nil
	}
	return o.Pathname
}

func (o *CreateDeploymentRemotePattern) GetSearch() *string {
	if o == nil {
		return nil
	}
	return o.Search
}

type CreateDeploymentLocalPattern struct {
	// Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
	Pathname *string `json:"pathname,omitempty"`
	// Can be literal query string such as `?v=1` or empty string meaning no query string.
	Search *string `json:"search,omitempty"`
}

func (o *CreateDeploymentLocalPattern) GetPathname() *string {
	if o == nil {
		return nil
	}
	return o.Pathname
}

func (o *CreateDeploymentLocalPattern) GetSearch() *string {
	if o == nil {
		return nil
	}
	return o.Search
}

type CreateDeploymentFormat string

const (
	CreateDeploymentFormatImageAvif CreateDeploymentFormat = "image/avif"
	CreateDeploymentFormatImageWebp CreateDeploymentFormat = "image/webp"
)

func (e CreateDeploymentFormat) ToPointer() *CreateDeploymentFormat {
	return &e
}
func (e *CreateDeploymentFormat) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "image/avif":
		fallthrough
	case "image/webp":
		*e = CreateDeploymentFormat(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFormat: %v", v)
	}
}

type CreateDeploymentContentDispositionType string

const (
	CreateDeploymentContentDispositionTypeInline     CreateDeploymentContentDispositionType = "inline"
	CreateDeploymentContentDispositionTypeAttachment CreateDeploymentContentDispositionType = "attachment"
)

func (e CreateDeploymentContentDispositionType) ToPointer() *CreateDeploymentContentDispositionType {
	return &e
}
func (e *CreateDeploymentContentDispositionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "inline":
		fallthrough
	case "attachment":
		*e = CreateDeploymentContentDispositionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentContentDispositionType: %v", v)
	}
}

type CreateDeploymentImages struct {
	Sizes                  []float64                               `json:"sizes,omitempty"`
	Qualities              []float64                               `json:"qualities,omitempty"`
	Domains                []string                                `json:"domains,omitempty"`
	RemotePatterns         []CreateDeploymentRemotePattern         `json:"remotePatterns,omitempty"`
	LocalPatterns          []CreateDeploymentLocalPattern          `json:"localPatterns,omitempty"`
	MinimumCacheTTL        *float64                                `json:"minimumCacheTTL,omitempty"`
	Formats                []CreateDeploymentFormat                `json:"formats,omitempty"`
	DangerouslyAllowSVG    *bool                                   `json:"dangerouslyAllowSVG,omitempty"`
	ContentSecurityPolicy  *string                                 `json:"contentSecurityPolicy,omitempty"`
	ContentDispositionType *CreateDeploymentContentDispositionType `json:"contentDispositionType,omitempty"`
}

func (o *CreateDeploymentImages) GetSizes() []float64 {
	if o == nil {
		return nil
	}
	return o.Sizes
}

func (o *CreateDeploymentImages) GetQualities() []float64 {
	if o == nil {
		return nil
	}
	return o.Qualities
}

func (o *CreateDeploymentImages) GetDomains() []string {
	if o == nil {
		return nil
	}
	return o.Domains
}

func (o *CreateDeploymentImages) GetRemotePatterns() []CreateDeploymentRemotePattern {
	if o == nil {
		return nil
	}
	return o.RemotePatterns
}

func (o *CreateDeploymentImages) GetLocalPatterns() []CreateDeploymentLocalPattern {
	if o == nil {
		return nil
	}
	return o.LocalPatterns
}

func (o *CreateDeploymentImages) GetMinimumCacheTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.MinimumCacheTTL
}

func (o *CreateDeploymentImages) GetFormats() []CreateDeploymentFormat {
	if o == nil {
		return nil
	}
	return o.Formats
}

func (o *CreateDeploymentImages) GetDangerouslyAllowSVG() *bool {
	if o == nil {
		return nil
	}
	return o.DangerouslyAllowSVG
}

func (o *CreateDeploymentImages) GetContentSecurityPolicy() *string {
	if o == nil {
		return nil
	}
	return o.ContentSecurityPolicy
}

func (o *CreateDeploymentImages) GetContentDispositionType() *CreateDeploymentContentDispositionType {
	if o == nil {
		return nil
	}
	return o.ContentDispositionType
}

// CreateDeploymentCreator - Information about the deployment creator
type CreateDeploymentCreator struct {
	// The ID of the user that created the deployment
	UID string `json:"uid"`
	// The username of the user that created the deployment
	Username *string `json:"username,omitempty"`
	// The avatar of the user that created the deployment
	Avatar *string `json:"avatar,omitempty"`
}

func (o *CreateDeploymentCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *CreateDeploymentCreator) GetUsername() *string {
	if o == nil {
		return nil
	}
	return o.Username
}

func (o *CreateDeploymentCreator) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

type CreateDeploymentLambdaReadyState string

const (
	CreateDeploymentLambdaReadyStateBuilding     CreateDeploymentLambdaReadyState = "BUILDING"
	CreateDeploymentLambdaReadyStateError        CreateDeploymentLambdaReadyState = "ERROR"
	CreateDeploymentLambdaReadyStateInitializing CreateDeploymentLambdaReadyState = "INITIALIZING"
	CreateDeploymentLambdaReadyStateReady        CreateDeploymentLambdaReadyState = "READY"
)

func (e CreateDeploymentLambdaReadyState) ToPointer() *CreateDeploymentLambdaReadyState {
	return &e
}
func (e *CreateDeploymentLambdaReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "BUILDING":
		fallthrough
	case "ERROR":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		*e = CreateDeploymentLambdaReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentLambdaReadyState: %v", v)
	}
}

type CreateDeploymentOutput struct {
	Path         string `json:"path"`
	FunctionName string `json:"functionName"`
}

func (o *CreateDeploymentOutput) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentOutput) GetFunctionName() string {
	if o == nil {
		return ""
	}
	return o.FunctionName
}

// CreateDeploymentLambda - A partial representation of a Build used by the deployment endpoint.
type CreateDeploymentLambda struct {
	ID           string                            `json:"id"`
	CreatedAt    *float64                          `json:"createdAt,omitempty"`
	ReadyState   *CreateDeploymentLambdaReadyState `json:"readyState,omitempty"`
	Entrypoint   *string                           `json:"entrypoint,omitempty"`
	ReadyStateAt *float64                          `json:"readyStateAt,omitempty"`
	Output       []CreateDeploymentOutput          `json:"output"`
}

func (o *CreateDeploymentLambda) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentLambda) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *CreateDeploymentLambda) GetReadyState() *CreateDeploymentLambdaReadyState {
	if o == nil {
		return nil
	}
	return o.ReadyState
}

func (o *CreateDeploymentLambda) GetEntrypoint() *string {
	if o == nil {
		return nil
	}
	return o.Entrypoint
}

func (o *CreateDeploymentLambda) GetReadyStateAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ReadyStateAt
}

func (o *CreateDeploymentLambda) GetOutput() []CreateDeploymentOutput {
	if o == nil {
		return []CreateDeploymentOutput{}
	}
	return o.Output
}

type CreateDeploymentStatus string

const (
	CreateDeploymentStatusQueued       CreateDeploymentStatus = "QUEUED"
	CreateDeploymentStatusBuilding     CreateDeploymentStatus = "BUILDING"
	CreateDeploymentStatusError        CreateDeploymentStatus = "ERROR"
	CreateDeploymentStatusInitializing CreateDeploymentStatus = "INITIALIZING"
	CreateDeploymentStatusReady        CreateDeploymentStatus = "READY"
	CreateDeploymentStatusCanceled     CreateDeploymentStatus = "CANCELED"
)

func (e CreateDeploymentStatus) ToPointer() *CreateDeploymentStatus {
	return &e
}
func (e *CreateDeploymentStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "QUEUED":
		fallthrough
	case "BUILDING":
		fallthrough
	case "ERROR":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		fallthrough
	case "CANCELED":
		*e = CreateDeploymentStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentStatus: %v", v)
	}
}

// CreateDeploymentTeam - The team that owns the deployment if any
type CreateDeploymentTeam struct {
	ID     string  `json:"id"`
	Name   string  `json:"name"`
	Slug   string  `json:"slug"`
	Avatar *string `json:"avatar,omitempty"`
}

func (o *CreateDeploymentTeam) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentTeam) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentTeam) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateDeploymentTeam) GetAvatar() *string {
	if o == nil {
		return nil
	}
	return o.Avatar
}

// CreateDeploymentCustomEnvironment2 - If the deployment was created using a Custom Environment, then this property contains information regarding the environment used.
type CreateDeploymentCustomEnvironment2 struct {
	ID string `json:"id"`
}

func (c CreateDeploymentCustomEnvironment2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentCustomEnvironment2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentCustomEnvironment2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

// CreateDeploymentCustomEnvironmentType - The type of environment (production, preview, or development)
type CreateDeploymentCustomEnvironmentType string

const (
	CreateDeploymentCustomEnvironmentTypeProduction  CreateDeploymentCustomEnvironmentType = "production"
	CreateDeploymentCustomEnvironmentTypePreview     CreateDeploymentCustomEnvironmentType = "preview"
	CreateDeploymentCustomEnvironmentTypeDevelopment CreateDeploymentCustomEnvironmentType = "development"
)

func (e CreateDeploymentCustomEnvironmentType) ToPointer() *CreateDeploymentCustomEnvironmentType {
	return &e
}
func (e *CreateDeploymentCustomEnvironmentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		fallthrough
	case "development":
		*e = CreateDeploymentCustomEnvironmentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentCustomEnvironmentType: %v", v)
	}
}

// CreateDeploymentBranchMatcherType - The type of matching to perform
type CreateDeploymentBranchMatcherType string

const (
	CreateDeploymentBranchMatcherTypeEndsWith   CreateDeploymentBranchMatcherType = "endsWith"
	CreateDeploymentBranchMatcherTypeStartsWith CreateDeploymentBranchMatcherType = "startsWith"
	CreateDeploymentBranchMatcherTypeEquals     CreateDeploymentBranchMatcherType = "equals"
)

func (e CreateDeploymentBranchMatcherType) ToPointer() *CreateDeploymentBranchMatcherType {
	return &e
}
func (e *CreateDeploymentBranchMatcherType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "endsWith":
		fallthrough
	case "startsWith":
		fallthrough
	case "equals":
		*e = CreateDeploymentBranchMatcherType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentBranchMatcherType: %v", v)
	}
}

// CreateDeploymentBranchMatcher - Configuration for matching git branches to this environment
type CreateDeploymentBranchMatcher struct {
	// The type of matching to perform
	Type CreateDeploymentBranchMatcherType `json:"type"`
	// The pattern to match against branch names
	Pattern string `json:"pattern"`
}

func (c CreateDeploymentBranchMatcher) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentBranchMatcher) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "pattern"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentBranchMatcher) GetType() CreateDeploymentBranchMatcherType {
	if o == nil {
		return CreateDeploymentBranchMatcherType("")
	}
	return o.Type
}

func (o *CreateDeploymentBranchMatcher) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

// CreateDeploymentVerification - A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
type CreateDeploymentVerification struct {
	Type   string `json:"type"`
	Domain string `json:"domain"`
	Value  string `json:"value"`
	Reason string `json:"reason"`
}

func (c CreateDeploymentVerification) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentVerification) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "domain", "value", "reason"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentVerification) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *CreateDeploymentVerification) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *CreateDeploymentVerification) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

func (o *CreateDeploymentVerification) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

// CreateDeploymentDomain - List of domains associated with this environment
type CreateDeploymentDomain struct {
	Name                string   `json:"name"`
	ApexName            string   `json:"apexName"`
	ProjectID           string   `json:"projectId"`
	Redirect            *string  `json:"redirect,omitempty"`
	RedirectStatusCode  *float64 `json:"redirectStatusCode,omitempty"`
	GitBranch           *string  `json:"gitBranch,omitempty"`
	CustomEnvironmentID *string  `json:"customEnvironmentId,omitempty"`
	UpdatedAt           *float64 `json:"updatedAt,omitempty"`
	CreatedAt           *float64 `json:"createdAt,omitempty"`
	// `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
	Verified bool `json:"verified"`
	// A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
	Verification []CreateDeploymentVerification `json:"verification,omitempty"`
}

func (c CreateDeploymentDomain) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentDomain) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"name", "apexName", "projectId", "verified"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentDomain) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentDomain) GetApexName() string {
	if o == nil {
		return ""
	}
	return o.ApexName
}

func (o *CreateDeploymentDomain) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateDeploymentDomain) GetRedirect() *string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *CreateDeploymentDomain) GetRedirectStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.RedirectStatusCode
}

func (o *CreateDeploymentDomain) GetGitBranch() *string {
	if o == nil {
		return nil
	}
	return o.GitBranch
}

func (o *CreateDeploymentDomain) GetCustomEnvironmentID() *string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentID
}

func (o *CreateDeploymentDomain) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *CreateDeploymentDomain) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *CreateDeploymentDomain) GetVerified() bool {
	if o == nil {
		return false
	}
	return o.Verified
}

func (o *CreateDeploymentDomain) GetVerification() []CreateDeploymentVerification {
	if o == nil {
		return nil
	}
	return o.Verification
}

// CreateDeploymentCustomEnvironment1 - If the deployment was created using a Custom Environment, then this property contains information regarding the environment used.
type CreateDeploymentCustomEnvironment1 struct {
	// Unique identifier for the custom environment (format: env_*)
	ID string `json:"id"`
	// URL-friendly name of the environment
	Slug string `json:"slug"`
	// The type of environment (production, preview, or development)
	Type CreateDeploymentCustomEnvironmentType `json:"type"`
	// Optional description of the environment's purpose
	Description *string `json:"description,omitempty"`
	// Configuration for matching git branches to this environment
	BranchMatcher *CreateDeploymentBranchMatcher `json:"branchMatcher,omitempty"`
	// List of domains associated with this environment
	Domains []CreateDeploymentDomain `json:"domains,omitempty"`
	// List of aliases for the current deployment
	CurrentDeploymentAliases []string `json:"currentDeploymentAliases,omitempty"`
	// Timestamp when the environment was created
	CreatedAt float64 `json:"createdAt"`
	// Timestamp when the environment was last updated
	UpdatedAt float64 `json:"updatedAt"`
}

func (c CreateDeploymentCustomEnvironment1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentCustomEnvironment1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"id", "slug", "type", "createdAt", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentCustomEnvironment1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentCustomEnvironment1) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateDeploymentCustomEnvironment1) GetType() CreateDeploymentCustomEnvironmentType {
	if o == nil {
		return CreateDeploymentCustomEnvironmentType("")
	}
	return o.Type
}

func (o *CreateDeploymentCustomEnvironment1) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateDeploymentCustomEnvironment1) GetBranchMatcher() *CreateDeploymentBranchMatcher {
	if o == nil {
		return nil
	}
	return o.BranchMatcher
}

func (o *CreateDeploymentCustomEnvironment1) GetDomains() []CreateDeploymentDomain {
	if o == nil {
		return nil
	}
	return o.Domains
}

func (o *CreateDeploymentCustomEnvironment1) GetCurrentDeploymentAliases() []string {
	if o == nil {
		return nil
	}
	return o.CurrentDeploymentAliases
}

func (o *CreateDeploymentCustomEnvironment1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *CreateDeploymentCustomEnvironment1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

type CreateDeploymentCustomEnvironmentUnionType string

const (
	CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment1 CreateDeploymentCustomEnvironmentUnionType = "createDeployment_customEnvironment_1"
	CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment2 CreateDeploymentCustomEnvironmentUnionType = "createDeployment_customEnvironment_2"
)

type CreateDeploymentCustomEnvironmentUnion struct {
	CreateDeploymentCustomEnvironment1 *CreateDeploymentCustomEnvironment1 `queryParam:"inline"`
	CreateDeploymentCustomEnvironment2 *CreateDeploymentCustomEnvironment2 `queryParam:"inline"`

	Type CreateDeploymentCustomEnvironmentUnionType
}

func CreateCreateDeploymentCustomEnvironmentUnionCreateDeploymentCustomEnvironment1(createDeploymentCustomEnvironment1 CreateDeploymentCustomEnvironment1) CreateDeploymentCustomEnvironmentUnion {
	typ := CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment1

	return CreateDeploymentCustomEnvironmentUnion{
		CreateDeploymentCustomEnvironment1: &createDeploymentCustomEnvironment1,
		Type:                               typ,
	}
}

func CreateCreateDeploymentCustomEnvironmentUnionCreateDeploymentCustomEnvironment2(createDeploymentCustomEnvironment2 CreateDeploymentCustomEnvironment2) CreateDeploymentCustomEnvironmentUnion {
	typ := CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment2

	return CreateDeploymentCustomEnvironmentUnion{
		CreateDeploymentCustomEnvironment2: &createDeploymentCustomEnvironment2,
		Type:                               typ,
	}
}

func (u *CreateDeploymentCustomEnvironmentUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentCustomEnvironment1 CreateDeploymentCustomEnvironment1 = CreateDeploymentCustomEnvironment1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentCustomEnvironment1, "", true, nil); err == nil {
		u.CreateDeploymentCustomEnvironment1 = &createDeploymentCustomEnvironment1
		u.Type = CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment1
		return nil
	}

	var createDeploymentCustomEnvironment2 CreateDeploymentCustomEnvironment2 = CreateDeploymentCustomEnvironment2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentCustomEnvironment2, "", true, nil); err == nil {
		u.CreateDeploymentCustomEnvironment2 = &createDeploymentCustomEnvironment2
		u.Type = CreateDeploymentCustomEnvironmentUnionTypeCreateDeploymentCustomEnvironment2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentCustomEnvironmentUnion", string(data))
}

func (u CreateDeploymentCustomEnvironmentUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentCustomEnvironment1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentCustomEnvironment1, "", true)
	}

	if u.CreateDeploymentCustomEnvironment2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentCustomEnvironment2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentCustomEnvironmentUnion: all fields are null")
}

type CreateDeploymentOomReport string

const (
	CreateDeploymentOomReportOutOfMemory CreateDeploymentOomReport = "out-of-memory"
)

func (e CreateDeploymentOomReport) ToPointer() *CreateDeploymentOomReport {
	return &e
}
func (e *CreateDeploymentOomReport) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "out-of-memory":
		*e = CreateDeploymentOomReport(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentOomReport: %v", v)
	}
}

type CreateDeploymentAliasWarning struct {
	Code    string  `json:"code"`
	Message string  `json:"message"`
	Link    *string `json:"link,omitempty"`
	Action  *string `json:"action,omitempty"`
}

func (o *CreateDeploymentAliasWarning) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *CreateDeploymentAliasWarning) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

func (o *CreateDeploymentAliasWarning) GetLink() *string {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *CreateDeploymentAliasWarning) GetAction() *string {
	if o == nil {
		return nil
	}
	return o.Action
}

// CreateDeploymentReadyState - The state of the deployment depending on the process of deploying, or if it is ready or in an error state
type CreateDeploymentReadyState string

const (
	CreateDeploymentReadyStateQueued       CreateDeploymentReadyState = "QUEUED"
	CreateDeploymentReadyStateBuilding     CreateDeploymentReadyState = "BUILDING"
	CreateDeploymentReadyStateError        CreateDeploymentReadyState = "ERROR"
	CreateDeploymentReadyStateInitializing CreateDeploymentReadyState = "INITIALIZING"
	CreateDeploymentReadyStateReady        CreateDeploymentReadyState = "READY"
	CreateDeploymentReadyStateCanceled     CreateDeploymentReadyState = "CANCELED"
)

func (e CreateDeploymentReadyState) ToPointer() *CreateDeploymentReadyState {
	return &e
}
func (e *CreateDeploymentReadyState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "QUEUED":
		fallthrough
	case "BUILDING":
		fallthrough
	case "ERROR":
		fallthrough
	case "INITIALIZING":
		fallthrough
	case "READY":
		fallthrough
	case "CANCELED":
		*e = CreateDeploymentReadyState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentReadyState: %v", v)
	}
}

type CreateDeploymentTypeLambdas string

const (
	CreateDeploymentTypeLambdasLambdas CreateDeploymentTypeLambdas = "LAMBDAS"
)

func (e CreateDeploymentTypeLambdas) ToPointer() *CreateDeploymentTypeLambdas {
	return &e
}
func (e *CreateDeploymentTypeLambdas) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "LAMBDAS":
		*e = CreateDeploymentTypeLambdas(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeLambdas: %v", v)
	}
}

// CreateDeploymentAliasError - An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
type CreateDeploymentAliasError struct {
	Code    string `json:"code"`
	Message string `json:"message"`
}

func (o *CreateDeploymentAliasError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *CreateDeploymentAliasError) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type CreateDeploymentChecksState string

const (
	CreateDeploymentChecksStateRegistered CreateDeploymentChecksState = "registered"
	CreateDeploymentChecksStateRunning    CreateDeploymentChecksState = "running"
	CreateDeploymentChecksStateCompleted  CreateDeploymentChecksState = "completed"
)

func (e CreateDeploymentChecksState) ToPointer() *CreateDeploymentChecksState {
	return &e
}
func (e *CreateDeploymentChecksState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "registered":
		fallthrough
	case "running":
		fallthrough
	case "completed":
		*e = CreateDeploymentChecksState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentChecksState: %v", v)
	}
}

type CreateDeploymentChecksConclusion string

const (
	CreateDeploymentChecksConclusionSucceeded CreateDeploymentChecksConclusion = "succeeded"
	CreateDeploymentChecksConclusionFailed    CreateDeploymentChecksConclusion = "failed"
	CreateDeploymentChecksConclusionSkipped   CreateDeploymentChecksConclusion = "skipped"
	CreateDeploymentChecksConclusionCanceled  CreateDeploymentChecksConclusion = "canceled"
)

func (e CreateDeploymentChecksConclusion) ToPointer() *CreateDeploymentChecksConclusion {
	return &e
}
func (e *CreateDeploymentChecksConclusion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "succeeded":
		fallthrough
	case "failed":
		fallthrough
	case "skipped":
		fallthrough
	case "canceled":
		*e = CreateDeploymentChecksConclusion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentChecksConclusion: %v", v)
	}
}

type CreateDeploymentGitSourceTypeLambdasBitbucket3 string

const (
	CreateDeploymentGitSourceTypeLambdasBitbucket3Bitbucket CreateDeploymentGitSourceTypeLambdasBitbucket3 = "bitbucket"
)

func (e CreateDeploymentGitSourceTypeLambdasBitbucket3) ToPointer() *CreateDeploymentGitSourceTypeLambdasBitbucket3 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasBitbucket3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceTypeLambdasBitbucket3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasBitbucket3: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasBitbucket3 struct {
	Type          CreateDeploymentGitSourceTypeLambdasBitbucket3 `json:"type"`
	Ref           string                                         `json:"ref"`
	Sha           string                                         `json:"sha"`
	Owner         *string                                        `json:"owner,omitempty"`
	Slug          *string                                        `json:"slug,omitempty"`
	WorkspaceUUID string                                         `json:"workspaceUuid"`
	RepoUUID      string                                         `json:"repoUuid"`
}

func (c CreateDeploymentGitSourceLambdasBitbucket3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasBitbucket3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "ref", "sha", "workspaceUuid", "repoUuid"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetType() CreateDeploymentGitSourceTypeLambdasBitbucket3 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasBitbucket3("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetOwner() *string {
	if o == nil {
		return nil
	}
	return o.Owner
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *CreateDeploymentGitSourceLambdasBitbucket3) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

type CreateDeploymentGitSourceTypeLambdasGitlab2 string

const (
	CreateDeploymentGitSourceTypeLambdasGitlab2Gitlab CreateDeploymentGitSourceTypeLambdasGitlab2 = "gitlab"
)

func (e CreateDeploymentGitSourceTypeLambdasGitlab2) ToPointer() *CreateDeploymentGitSourceTypeLambdasGitlab2 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasGitlab2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceTypeLambdasGitlab2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasGitlab2: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasGitlab2 struct {
	Type      CreateDeploymentGitSourceTypeLambdasGitlab2 `json:"type"`
	Ref       string                                      `json:"ref"`
	Sha       string                                      `json:"sha"`
	ProjectID float64                                     `json:"projectId"`
}

func (c CreateDeploymentGitSourceLambdasGitlab2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGitlab2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "ref", "sha", "projectId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGitlab2) GetType() CreateDeploymentGitSourceTypeLambdasGitlab2 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasGitlab2("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGitlab2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGitlab2) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGitlab2) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

type CreateDeploymentTypeLambdasGithubLimited3 string

const (
	CreateDeploymentTypeLambdasGithubLimited3GithubLimited CreateDeploymentTypeLambdasGithubLimited3 = "github-limited"
)

func (e CreateDeploymentTypeLambdasGithubLimited3) ToPointer() *CreateDeploymentTypeLambdasGithubLimited3 {
	return &e
}
func (e *CreateDeploymentTypeLambdasGithubLimited3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = CreateDeploymentTypeLambdasGithubLimited3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeLambdasGithubLimited3: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasGithubLimited3 struct {
	Type   CreateDeploymentTypeLambdasGithubLimited3 `json:"type"`
	Ref    string                                    `json:"ref"`
	Sha    string                                    `json:"sha"`
	RepoID float64                                   `json:"repoId"`
	Org    *string                                   `json:"org,omitempty"`
	Repo   *string                                   `json:"repo,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithubLimited3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithubLimited3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "ref", "sha", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetType() CreateDeploymentTypeLambdasGithubLimited3 {
	if o == nil {
		return CreateDeploymentTypeLambdasGithubLimited3("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetOrg() *string {
	if o == nil {
		return nil
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited3) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

type CreateDeploymentTypeGithubCustomHost3 string

const (
	CreateDeploymentTypeGithubCustomHost3GithubCustomHost CreateDeploymentTypeGithubCustomHost3 = "github-custom-host"
)

func (e CreateDeploymentTypeGithubCustomHost3) ToPointer() *CreateDeploymentTypeGithubCustomHost3 {
	return &e
}
func (e *CreateDeploymentTypeGithubCustomHost3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-custom-host":
		*e = CreateDeploymentTypeGithubCustomHost3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeGithubCustomHost3: %v", v)
	}
}

type CreateDeploymentGitSourceGithubCustomHost3 struct {
	Type   CreateDeploymentTypeGithubCustomHost3 `json:"type"`
	Host   string                                `json:"host"`
	Ref    string                                `json:"ref"`
	Sha    string                                `json:"sha"`
	RepoID float64                               `json:"repoId"`
	Org    *string                               `json:"org,omitempty"`
	Repo   *string                               `json:"repo,omitempty"`
}

func (c CreateDeploymentGitSourceGithubCustomHost3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceGithubCustomHost3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "host", "ref", "sha", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetType() CreateDeploymentTypeGithubCustomHost3 {
	if o == nil {
		return CreateDeploymentTypeGithubCustomHost3("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetOrg() *string {
	if o == nil {
		return nil
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceGithubCustomHost3) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

type CreateDeploymentGitSourceTypeLambdasGithub3 string

const (
	CreateDeploymentGitSourceTypeLambdasGithub3Github CreateDeploymentGitSourceTypeLambdasGithub3 = "github"
)

func (e CreateDeploymentGitSourceTypeLambdasGithub3) ToPointer() *CreateDeploymentGitSourceTypeLambdasGithub3 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasGithub3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceTypeLambdasGithub3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasGithub3: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasGithub3 struct {
	Type   CreateDeploymentGitSourceTypeLambdasGithub3 `json:"type"`
	Ref    string                                      `json:"ref"`
	Sha    string                                      `json:"sha"`
	RepoID float64                                     `json:"repoId"`
	Org    *string                                     `json:"org,omitempty"`
	Repo   *string                                     `json:"repo,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithub3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithub3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "ref", "sha", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetType() CreateDeploymentGitSourceTypeLambdasGithub3 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasGithub3("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetOrg() *string {
	if o == nil {
		return nil
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceLambdasGithub3) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

type CreateDeploymentTypeCustom string

const (
	CreateDeploymentTypeCustomCustom CreateDeploymentTypeCustom = "custom"
)

func (e CreateDeploymentTypeCustom) ToPointer() *CreateDeploymentTypeCustom {
	return &e
}
func (e *CreateDeploymentTypeCustom) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "custom":
		*e = CreateDeploymentTypeCustom(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeCustom: %v", v)
	}
}

// CreateDeploymentGitSourceCustom - Allows custom git sources (local folder mounted to the container) in test mode
type CreateDeploymentGitSourceCustom struct {
	Type   CreateDeploymentTypeCustom `json:"type"`
	Ref    string                     `json:"ref"`
	Sha    string                     `json:"sha"`
	GitURL string                     `json:"gitUrl"`
}

func (c CreateDeploymentGitSourceCustom) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceCustom) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "ref", "sha", "gitUrl"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceCustom) GetType() CreateDeploymentTypeCustom {
	if o == nil {
		return CreateDeploymentTypeCustom("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceCustom) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceCustom) GetSha() string {
	if o == nil {
		return ""
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceCustom) GetGitURL() string {
	if o == nil {
		return ""
	}
	return o.GitURL
}

type CreateDeploymentGitSourceTypeLambdasBitbucket2 string

const (
	CreateDeploymentGitSourceTypeLambdasBitbucket2Bitbucket CreateDeploymentGitSourceTypeLambdasBitbucket2 = "bitbucket"
)

func (e CreateDeploymentGitSourceTypeLambdasBitbucket2) ToPointer() *CreateDeploymentGitSourceTypeLambdasBitbucket2 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasBitbucket2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceTypeLambdasBitbucket2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasBitbucket2: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasBitbucket2 struct {
	Type  CreateDeploymentGitSourceTypeLambdasBitbucket2 `json:"type"`
	Owner string                                         `json:"owner"`
	Slug  string                                         `json:"slug"`
	Ref   *string                                        `json:"ref,omitempty"`
	Sha   *string                                        `json:"sha,omitempty"`
	PrID  *float64                                       `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasBitbucket2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasBitbucket2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "owner", "slug"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetType() CreateDeploymentGitSourceTypeLambdasBitbucket2 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasBitbucket2("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasBitbucket2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceTypeLambdasBitbucket1 string

const (
	CreateDeploymentGitSourceTypeLambdasBitbucket1Bitbucket CreateDeploymentGitSourceTypeLambdasBitbucket1 = "bitbucket"
)

func (e CreateDeploymentGitSourceTypeLambdasBitbucket1) ToPointer() *CreateDeploymentGitSourceTypeLambdasBitbucket1 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasBitbucket1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitSourceTypeLambdasBitbucket1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasBitbucket1: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasBitbucket1 struct {
	Type          CreateDeploymentGitSourceTypeLambdasBitbucket1 `json:"type"`
	WorkspaceUUID *string                                        `json:"workspaceUuid,omitempty"`
	RepoUUID      string                                         `json:"repoUuid"`
	Ref           *string                                        `json:"ref,omitempty"`
	Sha           *string                                        `json:"sha,omitempty"`
	PrID          *float64                                       `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasBitbucket1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasBitbucket1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "repoUuid"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetType() CreateDeploymentGitSourceTypeLambdasBitbucket1 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasBitbucket1("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetWorkspaceUUID() *string {
	if o == nil {
		return nil
	}
	return o.WorkspaceUUID
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasBitbucket1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceTypeLambdasGitlab1 string

const (
	CreateDeploymentGitSourceTypeLambdasGitlab1Gitlab CreateDeploymentGitSourceTypeLambdasGitlab1 = "gitlab"
)

func (e CreateDeploymentGitSourceTypeLambdasGitlab1) ToPointer() *CreateDeploymentGitSourceTypeLambdasGitlab1 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasGitlab1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitSourceTypeLambdasGitlab1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasGitlab1: %v", v)
	}
}

type CreateDeploymentProjectIDLambdasType string

const (
	CreateDeploymentProjectIDLambdasTypeStr    CreateDeploymentProjectIDLambdasType = "str"
	CreateDeploymentProjectIDLambdasTypeNumber CreateDeploymentProjectIDLambdasType = "number"
)

type CreateDeploymentProjectIDLambdas struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentProjectIDLambdasType
}

func CreateCreateDeploymentProjectIDLambdasStr(str string) CreateDeploymentProjectIDLambdas {
	typ := CreateDeploymentProjectIDLambdasTypeStr

	return CreateDeploymentProjectIDLambdas{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentProjectIDLambdasNumber(number float64) CreateDeploymentProjectIDLambdas {
	typ := CreateDeploymentProjectIDLambdasTypeNumber

	return CreateDeploymentProjectIDLambdas{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentProjectIDLambdas) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentProjectIDLambdasTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentProjectIDLambdasTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentProjectIDLambdas", string(data))
}

func (u CreateDeploymentProjectIDLambdas) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentProjectIDLambdas: all fields are null")
}

type CreateDeploymentGitSourceLambdasGitlab1 struct {
	Type      CreateDeploymentGitSourceTypeLambdasGitlab1 `json:"type"`
	ProjectID CreateDeploymentProjectIDLambdas            `json:"projectId"`
	Ref       *string                                     `json:"ref,omitempty"`
	Sha       *string                                     `json:"sha,omitempty"`
	PrID      *float64                                    `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGitlab1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGitlab1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "projectId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGitlab1) GetType() CreateDeploymentGitSourceTypeLambdasGitlab1 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasGitlab1("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGitlab1) GetProjectID() CreateDeploymentProjectIDLambdas {
	if o == nil {
		return CreateDeploymentProjectIDLambdas{}
	}
	return o.ProjectID
}

func (o *CreateDeploymentGitSourceLambdasGitlab1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGitlab1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGitlab1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentTypeLambdasGithubLimited2 string

const (
	CreateDeploymentTypeLambdasGithubLimited2GithubLimited CreateDeploymentTypeLambdasGithubLimited2 = "github-limited"
)

func (e CreateDeploymentTypeLambdasGithubLimited2) ToPointer() *CreateDeploymentTypeLambdasGithubLimited2 {
	return &e
}
func (e *CreateDeploymentTypeLambdasGithubLimited2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = CreateDeploymentTypeLambdasGithubLimited2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeLambdasGithubLimited2: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasGithubLimited2 struct {
	Type CreateDeploymentTypeLambdasGithubLimited2 `json:"type"`
	Org  string                                    `json:"org"`
	Repo string                                    `json:"repo"`
	Ref  *string                                   `json:"ref,omitempty"`
	Sha  *string                                   `json:"sha,omitempty"`
	PrID *float64                                  `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithubLimited2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithubLimited2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "org", "repo"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetType() CreateDeploymentTypeLambdasGithubLimited2 {
	if o == nil {
		return CreateDeploymentTypeLambdasGithubLimited2("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentTypeLambdasGithubLimited1 string

const (
	CreateDeploymentTypeLambdasGithubLimited1GithubLimited CreateDeploymentTypeLambdasGithubLimited1 = "github-limited"
)

func (e CreateDeploymentTypeLambdasGithubLimited1) ToPointer() *CreateDeploymentTypeLambdasGithubLimited1 {
	return &e
}
func (e *CreateDeploymentTypeLambdasGithubLimited1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = CreateDeploymentTypeLambdasGithubLimited1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeLambdasGithubLimited1: %v", v)
	}
}

type CreateDeploymentRepoIDLambdas3Type string

const (
	CreateDeploymentRepoIDLambdas3TypeStr    CreateDeploymentRepoIDLambdas3Type = "str"
	CreateDeploymentRepoIDLambdas3TypeNumber CreateDeploymentRepoIDLambdas3Type = "number"
)

type CreateDeploymentRepoIDLambdas3 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentRepoIDLambdas3Type
}

func CreateCreateDeploymentRepoIDLambdas3Str(str string) CreateDeploymentRepoIDLambdas3 {
	typ := CreateDeploymentRepoIDLambdas3TypeStr

	return CreateDeploymentRepoIDLambdas3{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentRepoIDLambdas3Number(number float64) CreateDeploymentRepoIDLambdas3 {
	typ := CreateDeploymentRepoIDLambdas3TypeNumber

	return CreateDeploymentRepoIDLambdas3{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentRepoIDLambdas3) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentRepoIDLambdas3TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentRepoIDLambdas3TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentRepoIDLambdas3", string(data))
}

func (u CreateDeploymentRepoIDLambdas3) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentRepoIDLambdas3: all fields are null")
}

type CreateDeploymentGitSourceLambdasGithubLimited1 struct {
	Type   CreateDeploymentTypeLambdasGithubLimited1 `json:"type"`
	RepoID CreateDeploymentRepoIDLambdas3            `json:"repoId"`
	Ref    *string                                   `json:"ref,omitempty"`
	Sha    *string                                   `json:"sha,omitempty"`
	PrID   *float64                                  `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithubLimited1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithubLimited1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited1) GetType() CreateDeploymentTypeLambdasGithubLimited1 {
	if o == nil {
		return CreateDeploymentTypeLambdasGithubLimited1("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited1) GetRepoID() CreateDeploymentRepoIDLambdas3 {
	if o == nil {
		return CreateDeploymentRepoIDLambdas3{}
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithubLimited1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentTypeGithubCustomHost2 string

const (
	CreateDeploymentTypeGithubCustomHost2GithubCustomHost CreateDeploymentTypeGithubCustomHost2 = "github-custom-host"
)

func (e CreateDeploymentTypeGithubCustomHost2) ToPointer() *CreateDeploymentTypeGithubCustomHost2 {
	return &e
}
func (e *CreateDeploymentTypeGithubCustomHost2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-custom-host":
		*e = CreateDeploymentTypeGithubCustomHost2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeGithubCustomHost2: %v", v)
	}
}

type CreateDeploymentGitSourceGithubCustomHost2 struct {
	Type CreateDeploymentTypeGithubCustomHost2 `json:"type"`
	Host string                                `json:"host"`
	Org  string                                `json:"org"`
	Repo string                                `json:"repo"`
	Ref  *string                               `json:"ref,omitempty"`
	Sha  *string                               `json:"sha,omitempty"`
	PrID *float64                              `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceGithubCustomHost2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceGithubCustomHost2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "host", "org", "repo"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetType() CreateDeploymentTypeGithubCustomHost2 {
	if o == nil {
		return CreateDeploymentTypeGithubCustomHost2("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceGithubCustomHost2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentTypeGithubCustomHost1 string

const (
	CreateDeploymentTypeGithubCustomHost1GithubCustomHost CreateDeploymentTypeGithubCustomHost1 = "github-custom-host"
)

func (e CreateDeploymentTypeGithubCustomHost1) ToPointer() *CreateDeploymentTypeGithubCustomHost1 {
	return &e
}
func (e *CreateDeploymentTypeGithubCustomHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-custom-host":
		*e = CreateDeploymentTypeGithubCustomHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTypeGithubCustomHost1: %v", v)
	}
}

type CreateDeploymentRepoIDLambdas2Type string

const (
	CreateDeploymentRepoIDLambdas2TypeStr    CreateDeploymentRepoIDLambdas2Type = "str"
	CreateDeploymentRepoIDLambdas2TypeNumber CreateDeploymentRepoIDLambdas2Type = "number"
)

type CreateDeploymentRepoIDLambdas2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentRepoIDLambdas2Type
}

func CreateCreateDeploymentRepoIDLambdas2Str(str string) CreateDeploymentRepoIDLambdas2 {
	typ := CreateDeploymentRepoIDLambdas2TypeStr

	return CreateDeploymentRepoIDLambdas2{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentRepoIDLambdas2Number(number float64) CreateDeploymentRepoIDLambdas2 {
	typ := CreateDeploymentRepoIDLambdas2TypeNumber

	return CreateDeploymentRepoIDLambdas2{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentRepoIDLambdas2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentRepoIDLambdas2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentRepoIDLambdas2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentRepoIDLambdas2", string(data))
}

func (u CreateDeploymentRepoIDLambdas2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentRepoIDLambdas2: all fields are null")
}

type CreateDeploymentGitSourceGithubCustomHost1 struct {
	Type   CreateDeploymentTypeGithubCustomHost1 `json:"type"`
	Host   string                                `json:"host"`
	RepoID CreateDeploymentRepoIDLambdas2        `json:"repoId"`
	Ref    *string                               `json:"ref,omitempty"`
	Sha    *string                               `json:"sha,omitempty"`
	PrID   *float64                              `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceGithubCustomHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceGithubCustomHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "host", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetType() CreateDeploymentTypeGithubCustomHost1 {
	if o == nil {
		return CreateDeploymentTypeGithubCustomHost1("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetRepoID() CreateDeploymentRepoIDLambdas2 {
	if o == nil {
		return CreateDeploymentRepoIDLambdas2{}
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceGithubCustomHost1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceTypeLambdasGithub2 string

const (
	CreateDeploymentGitSourceTypeLambdasGithub2Github CreateDeploymentGitSourceTypeLambdasGithub2 = "github"
)

func (e CreateDeploymentGitSourceTypeLambdasGithub2) ToPointer() *CreateDeploymentGitSourceTypeLambdasGithub2 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasGithub2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceTypeLambdasGithub2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasGithub2: %v", v)
	}
}

type CreateDeploymentGitSourceLambdasGithub2 struct {
	Type CreateDeploymentGitSourceTypeLambdasGithub2 `json:"type"`
	Org  string                                      `json:"org"`
	Repo string                                      `json:"repo"`
	Ref  *string                                     `json:"ref,omitempty"`
	Sha  *string                                     `json:"sha,omitempty"`
	PrID *float64                                    `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithub2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithub2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "org", "repo"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetType() CreateDeploymentGitSourceTypeLambdasGithub2 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasGithub2("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithub2) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceTypeLambdasGithub1 string

const (
	CreateDeploymentGitSourceTypeLambdasGithub1Github CreateDeploymentGitSourceTypeLambdasGithub1 = "github"
)

func (e CreateDeploymentGitSourceTypeLambdasGithub1) ToPointer() *CreateDeploymentGitSourceTypeLambdasGithub1 {
	return &e
}
func (e *CreateDeploymentGitSourceTypeLambdasGithub1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitSourceTypeLambdasGithub1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitSourceTypeLambdasGithub1: %v", v)
	}
}

type CreateDeploymentRepoIDLambdas1Type string

const (
	CreateDeploymentRepoIDLambdas1TypeStr    CreateDeploymentRepoIDLambdas1Type = "str"
	CreateDeploymentRepoIDLambdas1TypeNumber CreateDeploymentRepoIDLambdas1Type = "number"
)

type CreateDeploymentRepoIDLambdas1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentRepoIDLambdas1Type
}

func CreateCreateDeploymentRepoIDLambdas1Str(str string) CreateDeploymentRepoIDLambdas1 {
	typ := CreateDeploymentRepoIDLambdas1TypeStr

	return CreateDeploymentRepoIDLambdas1{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentRepoIDLambdas1Number(number float64) CreateDeploymentRepoIDLambdas1 {
	typ := CreateDeploymentRepoIDLambdas1TypeNumber

	return CreateDeploymentRepoIDLambdas1{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentRepoIDLambdas1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentRepoIDLambdas1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentRepoIDLambdas1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentRepoIDLambdas1", string(data))
}

func (u CreateDeploymentRepoIDLambdas1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentRepoIDLambdas1: all fields are null")
}

type CreateDeploymentGitSourceLambdasGithub1 struct {
	Type   CreateDeploymentGitSourceTypeLambdasGithub1 `json:"type"`
	RepoID CreateDeploymentRepoIDLambdas1              `json:"repoId"`
	Ref    *string                                     `json:"ref,omitempty"`
	Sha    *string                                     `json:"sha,omitempty"`
	PrID   *float64                                    `json:"prId,omitempty"`
}

func (c CreateDeploymentGitSourceLambdasGithub1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitSourceLambdasGithub1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "repoId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitSourceLambdasGithub1) GetType() CreateDeploymentGitSourceTypeLambdasGithub1 {
	if o == nil {
		return CreateDeploymentGitSourceTypeLambdasGithub1("")
	}
	return o.Type
}

func (o *CreateDeploymentGitSourceLambdasGithub1) GetRepoID() CreateDeploymentRepoIDLambdas1 {
	if o == nil {
		return CreateDeploymentRepoIDLambdas1{}
	}
	return o.RepoID
}

func (o *CreateDeploymentGitSourceLambdasGithub1) GetRef() *string {
	if o == nil {
		return nil
	}
	return o.Ref
}

func (o *CreateDeploymentGitSourceLambdasGithub1) GetSha() *string {
	if o == nil {
		return nil
	}
	return o.Sha
}

func (o *CreateDeploymentGitSourceLambdasGithub1) GetPrID() *float64 {
	if o == nil {
		return nil
	}
	return o.PrID
}

type CreateDeploymentGitSourceLambdasUnionType string

const (
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub1        CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Github_1"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub2        CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Github_2"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost1     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_GithubCustomHost_1"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost2     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_GithubCustomHost_2"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited1 CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_GithubLimited_1"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited2 CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_GithubLimited_2"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab1        CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Gitlab_1"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket1     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Bitbucket_1"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket2     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Bitbucket_2"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceCustom                CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Custom"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub3        CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Github_3"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost3     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_GithubCustomHost_3"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited3 CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_GithubLimited_3"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab2        CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Gitlab_2"
	CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket3     CreateDeploymentGitSourceLambdasUnionType = "createDeployment_gitSource_Lambdas_Bitbucket_3"
)

type CreateDeploymentGitSourceLambdasUnion struct {
	CreateDeploymentGitSourceLambdasGithub1        *CreateDeploymentGitSourceLambdasGithub1        `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGithub2        *CreateDeploymentGitSourceLambdasGithub2        `queryParam:"inline"`
	CreateDeploymentGitSourceGithubCustomHost1     *CreateDeploymentGitSourceGithubCustomHost1     `queryParam:"inline"`
	CreateDeploymentGitSourceGithubCustomHost2     *CreateDeploymentGitSourceGithubCustomHost2     `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGithubLimited1 *CreateDeploymentGitSourceLambdasGithubLimited1 `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGithubLimited2 *CreateDeploymentGitSourceLambdasGithubLimited2 `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGitlab1        *CreateDeploymentGitSourceLambdasGitlab1        `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasBitbucket1     *CreateDeploymentGitSourceLambdasBitbucket1     `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasBitbucket2     *CreateDeploymentGitSourceLambdasBitbucket2     `queryParam:"inline"`
	CreateDeploymentGitSourceCustom                *CreateDeploymentGitSourceCustom                `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGithub3        *CreateDeploymentGitSourceLambdasGithub3        `queryParam:"inline"`
	CreateDeploymentGitSourceGithubCustomHost3     *CreateDeploymentGitSourceGithubCustomHost3     `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGithubLimited3 *CreateDeploymentGitSourceLambdasGithubLimited3 `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasGitlab2        *CreateDeploymentGitSourceLambdasGitlab2        `queryParam:"inline"`
	CreateDeploymentGitSourceLambdasBitbucket3     *CreateDeploymentGitSourceLambdasBitbucket3     `queryParam:"inline"`

	Type CreateDeploymentGitSourceLambdasUnionType
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithub1(createDeploymentGitSourceLambdasGithub1 CreateDeploymentGitSourceLambdasGithub1) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub1

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithub1: &createDeploymentGitSourceLambdasGithub1,
		Type:                                    typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithub2(createDeploymentGitSourceLambdasGithub2 CreateDeploymentGitSourceLambdasGithub2) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub2

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithub2: &createDeploymentGitSourceLambdasGithub2,
		Type:                                    typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceGithubCustomHost1(createDeploymentGitSourceGithubCustomHost1 CreateDeploymentGitSourceGithubCustomHost1) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost1

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceGithubCustomHost1: &createDeploymentGitSourceGithubCustomHost1,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceGithubCustomHost2(createDeploymentGitSourceGithubCustomHost2 CreateDeploymentGitSourceGithubCustomHost2) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost2

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceGithubCustomHost2: &createDeploymentGitSourceGithubCustomHost2,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithubLimited1(createDeploymentGitSourceLambdasGithubLimited1 CreateDeploymentGitSourceLambdasGithubLimited1) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited1

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithubLimited1: &createDeploymentGitSourceLambdasGithubLimited1,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithubLimited2(createDeploymentGitSourceLambdasGithubLimited2 CreateDeploymentGitSourceLambdasGithubLimited2) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited2

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithubLimited2: &createDeploymentGitSourceLambdasGithubLimited2,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGitlab1(createDeploymentGitSourceLambdasGitlab1 CreateDeploymentGitSourceLambdasGitlab1) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab1

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGitlab1: &createDeploymentGitSourceLambdasGitlab1,
		Type:                                    typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasBitbucket1(createDeploymentGitSourceLambdasBitbucket1 CreateDeploymentGitSourceLambdasBitbucket1) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket1

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasBitbucket1: &createDeploymentGitSourceLambdasBitbucket1,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasBitbucket2(createDeploymentGitSourceLambdasBitbucket2 CreateDeploymentGitSourceLambdasBitbucket2) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket2

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasBitbucket2: &createDeploymentGitSourceLambdasBitbucket2,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceCustom(createDeploymentGitSourceCustom CreateDeploymentGitSourceCustom) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceCustom

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceCustom: &createDeploymentGitSourceCustom,
		Type:                            typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithub3(createDeploymentGitSourceLambdasGithub3 CreateDeploymentGitSourceLambdasGithub3) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub3

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithub3: &createDeploymentGitSourceLambdasGithub3,
		Type:                                    typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceGithubCustomHost3(createDeploymentGitSourceGithubCustomHost3 CreateDeploymentGitSourceGithubCustomHost3) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost3

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceGithubCustomHost3: &createDeploymentGitSourceGithubCustomHost3,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGithubLimited3(createDeploymentGitSourceLambdasGithubLimited3 CreateDeploymentGitSourceLambdasGithubLimited3) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited3

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGithubLimited3: &createDeploymentGitSourceLambdasGithubLimited3,
		Type: typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasGitlab2(createDeploymentGitSourceLambdasGitlab2 CreateDeploymentGitSourceLambdasGitlab2) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab2

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasGitlab2: &createDeploymentGitSourceLambdasGitlab2,
		Type:                                    typ,
	}
}

func CreateCreateDeploymentGitSourceLambdasUnionCreateDeploymentGitSourceLambdasBitbucket3(createDeploymentGitSourceLambdasBitbucket3 CreateDeploymentGitSourceLambdasBitbucket3) CreateDeploymentGitSourceLambdasUnion {
	typ := CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket3

	return CreateDeploymentGitSourceLambdasUnion{
		CreateDeploymentGitSourceLambdasBitbucket3: &createDeploymentGitSourceLambdasBitbucket3,
		Type: typ,
	}
}

func (u *CreateDeploymentGitSourceLambdasUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentGitSourceGithubCustomHost3 CreateDeploymentGitSourceGithubCustomHost3 = CreateDeploymentGitSourceGithubCustomHost3{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceGithubCustomHost3, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceGithubCustomHost3 = &createDeploymentGitSourceGithubCustomHost3
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost3
		return nil
	}

	var createDeploymentGitSourceLambdasBitbucket3 CreateDeploymentGitSourceLambdasBitbucket3 = CreateDeploymentGitSourceLambdasBitbucket3{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasBitbucket3, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasBitbucket3 = &createDeploymentGitSourceLambdasBitbucket3
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket3
		return nil
	}

	var createDeploymentGitSourceGithubCustomHost2 CreateDeploymentGitSourceGithubCustomHost2 = CreateDeploymentGitSourceGithubCustomHost2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceGithubCustomHost2, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceGithubCustomHost2 = &createDeploymentGitSourceGithubCustomHost2
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost2
		return nil
	}

	var createDeploymentGitSourceCustom CreateDeploymentGitSourceCustom = CreateDeploymentGitSourceCustom{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceCustom, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceCustom = &createDeploymentGitSourceCustom
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceCustom
		return nil
	}

	var createDeploymentGitSourceLambdasGithub3 CreateDeploymentGitSourceLambdasGithub3 = CreateDeploymentGitSourceLambdasGithub3{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithub3, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithub3 = &createDeploymentGitSourceLambdasGithub3
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub3
		return nil
	}

	var createDeploymentGitSourceLambdasGithubLimited3 CreateDeploymentGitSourceLambdasGithubLimited3 = CreateDeploymentGitSourceLambdasGithubLimited3{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithubLimited3, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithubLimited3 = &createDeploymentGitSourceLambdasGithubLimited3
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited3
		return nil
	}

	var createDeploymentGitSourceLambdasGitlab2 CreateDeploymentGitSourceLambdasGitlab2 = CreateDeploymentGitSourceLambdasGitlab2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGitlab2, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGitlab2 = &createDeploymentGitSourceLambdasGitlab2
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab2
		return nil
	}

	var createDeploymentGitSourceLambdasGithub2 CreateDeploymentGitSourceLambdasGithub2 = CreateDeploymentGitSourceLambdasGithub2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithub2, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithub2 = &createDeploymentGitSourceLambdasGithub2
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub2
		return nil
	}

	var createDeploymentGitSourceGithubCustomHost1 CreateDeploymentGitSourceGithubCustomHost1 = CreateDeploymentGitSourceGithubCustomHost1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceGithubCustomHost1, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceGithubCustomHost1 = &createDeploymentGitSourceGithubCustomHost1
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceGithubCustomHost1
		return nil
	}

	var createDeploymentGitSourceLambdasGithubLimited2 CreateDeploymentGitSourceLambdasGithubLimited2 = CreateDeploymentGitSourceLambdasGithubLimited2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithubLimited2, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithubLimited2 = &createDeploymentGitSourceLambdasGithubLimited2
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited2
		return nil
	}

	var createDeploymentGitSourceLambdasBitbucket2 CreateDeploymentGitSourceLambdasBitbucket2 = CreateDeploymentGitSourceLambdasBitbucket2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasBitbucket2, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasBitbucket2 = &createDeploymentGitSourceLambdasBitbucket2
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket2
		return nil
	}

	var createDeploymentGitSourceLambdasGithub1 CreateDeploymentGitSourceLambdasGithub1 = CreateDeploymentGitSourceLambdasGithub1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithub1, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithub1 = &createDeploymentGitSourceLambdasGithub1
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithub1
		return nil
	}

	var createDeploymentGitSourceLambdasGithubLimited1 CreateDeploymentGitSourceLambdasGithubLimited1 = CreateDeploymentGitSourceLambdasGithubLimited1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGithubLimited1, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGithubLimited1 = &createDeploymentGitSourceLambdasGithubLimited1
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGithubLimited1
		return nil
	}

	var createDeploymentGitSourceLambdasGitlab1 CreateDeploymentGitSourceLambdasGitlab1 = CreateDeploymentGitSourceLambdasGitlab1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasGitlab1, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasGitlab1 = &createDeploymentGitSourceLambdasGitlab1
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasGitlab1
		return nil
	}

	var createDeploymentGitSourceLambdasBitbucket1 CreateDeploymentGitSourceLambdasBitbucket1 = CreateDeploymentGitSourceLambdasBitbucket1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitSourceLambdasBitbucket1, "", true, nil); err == nil {
		u.CreateDeploymentGitSourceLambdasBitbucket1 = &createDeploymentGitSourceLambdasBitbucket1
		u.Type = CreateDeploymentGitSourceLambdasUnionTypeCreateDeploymentGitSourceLambdasBitbucket1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentGitSourceLambdasUnion", string(data))
}

func (u CreateDeploymentGitSourceLambdasUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentGitSourceLambdasGithub1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithub1, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGithub2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithub2, "", true)
	}

	if u.CreateDeploymentGitSourceGithubCustomHost1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceGithubCustomHost1, "", true)
	}

	if u.CreateDeploymentGitSourceGithubCustomHost2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceGithubCustomHost2, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGithubLimited1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithubLimited1, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGithubLimited2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithubLimited2, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGitlab1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGitlab1, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasBitbucket1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasBitbucket1, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasBitbucket2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasBitbucket2, "", true)
	}

	if u.CreateDeploymentGitSourceCustom != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceCustom, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGithub3 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithub3, "", true)
	}

	if u.CreateDeploymentGitSourceGithubCustomHost3 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceGithubCustomHost3, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGithubLimited3 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGithubLimited3, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasGitlab2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasGitlab2, "", true)
	}

	if u.CreateDeploymentGitSourceLambdasBitbucket3 != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitSourceLambdasBitbucket3, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentGitSourceLambdasUnion: all fields are null")
}

// CreateDeploymentNodeVersionLambdas - If set it overrides the `projectSettings.nodeVersion` for this deployment.
type CreateDeploymentNodeVersionLambdas string

const (
	CreateDeploymentNodeVersionLambdasTwentyFourDotX CreateDeploymentNodeVersionLambdas = "24.x"
	CreateDeploymentNodeVersionLambdasTwentyTwoDotX  CreateDeploymentNodeVersionLambdas = "22.x"
	CreateDeploymentNodeVersionLambdasTwentyDotX     CreateDeploymentNodeVersionLambdas = "20.x"
	CreateDeploymentNodeVersionLambdasEighteenDotX   CreateDeploymentNodeVersionLambdas = "18.x"
	CreateDeploymentNodeVersionLambdasSixteenDotX    CreateDeploymentNodeVersionLambdas = "16.x"
	CreateDeploymentNodeVersionLambdasFourteenDotX   CreateDeploymentNodeVersionLambdas = "14.x"
	CreateDeploymentNodeVersionLambdasTwelveDotX     CreateDeploymentNodeVersionLambdas = "12.x"
	CreateDeploymentNodeVersionLambdasTenDotX        CreateDeploymentNodeVersionLambdas = "10.x"
	CreateDeploymentNodeVersionLambdasEightDot10DotX CreateDeploymentNodeVersionLambdas = "8.10.x"
)

func (e CreateDeploymentNodeVersionLambdas) ToPointer() *CreateDeploymentNodeVersionLambdas {
	return &e
}
func (e *CreateDeploymentNodeVersionLambdas) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "24.x":
		fallthrough
	case "22.x":
		fallthrough
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		fallthrough
	case "14.x":
		fallthrough
	case "12.x":
		fallthrough
	case "10.x":
		fallthrough
	case "8.10.x":
		*e = CreateDeploymentNodeVersionLambdas(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentNodeVersionLambdas: %v", v)
	}
}

// CreateDeploymentProject - The public project information associated with the deployment.
type CreateDeploymentProject struct {
	ID        string  `json:"id"`
	Name      string  `json:"name"`
	Framework *string `json:"framework,omitempty"`
}

func (o *CreateDeploymentProject) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentProject) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentProject) GetFramework() *string {
	if o == nil {
		return nil
	}
	return o.Framework
}

// CreateDeploymentReadySubstate - Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
type CreateDeploymentReadySubstate string

const (
	CreateDeploymentReadySubstateStaged   CreateDeploymentReadySubstate = "STAGED"
	CreateDeploymentReadySubstateRolling  CreateDeploymentReadySubstate = "ROLLING"
	CreateDeploymentReadySubstatePromoted CreateDeploymentReadySubstate = "PROMOTED"
)

func (e CreateDeploymentReadySubstate) ToPointer() *CreateDeploymentReadySubstate {
	return &e
}
func (e *CreateDeploymentReadySubstate) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "STAGED":
		fallthrough
	case "ROLLING":
		fallthrough
	case "PROMOTED":
		*e = CreateDeploymentReadySubstate(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentReadySubstate: %v", v)
	}
}

// CreateDeploymentSource - Where was the deployment created from
type CreateDeploymentSource string

const (
	CreateDeploymentSourceAPITriggerGitDeploy CreateDeploymentSource = "api-trigger-git-deploy"
	CreateDeploymentSourceCli                 CreateDeploymentSource = "cli"
	CreateDeploymentSourceCloneRepo           CreateDeploymentSource = "clone/repo"
	CreateDeploymentSourceGit                 CreateDeploymentSource = "git"
	CreateDeploymentSourceImport              CreateDeploymentSource = "import"
	CreateDeploymentSourceImportRepo          CreateDeploymentSource = "import/repo"
	CreateDeploymentSourceRedeploy            CreateDeploymentSource = "redeploy"
	CreateDeploymentSourceV0Web               CreateDeploymentSource = "v0-web"
)

func (e CreateDeploymentSource) ToPointer() *CreateDeploymentSource {
	return &e
}
func (e *CreateDeploymentSource) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "api-trigger-git-deploy":
		fallthrough
	case "cli":
		fallthrough
	case "clone/repo":
		fallthrough
	case "git":
		fallthrough
	case "import":
		fallthrough
	case "import/repo":
		fallthrough
	case "redeploy":
		fallthrough
	case "v0-web":
		*e = CreateDeploymentSource(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentSource: %v", v)
	}
}

// CreateDeploymentTargetEnum - If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
type CreateDeploymentTargetEnum string

const (
	CreateDeploymentTargetEnumStaging    CreateDeploymentTargetEnum = "staging"
	CreateDeploymentTargetEnumProduction CreateDeploymentTargetEnum = "production"
)

func (e CreateDeploymentTargetEnum) ToPointer() *CreateDeploymentTargetEnum {
	return &e
}
func (e *CreateDeploymentTargetEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "staging":
		fallthrough
	case "production":
		*e = CreateDeploymentTargetEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTargetEnum: %v", v)
	}
}

type CreateDeploymentOidcTokenClaims struct {
	Iss         string `json:"iss"`
	Sub         string `json:"sub"`
	Scope       string `json:"scope"`
	Aud         string `json:"aud"`
	Owner       string `json:"owner"`
	OwnerID     string `json:"owner_id"`
	Project     string `json:"project"`
	ProjectID   string `json:"project_id"`
	Environment string `json:"environment"`
}

func (o *CreateDeploymentOidcTokenClaims) GetIss() string {
	if o == nil {
		return ""
	}
	return o.Iss
}

func (o *CreateDeploymentOidcTokenClaims) GetSub() string {
	if o == nil {
		return ""
	}
	return o.Sub
}

func (o *CreateDeploymentOidcTokenClaims) GetScope() string {
	if o == nil {
		return ""
	}
	return o.Scope
}

func (o *CreateDeploymentOidcTokenClaims) GetAud() string {
	if o == nil {
		return ""
	}
	return o.Aud
}

func (o *CreateDeploymentOidcTokenClaims) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *CreateDeploymentOidcTokenClaims) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *CreateDeploymentOidcTokenClaims) GetProject() string {
	if o == nil {
		return ""
	}
	return o.Project
}

func (o *CreateDeploymentOidcTokenClaims) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateDeploymentOidcTokenClaims) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type CreateDeploymentPlan string

const (
	CreateDeploymentPlanPro        CreateDeploymentPlan = "pro"
	CreateDeploymentPlanEnterprise CreateDeploymentPlan = "enterprise"
	CreateDeploymentPlanHobby      CreateDeploymentPlan = "hobby"
)

func (e CreateDeploymentPlan) ToPointer() *CreateDeploymentPlan {
	return &e
}
func (e *CreateDeploymentPlan) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pro":
		fallthrough
	case "enterprise":
		fallthrough
	case "hobby":
		*e = CreateDeploymentPlan(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentPlan: %v", v)
	}
}

type CreateDeploymentCron struct {
	Schedule string `json:"schedule"`
	Path     string `json:"path"`
}

func (o *CreateDeploymentCron) GetSchedule() string {
	if o == nil {
		return ""
	}
	return o.Schedule
}

func (o *CreateDeploymentCron) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type CreateDeploymentArchitecture string

const (
	CreateDeploymentArchitectureX8664 CreateDeploymentArchitecture = "x86_64"
	CreateDeploymentArchitectureArm64 CreateDeploymentArchitecture = "arm64"
)

func (e CreateDeploymentArchitecture) ToPointer() *CreateDeploymentArchitecture {
	return &e
}
func (e *CreateDeploymentArchitecture) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x86_64":
		fallthrough
	case "arm64":
		*e = CreateDeploymentArchitecture(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentArchitecture: %v", v)
	}
}

// CreateDeploymentFunctionsType - Event type - must be "queue/v1beta" (REQUIRED)
type CreateDeploymentFunctionsType string

const (
	CreateDeploymentFunctionsTypeQueueV1beta CreateDeploymentFunctionsType = "queue/v1beta"
)

func (e CreateDeploymentFunctionsType) ToPointer() *CreateDeploymentFunctionsType {
	return &e
}
func (e *CreateDeploymentFunctionsType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue/v1beta":
		*e = CreateDeploymentFunctionsType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFunctionsType: %v", v)
	}
}

// CreateDeploymentExperimentalTrigger - Queue trigger event for Vercel's queue system. Handles "queue/v1beta" events with queue-specific configuration.
type CreateDeploymentExperimentalTrigger struct {
	// Event type - must be "queue/v1beta" (REQUIRED)
	Type CreateDeploymentFunctionsType `json:"type"`
	// Name of the queue topic to consume from (REQUIRED)
	Topic string `json:"topic"`
	// Name of the consumer group for this trigger (REQUIRED)
	Consumer string `json:"consumer"`
	// Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
	MaxDeliveries *float64 `json:"maxDeliveries,omitempty"`
	// Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
	RetryAfterSeconds *float64 `json:"retryAfterSeconds,omitempty"`
	// Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty"`
}

func (o *CreateDeploymentExperimentalTrigger) GetType() CreateDeploymentFunctionsType {
	if o == nil {
		return CreateDeploymentFunctionsType("")
	}
	return o.Type
}

func (o *CreateDeploymentExperimentalTrigger) GetTopic() string {
	if o == nil {
		return ""
	}
	return o.Topic
}

func (o *CreateDeploymentExperimentalTrigger) GetConsumer() string {
	if o == nil {
		return ""
	}
	return o.Consumer
}

func (o *CreateDeploymentExperimentalTrigger) GetMaxDeliveries() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDeliveries
}

func (o *CreateDeploymentExperimentalTrigger) GetRetryAfterSeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.RetryAfterSeconds
}

func (o *CreateDeploymentExperimentalTrigger) GetInitialDelaySeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.InitialDelaySeconds
}

type CreateDeploymentFunctions struct {
	Architecture         *CreateDeploymentArchitecture         `json:"architecture,omitempty"`
	Memory               *float64                              `json:"memory,omitempty"`
	MaxDuration          *float64                              `json:"maxDuration,omitempty"`
	Runtime              *string                               `json:"runtime,omitempty"`
	IncludeFiles         *string                               `json:"includeFiles,omitempty"`
	ExcludeFiles         *string                               `json:"excludeFiles,omitempty"`
	ExperimentalTriggers []CreateDeploymentExperimentalTrigger `json:"experimentalTriggers,omitempty"`
	SupportsCancellation *bool                                 `json:"supportsCancellation,omitempty"`
}

func (o *CreateDeploymentFunctions) GetArchitecture() *CreateDeploymentArchitecture {
	if o == nil {
		return nil
	}
	return o.Architecture
}

func (o *CreateDeploymentFunctions) GetMemory() *float64 {
	if o == nil {
		return nil
	}
	return o.Memory
}

func (o *CreateDeploymentFunctions) GetMaxDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDuration
}

func (o *CreateDeploymentFunctions) GetRuntime() *string {
	if o == nil {
		return nil
	}
	return o.Runtime
}

func (o *CreateDeploymentFunctions) GetIncludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.IncludeFiles
}

func (o *CreateDeploymentFunctions) GetExcludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeFiles
}

func (o *CreateDeploymentFunctions) GetExperimentalTriggers() []CreateDeploymentExperimentalTrigger {
	if o == nil {
		return nil
	}
	return o.ExperimentalTriggers
}

func (o *CreateDeploymentFunctions) GetSupportsCancellation() *bool {
	if o == nil {
		return nil
	}
	return o.SupportsCancellation
}

type CreateDeploymentRoute3 struct {
	Src        string  `json:"src"`
	Continue   bool    `json:"continue"`
	Middleware float64 `json:"middleware"`
}

func (c CreateDeploymentRoute3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentRoute3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"src", "continue", "middleware"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentRoute3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *CreateDeploymentRoute3) GetContinue() bool {
	if o == nil {
		return false
	}
	return o.Continue
}

func (o *CreateDeploymentRoute3) GetMiddleware() float64 {
	if o == nil {
		return 0.0
	}
	return o.Middleware
}

type CreateDeploymentHandle string

const (
	CreateDeploymentHandleError      CreateDeploymentHandle = "error"
	CreateDeploymentHandleFilesystem CreateDeploymentHandle = "filesystem"
	CreateDeploymentHandleHit        CreateDeploymentHandle = "hit"
	CreateDeploymentHandleMiss       CreateDeploymentHandle = "miss"
	CreateDeploymentHandleRewrite    CreateDeploymentHandle = "rewrite"
	CreateDeploymentHandleResource   CreateDeploymentHandle = "resource"
)

func (e CreateDeploymentHandle) ToPointer() *CreateDeploymentHandle {
	return &e
}
func (e *CreateDeploymentHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "filesystem":
		fallthrough
	case "hit":
		fallthrough
	case "miss":
		fallthrough
	case "rewrite":
		fallthrough
	case "resource":
		*e = CreateDeploymentHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentHandle: %v", v)
	}
}

type CreateDeploymentRoute2 struct {
	Handle CreateDeploymentHandle `json:"handle"`
	Src    *string                `json:"src,omitempty"`
	Dest   *string                `json:"dest,omitempty"`
	Status *float64               `json:"status,omitempty"`
}

func (c CreateDeploymentRoute2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentRoute2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"handle"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentRoute2) GetHandle() CreateDeploymentHandle {
	if o == nil {
		return CreateDeploymentHandle("")
	}
	return o.Handle
}

func (o *CreateDeploymentRoute2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *CreateDeploymentRoute2) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *CreateDeploymentRoute2) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

type CreateDeploymentHasType string

const (
	CreateDeploymentHasTypeHeader CreateDeploymentHasType = "header"
	CreateDeploymentHasTypeCookie CreateDeploymentHasType = "cookie"
	CreateDeploymentHasTypeQuery  CreateDeploymentHasType = "query"
)

func (e CreateDeploymentHasType) ToPointer() *CreateDeploymentHasType {
	return &e
}
func (e *CreateDeploymentHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentHasType: %v", v)
	}
}

type CreateDeploymentHasEq2Type string

const (
	CreateDeploymentHasEq2TypeStr    CreateDeploymentHasEq2Type = "str"
	CreateDeploymentHasEq2TypeNumber CreateDeploymentHasEq2Type = "number"
)

type CreateDeploymentHasEq2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentHasEq2Type
}

func CreateCreateDeploymentHasEq2Str(str string) CreateDeploymentHasEq2 {
	typ := CreateDeploymentHasEq2TypeStr

	return CreateDeploymentHasEq2{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentHasEq2Number(number float64) CreateDeploymentHasEq2 {
	typ := CreateDeploymentHasEq2TypeNumber

	return CreateDeploymentHasEq2{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentHasEq2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentHasEq2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentHasEq2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentHasEq2", string(data))
}

func (u CreateDeploymentHasEq2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentHasEq2: all fields are null")
}

type CreateDeploymentHasValue2 struct {
	Eq   *CreateDeploymentHasEq2 `json:"eq,omitempty"`
	Neq  *string                 `json:"neq,omitempty"`
	Inc  []string                `json:"inc,omitempty"`
	Ninc []string                `json:"ninc,omitempty"`
	Pre  *string                 `json:"pre,omitempty"`
	Suf  *string                 `json:"suf,omitempty"`
	Re   *string                 `json:"re,omitempty"`
	Gt   *float64                `json:"gt,omitempty"`
	Gte  *float64                `json:"gte,omitempty"`
	Lt   *float64                `json:"lt,omitempty"`
	Lte  *float64                `json:"lte,omitempty"`
}

func (c CreateDeploymentHasValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentHasValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentHasValue2) GetEq() *CreateDeploymentHasEq2 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *CreateDeploymentHasValue2) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *CreateDeploymentHasValue2) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *CreateDeploymentHasValue2) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *CreateDeploymentHasValue2) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *CreateDeploymentHasValue2) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *CreateDeploymentHasValue2) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *CreateDeploymentHasValue2) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *CreateDeploymentHasValue2) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *CreateDeploymentHasValue2) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *CreateDeploymentHasValue2) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type CreateDeploymentHasValueUnion2Type string

const (
	CreateDeploymentHasValueUnion2TypeStr                       CreateDeploymentHasValueUnion2Type = "str"
	CreateDeploymentHasValueUnion2TypeCreateDeploymentHasValue2 CreateDeploymentHasValueUnion2Type = "createDeployment_has_value_2"
)

type CreateDeploymentHasValueUnion2 struct {
	Str                       *string                    `queryParam:"inline"`
	CreateDeploymentHasValue2 *CreateDeploymentHasValue2 `queryParam:"inline"`

	Type CreateDeploymentHasValueUnion2Type
}

func CreateCreateDeploymentHasValueUnion2Str(str string) CreateDeploymentHasValueUnion2 {
	typ := CreateDeploymentHasValueUnion2TypeStr

	return CreateDeploymentHasValueUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentHasValueUnion2CreateDeploymentHasValue2(createDeploymentHasValue2 CreateDeploymentHasValue2) CreateDeploymentHasValueUnion2 {
	typ := CreateDeploymentHasValueUnion2TypeCreateDeploymentHasValue2

	return CreateDeploymentHasValueUnion2{
		CreateDeploymentHasValue2: &createDeploymentHasValue2,
		Type:                      typ,
	}
}

func (u *CreateDeploymentHasValueUnion2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentHasValueUnion2TypeStr
		return nil
	}

	var createDeploymentHasValue2 CreateDeploymentHasValue2 = CreateDeploymentHasValue2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentHasValue2, "", true, nil); err == nil {
		u.CreateDeploymentHasValue2 = &createDeploymentHasValue2
		u.Type = CreateDeploymentHasValueUnion2TypeCreateDeploymentHasValue2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentHasValueUnion2", string(data))
}

func (u CreateDeploymentHasValueUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.CreateDeploymentHasValue2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentHasValue2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentHasValueUnion2: all fields are null")
}

type CreateDeploymentHas struct {
	Type  CreateDeploymentHasType         `json:"type"`
	Key   string                          `json:"key"`
	Value *CreateDeploymentHasValueUnion2 `json:"value,omitempty"`
}

func (c CreateDeploymentHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentHas) GetType() CreateDeploymentHasType {
	if o == nil {
		return CreateDeploymentHasType("")
	}
	return o.Type
}

func (o *CreateDeploymentHas) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *CreateDeploymentHas) GetValue() *CreateDeploymentHasValueUnion2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type CreateDeploymentHasTypeHost string

const (
	CreateDeploymentHasTypeHostHost CreateDeploymentHasTypeHost = "host"
)

func (e CreateDeploymentHasTypeHost) ToPointer() *CreateDeploymentHasTypeHost {
	return &e
}
func (e *CreateDeploymentHasTypeHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = CreateDeploymentHasTypeHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentHasTypeHost: %v", v)
	}
}

type CreateDeploymentHasEq1Type string

const (
	CreateDeploymentHasEq1TypeStr    CreateDeploymentHasEq1Type = "str"
	CreateDeploymentHasEq1TypeNumber CreateDeploymentHasEq1Type = "number"
)

type CreateDeploymentHasEq1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentHasEq1Type
}

func CreateCreateDeploymentHasEq1Str(str string) CreateDeploymentHasEq1 {
	typ := CreateDeploymentHasEq1TypeStr

	return CreateDeploymentHasEq1{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentHasEq1Number(number float64) CreateDeploymentHasEq1 {
	typ := CreateDeploymentHasEq1TypeNumber

	return CreateDeploymentHasEq1{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentHasEq1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentHasEq1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentHasEq1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentHasEq1", string(data))
}

func (u CreateDeploymentHasEq1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentHasEq1: all fields are null")
}

type CreateDeploymentHasValue1 struct {
	Eq   *CreateDeploymentHasEq1 `json:"eq,omitempty"`
	Neq  *string                 `json:"neq,omitempty"`
	Inc  []string                `json:"inc,omitempty"`
	Ninc []string                `json:"ninc,omitempty"`
	Pre  *string                 `json:"pre,omitempty"`
	Suf  *string                 `json:"suf,omitempty"`
	Re   *string                 `json:"re,omitempty"`
	Gt   *float64                `json:"gt,omitempty"`
	Gte  *float64                `json:"gte,omitempty"`
	Lt   *float64                `json:"lt,omitempty"`
	Lte  *float64                `json:"lte,omitempty"`
}

func (c CreateDeploymentHasValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentHasValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentHasValue1) GetEq() *CreateDeploymentHasEq1 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *CreateDeploymentHasValue1) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *CreateDeploymentHasValue1) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *CreateDeploymentHasValue1) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *CreateDeploymentHasValue1) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *CreateDeploymentHasValue1) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *CreateDeploymentHasValue1) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *CreateDeploymentHasValue1) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *CreateDeploymentHasValue1) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *CreateDeploymentHasValue1) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *CreateDeploymentHasValue1) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type CreateDeploymentHasValueUnion1Type string

const (
	CreateDeploymentHasValueUnion1TypeStr                       CreateDeploymentHasValueUnion1Type = "str"
	CreateDeploymentHasValueUnion1TypeCreateDeploymentHasValue1 CreateDeploymentHasValueUnion1Type = "createDeployment_has_value_1"
)

type CreateDeploymentHasValueUnion1 struct {
	Str                       *string                    `queryParam:"inline"`
	CreateDeploymentHasValue1 *CreateDeploymentHasValue1 `queryParam:"inline"`

	Type CreateDeploymentHasValueUnion1Type
}

func CreateCreateDeploymentHasValueUnion1Str(str string) CreateDeploymentHasValueUnion1 {
	typ := CreateDeploymentHasValueUnion1TypeStr

	return CreateDeploymentHasValueUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentHasValueUnion1CreateDeploymentHasValue1(createDeploymentHasValue1 CreateDeploymentHasValue1) CreateDeploymentHasValueUnion1 {
	typ := CreateDeploymentHasValueUnion1TypeCreateDeploymentHasValue1

	return CreateDeploymentHasValueUnion1{
		CreateDeploymentHasValue1: &createDeploymentHasValue1,
		Type:                      typ,
	}
}

func (u *CreateDeploymentHasValueUnion1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentHasValueUnion1TypeStr
		return nil
	}

	var createDeploymentHasValue1 CreateDeploymentHasValue1 = CreateDeploymentHasValue1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentHasValue1, "", true, nil); err == nil {
		u.CreateDeploymentHasValue1 = &createDeploymentHasValue1
		u.Type = CreateDeploymentHasValueUnion1TypeCreateDeploymentHasValue1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentHasValueUnion1", string(data))
}

func (u CreateDeploymentHasValueUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.CreateDeploymentHasValue1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentHasValue1, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentHasValueUnion1: all fields are null")
}

type CreateDeploymentHasHost struct {
	Type  CreateDeploymentHasTypeHost    `json:"type"`
	Value CreateDeploymentHasValueUnion1 `json:"value"`
}

func (c CreateDeploymentHasHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentHasHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentHasHost) GetType() CreateDeploymentHasTypeHost {
	if o == nil {
		return CreateDeploymentHasTypeHost("")
	}
	return o.Type
}

func (o *CreateDeploymentHasHost) GetValue() CreateDeploymentHasValueUnion1 {
	if o == nil {
		return CreateDeploymentHasValueUnion1{}
	}
	return o.Value
}

type CreateDeploymentHasUnionType string

const (
	CreateDeploymentHasUnionTypeCreateDeploymentHasHost CreateDeploymentHasUnionType = "createDeployment_has_Host"
	CreateDeploymentHasUnionTypeCreateDeploymentHas     CreateDeploymentHasUnionType = "createDeployment_has"
)

type CreateDeploymentHasUnion struct {
	CreateDeploymentHasHost *CreateDeploymentHasHost `queryParam:"inline"`
	CreateDeploymentHas     *CreateDeploymentHas     `queryParam:"inline"`

	Type CreateDeploymentHasUnionType
}

func CreateCreateDeploymentHasUnionCreateDeploymentHasHost(createDeploymentHasHost CreateDeploymentHasHost) CreateDeploymentHasUnion {
	typ := CreateDeploymentHasUnionTypeCreateDeploymentHasHost

	return CreateDeploymentHasUnion{
		CreateDeploymentHasHost: &createDeploymentHasHost,
		Type:                    typ,
	}
}

func CreateCreateDeploymentHasUnionCreateDeploymentHas(createDeploymentHas CreateDeploymentHas) CreateDeploymentHasUnion {
	typ := CreateDeploymentHasUnionTypeCreateDeploymentHas

	return CreateDeploymentHasUnion{
		CreateDeploymentHas: &createDeploymentHas,
		Type:                typ,
	}
}

func (u *CreateDeploymentHasUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentHasHost CreateDeploymentHasHost = CreateDeploymentHasHost{}
	if err := utils.UnmarshalJSON(data, &createDeploymentHasHost, "", true, nil); err == nil {
		u.CreateDeploymentHasHost = &createDeploymentHasHost
		u.Type = CreateDeploymentHasUnionTypeCreateDeploymentHasHost
		return nil
	}

	var createDeploymentHas CreateDeploymentHas = CreateDeploymentHas{}
	if err := utils.UnmarshalJSON(data, &createDeploymentHas, "", true, nil); err == nil {
		u.CreateDeploymentHas = &createDeploymentHas
		u.Type = CreateDeploymentHasUnionTypeCreateDeploymentHas
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentHasUnion", string(data))
}

func (u CreateDeploymentHasUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentHasHost != nil {
		return utils.MarshalJSON(u.CreateDeploymentHasHost, "", true)
	}

	if u.CreateDeploymentHas != nil {
		return utils.MarshalJSON(u.CreateDeploymentHas, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentHasUnion: all fields are null")
}

type CreateDeploymentMissingType string

const (
	CreateDeploymentMissingTypeHeader CreateDeploymentMissingType = "header"
	CreateDeploymentMissingTypeCookie CreateDeploymentMissingType = "cookie"
	CreateDeploymentMissingTypeQuery  CreateDeploymentMissingType = "query"
)

func (e CreateDeploymentMissingType) ToPointer() *CreateDeploymentMissingType {
	return &e
}
func (e *CreateDeploymentMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = CreateDeploymentMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentMissingType: %v", v)
	}
}

type CreateDeploymentMissingEq2Type string

const (
	CreateDeploymentMissingEq2TypeStr    CreateDeploymentMissingEq2Type = "str"
	CreateDeploymentMissingEq2TypeNumber CreateDeploymentMissingEq2Type = "number"
)

type CreateDeploymentMissingEq2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentMissingEq2Type
}

func CreateCreateDeploymentMissingEq2Str(str string) CreateDeploymentMissingEq2 {
	typ := CreateDeploymentMissingEq2TypeStr

	return CreateDeploymentMissingEq2{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentMissingEq2Number(number float64) CreateDeploymentMissingEq2 {
	typ := CreateDeploymentMissingEq2TypeNumber

	return CreateDeploymentMissingEq2{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentMissingEq2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentMissingEq2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentMissingEq2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMissingEq2", string(data))
}

func (u CreateDeploymentMissingEq2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMissingEq2: all fields are null")
}

type CreateDeploymentMissingValue2 struct {
	Eq   *CreateDeploymentMissingEq2 `json:"eq,omitempty"`
	Neq  *string                     `json:"neq,omitempty"`
	Inc  []string                    `json:"inc,omitempty"`
	Ninc []string                    `json:"ninc,omitempty"`
	Pre  *string                     `json:"pre,omitempty"`
	Suf  *string                     `json:"suf,omitempty"`
	Re   *string                     `json:"re,omitempty"`
	Gt   *float64                    `json:"gt,omitempty"`
	Gte  *float64                    `json:"gte,omitempty"`
	Lt   *float64                    `json:"lt,omitempty"`
	Lte  *float64                    `json:"lte,omitempty"`
}

func (c CreateDeploymentMissingValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMissingValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMissingValue2) GetEq() *CreateDeploymentMissingEq2 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *CreateDeploymentMissingValue2) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *CreateDeploymentMissingValue2) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *CreateDeploymentMissingValue2) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *CreateDeploymentMissingValue2) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *CreateDeploymentMissingValue2) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *CreateDeploymentMissingValue2) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *CreateDeploymentMissingValue2) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *CreateDeploymentMissingValue2) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *CreateDeploymentMissingValue2) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *CreateDeploymentMissingValue2) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type CreateDeploymentMissingValueUnion2Type string

const (
	CreateDeploymentMissingValueUnion2TypeStr                           CreateDeploymentMissingValueUnion2Type = "str"
	CreateDeploymentMissingValueUnion2TypeCreateDeploymentMissingValue2 CreateDeploymentMissingValueUnion2Type = "createDeployment_missing_value_2"
)

type CreateDeploymentMissingValueUnion2 struct {
	Str                           *string                        `queryParam:"inline"`
	CreateDeploymentMissingValue2 *CreateDeploymentMissingValue2 `queryParam:"inline"`

	Type CreateDeploymentMissingValueUnion2Type
}

func CreateCreateDeploymentMissingValueUnion2Str(str string) CreateDeploymentMissingValueUnion2 {
	typ := CreateDeploymentMissingValueUnion2TypeStr

	return CreateDeploymentMissingValueUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentMissingValueUnion2CreateDeploymentMissingValue2(createDeploymentMissingValue2 CreateDeploymentMissingValue2) CreateDeploymentMissingValueUnion2 {
	typ := CreateDeploymentMissingValueUnion2TypeCreateDeploymentMissingValue2

	return CreateDeploymentMissingValueUnion2{
		CreateDeploymentMissingValue2: &createDeploymentMissingValue2,
		Type:                          typ,
	}
}

func (u *CreateDeploymentMissingValueUnion2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentMissingValueUnion2TypeStr
		return nil
	}

	var createDeploymentMissingValue2 CreateDeploymentMissingValue2 = CreateDeploymentMissingValue2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMissingValue2, "", true, nil); err == nil {
		u.CreateDeploymentMissingValue2 = &createDeploymentMissingValue2
		u.Type = CreateDeploymentMissingValueUnion2TypeCreateDeploymentMissingValue2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMissingValueUnion2", string(data))
}

func (u CreateDeploymentMissingValueUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.CreateDeploymentMissingValue2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentMissingValue2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMissingValueUnion2: all fields are null")
}

type CreateDeploymentMissing struct {
	Type  CreateDeploymentMissingType         `json:"type"`
	Key   string                              `json:"key"`
	Value *CreateDeploymentMissingValueUnion2 `json:"value,omitempty"`
}

func (c CreateDeploymentMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMissing) GetType() CreateDeploymentMissingType {
	if o == nil {
		return CreateDeploymentMissingType("")
	}
	return o.Type
}

func (o *CreateDeploymentMissing) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *CreateDeploymentMissing) GetValue() *CreateDeploymentMissingValueUnion2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type CreateDeploymentMissingTypeHost string

const (
	CreateDeploymentMissingTypeHostHost CreateDeploymentMissingTypeHost = "host"
)

func (e CreateDeploymentMissingTypeHost) ToPointer() *CreateDeploymentMissingTypeHost {
	return &e
}
func (e *CreateDeploymentMissingTypeHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = CreateDeploymentMissingTypeHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentMissingTypeHost: %v", v)
	}
}

type CreateDeploymentMissingEq1Type string

const (
	CreateDeploymentMissingEq1TypeStr    CreateDeploymentMissingEq1Type = "str"
	CreateDeploymentMissingEq1TypeNumber CreateDeploymentMissingEq1Type = "number"
)

type CreateDeploymentMissingEq1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentMissingEq1Type
}

func CreateCreateDeploymentMissingEq1Str(str string) CreateDeploymentMissingEq1 {
	typ := CreateDeploymentMissingEq1TypeStr

	return CreateDeploymentMissingEq1{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentMissingEq1Number(number float64) CreateDeploymentMissingEq1 {
	typ := CreateDeploymentMissingEq1TypeNumber

	return CreateDeploymentMissingEq1{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentMissingEq1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentMissingEq1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentMissingEq1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMissingEq1", string(data))
}

func (u CreateDeploymentMissingEq1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMissingEq1: all fields are null")
}

type CreateDeploymentMissingValue1 struct {
	Eq   *CreateDeploymentMissingEq1 `json:"eq,omitempty"`
	Neq  *string                     `json:"neq,omitempty"`
	Inc  []string                    `json:"inc,omitempty"`
	Ninc []string                    `json:"ninc,omitempty"`
	Pre  *string                     `json:"pre,omitempty"`
	Suf  *string                     `json:"suf,omitempty"`
	Re   *string                     `json:"re,omitempty"`
	Gt   *float64                    `json:"gt,omitempty"`
	Gte  *float64                    `json:"gte,omitempty"`
	Lt   *float64                    `json:"lt,omitempty"`
	Lte  *float64                    `json:"lte,omitempty"`
}

func (c CreateDeploymentMissingValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMissingValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMissingValue1) GetEq() *CreateDeploymentMissingEq1 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *CreateDeploymentMissingValue1) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *CreateDeploymentMissingValue1) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *CreateDeploymentMissingValue1) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *CreateDeploymentMissingValue1) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *CreateDeploymentMissingValue1) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *CreateDeploymentMissingValue1) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *CreateDeploymentMissingValue1) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *CreateDeploymentMissingValue1) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *CreateDeploymentMissingValue1) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *CreateDeploymentMissingValue1) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type CreateDeploymentMissingValueUnion1Type string

const (
	CreateDeploymentMissingValueUnion1TypeStr                           CreateDeploymentMissingValueUnion1Type = "str"
	CreateDeploymentMissingValueUnion1TypeCreateDeploymentMissingValue1 CreateDeploymentMissingValueUnion1Type = "createDeployment_missing_value_1"
)

type CreateDeploymentMissingValueUnion1 struct {
	Str                           *string                        `queryParam:"inline"`
	CreateDeploymentMissingValue1 *CreateDeploymentMissingValue1 `queryParam:"inline"`

	Type CreateDeploymentMissingValueUnion1Type
}

func CreateCreateDeploymentMissingValueUnion1Str(str string) CreateDeploymentMissingValueUnion1 {
	typ := CreateDeploymentMissingValueUnion1TypeStr

	return CreateDeploymentMissingValueUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentMissingValueUnion1CreateDeploymentMissingValue1(createDeploymentMissingValue1 CreateDeploymentMissingValue1) CreateDeploymentMissingValueUnion1 {
	typ := CreateDeploymentMissingValueUnion1TypeCreateDeploymentMissingValue1

	return CreateDeploymentMissingValueUnion1{
		CreateDeploymentMissingValue1: &createDeploymentMissingValue1,
		Type:                          typ,
	}
}

func (u *CreateDeploymentMissingValueUnion1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentMissingValueUnion1TypeStr
		return nil
	}

	var createDeploymentMissingValue1 CreateDeploymentMissingValue1 = CreateDeploymentMissingValue1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMissingValue1, "", true, nil); err == nil {
		u.CreateDeploymentMissingValue1 = &createDeploymentMissingValue1
		u.Type = CreateDeploymentMissingValueUnion1TypeCreateDeploymentMissingValue1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMissingValueUnion1", string(data))
}

func (u CreateDeploymentMissingValueUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.CreateDeploymentMissingValue1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentMissingValue1, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMissingValueUnion1: all fields are null")
}

type CreateDeploymentMissingHost struct {
	Type  CreateDeploymentMissingTypeHost    `json:"type"`
	Value CreateDeploymentMissingValueUnion1 `json:"value"`
}

func (c CreateDeploymentMissingHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMissingHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMissingHost) GetType() CreateDeploymentMissingTypeHost {
	if o == nil {
		return CreateDeploymentMissingTypeHost("")
	}
	return o.Type
}

func (o *CreateDeploymentMissingHost) GetValue() CreateDeploymentMissingValueUnion1 {
	if o == nil {
		return CreateDeploymentMissingValueUnion1{}
	}
	return o.Value
}

type CreateDeploymentMissingUnionType string

const (
	CreateDeploymentMissingUnionTypeCreateDeploymentMissingHost CreateDeploymentMissingUnionType = "createDeployment_missing_Host"
	CreateDeploymentMissingUnionTypeCreateDeploymentMissing     CreateDeploymentMissingUnionType = "createDeployment_missing"
)

type CreateDeploymentMissingUnion struct {
	CreateDeploymentMissingHost *CreateDeploymentMissingHost `queryParam:"inline"`
	CreateDeploymentMissing     *CreateDeploymentMissing     `queryParam:"inline"`

	Type CreateDeploymentMissingUnionType
}

func CreateCreateDeploymentMissingUnionCreateDeploymentMissingHost(createDeploymentMissingHost CreateDeploymentMissingHost) CreateDeploymentMissingUnion {
	typ := CreateDeploymentMissingUnionTypeCreateDeploymentMissingHost

	return CreateDeploymentMissingUnion{
		CreateDeploymentMissingHost: &createDeploymentMissingHost,
		Type:                        typ,
	}
}

func CreateCreateDeploymentMissingUnionCreateDeploymentMissing(createDeploymentMissing CreateDeploymentMissing) CreateDeploymentMissingUnion {
	typ := CreateDeploymentMissingUnionTypeCreateDeploymentMissing

	return CreateDeploymentMissingUnion{
		CreateDeploymentMissing: &createDeploymentMissing,
		Type:                    typ,
	}
}

func (u *CreateDeploymentMissingUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentMissingHost CreateDeploymentMissingHost = CreateDeploymentMissingHost{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMissingHost, "", true, nil); err == nil {
		u.CreateDeploymentMissingHost = &createDeploymentMissingHost
		u.Type = CreateDeploymentMissingUnionTypeCreateDeploymentMissingHost
		return nil
	}

	var createDeploymentMissing CreateDeploymentMissing = CreateDeploymentMissing{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMissing, "", true, nil); err == nil {
		u.CreateDeploymentMissing = &createDeploymentMissing
		u.Type = CreateDeploymentMissingUnionTypeCreateDeploymentMissing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMissingUnion", string(data))
}

func (u CreateDeploymentMissingUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentMissingHost != nil {
		return utils.MarshalJSON(u.CreateDeploymentMissingHost, "", true)
	}

	if u.CreateDeploymentMissing != nil {
		return utils.MarshalJSON(u.CreateDeploymentMissing, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMissingUnion: all fields are null")
}

type CreateDeploymentAction string

const (
	CreateDeploymentActionChallenge CreateDeploymentAction = "challenge"
	CreateDeploymentActionDeny      CreateDeploymentAction = "deny"
)

func (e CreateDeploymentAction) ToPointer() *CreateDeploymentAction {
	return &e
}
func (e *CreateDeploymentAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "challenge":
		fallthrough
	case "deny":
		*e = CreateDeploymentAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentAction: %v", v)
	}
}

type CreateDeploymentMitigate struct {
	Action CreateDeploymentAction `json:"action"`
}

func (c CreateDeploymentMitigate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMitigate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMitigate) GetAction() CreateDeploymentAction {
	if o == nil {
		return CreateDeploymentAction("")
	}
	return o.Action
}

type CreateDeploymentTransformType string

const (
	CreateDeploymentTransformTypeRequestHeaders  CreateDeploymentTransformType = "request.headers"
	CreateDeploymentTransformTypeRequestQuery    CreateDeploymentTransformType = "request.query"
	CreateDeploymentTransformTypeResponseHeaders CreateDeploymentTransformType = "response.headers"
)

func (e CreateDeploymentTransformType) ToPointer() *CreateDeploymentTransformType {
	return &e
}
func (e *CreateDeploymentTransformType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "request.headers":
		fallthrough
	case "request.query":
		fallthrough
	case "response.headers":
		*e = CreateDeploymentTransformType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentTransformType: %v", v)
	}
}

type CreateDeploymentOp string

const (
	CreateDeploymentOpAppend CreateDeploymentOp = "append"
	CreateDeploymentOpSet    CreateDeploymentOp = "set"
	CreateDeploymentOpDelete CreateDeploymentOp = "delete"
)

func (e CreateDeploymentOp) ToPointer() *CreateDeploymentOp {
	return &e
}
func (e *CreateDeploymentOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "append":
		fallthrough
	case "set":
		fallthrough
	case "delete":
		*e = CreateDeploymentOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentOp: %v", v)
	}
}

type CreateDeploymentKeyEqType string

const (
	CreateDeploymentKeyEqTypeStr    CreateDeploymentKeyEqType = "str"
	CreateDeploymentKeyEqTypeNumber CreateDeploymentKeyEqType = "number"
)

type CreateDeploymentKeyEq struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type CreateDeploymentKeyEqType
}

func CreateCreateDeploymentKeyEqStr(str string) CreateDeploymentKeyEq {
	typ := CreateDeploymentKeyEqTypeStr

	return CreateDeploymentKeyEq{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentKeyEqNumber(number float64) CreateDeploymentKeyEq {
	typ := CreateDeploymentKeyEqTypeNumber

	return CreateDeploymentKeyEq{
		Number: &number,
		Type:   typ,
	}
}

func (u *CreateDeploymentKeyEq) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentKeyEqTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateDeploymentKeyEqTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentKeyEq", string(data))
}

func (u CreateDeploymentKeyEq) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentKeyEq: all fields are null")
}

type CreateDeploymentKey struct {
	Eq   *CreateDeploymentKeyEq `json:"eq,omitempty"`
	Neq  *string                `json:"neq,omitempty"`
	Inc  []string               `json:"inc,omitempty"`
	Ninc []string               `json:"ninc,omitempty"`
	Pre  *string                `json:"pre,omitempty"`
	Suf  *string                `json:"suf,omitempty"`
	Gt   *float64               `json:"gt,omitempty"`
	Gte  *float64               `json:"gte,omitempty"`
	Lt   *float64               `json:"lt,omitempty"`
	Lte  *float64               `json:"lte,omitempty"`
}

func (c CreateDeploymentKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentKey) GetEq() *CreateDeploymentKeyEq {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *CreateDeploymentKey) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *CreateDeploymentKey) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *CreateDeploymentKey) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *CreateDeploymentKey) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *CreateDeploymentKey) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *CreateDeploymentKey) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *CreateDeploymentKey) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *CreateDeploymentKey) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *CreateDeploymentKey) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type CreateDeploymentKeyUnionType string

const (
	CreateDeploymentKeyUnionTypeStr                 CreateDeploymentKeyUnionType = "str"
	CreateDeploymentKeyUnionTypeCreateDeploymentKey CreateDeploymentKeyUnionType = "createDeployment_key"
)

type CreateDeploymentKeyUnion struct {
	Str                 *string              `queryParam:"inline"`
	CreateDeploymentKey *CreateDeploymentKey `queryParam:"inline"`

	Type CreateDeploymentKeyUnionType
}

func CreateCreateDeploymentKeyUnionStr(str string) CreateDeploymentKeyUnion {
	typ := CreateDeploymentKeyUnionTypeStr

	return CreateDeploymentKeyUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentKeyUnionCreateDeploymentKey(createDeploymentKey CreateDeploymentKey) CreateDeploymentKeyUnion {
	typ := CreateDeploymentKeyUnionTypeCreateDeploymentKey

	return CreateDeploymentKeyUnion{
		CreateDeploymentKey: &createDeploymentKey,
		Type:                typ,
	}
}

func (u *CreateDeploymentKeyUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentKeyUnionTypeStr
		return nil
	}

	var createDeploymentKey CreateDeploymentKey = CreateDeploymentKey{}
	if err := utils.UnmarshalJSON(data, &createDeploymentKey, "", true, nil); err == nil {
		u.CreateDeploymentKey = &createDeploymentKey
		u.Type = CreateDeploymentKeyUnionTypeCreateDeploymentKey
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentKeyUnion", string(data))
}

func (u CreateDeploymentKeyUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.CreateDeploymentKey != nil {
		return utils.MarshalJSON(u.CreateDeploymentKey, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentKeyUnion: all fields are null")
}

type CreateDeploymentRouteTarget struct {
	Key CreateDeploymentKeyUnion `json:"key"`
}

func (c CreateDeploymentRouteTarget) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentRouteTarget) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"key"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentRouteTarget) GetKey() CreateDeploymentKeyUnion {
	if o == nil {
		return CreateDeploymentKeyUnion{}
	}
	return o.Key
}

type CreateDeploymentArgsType string

const (
	CreateDeploymentArgsTypeStr        CreateDeploymentArgsType = "str"
	CreateDeploymentArgsTypeArrayOfStr CreateDeploymentArgsType = "arrayOfStr"
)

type CreateDeploymentArgs struct {
	Str        *string  `queryParam:"inline"`
	ArrayOfStr []string `queryParam:"inline"`

	Type CreateDeploymentArgsType
}

func CreateCreateDeploymentArgsStr(str string) CreateDeploymentArgs {
	typ := CreateDeploymentArgsTypeStr

	return CreateDeploymentArgs{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateDeploymentArgsArrayOfStr(arrayOfStr []string) CreateDeploymentArgs {
	typ := CreateDeploymentArgsTypeArrayOfStr

	return CreateDeploymentArgs{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *CreateDeploymentArgs) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateDeploymentArgsTypeStr
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = CreateDeploymentArgsTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentArgs", string(data))
}

func (u CreateDeploymentArgs) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentArgs: all fields are null")
}

type CreateDeploymentTransform struct {
	Type   CreateDeploymentTransformType `json:"type"`
	Op     CreateDeploymentOp            `json:"op"`
	Target CreateDeploymentRouteTarget   `json:"target"`
	Args   *CreateDeploymentArgs         `json:"args,omitempty"`
}

func (c CreateDeploymentTransform) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentTransform) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "op", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentTransform) GetType() CreateDeploymentTransformType {
	if o == nil {
		return CreateDeploymentTransformType("")
	}
	return o.Type
}

func (o *CreateDeploymentTransform) GetOp() CreateDeploymentOp {
	if o == nil {
		return CreateDeploymentOp("")
	}
	return o.Op
}

func (o *CreateDeploymentTransform) GetTarget() CreateDeploymentRouteTarget {
	if o == nil {
		return CreateDeploymentRouteTarget{}
	}
	return o.Target
}

func (o *CreateDeploymentTransform) GetArgs() *CreateDeploymentArgs {
	if o == nil {
		return nil
	}
	return o.Args
}

type CreateDeploymentLocale struct {
	Redirect map[string]string `json:"redirect,omitempty"`
	Cookie   *string           `json:"cookie,omitempty"`
}

func (c CreateDeploymentLocale) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentLocale) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentLocale) GetRedirect() map[string]string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *CreateDeploymentLocale) GetCookie() *string {
	if o == nil {
		return nil
	}
	return o.Cookie
}

type CreateDeploymentRoute1 struct {
	Src           string                         `json:"src"`
	Dest          *string                        `json:"dest,omitempty"`
	Headers       map[string]string              `json:"headers,omitempty"`
	Methods       []string                       `json:"methods,omitempty"`
	Continue      *bool                          `json:"continue,omitempty"`
	Override      *bool                          `json:"override,omitempty"`
	CaseSensitive *bool                          `json:"caseSensitive,omitempty"`
	Check         *bool                          `json:"check,omitempty"`
	Important     *bool                          `json:"important,omitempty"`
	Status        *float64                       `json:"status,omitempty"`
	Has           []CreateDeploymentHasUnion     `json:"has,omitempty"`
	Missing       []CreateDeploymentMissingUnion `json:"missing,omitempty"`
	Mitigate      *CreateDeploymentMitigate      `json:"mitigate,omitempty"`
	Transforms    []CreateDeploymentTransform    `json:"transforms,omitempty"`
	Locale        *CreateDeploymentLocale        `json:"locale,omitempty"`
	// A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
	MiddlewarePath *string `json:"middlewarePath,omitempty"`
	// The original middleware matchers.
	MiddlewareRawSrc []string `json:"middlewareRawSrc,omitempty"`
	// A middleware index in the `middleware` key under the build result
	Middleware *float64 `json:"middleware,omitempty"`
}

func (c CreateDeploymentRoute1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentRoute1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"src"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentRoute1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *CreateDeploymentRoute1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *CreateDeploymentRoute1) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *CreateDeploymentRoute1) GetMethods() []string {
	if o == nil {
		return nil
	}
	return o.Methods
}

func (o *CreateDeploymentRoute1) GetContinue() *bool {
	if o == nil {
		return nil
	}
	return o.Continue
}

func (o *CreateDeploymentRoute1) GetOverride() *bool {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *CreateDeploymentRoute1) GetCaseSensitive() *bool {
	if o == nil {
		return nil
	}
	return o.CaseSensitive
}

func (o *CreateDeploymentRoute1) GetCheck() *bool {
	if o == nil {
		return nil
	}
	return o.Check
}

func (o *CreateDeploymentRoute1) GetImportant() *bool {
	if o == nil {
		return nil
	}
	return o.Important
}

func (o *CreateDeploymentRoute1) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *CreateDeploymentRoute1) GetHas() []CreateDeploymentHasUnion {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *CreateDeploymentRoute1) GetMissing() []CreateDeploymentMissingUnion {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *CreateDeploymentRoute1) GetMitigate() *CreateDeploymentMitigate {
	if o == nil {
		return nil
	}
	return o.Mitigate
}

func (o *CreateDeploymentRoute1) GetTransforms() []CreateDeploymentTransform {
	if o == nil {
		return nil
	}
	return o.Transforms
}

func (o *CreateDeploymentRoute1) GetLocale() *CreateDeploymentLocale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *CreateDeploymentRoute1) GetMiddlewarePath() *string {
	if o == nil {
		return nil
	}
	return o.MiddlewarePath
}

func (o *CreateDeploymentRoute1) GetMiddlewareRawSrc() []string {
	if o == nil {
		return nil
	}
	return o.MiddlewareRawSrc
}

func (o *CreateDeploymentRoute1) GetMiddleware() *float64 {
	if o == nil {
		return nil
	}
	return o.Middleware
}

type CreateDeploymentRouteUnionType string

const (
	CreateDeploymentRouteUnionTypeCreateDeploymentRoute1 CreateDeploymentRouteUnionType = "createDeployment_route_1"
	CreateDeploymentRouteUnionTypeCreateDeploymentRoute2 CreateDeploymentRouteUnionType = "createDeployment_route_2"
	CreateDeploymentRouteUnionTypeCreateDeploymentRoute3 CreateDeploymentRouteUnionType = "createDeployment_route_3"
)

type CreateDeploymentRouteUnion struct {
	CreateDeploymentRoute1 *CreateDeploymentRoute1 `queryParam:"inline"`
	CreateDeploymentRoute2 *CreateDeploymentRoute2 `queryParam:"inline"`
	CreateDeploymentRoute3 *CreateDeploymentRoute3 `queryParam:"inline"`

	Type CreateDeploymentRouteUnionType
}

func CreateCreateDeploymentRouteUnionCreateDeploymentRoute1(createDeploymentRoute1 CreateDeploymentRoute1) CreateDeploymentRouteUnion {
	typ := CreateDeploymentRouteUnionTypeCreateDeploymentRoute1

	return CreateDeploymentRouteUnion{
		CreateDeploymentRoute1: &createDeploymentRoute1,
		Type:                   typ,
	}
}

func CreateCreateDeploymentRouteUnionCreateDeploymentRoute2(createDeploymentRoute2 CreateDeploymentRoute2) CreateDeploymentRouteUnion {
	typ := CreateDeploymentRouteUnionTypeCreateDeploymentRoute2

	return CreateDeploymentRouteUnion{
		CreateDeploymentRoute2: &createDeploymentRoute2,
		Type:                   typ,
	}
}

func CreateCreateDeploymentRouteUnionCreateDeploymentRoute3(createDeploymentRoute3 CreateDeploymentRoute3) CreateDeploymentRouteUnion {
	typ := CreateDeploymentRouteUnionTypeCreateDeploymentRoute3

	return CreateDeploymentRouteUnion{
		CreateDeploymentRoute3: &createDeploymentRoute3,
		Type:                   typ,
	}
}

func (u *CreateDeploymentRouteUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentRoute3 CreateDeploymentRoute3 = CreateDeploymentRoute3{}
	if err := utils.UnmarshalJSON(data, &createDeploymentRoute3, "", true, nil); err == nil {
		u.CreateDeploymentRoute3 = &createDeploymentRoute3
		u.Type = CreateDeploymentRouteUnionTypeCreateDeploymentRoute3
		return nil
	}

	var createDeploymentRoute1 CreateDeploymentRoute1 = CreateDeploymentRoute1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentRoute1, "", true, nil); err == nil {
		u.CreateDeploymentRoute1 = &createDeploymentRoute1
		u.Type = CreateDeploymentRouteUnionTypeCreateDeploymentRoute1
		return nil
	}

	var createDeploymentRoute2 CreateDeploymentRoute2 = CreateDeploymentRoute2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentRoute2, "", true, nil); err == nil {
		u.CreateDeploymentRoute2 = &createDeploymentRoute2
		u.Type = CreateDeploymentRouteUnionTypeCreateDeploymentRoute2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentRouteUnion", string(data))
}

func (u CreateDeploymentRouteUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentRoute1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentRoute1, "", true)
	}

	if u.CreateDeploymentRoute2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentRoute2, "", true)
	}

	if u.CreateDeploymentRoute3 != nil {
		return utils.MarshalJSON(u.CreateDeploymentRoute3, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentRouteUnion: all fields are null")
}

type CreateDeploymentGitRepoTypeBitbucket string

const (
	CreateDeploymentGitRepoTypeBitbucketBitbucket CreateDeploymentGitRepoTypeBitbucket = "bitbucket"
)

func (e CreateDeploymentGitRepoTypeBitbucket) ToPointer() *CreateDeploymentGitRepoTypeBitbucket {
	return &e
}
func (e *CreateDeploymentGitRepoTypeBitbucket) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = CreateDeploymentGitRepoTypeBitbucket(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoTypeBitbucket: %v", v)
	}
}

type CreateDeploymentOwnerType3 string

const (
	CreateDeploymentOwnerType3Team CreateDeploymentOwnerType3 = "team"
	CreateDeploymentOwnerType3User CreateDeploymentOwnerType3 = "user"
)

func (e CreateDeploymentOwnerType3) ToPointer() *CreateDeploymentOwnerType3 {
	return &e
}
func (e *CreateDeploymentOwnerType3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = CreateDeploymentOwnerType3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentOwnerType3: %v", v)
	}
}

type CreateDeploymentGitRepoBitbucket struct {
	Owner         string                               `json:"owner"`
	RepoUUID      string                               `json:"repoUuid"`
	Slug          string                               `json:"slug"`
	Type          CreateDeploymentGitRepoTypeBitbucket `json:"type"`
	WorkspaceUUID string                               `json:"workspaceUuid"`
	Path          string                               `json:"path"`
	DefaultBranch string                               `json:"defaultBranch"`
	Name          string                               `json:"name"`
	Private       bool                                 `json:"private"`
	OwnerType     CreateDeploymentOwnerType3           `json:"ownerType"`
}

func (c CreateDeploymentGitRepoBitbucket) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitRepoBitbucket) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"owner", "repoUuid", "slug", "type", "workspaceUuid", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitRepoBitbucket) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *CreateDeploymentGitRepoBitbucket) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *CreateDeploymentGitRepoBitbucket) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateDeploymentGitRepoBitbucket) GetType() CreateDeploymentGitRepoTypeBitbucket {
	if o == nil {
		return CreateDeploymentGitRepoTypeBitbucket("")
	}
	return o.Type
}

func (o *CreateDeploymentGitRepoBitbucket) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *CreateDeploymentGitRepoBitbucket) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentGitRepoBitbucket) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *CreateDeploymentGitRepoBitbucket) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentGitRepoBitbucket) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *CreateDeploymentGitRepoBitbucket) GetOwnerType() CreateDeploymentOwnerType3 {
	if o == nil {
		return CreateDeploymentOwnerType3("")
	}
	return o.OwnerType
}

type CreateDeploymentGitRepoTypeGithub string

const (
	CreateDeploymentGitRepoTypeGithubGithub CreateDeploymentGitRepoTypeGithub = "github"
)

func (e CreateDeploymentGitRepoTypeGithub) ToPointer() *CreateDeploymentGitRepoTypeGithub {
	return &e
}
func (e *CreateDeploymentGitRepoTypeGithub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = CreateDeploymentGitRepoTypeGithub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoTypeGithub: %v", v)
	}
}

type CreateDeploymentOwnerType2 string

const (
	CreateDeploymentOwnerType2Team CreateDeploymentOwnerType2 = "team"
	CreateDeploymentOwnerType2User CreateDeploymentOwnerType2 = "user"
)

func (e CreateDeploymentOwnerType2) ToPointer() *CreateDeploymentOwnerType2 {
	return &e
}
func (e *CreateDeploymentOwnerType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = CreateDeploymentOwnerType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentOwnerType2: %v", v)
	}
}

type CreateDeploymentGitRepoGithub struct {
	Org           string                            `json:"org"`
	Repo          string                            `json:"repo"`
	RepoID        float64                           `json:"repoId"`
	Type          CreateDeploymentGitRepoTypeGithub `json:"type"`
	RepoOwnerID   float64                           `json:"repoOwnerId"`
	Path          string                            `json:"path"`
	DefaultBranch string                            `json:"defaultBranch"`
	Name          string                            `json:"name"`
	Private       bool                              `json:"private"`
	OwnerType     CreateDeploymentOwnerType2        `json:"ownerType"`
}

func (c CreateDeploymentGitRepoGithub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitRepoGithub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"org", "repo", "repoId", "type", "repoOwnerId", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitRepoGithub) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *CreateDeploymentGitRepoGithub) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *CreateDeploymentGitRepoGithub) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *CreateDeploymentGitRepoGithub) GetType() CreateDeploymentGitRepoTypeGithub {
	if o == nil {
		return CreateDeploymentGitRepoTypeGithub("")
	}
	return o.Type
}

func (o *CreateDeploymentGitRepoGithub) GetRepoOwnerID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoOwnerID
}

func (o *CreateDeploymentGitRepoGithub) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentGitRepoGithub) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *CreateDeploymentGitRepoGithub) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentGitRepoGithub) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *CreateDeploymentGitRepoGithub) GetOwnerType() CreateDeploymentOwnerType2 {
	if o == nil {
		return CreateDeploymentOwnerType2("")
	}
	return o.OwnerType
}

type CreateDeploymentGitRepoTypeGitlab string

const (
	CreateDeploymentGitRepoTypeGitlabGitlab CreateDeploymentGitRepoTypeGitlab = "gitlab"
)

func (e CreateDeploymentGitRepoTypeGitlab) ToPointer() *CreateDeploymentGitRepoTypeGitlab {
	return &e
}
func (e *CreateDeploymentGitRepoTypeGitlab) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = CreateDeploymentGitRepoTypeGitlab(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentGitRepoTypeGitlab: %v", v)
	}
}

type CreateDeploymentOwnerType1 string

const (
	CreateDeploymentOwnerType1Team CreateDeploymentOwnerType1 = "team"
	CreateDeploymentOwnerType1User CreateDeploymentOwnerType1 = "user"
)

func (e CreateDeploymentOwnerType1) ToPointer() *CreateDeploymentOwnerType1 {
	return &e
}
func (e *CreateDeploymentOwnerType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = CreateDeploymentOwnerType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentOwnerType1: %v", v)
	}
}

type CreateDeploymentGitRepoGitlab struct {
	Namespace     string                            `json:"namespace"`
	ProjectID     float64                           `json:"projectId"`
	Type          CreateDeploymentGitRepoTypeGitlab `json:"type"`
	URL           string                            `json:"url"`
	Path          string                            `json:"path"`
	DefaultBranch string                            `json:"defaultBranch"`
	Name          string                            `json:"name"`
	Private       bool                              `json:"private"`
	OwnerType     CreateDeploymentOwnerType1        `json:"ownerType"`
}

func (c CreateDeploymentGitRepoGitlab) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentGitRepoGitlab) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"namespace", "projectId", "type", "url", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentGitRepoGitlab) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *CreateDeploymentGitRepoGitlab) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

func (o *CreateDeploymentGitRepoGitlab) GetType() CreateDeploymentGitRepoTypeGitlab {
	if o == nil {
		return CreateDeploymentGitRepoTypeGitlab("")
	}
	return o.Type
}

func (o *CreateDeploymentGitRepoGitlab) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *CreateDeploymentGitRepoGitlab) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *CreateDeploymentGitRepoGitlab) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *CreateDeploymentGitRepoGitlab) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentGitRepoGitlab) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *CreateDeploymentGitRepoGitlab) GetOwnerType() CreateDeploymentOwnerType1 {
	if o == nil {
		return CreateDeploymentOwnerType1("")
	}
	return o.OwnerType
}

type CreateDeploymentGitRepoUnionType string

const (
	CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGitlab    CreateDeploymentGitRepoUnionType = "createDeployment_gitRepo_Gitlab"
	CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGithub    CreateDeploymentGitRepoUnionType = "createDeployment_gitRepo_Github"
	CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoBitbucket CreateDeploymentGitRepoUnionType = "createDeployment_gitRepo_Bitbucket"
)

type CreateDeploymentGitRepoUnion struct {
	CreateDeploymentGitRepoGitlab    *CreateDeploymentGitRepoGitlab    `queryParam:"inline"`
	CreateDeploymentGitRepoGithub    *CreateDeploymentGitRepoGithub    `queryParam:"inline"`
	CreateDeploymentGitRepoBitbucket *CreateDeploymentGitRepoBitbucket `queryParam:"inline"`

	Type CreateDeploymentGitRepoUnionType
}

func CreateCreateDeploymentGitRepoUnionCreateDeploymentGitRepoGitlab(createDeploymentGitRepoGitlab CreateDeploymentGitRepoGitlab) CreateDeploymentGitRepoUnion {
	typ := CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGitlab

	return CreateDeploymentGitRepoUnion{
		CreateDeploymentGitRepoGitlab: &createDeploymentGitRepoGitlab,
		Type:                          typ,
	}
}

func CreateCreateDeploymentGitRepoUnionCreateDeploymentGitRepoGithub(createDeploymentGitRepoGithub CreateDeploymentGitRepoGithub) CreateDeploymentGitRepoUnion {
	typ := CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGithub

	return CreateDeploymentGitRepoUnion{
		CreateDeploymentGitRepoGithub: &createDeploymentGitRepoGithub,
		Type:                          typ,
	}
}

func CreateCreateDeploymentGitRepoUnionCreateDeploymentGitRepoBitbucket(createDeploymentGitRepoBitbucket CreateDeploymentGitRepoBitbucket) CreateDeploymentGitRepoUnion {
	typ := CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoBitbucket

	return CreateDeploymentGitRepoUnion{
		CreateDeploymentGitRepoBitbucket: &createDeploymentGitRepoBitbucket,
		Type:                             typ,
	}
}

func (u *CreateDeploymentGitRepoUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentGitRepoGithub CreateDeploymentGitRepoGithub = CreateDeploymentGitRepoGithub{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitRepoGithub, "", true, nil); err == nil {
		u.CreateDeploymentGitRepoGithub = &createDeploymentGitRepoGithub
		u.Type = CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGithub
		return nil
	}

	var createDeploymentGitRepoBitbucket CreateDeploymentGitRepoBitbucket = CreateDeploymentGitRepoBitbucket{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitRepoBitbucket, "", true, nil); err == nil {
		u.CreateDeploymentGitRepoBitbucket = &createDeploymentGitRepoBitbucket
		u.Type = CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoBitbucket
		return nil
	}

	var createDeploymentGitRepoGitlab CreateDeploymentGitRepoGitlab = CreateDeploymentGitRepoGitlab{}
	if err := utils.UnmarshalJSON(data, &createDeploymentGitRepoGitlab, "", true, nil); err == nil {
		u.CreateDeploymentGitRepoGitlab = &createDeploymentGitRepoGitlab
		u.Type = CreateDeploymentGitRepoUnionTypeCreateDeploymentGitRepoGitlab
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentGitRepoUnion", string(data))
}

func (u CreateDeploymentGitRepoUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentGitRepoGitlab != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitRepoGitlab, "", true)
	}

	if u.CreateDeploymentGitRepoGithub != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitRepoGithub, "", true)
	}

	if u.CreateDeploymentGitRepoBitbucket != nil {
		return utils.MarshalJSON(u.CreateDeploymentGitRepoBitbucket, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentGitRepoUnion: all fields are null")
}

// CreateDeploymentFlags2 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type CreateDeploymentFlags2 struct {
}

func (c CreateDeploymentFlags2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentFlags2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

type CreateDeploymentOption struct {
	Value *components.FlagJSONValue `json:"value"`
	Label *string                   `json:"label,omitempty"`
}

func (c CreateDeploymentOption) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentOption) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentOption) GetValue() *components.FlagJSONValue {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *CreateDeploymentOption) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

type CreateDeploymentDefinitions struct {
	Options     []CreateDeploymentOption `json:"options,omitempty"`
	URL         *string                  `json:"url,omitempty"`
	Description *string                  `json:"description,omitempty"`
}

func (c CreateDeploymentDefinitions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentDefinitions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentDefinitions) GetOptions() []CreateDeploymentOption {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *CreateDeploymentDefinitions) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *CreateDeploymentDefinitions) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// CreateDeploymentFlags1 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type CreateDeploymentFlags1 struct {
	Definitions map[string]CreateDeploymentDefinitions `json:"definitions"`
}

func (c CreateDeploymentFlags1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentFlags1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"definitions"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentFlags1) GetDefinitions() map[string]CreateDeploymentDefinitions {
	if o == nil {
		return map[string]CreateDeploymentDefinitions{}
	}
	return o.Definitions
}

type CreateDeploymentFlagsUnionType string

const (
	CreateDeploymentFlagsUnionTypeCreateDeploymentFlags1        CreateDeploymentFlagsUnionType = "createDeployment_flags_1"
	CreateDeploymentFlagsUnionTypeArrayOfCreateDeploymentFlags2 CreateDeploymentFlagsUnionType = "arrayOfCreateDeploymentFlags2"
)

type CreateDeploymentFlagsUnion struct {
	CreateDeploymentFlags1        *CreateDeploymentFlags1  `queryParam:"inline"`
	ArrayOfCreateDeploymentFlags2 []CreateDeploymentFlags2 `queryParam:"inline"`

	Type CreateDeploymentFlagsUnionType
}

func CreateCreateDeploymentFlagsUnionCreateDeploymentFlags1(createDeploymentFlags1 CreateDeploymentFlags1) CreateDeploymentFlagsUnion {
	typ := CreateDeploymentFlagsUnionTypeCreateDeploymentFlags1

	return CreateDeploymentFlagsUnion{
		CreateDeploymentFlags1: &createDeploymentFlags1,
		Type:                   typ,
	}
}

func CreateCreateDeploymentFlagsUnionArrayOfCreateDeploymentFlags2(arrayOfCreateDeploymentFlags2 []CreateDeploymentFlags2) CreateDeploymentFlagsUnion {
	typ := CreateDeploymentFlagsUnionTypeArrayOfCreateDeploymentFlags2

	return CreateDeploymentFlagsUnion{
		ArrayOfCreateDeploymentFlags2: arrayOfCreateDeploymentFlags2,
		Type:                          typ,
	}
}

func (u *CreateDeploymentFlagsUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentFlags1 CreateDeploymentFlags1 = CreateDeploymentFlags1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentFlags1, "", true, nil); err == nil {
		u.CreateDeploymentFlags1 = &createDeploymentFlags1
		u.Type = CreateDeploymentFlagsUnionTypeCreateDeploymentFlags1
		return nil
	}

	var arrayOfCreateDeploymentFlags2 []CreateDeploymentFlags2 = []CreateDeploymentFlags2{}
	if err := utils.UnmarshalJSON(data, &arrayOfCreateDeploymentFlags2, "", true, nil); err == nil {
		u.ArrayOfCreateDeploymentFlags2 = arrayOfCreateDeploymentFlags2
		u.Type = CreateDeploymentFlagsUnionTypeArrayOfCreateDeploymentFlags2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentFlagsUnion", string(data))
}

func (u CreateDeploymentFlagsUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentFlags1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentFlags1, "", true)
	}

	if u.ArrayOfCreateDeploymentFlags2 != nil {
		return utils.MarshalJSON(u.ArrayOfCreateDeploymentFlags2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentFlagsUnion: all fields are null")
}

// CreateDeploymentApplications - A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment. Note: this field will be removed when MFE alias routing is fully rolled out.
type CreateDeploymentApplications struct {
	IsDefaultApp *bool `json:"isDefaultApp,omitempty"`
	// This is the production alias, it will always show the most up to date of each application.
	ProductionHost string `json:"productionHost"`
	// Use the fixed deploymentAlias and deploymentHost so that the microfrontend preview stays in sync with the deployment. These are only present for mono-repos when a single commit creates multiple deployments. If they are not present, productionHost will be used.
	DeploymentAlias *string `json:"deploymentAlias,omitempty"`
	DeploymentHost  *string `json:"deploymentHost,omitempty"`
}

func (c CreateDeploymentApplications) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentApplications) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"productionHost"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentApplications) GetIsDefaultApp() *bool {
	if o == nil {
		return nil
	}
	return o.IsDefaultApp
}

func (o *CreateDeploymentApplications) GetProductionHost() string {
	if o == nil {
		return ""
	}
	return o.ProductionHost
}

func (o *CreateDeploymentApplications) GetDeploymentAlias() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentAlias
}

func (o *CreateDeploymentApplications) GetDeploymentHost() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentHost
}

// CreateDeploymentMfeConfigUploadState - The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
type CreateDeploymentMfeConfigUploadState string

const (
	CreateDeploymentMfeConfigUploadStateSuccess        CreateDeploymentMfeConfigUploadState = "success"
	CreateDeploymentMfeConfigUploadStateWaitingOnBuild CreateDeploymentMfeConfigUploadState = "waiting_on_build"
	CreateDeploymentMfeConfigUploadStateNoConfig       CreateDeploymentMfeConfigUploadState = "no_config"
)

func (e CreateDeploymentMfeConfigUploadState) ToPointer() *CreateDeploymentMfeConfigUploadState {
	return &e
}
func (e *CreateDeploymentMfeConfigUploadState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "waiting_on_build":
		fallthrough
	case "no_config":
		*e = CreateDeploymentMfeConfigUploadState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentMfeConfigUploadState: %v", v)
	}
}

type CreateDeploymentMicrofrontends2 struct {
	IsDefaultApp bool `json:"isDefaultApp"`
	// A map of the other applications that are part of this group. Only defined on the default application. The field is set after deployments have been created, so can be undefined, but should be there for a successful deployment. Note: this field will be removed when MFE alias routing is fully rolled out.
	Applications map[string]CreateDeploymentApplications `json:"applications,omitempty"`
	// The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
	MfeConfigUploadState *CreateDeploymentMfeConfigUploadState `json:"mfeConfigUploadState,omitempty"`
	// The project name of the default app of this deployment's microfrontends group.
	DefaultAppProjectName string `json:"defaultAppProjectName"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
	// Whether the MicrofrontendsAlias2 team flag should be considered enabled for this deployment or not.
	MicrofrontendsAlias2Enabled *bool `json:"microfrontendsAlias2Enabled,omitempty"`
}

func (c CreateDeploymentMicrofrontends2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMicrofrontends2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"isDefaultApp", "defaultAppProjectName", "groupIds"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMicrofrontends2) GetIsDefaultApp() bool {
	if o == nil {
		return false
	}
	return o.IsDefaultApp
}

func (o *CreateDeploymentMicrofrontends2) GetApplications() map[string]CreateDeploymentApplications {
	if o == nil {
		return nil
	}
	return o.Applications
}

func (o *CreateDeploymentMicrofrontends2) GetMfeConfigUploadState() *CreateDeploymentMfeConfigUploadState {
	if o == nil {
		return nil
	}
	return o.MfeConfigUploadState
}

func (o *CreateDeploymentMicrofrontends2) GetDefaultAppProjectName() string {
	if o == nil {
		return ""
	}
	return o.DefaultAppProjectName
}

func (o *CreateDeploymentMicrofrontends2) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *CreateDeploymentMicrofrontends2) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

func (o *CreateDeploymentMicrofrontends2) GetMicrofrontendsAlias2Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.MicrofrontendsAlias2Enabled
}

type CreateDeploymentMicrofrontends1 struct {
	IsDefaultApp *bool `json:"isDefaultApp,omitempty"`
	// The project name of the default app of this deployment's microfrontends group.
	DefaultAppProjectName string `json:"defaultAppProjectName"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
	// Whether the MicrofrontendsAlias2 team flag should be considered enabled for this deployment or not.
	MicrofrontendsAlias2Enabled *bool `json:"microfrontendsAlias2Enabled,omitempty"`
}

func (c CreateDeploymentMicrofrontends1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateDeploymentMicrofrontends1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"defaultAppProjectName", "groupIds"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateDeploymentMicrofrontends1) GetIsDefaultApp() *bool {
	if o == nil {
		return nil
	}
	return o.IsDefaultApp
}

func (o *CreateDeploymentMicrofrontends1) GetDefaultAppProjectName() string {
	if o == nil {
		return ""
	}
	return o.DefaultAppProjectName
}

func (o *CreateDeploymentMicrofrontends1) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *CreateDeploymentMicrofrontends1) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

func (o *CreateDeploymentMicrofrontends1) GetMicrofrontendsAlias2Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.MicrofrontendsAlias2Enabled
}

type CreateDeploymentMicrofrontendsUnionType string

const (
	CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends1 CreateDeploymentMicrofrontendsUnionType = "createDeployment_microfrontends_1"
	CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends2 CreateDeploymentMicrofrontendsUnionType = "createDeployment_microfrontends_2"
)

type CreateDeploymentMicrofrontendsUnion struct {
	CreateDeploymentMicrofrontends1 *CreateDeploymentMicrofrontends1 `queryParam:"inline"`
	CreateDeploymentMicrofrontends2 *CreateDeploymentMicrofrontends2 `queryParam:"inline"`

	Type CreateDeploymentMicrofrontendsUnionType
}

func CreateCreateDeploymentMicrofrontendsUnionCreateDeploymentMicrofrontends1(createDeploymentMicrofrontends1 CreateDeploymentMicrofrontends1) CreateDeploymentMicrofrontendsUnion {
	typ := CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends1

	return CreateDeploymentMicrofrontendsUnion{
		CreateDeploymentMicrofrontends1: &createDeploymentMicrofrontends1,
		Type:                            typ,
	}
}

func CreateCreateDeploymentMicrofrontendsUnionCreateDeploymentMicrofrontends2(createDeploymentMicrofrontends2 CreateDeploymentMicrofrontends2) CreateDeploymentMicrofrontendsUnion {
	typ := CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends2

	return CreateDeploymentMicrofrontendsUnion{
		CreateDeploymentMicrofrontends2: &createDeploymentMicrofrontends2,
		Type:                            typ,
	}
}

func (u *CreateDeploymentMicrofrontendsUnion) UnmarshalJSON(data []byte) error {

	var createDeploymentMicrofrontends2 CreateDeploymentMicrofrontends2 = CreateDeploymentMicrofrontends2{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMicrofrontends2, "", true, nil); err == nil {
		u.CreateDeploymentMicrofrontends2 = &createDeploymentMicrofrontends2
		u.Type = CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends2
		return nil
	}

	var createDeploymentMicrofrontends1 CreateDeploymentMicrofrontends1 = CreateDeploymentMicrofrontends1{}
	if err := utils.UnmarshalJSON(data, &createDeploymentMicrofrontends1, "", true, nil); err == nil {
		u.CreateDeploymentMicrofrontends1 = &createDeploymentMicrofrontends1
		u.Type = CreateDeploymentMicrofrontendsUnionTypeCreateDeploymentMicrofrontends1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateDeploymentMicrofrontendsUnion", string(data))
}

func (u CreateDeploymentMicrofrontendsUnion) MarshalJSON() ([]byte, error) {
	if u.CreateDeploymentMicrofrontends1 != nil {
		return utils.MarshalJSON(u.CreateDeploymentMicrofrontends1, "", true)
	}

	if u.CreateDeploymentMicrofrontends2 != nil {
		return utils.MarshalJSON(u.CreateDeploymentMicrofrontends2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateDeploymentMicrofrontendsUnion: all fields are null")
}

type CreateDeploymentFunctionType string

const (
	CreateDeploymentFunctionTypeFluid    CreateDeploymentFunctionType = "fluid"
	CreateDeploymentFunctionTypeStandard CreateDeploymentFunctionType = "standard"
)

func (e CreateDeploymentFunctionType) ToPointer() *CreateDeploymentFunctionType {
	return &e
}
func (e *CreateDeploymentFunctionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fluid":
		fallthrough
	case "standard":
		*e = CreateDeploymentFunctionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFunctionType: %v", v)
	}
}

type CreateDeploymentFunctionMemoryType string

const (
	CreateDeploymentFunctionMemoryTypeStandard       CreateDeploymentFunctionMemoryType = "standard"
	CreateDeploymentFunctionMemoryTypeStandardLegacy CreateDeploymentFunctionMemoryType = "standard_legacy"
	CreateDeploymentFunctionMemoryTypePerformance    CreateDeploymentFunctionMemoryType = "performance"
)

func (e CreateDeploymentFunctionMemoryType) ToPointer() *CreateDeploymentFunctionMemoryType {
	return &e
}
func (e *CreateDeploymentFunctionMemoryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "standard_legacy":
		fallthrough
	case "performance":
		*e = CreateDeploymentFunctionMemoryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentFunctionMemoryType: %v", v)
	}
}

// CreateDeploymentConfig - Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
type CreateDeploymentConfig struct {
	Version                     *float64                           `json:"version,omitempty"`
	FunctionType                CreateDeploymentFunctionType       `json:"functionType"`
	FunctionMemoryType          CreateDeploymentFunctionMemoryType `json:"functionMemoryType"`
	FunctionTimeout             *float64                           `json:"functionTimeout"`
	SecureComputePrimaryRegion  *string                            `json:"secureComputePrimaryRegion"`
	SecureComputeFallbackRegion *string                            `json:"secureComputeFallbackRegion"`
	IsUsingActiveCPU            *bool                              `json:"isUsingActiveCPU,omitempty"`
}

func (o *CreateDeploymentConfig) GetVersion() *float64 {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *CreateDeploymentConfig) GetFunctionType() CreateDeploymentFunctionType {
	if o == nil {
		return CreateDeploymentFunctionType("")
	}
	return o.FunctionType
}

func (o *CreateDeploymentConfig) GetFunctionMemoryType() CreateDeploymentFunctionMemoryType {
	if o == nil {
		return CreateDeploymentFunctionMemoryType("")
	}
	return o.FunctionMemoryType
}

func (o *CreateDeploymentConfig) GetFunctionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.FunctionTimeout
}

func (o *CreateDeploymentConfig) GetSecureComputePrimaryRegion() *string {
	if o == nil {
		return nil
	}
	return o.SecureComputePrimaryRegion
}

func (o *CreateDeploymentConfig) GetSecureComputeFallbackRegion() *string {
	if o == nil {
		return nil
	}
	return o.SecureComputeFallbackRegion
}

func (o *CreateDeploymentConfig) GetIsUsingActiveCPU() *bool {
	if o == nil {
		return nil
	}
	return o.IsUsingActiveCPU
}

type CreateDeploymentState string

const (
	CreateDeploymentStateSucceeded CreateDeploymentState = "succeeded"
	CreateDeploymentStateFailed    CreateDeploymentState = "failed"
	CreateDeploymentStatePending   CreateDeploymentState = "pending"
)

func (e CreateDeploymentState) ToPointer() *CreateDeploymentState {
	return &e
}
func (e *CreateDeploymentState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "succeeded":
		fallthrough
	case "failed":
		fallthrough
	case "pending":
		*e = CreateDeploymentState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateDeploymentState: %v", v)
	}
}

// CreateDeploymentDeploymentAlias - Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
type CreateDeploymentDeploymentAlias struct {
	State       CreateDeploymentState `json:"state"`
	StartedAt   float64               `json:"startedAt"`
	CompletedAt *float64              `json:"completedAt,omitempty"`
}

func (o *CreateDeploymentDeploymentAlias) GetState() CreateDeploymentState {
	if o == nil {
		return CreateDeploymentState("")
	}
	return o.State
}

func (o *CreateDeploymentDeploymentAlias) GetStartedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.StartedAt
}

func (o *CreateDeploymentDeploymentAlias) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

type CreateDeploymentChecks struct {
	// Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
	DeploymentAlias CreateDeploymentDeploymentAlias `json:"deployment-alias"`
}

func (o *CreateDeploymentChecks) GetDeploymentAlias() CreateDeploymentDeploymentAlias {
	if o == nil {
		return CreateDeploymentDeploymentAlias{}
	}
	return o.DeploymentAlias
}

// CreateDeploymentResponseBody - The successfully created deployment
type CreateDeploymentResponseBody struct {
	AliasAssignedAt           *CreateDeploymentAliasAssignedAt       `json:"aliasAssignedAt,omitempty"`
	AlwaysRefuseToBuild       *bool                                  `json:"alwaysRefuseToBuild,omitempty"`
	Build                     CreateDeploymentBuild1                 `json:"build"`
	BuildArtifactUrls         []string                               `json:"buildArtifactUrls,omitempty"`
	Builds                    []CreateDeploymentBuild2               `json:"builds,omitempty"`
	Env                       []string                               `json:"env"`
	InspectorURL              *string                                `json:"inspectorUrl"`
	IsInConcurrentBuildsQueue bool                                   `json:"isInConcurrentBuildsQueue"`
	IsInSystemBuildsQueue     bool                                   `json:"isInSystemBuildsQueue"`
	ProjectSettings           CreateDeploymentProjectSettingsLambdas `json:"projectSettings"`
	ReadyStateReason          *string                                `json:"readyStateReason,omitempty"`
	Integrations              *CreateDeploymentIntegrations          `json:"integrations,omitempty"`
	Images                    *CreateDeploymentImages                `json:"images,omitempty"`
	// A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
	Alias []string `json:"alias,omitempty"`
	// A boolean that will be true when the aliases from the alias property were assigned successfully
	AliasAssigned bool    `json:"aliasAssigned"`
	BootedAt      float64 `json:"bootedAt"`
	BuildingAt    float64 `json:"buildingAt"`
	// Since April 2025 it necessary for On-Demand Concurrency Minutes calculation
	BuildContainerFinishedAt *float64 `json:"buildContainerFinishedAt,omitempty"`
	BuildSkipped             bool     `json:"buildSkipped"`
	// Information about the deployment creator
	Creator                 CreateDeploymentCreator  `json:"creator"`
	InitReadyAt             *float64                 `json:"initReadyAt,omitempty"`
	IsFirstBranchDeployment *bool                    `json:"isFirstBranchDeployment,omitempty"`
	Lambdas                 []CreateDeploymentLambda `json:"lambdas,omitempty"`
	// A boolean representing if the deployment is public or not. By default this is `false`
	Public bool                   `json:"public"`
	Ready  *float64               `json:"ready,omitempty"`
	Status CreateDeploymentStatus `json:"status"`
	// The team that owns the deployment if any
	Team *CreateDeploymentTeam `json:"team,omitempty"`
	// An array of domains that were provided by the user when creating the Deployment.
	UserAliases []string `json:"userAliases,omitempty"`
	// Whether or not preview comments are enabled for the deployment
	PreviewCommentsEnabled *bool                                   `json:"previewCommentsEnabled,omitempty"`
	TtyBuildLogs           *bool                                   `json:"ttyBuildLogs,omitempty"`
	CustomEnvironment      *CreateDeploymentCustomEnvironmentUnion `json:"customEnvironment,omitempty"`
	OomReport              *CreateDeploymentOomReport              `json:"oomReport,omitempty"`
	AliasWarning           *CreateDeploymentAliasWarning           `json:"aliasWarning,omitempty"`
	// A string holding the unique ID of the deployment
	ID string `json:"id"`
	// A number containing the date when the deployment was created in milliseconds
	CreatedAt float64 `json:"createdAt"`
	// The state of the deployment depending on the process of deploying, or if it is ready or in an error state
	ReadyState CreateDeploymentReadyState `json:"readyState"`
	// The name of the project associated with the deployment at the time that the deployment was created
	Name string                      `json:"name"`
	Type CreateDeploymentTypeLambdas `json:"type"`
	// An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
	AliasError *CreateDeploymentAliasError `json:"aliasError,omitempty"`
	AliasFinal *string                     `json:"aliasFinal,omitempty"`
	// applies to custom domains only, defaults to `true`
	AutoAssignCustomDomains *bool                             `json:"autoAssignCustomDomains,omitempty"`
	AutomaticAliases        []string                          `json:"automaticAliases,omitempty"`
	BuildErrorAt            *float64                          `json:"buildErrorAt,omitempty"`
	ChecksState             *CreateDeploymentChecksState      `json:"checksState,omitempty"`
	ChecksConclusion        *CreateDeploymentChecksConclusion `json:"checksConclusion,omitempty"`
	// A number containing the date when the deployment was deleted at milliseconds
	DeletedAt *float64 `json:"deletedAt,omitempty"`
	// Computed field that is only available for deployments with a microfrontend configuration.
	DefaultRoute *string  `json:"defaultRoute,omitempty"`
	CanceledAt   *float64 `json:"canceledAt,omitempty"`
	ErrorCode    *string  `json:"errorCode,omitempty"`
	ErrorLink    *string  `json:"errorLink,omitempty"`
	ErrorMessage *string  `json:"errorMessage,omitempty"`
	ErrorStep    *string  `json:"errorStep,omitempty"`
	// Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
	PassiveRegions    []string                               `json:"passiveRegions,omitempty"`
	GitSource         *CreateDeploymentGitSourceLambdasUnion `json:"gitSource,omitempty"`
	Meta              map[string]string                      `json:"meta"`
	OriginCacheRegion *string                                `json:"originCacheRegion,omitempty"`
	// If set it overrides the `projectSettings.nodeVersion` for this deployment.
	NodeVersion *CreateDeploymentNodeVersionLambdas `json:"nodeVersion,omitempty"`
	// The public project information associated with the deployment.
	Project *CreateDeploymentProject `json:"project,omitempty"`
	// Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
	ReadySubstate *CreateDeploymentReadySubstate `json:"readySubstate,omitempty"`
	// The regions the deployment exists in
	Regions []string `json:"regions"`
	// flag to indicate if the deployment was deleted by retention policy
	SoftDeletedByRetention *bool `json:"softDeletedByRetention,omitempty"`
	// Where was the deployment created from
	Source *CreateDeploymentSource `json:"source,omitempty"`
	// If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
	Target *CreateDeploymentTargetEnum `json:"target,omitempty"`
	// A number containing the date when the deployment was undeleted at milliseconds
	UndeletedAt *float64 `json:"undeletedAt,omitempty"`
	// A string with the unique URL of the deployment
	URL string `json:"url"`
	// The platform version that was used to create the deployment.
	Version                float64                              `json:"version"`
	OidcTokenClaims        *CreateDeploymentOidcTokenClaims     `json:"oidcTokenClaims,omitempty"`
	ProjectID              string                               `json:"projectId"`
	Plan                   CreateDeploymentPlan                 `json:"plan"`
	ConnectBuildsEnabled   *bool                                `json:"connectBuildsEnabled,omitempty"`
	ConnectConfigurationID *string                              `json:"connectConfigurationId,omitempty"`
	CreatedIn              string                               `json:"createdIn"`
	Crons                  []CreateDeploymentCron               `json:"crons,omitempty"`
	Functions              map[string]CreateDeploymentFunctions `json:"functions,omitempty"`
	MonorepoManager        *string                              `json:"monorepoManager,omitempty"`
	OwnerID                string                               `json:"ownerId"`
	// Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)
	PassiveConnectConfigurationID *string                              `json:"passiveConnectConfigurationId,omitempty"`
	Routes                        []CreateDeploymentRouteUnion         `json:"routes"`
	GitRepo                       *CreateDeploymentGitRepoUnion        `json:"gitRepo,omitempty"`
	Flags                         *CreateDeploymentFlagsUnion          `json:"flags,omitempty"`
	Microfrontends                *CreateDeploymentMicrofrontendsUnion `json:"microfrontends,omitempty"`
	// Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
	Config *CreateDeploymentConfig `json:"config,omitempty"`
	Checks *CreateDeploymentChecks `json:"checks,omitempty"`
}

func (o *CreateDeploymentResponseBody) GetAliasAssignedAt() *CreateDeploymentAliasAssignedAt {
	if o == nil {
		return nil
	}
	return o.AliasAssignedAt
}

func (o *CreateDeploymentResponseBody) GetAlwaysRefuseToBuild() *bool {
	if o == nil {
		return nil
	}
	return o.AlwaysRefuseToBuild
}

func (o *CreateDeploymentResponseBody) GetBuild() CreateDeploymentBuild1 {
	if o == nil {
		return CreateDeploymentBuild1{}
	}
	return o.Build
}

func (o *CreateDeploymentResponseBody) GetBuildArtifactUrls() []string {
	if o == nil {
		return nil
	}
	return o.BuildArtifactUrls
}

func (o *CreateDeploymentResponseBody) GetBuilds() []CreateDeploymentBuild2 {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *CreateDeploymentResponseBody) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

func (o *CreateDeploymentResponseBody) GetInspectorURL() *string {
	if o == nil {
		return nil
	}
	return o.InspectorURL
}

func (o *CreateDeploymentResponseBody) GetIsInConcurrentBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInConcurrentBuildsQueue
}

func (o *CreateDeploymentResponseBody) GetIsInSystemBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInSystemBuildsQueue
}

func (o *CreateDeploymentResponseBody) GetProjectSettings() CreateDeploymentProjectSettingsLambdas {
	if o == nil {
		return CreateDeploymentProjectSettingsLambdas{}
	}
	return o.ProjectSettings
}

func (o *CreateDeploymentResponseBody) GetReadyStateReason() *string {
	if o == nil {
		return nil
	}
	return o.ReadyStateReason
}

func (o *CreateDeploymentResponseBody) GetIntegrations() *CreateDeploymentIntegrations {
	if o == nil {
		return nil
	}
	return o.Integrations
}

func (o *CreateDeploymentResponseBody) GetImages() *CreateDeploymentImages {
	if o == nil {
		return nil
	}
	return o.Images
}

func (o *CreateDeploymentResponseBody) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *CreateDeploymentResponseBody) GetAliasAssigned() bool {
	if o == nil {
		return false
	}
	return o.AliasAssigned
}

func (o *CreateDeploymentResponseBody) GetBootedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BootedAt
}

func (o *CreateDeploymentResponseBody) GetBuildingAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BuildingAt
}

func (o *CreateDeploymentResponseBody) GetBuildContainerFinishedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildContainerFinishedAt
}

func (o *CreateDeploymentResponseBody) GetBuildSkipped() bool {
	if o == nil {
		return false
	}
	return o.BuildSkipped
}

func (o *CreateDeploymentResponseBody) GetCreator() CreateDeploymentCreator {
	if o == nil {
		return CreateDeploymentCreator{}
	}
	return o.Creator
}

func (o *CreateDeploymentResponseBody) GetInitReadyAt() *float64 {
	if o == nil {
		return nil
	}
	return o.InitReadyAt
}

func (o *CreateDeploymentResponseBody) GetIsFirstBranchDeployment() *bool {
	if o == nil {
		return nil
	}
	return o.IsFirstBranchDeployment
}

func (o *CreateDeploymentResponseBody) GetLambdas() []CreateDeploymentLambda {
	if o == nil {
		return nil
	}
	return o.Lambdas
}

func (o *CreateDeploymentResponseBody) GetPublic() bool {
	if o == nil {
		return false
	}
	return o.Public
}

func (o *CreateDeploymentResponseBody) GetReady() *float64 {
	if o == nil {
		return nil
	}
	return o.Ready
}

func (o *CreateDeploymentResponseBody) GetStatus() CreateDeploymentStatus {
	if o == nil {
		return CreateDeploymentStatus("")
	}
	return o.Status
}

func (o *CreateDeploymentResponseBody) GetTeam() *CreateDeploymentTeam {
	if o == nil {
		return nil
	}
	return o.Team
}

func (o *CreateDeploymentResponseBody) GetUserAliases() []string {
	if o == nil {
		return nil
	}
	return o.UserAliases
}

func (o *CreateDeploymentResponseBody) GetPreviewCommentsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PreviewCommentsEnabled
}

func (o *CreateDeploymentResponseBody) GetTtyBuildLogs() *bool {
	if o == nil {
		return nil
	}
	return o.TtyBuildLogs
}

func (o *CreateDeploymentResponseBody) GetCustomEnvironment() *CreateDeploymentCustomEnvironmentUnion {
	if o == nil {
		return nil
	}
	return o.CustomEnvironment
}

func (o *CreateDeploymentResponseBody) GetOomReport() *CreateDeploymentOomReport {
	if o == nil {
		return nil
	}
	return o.OomReport
}

func (o *CreateDeploymentResponseBody) GetAliasWarning() *CreateDeploymentAliasWarning {
	if o == nil {
		return nil
	}
	return o.AliasWarning
}

func (o *CreateDeploymentResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateDeploymentResponseBody) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *CreateDeploymentResponseBody) GetReadyState() CreateDeploymentReadyState {
	if o == nil {
		return CreateDeploymentReadyState("")
	}
	return o.ReadyState
}

func (o *CreateDeploymentResponseBody) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *CreateDeploymentResponseBody) GetType() CreateDeploymentTypeLambdas {
	if o == nil {
		return CreateDeploymentTypeLambdas("")
	}
	return o.Type
}

func (o *CreateDeploymentResponseBody) GetAliasError() *CreateDeploymentAliasError {
	if o == nil {
		return nil
	}
	return o.AliasError
}

func (o *CreateDeploymentResponseBody) GetAliasFinal() *string {
	if o == nil {
		return nil
	}
	return o.AliasFinal
}

func (o *CreateDeploymentResponseBody) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *CreateDeploymentResponseBody) GetAutomaticAliases() []string {
	if o == nil {
		return nil
	}
	return o.AutomaticAliases
}

func (o *CreateDeploymentResponseBody) GetBuildErrorAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildErrorAt
}

func (o *CreateDeploymentResponseBody) GetChecksState() *CreateDeploymentChecksState {
	if o == nil {
		return nil
	}
	return o.ChecksState
}

func (o *CreateDeploymentResponseBody) GetChecksConclusion() *CreateDeploymentChecksConclusion {
	if o == nil {
		return nil
	}
	return o.ChecksConclusion
}

func (o *CreateDeploymentResponseBody) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *CreateDeploymentResponseBody) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *CreateDeploymentResponseBody) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *CreateDeploymentResponseBody) GetErrorCode() *string {
	if o == nil {
		return nil
	}
	return o.ErrorCode
}

func (o *CreateDeploymentResponseBody) GetErrorLink() *string {
	if o == nil {
		return nil
	}
	return o.ErrorLink
}

func (o *CreateDeploymentResponseBody) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *CreateDeploymentResponseBody) GetErrorStep() *string {
	if o == nil {
		return nil
	}
	return o.ErrorStep
}

func (o *CreateDeploymentResponseBody) GetPassiveRegions() []string {
	if o == nil {
		return nil
	}
	return o.PassiveRegions
}

func (o *CreateDeploymentResponseBody) GetGitSource() *CreateDeploymentGitSourceLambdasUnion {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *CreateDeploymentResponseBody) GetMeta() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Meta
}

func (o *CreateDeploymentResponseBody) GetOriginCacheRegion() *string {
	if o == nil {
		return nil
	}
	return o.OriginCacheRegion
}

func (o *CreateDeploymentResponseBody) GetNodeVersion() *CreateDeploymentNodeVersionLambdas {
	if o == nil {
		return nil
	}
	return o.NodeVersion
}

func (o *CreateDeploymentResponseBody) GetProject() *CreateDeploymentProject {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *CreateDeploymentResponseBody) GetReadySubstate() *CreateDeploymentReadySubstate {
	if o == nil {
		return nil
	}
	return o.ReadySubstate
}

func (o *CreateDeploymentResponseBody) GetRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.Regions
}

func (o *CreateDeploymentResponseBody) GetSoftDeletedByRetention() *bool {
	if o == nil {
		return nil
	}
	return o.SoftDeletedByRetention
}

func (o *CreateDeploymentResponseBody) GetSource() *CreateDeploymentSource {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *CreateDeploymentResponseBody) GetTarget() *CreateDeploymentTargetEnum {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *CreateDeploymentResponseBody) GetUndeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UndeletedAt
}

func (o *CreateDeploymentResponseBody) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *CreateDeploymentResponseBody) GetVersion() float64 {
	if o == nil {
		return 0.0
	}
	return o.Version
}

func (o *CreateDeploymentResponseBody) GetOidcTokenClaims() *CreateDeploymentOidcTokenClaims {
	if o == nil {
		return nil
	}
	return o.OidcTokenClaims
}

func (o *CreateDeploymentResponseBody) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateDeploymentResponseBody) GetPlan() CreateDeploymentPlan {
	if o == nil {
		return CreateDeploymentPlan("")
	}
	return o.Plan
}

func (o *CreateDeploymentResponseBody) GetConnectBuildsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ConnectBuildsEnabled
}

func (o *CreateDeploymentResponseBody) GetConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *CreateDeploymentResponseBody) GetCrons() []CreateDeploymentCron {
	if o == nil {
		return nil
	}
	return o.Crons
}

func (o *CreateDeploymentResponseBody) GetFunctions() map[string]CreateDeploymentFunctions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *CreateDeploymentResponseBody) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *CreateDeploymentResponseBody) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *CreateDeploymentResponseBody) GetPassiveConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.PassiveConnectConfigurationID
}

func (o *CreateDeploymentResponseBody) GetRoutes() []CreateDeploymentRouteUnion {
	if o == nil {
		return nil
	}
	return o.Routes
}

func (o *CreateDeploymentResponseBody) GetGitRepo() *CreateDeploymentGitRepoUnion {
	if o == nil {
		return nil
	}
	return o.GitRepo
}

func (o *CreateDeploymentResponseBody) GetFlags() *CreateDeploymentFlagsUnion {
	if o == nil {
		return nil
	}
	return o.Flags
}

func (o *CreateDeploymentResponseBody) GetMicrofrontends() *CreateDeploymentMicrofrontendsUnion {
	if o == nil {
		return nil
	}
	return o.Microfrontends
}

func (o *CreateDeploymentResponseBody) GetConfig() *CreateDeploymentConfig {
	if o == nil {
		return nil
	}
	return o.Config
}

func (o *CreateDeploymentResponseBody) GetChecks() *CreateDeploymentChecks {
	if o == nil {
		return nil
	}
	return o.Checks
}

type CreateDeploymentResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The successfully created deployment
	Object *CreateDeploymentResponseBody
}

func (o *CreateDeploymentResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateDeploymentResponse) GetObject() *CreateDeploymentResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
