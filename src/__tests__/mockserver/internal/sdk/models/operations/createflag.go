// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

// KindRequest - The kind of flag
type KindRequest string

const (
	KindRequestBoolean KindRequest = "boolean"
	KindRequestString  KindRequest = "string"
	KindRequestNumber  KindRequest = "number"
)

func (e KindRequest) ToPointer() *KindRequest {
	return &e
}
func (e *KindRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "boolean":
		fallthrough
	case "string":
		fallthrough
	case "number":
		*e = KindRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for KindRequest: %v", v)
	}
}

type CreateFlagValueRequestType string

const (
	CreateFlagValueRequestTypeStr     CreateFlagValueRequestType = "str"
	CreateFlagValueRequestTypeNumber  CreateFlagValueRequestType = "number"
	CreateFlagValueRequestTypeBoolean CreateFlagValueRequestType = "boolean"
)

type CreateFlagValueRequest struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type CreateFlagValueRequestType
}

func CreateCreateFlagValueRequestStr(str string) CreateFlagValueRequest {
	typ := CreateFlagValueRequestTypeStr

	return CreateFlagValueRequest{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateFlagValueRequestNumber(number float64) CreateFlagValueRequest {
	typ := CreateFlagValueRequestTypeNumber

	return CreateFlagValueRequest{
		Number: &number,
		Type:   typ,
	}
}

func CreateCreateFlagValueRequestBoolean(boolean bool) CreateFlagValueRequest {
	typ := CreateFlagValueRequestTypeBoolean

	return CreateFlagValueRequest{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *CreateFlagValueRequest) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateFlagValueRequestTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateFlagValueRequestTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = CreateFlagValueRequestTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagValueRequest", string(data))
}

func (u CreateFlagValueRequest) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagValueRequest: all fields are null")
}

type CreateFlagVariantRequest struct {
	// The id of the variant
	ID string `json:"id"`
	// A label for the variant
	Label *string `json:"label,omitempty"`
	// A description of the variant
	Description *string                `json:"description,omitempty"`
	Value       CreateFlagValueRequest `json:"value"`
}

func (o *CreateFlagVariantRequest) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateFlagVariantRequest) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *CreateFlagVariantRequest) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateFlagVariantRequest) GetValue() CreateFlagValueRequest {
	if o == nil {
		return CreateFlagValueRequest{}
	}
	return o.Value
}

// CreateFlagReuseRequest - Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
type CreateFlagReuseRequest struct {
	// Whether the reuse is active or not
	Active bool `json:"active"`
	// The environment to link to
	Environment string `json:"environment"`
}

func (o *CreateFlagReuseRequest) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *CreateFlagReuseRequest) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type CreateFlagTargetRequest struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *CreateFlagTargetRequest) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *CreateFlagTargetRequest) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type CreateFlagPausedOutcomeRequest struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (o *CreateFlagPausedOutcomeRequest) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagPausedOutcomeRequest) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type CreateFlagLHSRequest2 struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (c CreateFlagLHSRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagLHSRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagLHSRequest2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagLHSRequest2) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *CreateFlagLHSRequest2) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type CreateFlagLHSRequest1 struct {
	Type any `json:"type"`
}

func (c CreateFlagLHSRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagLHSRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagLHSRequest1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type CreateFlagLHSRequestUnionType string

const (
	CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest1 CreateFlagLHSRequestUnionType = "createFlag_lhs_request_1"
	CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest2 CreateFlagLHSRequestUnionType = "createFlag_lhs_request_2"
)

type CreateFlagLHSRequestUnion struct {
	CreateFlagLHSRequest1 *CreateFlagLHSRequest1 `queryParam:"inline"`
	CreateFlagLHSRequest2 *CreateFlagLHSRequest2 `queryParam:"inline"`

	Type CreateFlagLHSRequestUnionType
}

func CreateCreateFlagLHSRequestUnionCreateFlagLHSRequest1(createFlagLHSRequest1 CreateFlagLHSRequest1) CreateFlagLHSRequestUnion {
	typ := CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest1

	return CreateFlagLHSRequestUnion{
		CreateFlagLHSRequest1: &createFlagLHSRequest1,
		Type:                  typ,
	}
}

func CreateCreateFlagLHSRequestUnionCreateFlagLHSRequest2(createFlagLHSRequest2 CreateFlagLHSRequest2) CreateFlagLHSRequestUnion {
	typ := CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest2

	return CreateFlagLHSRequestUnion{
		CreateFlagLHSRequest2: &createFlagLHSRequest2,
		Type:                  typ,
	}
}

func (u *CreateFlagLHSRequestUnion) UnmarshalJSON(data []byte) error {

	var createFlagLHSRequest2 CreateFlagLHSRequest2 = CreateFlagLHSRequest2{}
	if err := utils.UnmarshalJSON(data, &createFlagLHSRequest2, "", true, nil); err == nil {
		u.CreateFlagLHSRequest2 = &createFlagLHSRequest2
		u.Type = CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest2
		return nil
	}

	var createFlagLHSRequest1 CreateFlagLHSRequest1 = CreateFlagLHSRequest1{}
	if err := utils.UnmarshalJSON(data, &createFlagLHSRequest1, "", true, nil); err == nil {
		u.CreateFlagLHSRequest1 = &createFlagLHSRequest1
		u.Type = CreateFlagLHSRequestUnionTypeCreateFlagLHSRequest1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagLHSRequestUnion", string(data))
}

func (u CreateFlagLHSRequestUnion) MarshalJSON() ([]byte, error) {
	if u.CreateFlagLHSRequest1 != nil {
		return utils.MarshalJSON(u.CreateFlagLHSRequest1, "", true)
	}

	if u.CreateFlagLHSRequest2 != nil {
		return utils.MarshalJSON(u.CreateFlagLHSRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagLHSRequestUnion: all fields are null")
}

type CreateFlagCmpRequest string

const (
	CreateFlagCmpRequestEq             CreateFlagCmpRequest = "eq"
	CreateFlagCmpRequestNotEq          CreateFlagCmpRequest = "!eq"
	CreateFlagCmpRequestOneOf          CreateFlagCmpRequest = "oneOf"
	CreateFlagCmpRequestNotOneOf       CreateFlagCmpRequest = "!oneOf"
	CreateFlagCmpRequestContainsAllOf  CreateFlagCmpRequest = "containsAllOf"
	CreateFlagCmpRequestContainsAnyOf  CreateFlagCmpRequest = "containsAnyOf"
	CreateFlagCmpRequestContainsNoneOf CreateFlagCmpRequest = "containsNoneOf"
	CreateFlagCmpRequestStartsWith     CreateFlagCmpRequest = "startsWith"
	CreateFlagCmpRequestNotStartsWith  CreateFlagCmpRequest = "!startsWith"
	CreateFlagCmpRequestEndsWith       CreateFlagCmpRequest = "endsWith"
	CreateFlagCmpRequestNotEndsWith    CreateFlagCmpRequest = "!endsWith"
	CreateFlagCmpRequestEx             CreateFlagCmpRequest = "ex"
	CreateFlagCmpRequestNotEx          CreateFlagCmpRequest = "!ex"
	CreateFlagCmpRequestGt             CreateFlagCmpRequest = "gt"
	CreateFlagCmpRequestGte            CreateFlagCmpRequest = "gte"
	CreateFlagCmpRequestLt             CreateFlagCmpRequest = "lt"
	CreateFlagCmpRequestLte            CreateFlagCmpRequest = "lte"
	CreateFlagCmpRequestRegex          CreateFlagCmpRequest = "regex"
	CreateFlagCmpRequestNotRegex       CreateFlagCmpRequest = "!regex"
	CreateFlagCmpRequestBefore         CreateFlagCmpRequest = "before"
	CreateFlagCmpRequestAfter          CreateFlagCmpRequest = "after"
)

func (e CreateFlagCmpRequest) ToPointer() *CreateFlagCmpRequest {
	return &e
}
func (e *CreateFlagCmpRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = CreateFlagCmpRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateFlagCmpRequest: %v", v)
	}
}

type CreateFlagRHSRequest2 struct {
	Type    any    `json:"type"`
	Pattern string `json:"pattern"`
	Flags   string `json:"flags"`
}

func (c CreateFlagRHSRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagRHSRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagRHSRequest2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagRHSRequest2) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *CreateFlagRHSRequest2) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type CreateFlagTypeRequest string

const (
	CreateFlagTypeRequestListInline CreateFlagTypeRequest = "list/inline"
	CreateFlagTypeRequestList       CreateFlagTypeRequest = "list"
)

func (e CreateFlagTypeRequest) ToPointer() *CreateFlagTypeRequest {
	return &e
}
func (e *CreateFlagTypeRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = CreateFlagTypeRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateFlagTypeRequest: %v", v)
	}
}

type CreateFlagItemRequest2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (c CreateFlagItemRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagItemRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagItemRequest2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *CreateFlagItemRequest2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *CreateFlagItemRequest2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type CreateFlagItemRequest1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (c CreateFlagItemRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagItemRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagItemRequest1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *CreateFlagItemRequest1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *CreateFlagItemRequest1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type CreateFlagItemRequestUnionType string

const (
	CreateFlagItemRequestUnionTypeCreateFlagItemRequest1 CreateFlagItemRequestUnionType = "createFlag_item_request_1"
	CreateFlagItemRequestUnionTypeCreateFlagItemRequest2 CreateFlagItemRequestUnionType = "createFlag_item_request_2"
)

type CreateFlagItemRequestUnion struct {
	CreateFlagItemRequest1 *CreateFlagItemRequest1 `queryParam:"inline"`
	CreateFlagItemRequest2 *CreateFlagItemRequest2 `queryParam:"inline"`

	Type CreateFlagItemRequestUnionType
}

func CreateCreateFlagItemRequestUnionCreateFlagItemRequest1(createFlagItemRequest1 CreateFlagItemRequest1) CreateFlagItemRequestUnion {
	typ := CreateFlagItemRequestUnionTypeCreateFlagItemRequest1

	return CreateFlagItemRequestUnion{
		CreateFlagItemRequest1: &createFlagItemRequest1,
		Type:                   typ,
	}
}

func CreateCreateFlagItemRequestUnionCreateFlagItemRequest2(createFlagItemRequest2 CreateFlagItemRequest2) CreateFlagItemRequestUnion {
	typ := CreateFlagItemRequestUnionTypeCreateFlagItemRequest2

	return CreateFlagItemRequestUnion{
		CreateFlagItemRequest2: &createFlagItemRequest2,
		Type:                   typ,
	}
}

func (u *CreateFlagItemRequestUnion) UnmarshalJSON(data []byte) error {

	var createFlagItemRequest1 CreateFlagItemRequest1 = CreateFlagItemRequest1{}
	if err := utils.UnmarshalJSON(data, &createFlagItemRequest1, "", true, nil); err == nil {
		u.CreateFlagItemRequest1 = &createFlagItemRequest1
		u.Type = CreateFlagItemRequestUnionTypeCreateFlagItemRequest1
		return nil
	}

	var createFlagItemRequest2 CreateFlagItemRequest2 = CreateFlagItemRequest2{}
	if err := utils.UnmarshalJSON(data, &createFlagItemRequest2, "", true, nil); err == nil {
		u.CreateFlagItemRequest2 = &createFlagItemRequest2
		u.Type = CreateFlagItemRequestUnionTypeCreateFlagItemRequest2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagItemRequestUnion", string(data))
}

func (u CreateFlagItemRequestUnion) MarshalJSON() ([]byte, error) {
	if u.CreateFlagItemRequest1 != nil {
		return utils.MarshalJSON(u.CreateFlagItemRequest1, "", true)
	}

	if u.CreateFlagItemRequest2 != nil {
		return utils.MarshalJSON(u.CreateFlagItemRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagItemRequestUnion: all fields are null")
}

type CreateFlagRHSRequest1 struct {
	Type  CreateFlagTypeRequest        `json:"type"`
	Items []CreateFlagItemRequestUnion `json:"items"`
}

func (c CreateFlagRHSRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagRHSRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagRHSRequest1) GetType() CreateFlagTypeRequest {
	if o == nil {
		return CreateFlagTypeRequest("")
	}
	return o.Type
}

func (o *CreateFlagRHSRequest1) GetItems() []CreateFlagItemRequestUnion {
	if o == nil {
		return []CreateFlagItemRequestUnion{}
	}
	return o.Items
}

type CreateFlagRHSRequestUnionType string

const (
	CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest1 CreateFlagRHSRequestUnionType = "createFlag_rhs_request_1"
	CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest2 CreateFlagRHSRequestUnionType = "createFlag_rhs_request_2"
	CreateFlagRHSRequestUnionTypeStr                   CreateFlagRHSRequestUnionType = "str"
	CreateFlagRHSRequestUnionTypeNumber                CreateFlagRHSRequestUnionType = "number"
	CreateFlagRHSRequestUnionTypeBoolean               CreateFlagRHSRequestUnionType = "boolean"
)

type CreateFlagRHSRequestUnion struct {
	CreateFlagRHSRequest1 *CreateFlagRHSRequest1 `queryParam:"inline"`
	CreateFlagRHSRequest2 *CreateFlagRHSRequest2 `queryParam:"inline"`
	Str                   *string                `queryParam:"inline"`
	Number                *float64               `queryParam:"inline"`
	Boolean               *bool                  `queryParam:"inline"`

	Type CreateFlagRHSRequestUnionType
}

func CreateCreateFlagRHSRequestUnionCreateFlagRHSRequest1(createFlagRHSRequest1 CreateFlagRHSRequest1) CreateFlagRHSRequestUnion {
	typ := CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest1

	return CreateFlagRHSRequestUnion{
		CreateFlagRHSRequest1: &createFlagRHSRequest1,
		Type:                  typ,
	}
}

func CreateCreateFlagRHSRequestUnionCreateFlagRHSRequest2(createFlagRHSRequest2 CreateFlagRHSRequest2) CreateFlagRHSRequestUnion {
	typ := CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest2

	return CreateFlagRHSRequestUnion{
		CreateFlagRHSRequest2: &createFlagRHSRequest2,
		Type:                  typ,
	}
}

func CreateCreateFlagRHSRequestUnionStr(str string) CreateFlagRHSRequestUnion {
	typ := CreateFlagRHSRequestUnionTypeStr

	return CreateFlagRHSRequestUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateCreateFlagRHSRequestUnionNumber(number float64) CreateFlagRHSRequestUnion {
	typ := CreateFlagRHSRequestUnionTypeNumber

	return CreateFlagRHSRequestUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateCreateFlagRHSRequestUnionBoolean(boolean bool) CreateFlagRHSRequestUnion {
	typ := CreateFlagRHSRequestUnionTypeBoolean

	return CreateFlagRHSRequestUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *CreateFlagRHSRequestUnion) UnmarshalJSON(data []byte) error {

	var createFlagRHSRequest2 CreateFlagRHSRequest2 = CreateFlagRHSRequest2{}
	if err := utils.UnmarshalJSON(data, &createFlagRHSRequest2, "", true, nil); err == nil {
		u.CreateFlagRHSRequest2 = &createFlagRHSRequest2
		u.Type = CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest2
		return nil
	}

	var createFlagRHSRequest1 CreateFlagRHSRequest1 = CreateFlagRHSRequest1{}
	if err := utils.UnmarshalJSON(data, &createFlagRHSRequest1, "", true, nil); err == nil {
		u.CreateFlagRHSRequest1 = &createFlagRHSRequest1
		u.Type = CreateFlagRHSRequestUnionTypeCreateFlagRHSRequest1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CreateFlagRHSRequestUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = CreateFlagRHSRequestUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = CreateFlagRHSRequestUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagRHSRequestUnion", string(data))
}

func (u CreateFlagRHSRequestUnion) MarshalJSON() ([]byte, error) {
	if u.CreateFlagRHSRequest1 != nil {
		return utils.MarshalJSON(u.CreateFlagRHSRequest1, "", true)
	}

	if u.CreateFlagRHSRequest2 != nil {
		return utils.MarshalJSON(u.CreateFlagRHSRequest2, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagRHSRequestUnion: all fields are null")
}

type CreateFlagConditionRequest struct {
	LHS CreateFlagLHSRequestUnion  `json:"lhs"`
	Cmp CreateFlagCmpRequest       `json:"cmp"`
	RHS *CreateFlagRHSRequestUnion `json:"rhs,omitempty"`
}

func (o *CreateFlagConditionRequest) GetLHS() CreateFlagLHSRequestUnion {
	if o == nil {
		return CreateFlagLHSRequestUnion{}
	}
	return o.LHS
}

func (o *CreateFlagConditionRequest) GetCmp() CreateFlagCmpRequest {
	if o == nil {
		return CreateFlagCmpRequest("")
	}
	return o.Cmp
}

func (o *CreateFlagConditionRequest) GetRHS() *CreateFlagRHSRequestUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

type CreateFlagOutcomeBaseRequest struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (c CreateFlagOutcomeBaseRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagOutcomeBaseRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagOutcomeBaseRequest) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagOutcomeBaseRequest) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *CreateFlagOutcomeBaseRequest) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type CreateFlagOutcomeRequest2 struct {
	Type any                          `json:"type"`
	Base CreateFlagOutcomeBaseRequest `json:"base"`
	// The distribution for each variant
	Weights map[string]float64 `json:"weights"`
	// This variant will be used when the base attribute does not exist
	DefaultVariantID string `json:"defaultVariantId"`
}

func (c CreateFlagOutcomeRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagOutcomeRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagOutcomeRequest2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagOutcomeRequest2) GetBase() CreateFlagOutcomeBaseRequest {
	if o == nil {
		return CreateFlagOutcomeBaseRequest{}
	}
	return o.Base
}

func (o *CreateFlagOutcomeRequest2) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *CreateFlagOutcomeRequest2) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type CreateFlagOutcomeRequest1 struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (c CreateFlagOutcomeRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagOutcomeRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagOutcomeRequest1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagOutcomeRequest1) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type CreateFlagOutcomeRequestUnionType string

const (
	CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest1 CreateFlagOutcomeRequestUnionType = "createFlag_outcome_request_1"
	CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest2 CreateFlagOutcomeRequestUnionType = "createFlag_outcome_request_2"
)

type CreateFlagOutcomeRequestUnion struct {
	CreateFlagOutcomeRequest1 *CreateFlagOutcomeRequest1 `queryParam:"inline"`
	CreateFlagOutcomeRequest2 *CreateFlagOutcomeRequest2 `queryParam:"inline"`

	Type CreateFlagOutcomeRequestUnionType
}

func CreateCreateFlagOutcomeRequestUnionCreateFlagOutcomeRequest1(createFlagOutcomeRequest1 CreateFlagOutcomeRequest1) CreateFlagOutcomeRequestUnion {
	typ := CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest1

	return CreateFlagOutcomeRequestUnion{
		CreateFlagOutcomeRequest1: &createFlagOutcomeRequest1,
		Type:                      typ,
	}
}

func CreateCreateFlagOutcomeRequestUnionCreateFlagOutcomeRequest2(createFlagOutcomeRequest2 CreateFlagOutcomeRequest2) CreateFlagOutcomeRequestUnion {
	typ := CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest2

	return CreateFlagOutcomeRequestUnion{
		CreateFlagOutcomeRequest2: &createFlagOutcomeRequest2,
		Type:                      typ,
	}
}

func (u *CreateFlagOutcomeRequestUnion) UnmarshalJSON(data []byte) error {

	var createFlagOutcomeRequest2 CreateFlagOutcomeRequest2 = CreateFlagOutcomeRequest2{}
	if err := utils.UnmarshalJSON(data, &createFlagOutcomeRequest2, "", true, nil); err == nil {
		u.CreateFlagOutcomeRequest2 = &createFlagOutcomeRequest2
		u.Type = CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest2
		return nil
	}

	var createFlagOutcomeRequest1 CreateFlagOutcomeRequest1 = CreateFlagOutcomeRequest1{}
	if err := utils.UnmarshalJSON(data, &createFlagOutcomeRequest1, "", true, nil); err == nil {
		u.CreateFlagOutcomeRequest1 = &createFlagOutcomeRequest1
		u.Type = CreateFlagOutcomeRequestUnionTypeCreateFlagOutcomeRequest1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagOutcomeRequestUnion", string(data))
}

func (u CreateFlagOutcomeRequestUnion) MarshalJSON() ([]byte, error) {
	if u.CreateFlagOutcomeRequest1 != nil {
		return utils.MarshalJSON(u.CreateFlagOutcomeRequest1, "", true)
	}

	if u.CreateFlagOutcomeRequest2 != nil {
		return utils.MarshalJSON(u.CreateFlagOutcomeRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagOutcomeRequestUnion: all fields are null")
}

type CreateFlagRuleRequest struct {
	ID         string                        `json:"id"`
	Conditions []CreateFlagConditionRequest  `json:"conditions"`
	Outcome    CreateFlagOutcomeRequestUnion `json:"outcome"`
}

func (o *CreateFlagRuleRequest) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateFlagRuleRequest) GetConditions() []CreateFlagConditionRequest {
	if o == nil {
		return []CreateFlagConditionRequest{}
	}
	return o.Conditions
}

func (o *CreateFlagRuleRequest) GetOutcome() CreateFlagOutcomeRequestUnion {
	if o == nil {
		return CreateFlagOutcomeRequestUnion{}
	}
	return o.Outcome
}

type CreateFlagFallthroughBaseRequest struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (c CreateFlagFallthroughBaseRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagFallthroughBaseRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagFallthroughBaseRequest) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagFallthroughBaseRequest) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *CreateFlagFallthroughBaseRequest) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type CreateFlagFallthroughRequest2 struct {
	Type any                              `json:"type"`
	Base CreateFlagFallthroughBaseRequest `json:"base"`
	// The distribution for each variant
	Weights map[string]float64 `json:"weights"`
	// This variant will be used when the base attribute does not exist
	DefaultVariantID string `json:"defaultVariantId"`
}

func (c CreateFlagFallthroughRequest2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagFallthroughRequest2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagFallthroughRequest2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagFallthroughRequest2) GetBase() CreateFlagFallthroughBaseRequest {
	if o == nil {
		return CreateFlagFallthroughBaseRequest{}
	}
	return o.Base
}

func (o *CreateFlagFallthroughRequest2) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *CreateFlagFallthroughRequest2) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type CreateFlagFallthroughRequest1 struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (c CreateFlagFallthroughRequest1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *CreateFlagFallthroughRequest1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *CreateFlagFallthroughRequest1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *CreateFlagFallthroughRequest1) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type CreateFlagFallthroughRequestUnionType string

const (
	CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest1 CreateFlagFallthroughRequestUnionType = "createFlag_fallthrough_request_1"
	CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest2 CreateFlagFallthroughRequestUnionType = "createFlag_fallthrough_request_2"
)

type CreateFlagFallthroughRequestUnion struct {
	CreateFlagFallthroughRequest1 *CreateFlagFallthroughRequest1 `queryParam:"inline"`
	CreateFlagFallthroughRequest2 *CreateFlagFallthroughRequest2 `queryParam:"inline"`

	Type CreateFlagFallthroughRequestUnionType
}

func CreateCreateFlagFallthroughRequestUnionCreateFlagFallthroughRequest1(createFlagFallthroughRequest1 CreateFlagFallthroughRequest1) CreateFlagFallthroughRequestUnion {
	typ := CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest1

	return CreateFlagFallthroughRequestUnion{
		CreateFlagFallthroughRequest1: &createFlagFallthroughRequest1,
		Type:                          typ,
	}
}

func CreateCreateFlagFallthroughRequestUnionCreateFlagFallthroughRequest2(createFlagFallthroughRequest2 CreateFlagFallthroughRequest2) CreateFlagFallthroughRequestUnion {
	typ := CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest2

	return CreateFlagFallthroughRequestUnion{
		CreateFlagFallthroughRequest2: &createFlagFallthroughRequest2,
		Type:                          typ,
	}
}

func (u *CreateFlagFallthroughRequestUnion) UnmarshalJSON(data []byte) error {

	var createFlagFallthroughRequest2 CreateFlagFallthroughRequest2 = CreateFlagFallthroughRequest2{}
	if err := utils.UnmarshalJSON(data, &createFlagFallthroughRequest2, "", true, nil); err == nil {
		u.CreateFlagFallthroughRequest2 = &createFlagFallthroughRequest2
		u.Type = CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest2
		return nil
	}

	var createFlagFallthroughRequest1 CreateFlagFallthroughRequest1 = CreateFlagFallthroughRequest1{}
	if err := utils.UnmarshalJSON(data, &createFlagFallthroughRequest1, "", true, nil); err == nil {
		u.CreateFlagFallthroughRequest1 = &createFlagFallthroughRequest1
		u.Type = CreateFlagFallthroughRequestUnionTypeCreateFlagFallthroughRequest1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for CreateFlagFallthroughRequestUnion", string(data))
}

func (u CreateFlagFallthroughRequestUnion) MarshalJSON() ([]byte, error) {
	if u.CreateFlagFallthroughRequest1 != nil {
		return utils.MarshalJSON(u.CreateFlagFallthroughRequest1, "", true)
	}

	if u.CreateFlagFallthroughRequest2 != nil {
		return utils.MarshalJSON(u.CreateFlagFallthroughRequest2, "", true)
	}

	return nil, errors.New("could not marshal union type CreateFlagFallthroughRequestUnion: all fields are null")
}

type CreateFlagEnvironmentsRequest struct {
	Active bool `json:"active"`
	// Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
	Reuse *CreateFlagReuseRequest `json:"reuse,omitempty"`
	// Allows assigning targets to variants while bypassing the flag's rules
	Targets       map[string]map[string]map[string][]CreateFlagTargetRequest `json:"targets,omitempty"`
	PausedOutcome CreateFlagPausedOutcomeRequest                             `json:"pausedOutcome"`
	Rules         []CreateFlagRuleRequest                                    `json:"rules"`
	Fallthrough   CreateFlagFallthroughRequestUnion                          `json:"fallthrough"`
	// The revision of the environment config
	Revision *float64 `json:"revision,omitempty"`
}

func (o *CreateFlagEnvironmentsRequest) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *CreateFlagEnvironmentsRequest) GetReuse() *CreateFlagReuseRequest {
	if o == nil {
		return nil
	}
	return o.Reuse
}

func (o *CreateFlagEnvironmentsRequest) GetTargets() map[string]map[string]map[string][]CreateFlagTargetRequest {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *CreateFlagEnvironmentsRequest) GetPausedOutcome() CreateFlagPausedOutcomeRequest {
	if o == nil {
		return CreateFlagPausedOutcomeRequest{}
	}
	return o.PausedOutcome
}

func (o *CreateFlagEnvironmentsRequest) GetRules() []CreateFlagRuleRequest {
	if o == nil {
		return []CreateFlagRuleRequest{}
	}
	return o.Rules
}

func (o *CreateFlagEnvironmentsRequest) GetFallthrough() CreateFlagFallthroughRequestUnion {
	if o == nil {
		return CreateFlagFallthroughRequestUnion{}
	}
	return o.Fallthrough
}

func (o *CreateFlagEnvironmentsRequest) GetRevision() *float64 {
	if o == nil {
		return nil
	}
	return o.Revision
}

type CreateFlagStateRequest string

const (
	CreateFlagStateRequestActive   CreateFlagStateRequest = "active"
	CreateFlagStateRequestArchived CreateFlagStateRequest = "archived"
)

func (e CreateFlagStateRequest) ToPointer() *CreateFlagStateRequest {
	return &e
}
func (e *CreateFlagStateRequest) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "archived":
		*e = CreateFlagStateRequest(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateFlagStateRequest: %v", v)
	}
}

type CreateFlagRequestBody struct {
	// A unique (per project) key for the flag, composed of letters, numbers, dashes, and underscores
	Slug string `json:"slug"`
	// The kind of flag
	Kind KindRequest `json:"kind"`
	// The variants of the flag
	Variants []CreateFlagVariantRequest `json:"variants,omitempty"`
	// The configuration for the flag in different environments
	Environments map[string]CreateFlagEnvironmentsRequest `json:"environments"`
	// A random seed to prevent split points in different flags from having the same targets
	Seed *float64 `json:"seed,omitempty"`
	// A description of the flag
	Description *string                 `json:"description,omitempty"`
	State       *CreateFlagStateRequest `json:"state,omitempty"`
}

func (o *CreateFlagRequestBody) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateFlagRequestBody) GetKind() KindRequest {
	if o == nil {
		return KindRequest("")
	}
	return o.Kind
}

func (o *CreateFlagRequestBody) GetVariants() []CreateFlagVariantRequest {
	if o == nil {
		return nil
	}
	return o.Variants
}

func (o *CreateFlagRequestBody) GetEnvironments() map[string]CreateFlagEnvironmentsRequest {
	if o == nil {
		return map[string]CreateFlagEnvironmentsRequest{}
	}
	return o.Environments
}

func (o *CreateFlagRequestBody) GetSeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

func (o *CreateFlagRequestBody) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateFlagRequestBody) GetState() *CreateFlagStateRequest {
	if o == nil {
		return nil
	}
	return o.State
}

type CreateFlagRequest struct {
	// The project id or name
	ProjectIDOrName string `pathParam:"style=simple,explode=false,name=projectIdOrName"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string                `queryParam:"style=form,explode=true,name=slug"`
	Body *CreateFlagRequestBody `request:"mediaType=application/json"`
}

func (o *CreateFlagRequest) GetProjectIDOrName() string {
	if o == nil {
		return ""
	}
	return o.ProjectIDOrName
}

func (o *CreateFlagRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *CreateFlagRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *CreateFlagRequest) GetBody() *CreateFlagRequestBody {
	if o == nil {
		return nil
	}
	return o.Body
}

type ValueFlagType string

const (
	ValueFlagTypeStr     ValueFlagType = "str"
	ValueFlagTypeNumber  ValueFlagType = "number"
	ValueFlagTypeBoolean ValueFlagType = "boolean"
)

type ValueFlag struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ValueFlagType
}

func CreateValueFlagStr(str string) ValueFlag {
	typ := ValueFlagTypeStr

	return ValueFlag{
		Str:  &str,
		Type: typ,
	}
}

func CreateValueFlagNumber(number float64) ValueFlag {
	typ := ValueFlagTypeNumber

	return ValueFlag{
		Number: &number,
		Type:   typ,
	}
}

func CreateValueFlagBoolean(boolean bool) ValueFlag {
	typ := ValueFlagTypeBoolean

	return ValueFlag{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ValueFlag) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ValueFlagTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ValueFlagTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ValueFlagTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ValueFlag", string(data))
}

func (u ValueFlag) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ValueFlag: all fields are null")
}

type VariantFlag struct {
	Description *string   `json:"description,omitempty"`
	Label       *string   `json:"label,omitempty"`
	Value       ValueFlag `json:"value"`
	ID          string    `json:"id"`
}

func (o *VariantFlag) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *VariantFlag) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *VariantFlag) GetValue() ValueFlag {
	if o == nil {
		return ValueFlag{}
	}
	return o.Value
}

func (o *VariantFlag) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type ReuseFlag struct {
	Active      bool   `json:"active"`
	Environment string `json:"environment"`
}

func (o *ReuseFlag) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ReuseFlag) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type TargetFlag struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *TargetFlag) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *TargetFlag) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type TypeFlagVariant string

const (
	TypeFlagVariantVariant TypeFlagVariant = "variant"
)

func (e TypeFlagVariant) ToPointer() *TypeFlagVariant {
	return &e
}
func (e *TypeFlagVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = TypeFlagVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeFlagVariant: %v", v)
	}
}

type PausedOutcomeFlag struct {
	Type      TypeFlagVariant `json:"type"`
	VariantID string          `json:"variantId"`
}

func (o *PausedOutcomeFlag) GetType() TypeFlagVariant {
	if o == nil {
		return TypeFlagVariant("")
	}
	return o.Type
}

func (o *PausedOutcomeFlag) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type FallthroughTypeFlagSplit string

const (
	FallthroughTypeFlagSplitSplit FallthroughTypeFlagSplit = "split"
)

func (e FallthroughTypeFlagSplit) ToPointer() *FallthroughTypeFlagSplit {
	return &e
}
func (e *FallthroughTypeFlagSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = FallthroughTypeFlagSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeFlagSplit: %v", v)
	}
}

type FallthroughTypeFlagEntity string

const (
	FallthroughTypeFlagEntityEntity FallthroughTypeFlagEntity = "entity"
)

func (e FallthroughTypeFlagEntity) ToPointer() *FallthroughTypeFlagEntity {
	return &e
}
func (e *FallthroughTypeFlagEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = FallthroughTypeFlagEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeFlagEntity: %v", v)
	}
}

type FallthroughBaseFlag struct {
	Type      FallthroughTypeFlagEntity `json:"type"`
	Kind      string                    `json:"kind"`
	Attribute string                    `json:"attribute"`
}

func (f FallthroughBaseFlag) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughBaseFlag) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughBaseFlag) GetType() FallthroughTypeFlagEntity {
	if o == nil {
		return FallthroughTypeFlagEntity("")
	}
	return o.Type
}

func (o *FallthroughBaseFlag) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *FallthroughBaseFlag) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type FallthroughFlagSplit struct {
	Type             FallthroughTypeFlagSplit `json:"type"`
	Base             FallthroughBaseFlag      `json:"base"`
	Weights          map[string]float64       `json:"weights"`
	DefaultVariantID string                   `json:"defaultVariantId"`
}

func (f FallthroughFlagSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughFlagSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughFlagSplit) GetType() FallthroughTypeFlagSplit {
	if o == nil {
		return FallthroughTypeFlagSplit("")
	}
	return o.Type
}

func (o *FallthroughFlagSplit) GetBase() FallthroughBaseFlag {
	if o == nil {
		return FallthroughBaseFlag{}
	}
	return o.Base
}

func (o *FallthroughFlagSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *FallthroughFlagSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type FallthroughTypeFlagVariant string

const (
	FallthroughTypeFlagVariantVariant FallthroughTypeFlagVariant = "variant"
)

func (e FallthroughTypeFlagVariant) ToPointer() *FallthroughTypeFlagVariant {
	return &e
}
func (e *FallthroughTypeFlagVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = FallthroughTypeFlagVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FallthroughTypeFlagVariant: %v", v)
	}
}

type FallthroughFlagVariant struct {
	Type      FallthroughTypeFlagVariant `json:"type"`
	VariantID string                     `json:"variantId"`
}

func (f FallthroughFlagVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FallthroughFlagVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *FallthroughFlagVariant) GetType() FallthroughTypeFlagVariant {
	if o == nil {
		return FallthroughTypeFlagVariant("")
	}
	return o.Type
}

func (o *FallthroughFlagVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type FallthroughFlagUnionType string

const (
	FallthroughFlagUnionTypeVariant FallthroughFlagUnionType = "variant"
	FallthroughFlagUnionTypeSplit   FallthroughFlagUnionType = "split"
)

type FallthroughFlagUnion struct {
	FallthroughFlagVariant *FallthroughFlagVariant `queryParam:"inline"`
	FallthroughFlagSplit   *FallthroughFlagSplit   `queryParam:"inline"`

	Type FallthroughFlagUnionType
}

func CreateFallthroughFlagUnionVariant(variant FallthroughFlagVariant) FallthroughFlagUnion {
	typ := FallthroughFlagUnionTypeVariant

	typStr := FallthroughTypeFlagVariant(typ)
	variant.Type = typStr

	return FallthroughFlagUnion{
		FallthroughFlagVariant: &variant,
		Type:                   typ,
	}
}

func CreateFallthroughFlagUnionSplit(split FallthroughFlagSplit) FallthroughFlagUnion {
	typ := FallthroughFlagUnionTypeSplit

	typStr := FallthroughTypeFlagSplit(typ)
	split.Type = typStr

	return FallthroughFlagUnion{
		FallthroughFlagSplit: &split,
		Type:                 typ,
	}
}

func (u *FallthroughFlagUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		fallthroughFlagVariant := new(FallthroughFlagVariant)
		if err := utils.UnmarshalJSON(data, &fallthroughFlagVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type FallthroughFlagVariant within FallthroughFlagUnion: %w", string(data), err)
		}

		u.FallthroughFlagVariant = fallthroughFlagVariant
		u.Type = FallthroughFlagUnionTypeVariant
		return nil
	case "split":
		fallthroughFlagSplit := new(FallthroughFlagSplit)
		if err := utils.UnmarshalJSON(data, &fallthroughFlagSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type FallthroughFlagSplit within FallthroughFlagUnion: %w", string(data), err)
		}

		u.FallthroughFlagSplit = fallthroughFlagSplit
		u.Type = FallthroughFlagUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FallthroughFlagUnion", string(data))
}

func (u FallthroughFlagUnion) MarshalJSON() ([]byte, error) {
	if u.FallthroughFlagVariant != nil {
		return utils.MarshalJSON(u.FallthroughFlagVariant, "", true)
	}

	if u.FallthroughFlagSplit != nil {
		return utils.MarshalJSON(u.FallthroughFlagSplit, "", true)
	}

	return nil, errors.New("could not marshal union type FallthroughFlagUnion: all fields are null")
}

type OutcomeTypeFlagSplit string

const (
	OutcomeTypeFlagSplitSplit OutcomeTypeFlagSplit = "split"
)

func (e OutcomeTypeFlagSplit) ToPointer() *OutcomeTypeFlagSplit {
	return &e
}
func (e *OutcomeTypeFlagSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = OutcomeTypeFlagSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutcomeTypeFlagSplit: %v", v)
	}
}

type OutcomeTypeFlagEntity string

const (
	OutcomeTypeFlagEntityEntity OutcomeTypeFlagEntity = "entity"
)

func (e OutcomeTypeFlagEntity) ToPointer() *OutcomeTypeFlagEntity {
	return &e
}
func (e *OutcomeTypeFlagEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = OutcomeTypeFlagEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutcomeTypeFlagEntity: %v", v)
	}
}

type OutcomeBaseFlag struct {
	Type      OutcomeTypeFlagEntity `json:"type"`
	Kind      string                `json:"kind"`
	Attribute string                `json:"attribute"`
}

func (o OutcomeBaseFlag) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutcomeBaseFlag) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *OutcomeBaseFlag) GetType() OutcomeTypeFlagEntity {
	if o == nil {
		return OutcomeTypeFlagEntity("")
	}
	return o.Type
}

func (o *OutcomeBaseFlag) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *OutcomeBaseFlag) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type OutcomeFlagSplit struct {
	Type             OutcomeTypeFlagSplit `json:"type"`
	Base             OutcomeBaseFlag      `json:"base"`
	Weights          map[string]float64   `json:"weights"`
	DefaultVariantID string               `json:"defaultVariantId"`
}

func (o OutcomeFlagSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutcomeFlagSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *OutcomeFlagSplit) GetType() OutcomeTypeFlagSplit {
	if o == nil {
		return OutcomeTypeFlagSplit("")
	}
	return o.Type
}

func (o *OutcomeFlagSplit) GetBase() OutcomeBaseFlag {
	if o == nil {
		return OutcomeBaseFlag{}
	}
	return o.Base
}

func (o *OutcomeFlagSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *OutcomeFlagSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type OutcomeTypeFlagVariant string

const (
	OutcomeTypeFlagVariantVariant OutcomeTypeFlagVariant = "variant"
)

func (e OutcomeTypeFlagVariant) ToPointer() *OutcomeTypeFlagVariant {
	return &e
}
func (e *OutcomeTypeFlagVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = OutcomeTypeFlagVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OutcomeTypeFlagVariant: %v", v)
	}
}

type OutcomeFlagVariant struct {
	Type      OutcomeTypeFlagVariant `json:"type"`
	VariantID string                 `json:"variantId"`
}

func (o OutcomeFlagVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *OutcomeFlagVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *OutcomeFlagVariant) GetType() OutcomeTypeFlagVariant {
	if o == nil {
		return OutcomeTypeFlagVariant("")
	}
	return o.Type
}

func (o *OutcomeFlagVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type OutcomeFlagUnionType string

const (
	OutcomeFlagUnionTypeVariant OutcomeFlagUnionType = "variant"
	OutcomeFlagUnionTypeSplit   OutcomeFlagUnionType = "split"
)

type OutcomeFlagUnion struct {
	OutcomeFlagVariant *OutcomeFlagVariant `queryParam:"inline"`
	OutcomeFlagSplit   *OutcomeFlagSplit   `queryParam:"inline"`

	Type OutcomeFlagUnionType
}

func CreateOutcomeFlagUnionVariant(variant OutcomeFlagVariant) OutcomeFlagUnion {
	typ := OutcomeFlagUnionTypeVariant

	typStr := OutcomeTypeFlagVariant(typ)
	variant.Type = typStr

	return OutcomeFlagUnion{
		OutcomeFlagVariant: &variant,
		Type:               typ,
	}
}

func CreateOutcomeFlagUnionSplit(split OutcomeFlagSplit) OutcomeFlagUnion {
	typ := OutcomeFlagUnionTypeSplit

	typStr := OutcomeTypeFlagSplit(typ)
	split.Type = typStr

	return OutcomeFlagUnion{
		OutcomeFlagSplit: &split,
		Type:             typ,
	}
}

func (u *OutcomeFlagUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		outcomeFlagVariant := new(OutcomeFlagVariant)
		if err := utils.UnmarshalJSON(data, &outcomeFlagVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type OutcomeFlagVariant within OutcomeFlagUnion: %w", string(data), err)
		}

		u.OutcomeFlagVariant = outcomeFlagVariant
		u.Type = OutcomeFlagUnionTypeVariant
		return nil
	case "split":
		outcomeFlagSplit := new(OutcomeFlagSplit)
		if err := utils.UnmarshalJSON(data, &outcomeFlagSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type OutcomeFlagSplit within OutcomeFlagUnion: %w", string(data), err)
		}

		u.OutcomeFlagSplit = outcomeFlagSplit
		u.Type = OutcomeFlagUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OutcomeFlagUnion", string(data))
}

func (u OutcomeFlagUnion) MarshalJSON() ([]byte, error) {
	if u.OutcomeFlagVariant != nil {
		return utils.MarshalJSON(u.OutcomeFlagVariant, "", true)
	}

	if u.OutcomeFlagSplit != nil {
		return utils.MarshalJSON(u.OutcomeFlagSplit, "", true)
	}

	return nil, errors.New("could not marshal union type OutcomeFlagUnion: all fields are null")
}

type TypeFlagRegex string

const (
	TypeFlagRegexRegex TypeFlagRegex = "regex"
)

func (e TypeFlagRegex) ToPointer() *TypeFlagRegex {
	return &e
}
func (e *TypeFlagRegex) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		*e = TypeFlagRegex(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeFlagRegex: %v", v)
	}
}

type RHSFlagRegex struct {
	Type    TypeFlagRegex `json:"type"`
	Pattern string        `json:"pattern"`
	Flags   string        `json:"flags"`
}

func (r RHSFlagRegex) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RHSFlagRegex) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *RHSFlagRegex) GetType() TypeFlagRegex {
	if o == nil {
		return TypeFlagRegex("")
	}
	return o.Type
}

func (o *RHSFlagRegex) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *RHSFlagRegex) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type RHSTypeFlag string

const (
	RHSTypeFlagListInline RHSTypeFlag = "list/inline"
	RHSTypeFlagList       RHSTypeFlag = "list"
)

func (e RHSTypeFlag) ToPointer() *RHSTypeFlag {
	return &e
}
func (e *RHSTypeFlag) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = RHSTypeFlag(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RHSTypeFlag: %v", v)
	}
}

type ItemFlag2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (i ItemFlag2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *ItemFlag2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *ItemFlag2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *ItemFlag2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *ItemFlag2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type ItemFlag1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (i ItemFlag1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *ItemFlag1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *ItemFlag1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *ItemFlag1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *ItemFlag1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type ItemFlagUnionType string

const (
	ItemFlagUnionTypeItemFlag1 ItemFlagUnionType = "item_Flag_1"
	ItemFlagUnionTypeItemFlag2 ItemFlagUnionType = "item_Flag_2"
)

type ItemFlagUnion struct {
	ItemFlag1 *ItemFlag1 `queryParam:"inline"`
	ItemFlag2 *ItemFlag2 `queryParam:"inline"`

	Type ItemFlagUnionType
}

func CreateItemFlagUnionItemFlag1(itemFlag1 ItemFlag1) ItemFlagUnion {
	typ := ItemFlagUnionTypeItemFlag1

	return ItemFlagUnion{
		ItemFlag1: &itemFlag1,
		Type:      typ,
	}
}

func CreateItemFlagUnionItemFlag2(itemFlag2 ItemFlag2) ItemFlagUnion {
	typ := ItemFlagUnionTypeItemFlag2

	return ItemFlagUnion{
		ItemFlag2: &itemFlag2,
		Type:      typ,
	}
}

func (u *ItemFlagUnion) UnmarshalJSON(data []byte) error {

	var itemFlag1 ItemFlag1 = ItemFlag1{}
	if err := utils.UnmarshalJSON(data, &itemFlag1, "", true, nil); err == nil {
		u.ItemFlag1 = &itemFlag1
		u.Type = ItemFlagUnionTypeItemFlag1
		return nil
	}

	var itemFlag2 ItemFlag2 = ItemFlag2{}
	if err := utils.UnmarshalJSON(data, &itemFlag2, "", true, nil); err == nil {
		u.ItemFlag2 = &itemFlag2
		u.Type = ItemFlagUnionTypeItemFlag2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ItemFlagUnion", string(data))
}

func (u ItemFlagUnion) MarshalJSON() ([]byte, error) {
	if u.ItemFlag1 != nil {
		return utils.MarshalJSON(u.ItemFlag1, "", true)
	}

	if u.ItemFlag2 != nil {
		return utils.MarshalJSON(u.ItemFlag2, "", true)
	}

	return nil, errors.New("could not marshal union type ItemFlagUnion: all fields are null")
}

type RHSFlag struct {
	Type  RHSTypeFlag     `json:"type"`
	Items []ItemFlagUnion `json:"items"`
}

func (r RHSFlag) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RHSFlag) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *RHSFlag) GetType() RHSTypeFlag {
	if o == nil {
		return RHSTypeFlag("")
	}
	return o.Type
}

func (o *RHSFlag) GetItems() []ItemFlagUnion {
	if o == nil {
		return []ItemFlagUnion{}
	}
	return o.Items
}

type RHSFlagUnionType string

const (
	RHSFlagUnionTypeStr          RHSFlagUnionType = "str"
	RHSFlagUnionTypeNumber       RHSFlagUnionType = "number"
	RHSFlagUnionTypeRHSFlag      RHSFlagUnionType = "rhs_Flag"
	RHSFlagUnionTypeRHSFlagRegex RHSFlagUnionType = "rhs_Flag_Regex"
	RHSFlagUnionTypeBoolean      RHSFlagUnionType = "boolean"
)

type RHSFlagUnion struct {
	Str          *string       `queryParam:"inline"`
	Number       *float64      `queryParam:"inline"`
	RHSFlag      *RHSFlag      `queryParam:"inline"`
	RHSFlagRegex *RHSFlagRegex `queryParam:"inline"`
	Boolean      *bool         `queryParam:"inline"`

	Type RHSFlagUnionType
}

func CreateRHSFlagUnionStr(str string) RHSFlagUnion {
	typ := RHSFlagUnionTypeStr

	return RHSFlagUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateRHSFlagUnionNumber(number float64) RHSFlagUnion {
	typ := RHSFlagUnionTypeNumber

	return RHSFlagUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateRHSFlagUnionRHSFlag(rhsFlag RHSFlag) RHSFlagUnion {
	typ := RHSFlagUnionTypeRHSFlag

	return RHSFlagUnion{
		RHSFlag: &rhsFlag,
		Type:    typ,
	}
}

func CreateRHSFlagUnionRHSFlagRegex(rhsFlagRegex RHSFlagRegex) RHSFlagUnion {
	typ := RHSFlagUnionTypeRHSFlagRegex

	return RHSFlagUnion{
		RHSFlagRegex: &rhsFlagRegex,
		Type:         typ,
	}
}

func CreateRHSFlagUnionBoolean(boolean bool) RHSFlagUnion {
	typ := RHSFlagUnionTypeBoolean

	return RHSFlagUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *RHSFlagUnion) UnmarshalJSON(data []byte) error {

	var rhsFlagRegex RHSFlagRegex = RHSFlagRegex{}
	if err := utils.UnmarshalJSON(data, &rhsFlagRegex, "", true, nil); err == nil {
		u.RHSFlagRegex = &rhsFlagRegex
		u.Type = RHSFlagUnionTypeRHSFlagRegex
		return nil
	}

	var rhsFlag RHSFlag = RHSFlag{}
	if err := utils.UnmarshalJSON(data, &rhsFlag, "", true, nil); err == nil {
		u.RHSFlag = &rhsFlag
		u.Type = RHSFlagUnionTypeRHSFlag
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = RHSFlagUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = RHSFlagUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = RHSFlagUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for RHSFlagUnion", string(data))
}

func (u RHSFlagUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.RHSFlag != nil {
		return utils.MarshalJSON(u.RHSFlag, "", true)
	}

	if u.RHSFlagRegex != nil {
		return utils.MarshalJSON(u.RHSFlagRegex, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type RHSFlagUnion: all fields are null")
}

type LHSTypeFlagEntity string

const (
	LHSTypeFlagEntityEntity LHSTypeFlagEntity = "entity"
)

func (e LHSTypeFlagEntity) ToPointer() *LHSTypeFlagEntity {
	return &e
}
func (e *LHSTypeFlagEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = LHSTypeFlagEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LHSTypeFlagEntity: %v", v)
	}
}

type LHSFlagEntity struct {
	Type      LHSTypeFlagEntity `json:"type"`
	Kind      string            `json:"kind"`
	Attribute string            `json:"attribute"`
}

func (l LHSFlagEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LHSFlagEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *LHSFlagEntity) GetType() LHSTypeFlagEntity {
	if o == nil {
		return LHSTypeFlagEntity("")
	}
	return o.Type
}

func (o *LHSFlagEntity) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *LHSFlagEntity) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type TypeFlagSegment string

const (
	TypeFlagSegmentSegment TypeFlagSegment = "segment"
)

func (e TypeFlagSegment) ToPointer() *TypeFlagSegment {
	return &e
}
func (e *TypeFlagSegment) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "segment":
		*e = TypeFlagSegment(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TypeFlagSegment: %v", v)
	}
}

type LHSFlagSegment struct {
	Type TypeFlagSegment `json:"type"`
}

func (l LHSFlagSegment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LHSFlagSegment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *LHSFlagSegment) GetType() TypeFlagSegment {
	if o == nil {
		return TypeFlagSegment("")
	}
	return o.Type
}

type LHSFlagUnionType string

const (
	LHSFlagUnionTypeSegment LHSFlagUnionType = "segment"
	LHSFlagUnionTypeEntity  LHSFlagUnionType = "entity"
)

type LHSFlagUnion struct {
	LHSFlagSegment *LHSFlagSegment `queryParam:"inline"`
	LHSFlagEntity  *LHSFlagEntity  `queryParam:"inline"`

	Type LHSFlagUnionType
}

func CreateLHSFlagUnionSegment(segment LHSFlagSegment) LHSFlagUnion {
	typ := LHSFlagUnionTypeSegment

	typStr := TypeFlagSegment(typ)
	segment.Type = typStr

	return LHSFlagUnion{
		LHSFlagSegment: &segment,
		Type:           typ,
	}
}

func CreateLHSFlagUnionEntity(entity LHSFlagEntity) LHSFlagUnion {
	typ := LHSFlagUnionTypeEntity

	typStr := LHSTypeFlagEntity(typ)
	entity.Type = typStr

	return LHSFlagUnion{
		LHSFlagEntity: &entity,
		Type:          typ,
	}
}

func (u *LHSFlagUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "segment":
		lhsFlagSegment := new(LHSFlagSegment)
		if err := utils.UnmarshalJSON(data, &lhsFlagSegment, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == segment) type LHSFlagSegment within LHSFlagUnion: %w", string(data), err)
		}

		u.LHSFlagSegment = lhsFlagSegment
		u.Type = LHSFlagUnionTypeSegment
		return nil
	case "entity":
		lhsFlagEntity := new(LHSFlagEntity)
		if err := utils.UnmarshalJSON(data, &lhsFlagEntity, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == entity) type LHSFlagEntity within LHSFlagUnion: %w", string(data), err)
		}

		u.LHSFlagEntity = lhsFlagEntity
		u.Type = LHSFlagUnionTypeEntity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LHSFlagUnion", string(data))
}

func (u LHSFlagUnion) MarshalJSON() ([]byte, error) {
	if u.LHSFlagSegment != nil {
		return utils.MarshalJSON(u.LHSFlagSegment, "", true)
	}

	if u.LHSFlagEntity != nil {
		return utils.MarshalJSON(u.LHSFlagEntity, "", true)
	}

	return nil, errors.New("could not marshal union type LHSFlagUnion: all fields are null")
}

type CmpFlag string

const (
	CmpFlagEq             CmpFlag = "eq"
	CmpFlagNotEq          CmpFlag = "!eq"
	CmpFlagOneOf          CmpFlag = "oneOf"
	CmpFlagNotOneOf       CmpFlag = "!oneOf"
	CmpFlagContainsAllOf  CmpFlag = "containsAllOf"
	CmpFlagContainsAnyOf  CmpFlag = "containsAnyOf"
	CmpFlagContainsNoneOf CmpFlag = "containsNoneOf"
	CmpFlagStartsWith     CmpFlag = "startsWith"
	CmpFlagNotStartsWith  CmpFlag = "!startsWith"
	CmpFlagEndsWith       CmpFlag = "endsWith"
	CmpFlagNotEndsWith    CmpFlag = "!endsWith"
	CmpFlagEx             CmpFlag = "ex"
	CmpFlagNotEx          CmpFlag = "!ex"
	CmpFlagGt             CmpFlag = "gt"
	CmpFlagGte            CmpFlag = "gte"
	CmpFlagLt             CmpFlag = "lt"
	CmpFlagLte            CmpFlag = "lte"
	CmpFlagRegex          CmpFlag = "regex"
	CmpFlagNotRegex       CmpFlag = "!regex"
	CmpFlagBefore         CmpFlag = "before"
	CmpFlagAfter          CmpFlag = "after"
)

func (e CmpFlag) ToPointer() *CmpFlag {
	return &e
}
func (e *CmpFlag) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = CmpFlag(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CmpFlag: %v", v)
	}
}

type ConditionFlag struct {
	RHS *RHSFlagUnion `json:"rhs,omitempty"`
	LHS LHSFlagUnion  `json:"lhs"`
	Cmp CmpFlag       `json:"cmp"`
}

func (o *ConditionFlag) GetRHS() *RHSFlagUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

func (o *ConditionFlag) GetLHS() LHSFlagUnion {
	if o == nil {
		return LHSFlagUnion{}
	}
	return o.LHS
}

func (o *ConditionFlag) GetLHSSegment() *LHSFlagSegment {
	return o.GetLHS().LHSFlagSegment
}

func (o *ConditionFlag) GetLHSEntity() *LHSFlagEntity {
	return o.GetLHS().LHSFlagEntity
}

func (o *ConditionFlag) GetCmp() CmpFlag {
	if o == nil {
		return CmpFlag("")
	}
	return o.Cmp
}

type RuleFlag struct {
	ID         string           `json:"id"`
	Outcome    OutcomeFlagUnion `json:"outcome"`
	Conditions []ConditionFlag  `json:"conditions"`
}

func (o *RuleFlag) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *RuleFlag) GetOutcome() OutcomeFlagUnion {
	if o == nil {
		return OutcomeFlagUnion{}
	}
	return o.Outcome
}

func (o *RuleFlag) GetOutcomeVariant() *OutcomeFlagVariant {
	return o.GetOutcome().OutcomeFlagVariant
}

func (o *RuleFlag) GetOutcomeSplit() *OutcomeFlagSplit {
	return o.GetOutcome().OutcomeFlagSplit
}

func (o *RuleFlag) GetConditions() []ConditionFlag {
	if o == nil {
		return []ConditionFlag{}
	}
	return o.Conditions
}

type EnvironmentsFlag struct {
	Reuse         *ReuseFlag                                    `json:"reuse,omitempty"`
	Targets       map[string]map[string]map[string][]TargetFlag `json:"targets,omitempty"`
	Revision      *float64                                      `json:"revision,omitempty"`
	PausedOutcome PausedOutcomeFlag                             `json:"pausedOutcome"`
	Fallthrough   FallthroughFlagUnion                          `json:"fallthrough"`
	Active        bool                                          `json:"active"`
	Rules         []RuleFlag                                    `json:"rules"`
}

func (o *EnvironmentsFlag) GetReuse() *ReuseFlag {
	if o == nil {
		return nil
	}
	return o.Reuse
}

func (o *EnvironmentsFlag) GetTargets() map[string]map[string]map[string][]TargetFlag {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *EnvironmentsFlag) GetRevision() *float64 {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *EnvironmentsFlag) GetPausedOutcome() PausedOutcomeFlag {
	if o == nil {
		return PausedOutcomeFlag{}
	}
	return o.PausedOutcome
}

func (o *EnvironmentsFlag) GetFallthrough() FallthroughFlagUnion {
	if o == nil {
		return FallthroughFlagUnion{}
	}
	return o.Fallthrough
}

func (o *EnvironmentsFlag) GetFallthroughVariant() *FallthroughFlagVariant {
	return o.GetFallthrough().FallthroughFlagVariant
}

func (o *EnvironmentsFlag) GetFallthroughSplit() *FallthroughFlagSplit {
	return o.GetFallthrough().FallthroughFlagSplit
}

func (o *EnvironmentsFlag) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *EnvironmentsFlag) GetRules() []RuleFlag {
	if o == nil {
		return []RuleFlag{}
	}
	return o.Rules
}

type KindFlag string

const (
	KindFlagString  KindFlag = "string"
	KindFlagNumber  KindFlag = "number"
	KindFlagBoolean KindFlag = "boolean"
)

func (e KindFlag) ToPointer() *KindFlag {
	return &e
}
func (e *KindFlag) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "string":
		fallthrough
	case "number":
		fallthrough
	case "boolean":
		*e = KindFlag(v)
		return nil
	default:
		return fmt.Errorf("invalid value for KindFlag: %v", v)
	}
}

type StateFlag string

const (
	StateFlagActive   StateFlag = "active"
	StateFlagArchived StateFlag = "archived"
)

func (e StateFlag) ToPointer() *StateFlag {
	return &e
}
func (e *StateFlag) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "archived":
		*e = StateFlag(v)
		return nil
	default:
		return fmt.Errorf("invalid value for StateFlag: %v", v)
	}
}

type CreateFlagTypeName string

const (
	CreateFlagTypeNameFlag CreateFlagTypeName = "flag"
)

func (e CreateFlagTypeName) ToPointer() *CreateFlagTypeName {
	return &e
}
func (e *CreateFlagTypeName) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flag":
		*e = CreateFlagTypeName(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CreateFlagTypeName: %v", v)
	}
}

type CreateFlagResponseBody struct {
	Description  *string                     `json:"description,omitempty"`
	Variants     []VariantFlag               `json:"variants"`
	ID           string                      `json:"id"`
	Environments map[string]EnvironmentsFlag `json:"environments"`
	Kind         KindFlag                    `json:"kind"`
	Revision     float64                     `json:"revision"`
	Seed         float64                     `json:"seed"`
	State        StateFlag                   `json:"state"`
	Slug         string                      `json:"slug"`
	CreatedAt    float64                     `json:"createdAt"`
	UpdatedAt    float64                     `json:"updatedAt"`
	CreatedBy    string                      `json:"createdBy"`
	OwnerID      string                      `json:"ownerId"`
	ProjectID    string                      `json:"projectId"`
	TypeName     CreateFlagTypeName          `json:"typeName"`
}

func (o *CreateFlagResponseBody) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *CreateFlagResponseBody) GetVariants() []VariantFlag {
	if o == nil {
		return []VariantFlag{}
	}
	return o.Variants
}

func (o *CreateFlagResponseBody) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *CreateFlagResponseBody) GetEnvironments() map[string]EnvironmentsFlag {
	if o == nil {
		return map[string]EnvironmentsFlag{}
	}
	return o.Environments
}

func (o *CreateFlagResponseBody) GetKind() KindFlag {
	if o == nil {
		return KindFlag("")
	}
	return o.Kind
}

func (o *CreateFlagResponseBody) GetRevision() float64 {
	if o == nil {
		return 0.0
	}
	return o.Revision
}

func (o *CreateFlagResponseBody) GetSeed() float64 {
	if o == nil {
		return 0.0
	}
	return o.Seed
}

func (o *CreateFlagResponseBody) GetState() StateFlag {
	if o == nil {
		return StateFlag("")
	}
	return o.State
}

func (o *CreateFlagResponseBody) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *CreateFlagResponseBody) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *CreateFlagResponseBody) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *CreateFlagResponseBody) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *CreateFlagResponseBody) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *CreateFlagResponseBody) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *CreateFlagResponseBody) GetTypeName() CreateFlagTypeName {
	if o == nil {
		return CreateFlagTypeName("")
	}
	return o.TypeName
}

type CreateFlagResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *CreateFlagResponseBody
}

func (o *CreateFlagResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *CreateFlagResponse) GetObject() *CreateFlagResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
