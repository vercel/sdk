// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type GetAllLogDrainsRequest struct {
	ProjectID       *string `queryParam:"style=form,explode=true,name=projectId"`
	IncludeMetadata *bool   `default:"false" queryParam:"style=form,explode=true,name=includeMetadata"`
	ProjectIDOrName *string `queryParam:"style=form,explode=true,name=projectIdOrName"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (g GetAllLogDrainsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsRequest) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *GetAllLogDrainsRequest) GetIncludeMetadata() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeMetadata
}

func (o *GetAllLogDrainsRequest) GetProjectIDOrName() *string {
	if o == nil {
		return nil
	}
	return o.ProjectIDOrName
}

func (o *GetAllLogDrainsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetAllLogDrainsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type GetAllLogDrainsFramework string

const (
	GetAllLogDrainsFrameworkBlitzjs        GetAllLogDrainsFramework = "blitzjs"
	GetAllLogDrainsFrameworkNextjs         GetAllLogDrainsFramework = "nextjs"
	GetAllLogDrainsFrameworkGatsby         GetAllLogDrainsFramework = "gatsby"
	GetAllLogDrainsFrameworkRemix          GetAllLogDrainsFramework = "remix"
	GetAllLogDrainsFrameworkReactRouter    GetAllLogDrainsFramework = "react-router"
	GetAllLogDrainsFrameworkAstro          GetAllLogDrainsFramework = "astro"
	GetAllLogDrainsFrameworkHexo           GetAllLogDrainsFramework = "hexo"
	GetAllLogDrainsFrameworkEleventy       GetAllLogDrainsFramework = "eleventy"
	GetAllLogDrainsFrameworkDocusaurus2    GetAllLogDrainsFramework = "docusaurus-2"
	GetAllLogDrainsFrameworkDocusaurus     GetAllLogDrainsFramework = "docusaurus"
	GetAllLogDrainsFrameworkPreact         GetAllLogDrainsFramework = "preact"
	GetAllLogDrainsFrameworkSolidstart1    GetAllLogDrainsFramework = "solidstart-1"
	GetAllLogDrainsFrameworkSolidstart     GetAllLogDrainsFramework = "solidstart"
	GetAllLogDrainsFrameworkDojo           GetAllLogDrainsFramework = "dojo"
	GetAllLogDrainsFrameworkEmber          GetAllLogDrainsFramework = "ember"
	GetAllLogDrainsFrameworkVue            GetAllLogDrainsFramework = "vue"
	GetAllLogDrainsFrameworkScully         GetAllLogDrainsFramework = "scully"
	GetAllLogDrainsFrameworkIonicAngular   GetAllLogDrainsFramework = "ionic-angular"
	GetAllLogDrainsFrameworkAngular        GetAllLogDrainsFramework = "angular"
	GetAllLogDrainsFrameworkPolymer        GetAllLogDrainsFramework = "polymer"
	GetAllLogDrainsFrameworkSvelte         GetAllLogDrainsFramework = "svelte"
	GetAllLogDrainsFrameworkSveltekit      GetAllLogDrainsFramework = "sveltekit"
	GetAllLogDrainsFrameworkSveltekit1     GetAllLogDrainsFramework = "sveltekit-1"
	GetAllLogDrainsFrameworkIonicReact     GetAllLogDrainsFramework = "ionic-react"
	GetAllLogDrainsFrameworkCreateReactApp GetAllLogDrainsFramework = "create-react-app"
	GetAllLogDrainsFrameworkGridsome       GetAllLogDrainsFramework = "gridsome"
	GetAllLogDrainsFrameworkUmijs          GetAllLogDrainsFramework = "umijs"
	GetAllLogDrainsFrameworkSapper         GetAllLogDrainsFramework = "sapper"
	GetAllLogDrainsFrameworkSaber          GetAllLogDrainsFramework = "saber"
	GetAllLogDrainsFrameworkStencil        GetAllLogDrainsFramework = "stencil"
	GetAllLogDrainsFrameworkNuxtjs         GetAllLogDrainsFramework = "nuxtjs"
	GetAllLogDrainsFrameworkRedwoodjs      GetAllLogDrainsFramework = "redwoodjs"
	GetAllLogDrainsFrameworkHugo           GetAllLogDrainsFramework = "hugo"
	GetAllLogDrainsFrameworkJekyll         GetAllLogDrainsFramework = "jekyll"
	GetAllLogDrainsFrameworkBrunch         GetAllLogDrainsFramework = "brunch"
	GetAllLogDrainsFrameworkMiddleman      GetAllLogDrainsFramework = "middleman"
	GetAllLogDrainsFrameworkZola           GetAllLogDrainsFramework = "zola"
	GetAllLogDrainsFrameworkHydrogen       GetAllLogDrainsFramework = "hydrogen"
	GetAllLogDrainsFrameworkVite           GetAllLogDrainsFramework = "vite"
	GetAllLogDrainsFrameworkTanstackStart  GetAllLogDrainsFramework = "tanstack-start"
	GetAllLogDrainsFrameworkVitepress      GetAllLogDrainsFramework = "vitepress"
	GetAllLogDrainsFrameworkVuepress       GetAllLogDrainsFramework = "vuepress"
	GetAllLogDrainsFrameworkParcel         GetAllLogDrainsFramework = "parcel"
	GetAllLogDrainsFrameworkFastapi        GetAllLogDrainsFramework = "fastapi"
	GetAllLogDrainsFrameworkFlask          GetAllLogDrainsFramework = "flask"
	GetAllLogDrainsFrameworkFasthtml       GetAllLogDrainsFramework = "fasthtml"
	GetAllLogDrainsFrameworkSanityV3       GetAllLogDrainsFramework = "sanity-v3"
	GetAllLogDrainsFrameworkSanity         GetAllLogDrainsFramework = "sanity"
	GetAllLogDrainsFrameworkStorybook      GetAllLogDrainsFramework = "storybook"
	GetAllLogDrainsFrameworkNitro          GetAllLogDrainsFramework = "nitro"
	GetAllLogDrainsFrameworkHono           GetAllLogDrainsFramework = "hono"
	GetAllLogDrainsFrameworkExpress        GetAllLogDrainsFramework = "express"
	GetAllLogDrainsFrameworkH3             GetAllLogDrainsFramework = "h3"
	GetAllLogDrainsFrameworkNestjs         GetAllLogDrainsFramework = "nestjs"
	GetAllLogDrainsFrameworkElysia         GetAllLogDrainsFramework = "elysia"
	GetAllLogDrainsFrameworkFastify        GetAllLogDrainsFramework = "fastify"
	GetAllLogDrainsFrameworkXmcp           GetAllLogDrainsFramework = "xmcp"
)

func (e GetAllLogDrainsFramework) ToPointer() *GetAllLogDrainsFramework {
	return &e
}
func (e *GetAllLogDrainsFramework) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "react-router":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "tanstack-start":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fastapi":
		fallthrough
	case "flask":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		fallthrough
	case "nitro":
		fallthrough
	case "hono":
		fallthrough
	case "express":
		fallthrough
	case "h3":
		fallthrough
	case "nestjs":
		fallthrough
	case "elysia":
		fallthrough
	case "fastify":
		fallthrough
	case "xmcp":
		*e = GetAllLogDrainsFramework(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsFramework: %v", v)
	}
}

type GetAllLogDrainsProjectsMetadatum struct {
	ID               string                    `json:"id"`
	Name             string                    `json:"name"`
	Framework        *GetAllLogDrainsFramework `json:"framework,omitempty"`
	LatestDeployment *string                   `json:"latestDeployment,omitempty"`
}

func (g GetAllLogDrainsProjectsMetadatum) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsProjectsMetadatum) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsProjectsMetadatum) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetAllLogDrainsProjectsMetadatum) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetAllLogDrainsProjectsMetadatum) GetFramework() *GetAllLogDrainsFramework {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *GetAllLogDrainsProjectsMetadatum) GetLatestDeployment() *string {
	if o == nil {
		return nil
	}
	return o.LatestDeployment
}

type GetAllLogDrainsResponseBody2 struct {
	CreatedFrom                 string                             `json:"createdFrom"`
	ClientID                    *string                            `json:"clientId,omitempty"`
	ConfigurationID             *string                            `json:"configurationId,omitempty"`
	ProjectsMetadata            []GetAllLogDrainsProjectsMetadatum `json:"projectsMetadata,omitempty"`
	IntegrationIcon             *string                            `json:"integrationIcon,omitempty"`
	IntegrationConfigurationURI *string                            `json:"integrationConfigurationUri,omitempty"`
	IntegrationWebsite          *string                            `json:"integrationWebsite,omitempty"`
}

func (g GetAllLogDrainsResponseBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsResponseBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"createdFrom"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsResponseBody2) GetCreatedFrom() string {
	if o == nil {
		return ""
	}
	return o.CreatedFrom
}

func (o *GetAllLogDrainsResponseBody2) GetClientID() *string {
	if o == nil {
		return nil
	}
	return o.ClientID
}

func (o *GetAllLogDrainsResponseBody2) GetConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConfigurationID
}

func (o *GetAllLogDrainsResponseBody2) GetProjectsMetadata() []GetAllLogDrainsProjectsMetadatum {
	if o == nil {
		return nil
	}
	return o.ProjectsMetadata
}

func (o *GetAllLogDrainsResponseBody2) GetIntegrationIcon() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationIcon
}

func (o *GetAllLogDrainsResponseBody2) GetIntegrationConfigurationURI() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationConfigurationURI
}

func (o *GetAllLogDrainsResponseBody2) GetIntegrationWebsite() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationWebsite
}

type GetAllLogDrainsSchemasLog2 struct {
}

func (g GetAllLogDrainsSchemasLog2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSchemasLog2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsTrace2 struct {
}

func (g GetAllLogDrainsTrace2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsTrace2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsAnalytics2 struct {
}

func (g GetAllLogDrainsAnalytics2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsAnalytics2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsSpeedInsights2 struct {
}

func (g GetAllLogDrainsSpeedInsights2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSpeedInsights2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsSchemas2 struct {
	Log           *GetAllLogDrainsSchemasLog2    `json:"log,omitempty"`
	Trace         *GetAllLogDrainsTrace2         `json:"trace,omitempty"`
	Analytics     *GetAllLogDrainsAnalytics2     `json:"analytics,omitempty"`
	SpeedInsights *GetAllLogDrainsSpeedInsights2 `json:"speed_insights,omitempty"`
}

func (g GetAllLogDrainsSchemas2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSchemas2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSchemas2) GetLog() *GetAllLogDrainsSchemasLog2 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetAllLogDrainsSchemas2) GetTrace() *GetAllLogDrainsTrace2 {
	if o == nil {
		return nil
	}
	return o.Trace
}

func (o *GetAllLogDrainsSchemas2) GetAnalytics() *GetAllLogDrainsAnalytics2 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetAllLogDrainsSchemas2) GetSpeedInsights() *GetAllLogDrainsSpeedInsights2 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

type GetAllLogDrainsTypeInternal2 string

const (
	GetAllLogDrainsTypeInternal2Internal GetAllLogDrainsTypeInternal2 = "internal"
)

func (e GetAllLogDrainsTypeInternal2) ToPointer() *GetAllLogDrainsTypeInternal2 {
	return &e
}
func (e *GetAllLogDrainsTypeInternal2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internal":
		*e = GetAllLogDrainsTypeInternal2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeInternal2: %v", v)
	}
}

type GetAllLogDrainsTarget2 string

const (
	GetAllLogDrainsTarget2VercelOtelTracesDb GetAllLogDrainsTarget2 = "vercel-otel-traces-db"
)

func (e GetAllLogDrainsTarget2) ToPointer() *GetAllLogDrainsTarget2 {
	return &e
}
func (e *GetAllLogDrainsTarget2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "vercel-otel-traces-db":
		*e = GetAllLogDrainsTarget2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTarget2: %v", v)
	}
}

type GetAllLogDrainsDeliveryVercelOtelTracesDb2 struct {
	Type   GetAllLogDrainsTypeInternal2 `json:"type"`
	Target GetAllLogDrainsTarget2       `json:"target"`
}

func (g GetAllLogDrainsDeliveryVercelOtelTracesDb2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryVercelOtelTracesDb2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryVercelOtelTracesDb2) GetType() GetAllLogDrainsTypeInternal2 {
	if o == nil {
		return GetAllLogDrainsTypeInternal2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryVercelOtelTracesDb2) GetTarget() GetAllLogDrainsTarget2 {
	if o == nil {
		return GetAllLogDrainsTarget2("")
	}
	return o.Target
}

type GetAllLogDrainsTypeClickhouse2 string

const (
	GetAllLogDrainsTypeClickhouse2Clickhouse GetAllLogDrainsTypeClickhouse2 = "clickhouse"
)

func (e GetAllLogDrainsTypeClickhouse2) ToPointer() *GetAllLogDrainsTypeClickhouse2 {
	return &e
}
func (e *GetAllLogDrainsTypeClickhouse2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "clickhouse":
		*e = GetAllLogDrainsTypeClickhouse2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeClickhouse2: %v", v)
	}
}

type GetAllLogDrainsDeliveryClickhouse2 struct {
	Type     GetAllLogDrainsTypeClickhouse2 `json:"type"`
	Endpoint string                         `json:"endpoint"`
	Table    string                         `json:"table"`
}

func (g GetAllLogDrainsDeliveryClickhouse2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryClickhouse2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "table"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryClickhouse2) GetType() GetAllLogDrainsTypeClickhouse2 {
	if o == nil {
		return GetAllLogDrainsTypeClickhouse2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryClickhouse2) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryClickhouse2) GetTable() string {
	if o == nil {
		return ""
	}
	return o.Table
}

type GetAllLogDrainsTypeOtlphttp2 string

const (
	GetAllLogDrainsTypeOtlphttp2Otlphttp GetAllLogDrainsTypeOtlphttp2 = "otlphttp"
)

func (e GetAllLogDrainsTypeOtlphttp2) ToPointer() *GetAllLogDrainsTypeOtlphttp2 {
	return &e
}
func (e *GetAllLogDrainsTypeOtlphttp2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "otlphttp":
		*e = GetAllLogDrainsTypeOtlphttp2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeOtlphttp2: %v", v)
	}
}

type GetAllLogDrainsEndpoint2 struct {
	Traces string `json:"traces"`
}

func (g GetAllLogDrainsEndpoint2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsEndpoint2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"traces"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsEndpoint2) GetTraces() string {
	if o == nil {
		return ""
	}
	return o.Traces
}

type GetAllLogDrainsEncoding4 string

const (
	GetAllLogDrainsEncoding4JSON  GetAllLogDrainsEncoding4 = "json"
	GetAllLogDrainsEncoding4Proto GetAllLogDrainsEncoding4 = "proto"
)

func (e GetAllLogDrainsEncoding4) ToPointer() *GetAllLogDrainsEncoding4 {
	return &e
}
func (e *GetAllLogDrainsEncoding4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "proto":
		*e = GetAllLogDrainsEncoding4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEncoding4: %v", v)
	}
}

type GetAllLogDrainsSecretKind4 string

const (
	GetAllLogDrainsSecretKind4IntegrationSecret GetAllLogDrainsSecretKind4 = "INTEGRATION_SECRET"
)

func (e GetAllLogDrainsSecretKind4) ToPointer() *GetAllLogDrainsSecretKind4 {
	return &e
}
func (e *GetAllLogDrainsSecretKind4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetAllLogDrainsSecretKind4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsSecretKind4: %v", v)
	}
}

type GetAllLogDrainsSecretIntegrationSecret4 struct {
	Kind GetAllLogDrainsSecretKind4 `json:"kind"`
}

func (g GetAllLogDrainsSecretIntegrationSecret4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSecretIntegrationSecret4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSecretIntegrationSecret4) GetKind() GetAllLogDrainsSecretKind4 {
	if o == nil {
		return GetAllLogDrainsSecretKind4("")
	}
	return o.Kind
}

type GetAllLogDrainsSecretUnion4Type string

const (
	GetAllLogDrainsSecretUnion4TypeStr                                     GetAllLogDrainsSecretUnion4Type = "str"
	GetAllLogDrainsSecretUnion4TypeGetAllLogDrainsSecretIntegrationSecret4 GetAllLogDrainsSecretUnion4Type = "getAllLogDrains_secret_IntegrationSecret_4"
)

type GetAllLogDrainsSecretUnion4 struct {
	Str                                     *string                                  `queryParam:"inline"`
	GetAllLogDrainsSecretIntegrationSecret4 *GetAllLogDrainsSecretIntegrationSecret4 `queryParam:"inline"`

	Type GetAllLogDrainsSecretUnion4Type
}

func CreateGetAllLogDrainsSecretUnion4Str(str string) GetAllLogDrainsSecretUnion4 {
	typ := GetAllLogDrainsSecretUnion4TypeStr

	return GetAllLogDrainsSecretUnion4{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetAllLogDrainsSecretUnion4GetAllLogDrainsSecretIntegrationSecret4(getAllLogDrainsSecretIntegrationSecret4 GetAllLogDrainsSecretIntegrationSecret4) GetAllLogDrainsSecretUnion4 {
	typ := GetAllLogDrainsSecretUnion4TypeGetAllLogDrainsSecretIntegrationSecret4

	return GetAllLogDrainsSecretUnion4{
		GetAllLogDrainsSecretIntegrationSecret4: &getAllLogDrainsSecretIntegrationSecret4,
		Type:                                    typ,
	}
}

func (u *GetAllLogDrainsSecretUnion4) UnmarshalJSON(data []byte) error {

	var getAllLogDrainsSecretIntegrationSecret4 GetAllLogDrainsSecretIntegrationSecret4 = GetAllLogDrainsSecretIntegrationSecret4{}
	if err := utils.UnmarshalJSON(data, &getAllLogDrainsSecretIntegrationSecret4, "", true, nil); err == nil {
		u.GetAllLogDrainsSecretIntegrationSecret4 = &getAllLogDrainsSecretIntegrationSecret4
		u.Type = GetAllLogDrainsSecretUnion4TypeGetAllLogDrainsSecretIntegrationSecret4
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetAllLogDrainsSecretUnion4TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSecretUnion4", string(data))
}

func (u GetAllLogDrainsSecretUnion4) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetAllLogDrainsSecretIntegrationSecret4 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSecretIntegrationSecret4, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSecretUnion4: all fields are null")
}

type GetAllLogDrainsDeliveryOtlphttp2 struct {
	Type     GetAllLogDrainsTypeOtlphttp2 `json:"type"`
	Endpoint GetAllLogDrainsEndpoint2     `json:"endpoint"`
	Encoding GetAllLogDrainsEncoding4     `json:"encoding"`
	Headers  map[string]string            `json:"headers"`
	Secret   *GetAllLogDrainsSecretUnion4 `json:"secret,omitempty"`
}

func (g GetAllLogDrainsDeliveryOtlphttp2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryOtlphttp2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryOtlphttp2) GetType() GetAllLogDrainsTypeOtlphttp2 {
	if o == nil {
		return GetAllLogDrainsTypeOtlphttp2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryOtlphttp2) GetEndpoint() GetAllLogDrainsEndpoint2 {
	if o == nil {
		return GetAllLogDrainsEndpoint2{}
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryOtlphttp2) GetEncoding() GetAllLogDrainsEncoding4 {
	if o == nil {
		return GetAllLogDrainsEncoding4("")
	}
	return o.Encoding
}

func (o *GetAllLogDrainsDeliveryOtlphttp2) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetAllLogDrainsDeliveryOtlphttp2) GetSecret() *GetAllLogDrainsSecretUnion4 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetAllLogDrainsTypeHTTP2 string

const (
	GetAllLogDrainsTypeHTTP2HTTP GetAllLogDrainsTypeHTTP2 = "http"
)

func (e GetAllLogDrainsTypeHTTP2) ToPointer() *GetAllLogDrainsTypeHTTP2 {
	return &e
}
func (e *GetAllLogDrainsTypeHTTP2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = GetAllLogDrainsTypeHTTP2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeHTTP2: %v", v)
	}
}

type GetAllLogDrainsEncoding3 string

const (
	GetAllLogDrainsEncoding3JSON   GetAllLogDrainsEncoding3 = "json"
	GetAllLogDrainsEncoding3Ndjson GetAllLogDrainsEncoding3 = "ndjson"
)

func (e GetAllLogDrainsEncoding3) ToPointer() *GetAllLogDrainsEncoding3 {
	return &e
}
func (e *GetAllLogDrainsEncoding3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "ndjson":
		*e = GetAllLogDrainsEncoding3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEncoding3: %v", v)
	}
}

type GetAllLogDrainsCompression2 string

const (
	GetAllLogDrainsCompression2Gzip GetAllLogDrainsCompression2 = "gzip"
	GetAllLogDrainsCompression2None GetAllLogDrainsCompression2 = "none"
)

func (e GetAllLogDrainsCompression2) ToPointer() *GetAllLogDrainsCompression2 {
	return &e
}
func (e *GetAllLogDrainsCompression2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = GetAllLogDrainsCompression2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsCompression2: %v", v)
	}
}

type GetAllLogDrainsSecretKind3 string

const (
	GetAllLogDrainsSecretKind3IntegrationSecret GetAllLogDrainsSecretKind3 = "INTEGRATION_SECRET"
)

func (e GetAllLogDrainsSecretKind3) ToPointer() *GetAllLogDrainsSecretKind3 {
	return &e
}
func (e *GetAllLogDrainsSecretKind3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetAllLogDrainsSecretKind3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsSecretKind3: %v", v)
	}
}

type GetAllLogDrainsSecretIntegrationSecret3 struct {
	Kind GetAllLogDrainsSecretKind3 `json:"kind"`
}

func (g GetAllLogDrainsSecretIntegrationSecret3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSecretIntegrationSecret3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSecretIntegrationSecret3) GetKind() GetAllLogDrainsSecretKind3 {
	if o == nil {
		return GetAllLogDrainsSecretKind3("")
	}
	return o.Kind
}

type GetAllLogDrainsSecretUnion3Type string

const (
	GetAllLogDrainsSecretUnion3TypeStr                                     GetAllLogDrainsSecretUnion3Type = "str"
	GetAllLogDrainsSecretUnion3TypeGetAllLogDrainsSecretIntegrationSecret3 GetAllLogDrainsSecretUnion3Type = "getAllLogDrains_secret_IntegrationSecret_3"
)

type GetAllLogDrainsSecretUnion3 struct {
	Str                                     *string                                  `queryParam:"inline"`
	GetAllLogDrainsSecretIntegrationSecret3 *GetAllLogDrainsSecretIntegrationSecret3 `queryParam:"inline"`

	Type GetAllLogDrainsSecretUnion3Type
}

func CreateGetAllLogDrainsSecretUnion3Str(str string) GetAllLogDrainsSecretUnion3 {
	typ := GetAllLogDrainsSecretUnion3TypeStr

	return GetAllLogDrainsSecretUnion3{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetAllLogDrainsSecretUnion3GetAllLogDrainsSecretIntegrationSecret3(getAllLogDrainsSecretIntegrationSecret3 GetAllLogDrainsSecretIntegrationSecret3) GetAllLogDrainsSecretUnion3 {
	typ := GetAllLogDrainsSecretUnion3TypeGetAllLogDrainsSecretIntegrationSecret3

	return GetAllLogDrainsSecretUnion3{
		GetAllLogDrainsSecretIntegrationSecret3: &getAllLogDrainsSecretIntegrationSecret3,
		Type:                                    typ,
	}
}

func (u *GetAllLogDrainsSecretUnion3) UnmarshalJSON(data []byte) error {

	var getAllLogDrainsSecretIntegrationSecret3 GetAllLogDrainsSecretIntegrationSecret3 = GetAllLogDrainsSecretIntegrationSecret3{}
	if err := utils.UnmarshalJSON(data, &getAllLogDrainsSecretIntegrationSecret3, "", true, nil); err == nil {
		u.GetAllLogDrainsSecretIntegrationSecret3 = &getAllLogDrainsSecretIntegrationSecret3
		u.Type = GetAllLogDrainsSecretUnion3TypeGetAllLogDrainsSecretIntegrationSecret3
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetAllLogDrainsSecretUnion3TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSecretUnion3", string(data))
}

func (u GetAllLogDrainsSecretUnion3) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetAllLogDrainsSecretIntegrationSecret3 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSecretIntegrationSecret3, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSecretUnion3: all fields are null")
}

type GetAllLogDrainsDeliveryHTTP2 struct {
	Type        GetAllLogDrainsTypeHTTP2     `json:"type"`
	Endpoint    string                       `json:"endpoint"`
	Encoding    GetAllLogDrainsEncoding3     `json:"encoding"`
	Compression *GetAllLogDrainsCompression2 `json:"compression,omitempty"`
	Headers     map[string]string            `json:"headers"`
	Secret      *GetAllLogDrainsSecretUnion3 `json:"secret,omitempty"`
}

func (g GetAllLogDrainsDeliveryHTTP2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryHTTP2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetType() GetAllLogDrainsTypeHTTP2 {
	if o == nil {
		return GetAllLogDrainsTypeHTTP2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetEncoding() GetAllLogDrainsEncoding3 {
	if o == nil {
		return GetAllLogDrainsEncoding3("")
	}
	return o.Encoding
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetCompression() *GetAllLogDrainsCompression2 {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetAllLogDrainsDeliveryHTTP2) GetSecret() *GetAllLogDrainsSecretUnion3 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetAllLogDrainsDeliveryUnion2Type string

const (
	GetAllLogDrainsDeliveryUnion2TypeHTTP       GetAllLogDrainsDeliveryUnion2Type = "http"
	GetAllLogDrainsDeliveryUnion2TypeOtlphttp   GetAllLogDrainsDeliveryUnion2Type = "otlphttp"
	GetAllLogDrainsDeliveryUnion2TypeClickhouse GetAllLogDrainsDeliveryUnion2Type = "clickhouse"
	GetAllLogDrainsDeliveryUnion2TypeInternal   GetAllLogDrainsDeliveryUnion2Type = "internal"
)

type GetAllLogDrainsDeliveryUnion2 struct {
	GetAllLogDrainsDeliveryHTTP2               *GetAllLogDrainsDeliveryHTTP2               `queryParam:"inline"`
	GetAllLogDrainsDeliveryOtlphttp2           *GetAllLogDrainsDeliveryOtlphttp2           `queryParam:"inline"`
	GetAllLogDrainsDeliveryClickhouse2         *GetAllLogDrainsDeliveryClickhouse2         `queryParam:"inline"`
	GetAllLogDrainsDeliveryVercelOtelTracesDb2 *GetAllLogDrainsDeliveryVercelOtelTracesDb2 `queryParam:"inline"`

	Type GetAllLogDrainsDeliveryUnion2Type
}

func CreateGetAllLogDrainsDeliveryUnion2HTTP(http GetAllLogDrainsDeliveryHTTP2) GetAllLogDrainsDeliveryUnion2 {
	typ := GetAllLogDrainsDeliveryUnion2TypeHTTP

	typStr := GetAllLogDrainsTypeHTTP2(typ)
	http.Type = typStr

	return GetAllLogDrainsDeliveryUnion2{
		GetAllLogDrainsDeliveryHTTP2: &http,
		Type:                         typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion2Otlphttp(otlphttp GetAllLogDrainsDeliveryOtlphttp2) GetAllLogDrainsDeliveryUnion2 {
	typ := GetAllLogDrainsDeliveryUnion2TypeOtlphttp

	typStr := GetAllLogDrainsTypeOtlphttp2(typ)
	otlphttp.Type = typStr

	return GetAllLogDrainsDeliveryUnion2{
		GetAllLogDrainsDeliveryOtlphttp2: &otlphttp,
		Type:                             typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion2Clickhouse(clickhouse GetAllLogDrainsDeliveryClickhouse2) GetAllLogDrainsDeliveryUnion2 {
	typ := GetAllLogDrainsDeliveryUnion2TypeClickhouse

	typStr := GetAllLogDrainsTypeClickhouse2(typ)
	clickhouse.Type = typStr

	return GetAllLogDrainsDeliveryUnion2{
		GetAllLogDrainsDeliveryClickhouse2: &clickhouse,
		Type:                               typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion2Internal(internal GetAllLogDrainsDeliveryVercelOtelTracesDb2) GetAllLogDrainsDeliveryUnion2 {
	typ := GetAllLogDrainsDeliveryUnion2TypeInternal

	typStr := GetAllLogDrainsTypeInternal2(typ)
	internal.Type = typStr

	return GetAllLogDrainsDeliveryUnion2{
		GetAllLogDrainsDeliveryVercelOtelTracesDb2: &internal,
		Type: typ,
	}
}

func (u *GetAllLogDrainsDeliveryUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "http":
		getAllLogDrainsDeliveryHTTP2 := new(GetAllLogDrainsDeliveryHTTP2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryHTTP2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type GetAllLogDrainsDeliveryHTTP2 within GetAllLogDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryHTTP2 = getAllLogDrainsDeliveryHTTP2
		u.Type = GetAllLogDrainsDeliveryUnion2TypeHTTP
		return nil
	case "otlphttp":
		getAllLogDrainsDeliveryOtlphttp2 := new(GetAllLogDrainsDeliveryOtlphttp2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryOtlphttp2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == otlphttp) type GetAllLogDrainsDeliveryOtlphttp2 within GetAllLogDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryOtlphttp2 = getAllLogDrainsDeliveryOtlphttp2
		u.Type = GetAllLogDrainsDeliveryUnion2TypeOtlphttp
		return nil
	case "clickhouse":
		getAllLogDrainsDeliveryClickhouse2 := new(GetAllLogDrainsDeliveryClickhouse2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryClickhouse2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == clickhouse) type GetAllLogDrainsDeliveryClickhouse2 within GetAllLogDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryClickhouse2 = getAllLogDrainsDeliveryClickhouse2
		u.Type = GetAllLogDrainsDeliveryUnion2TypeClickhouse
		return nil
	case "internal":
		getAllLogDrainsDeliveryVercelOtelTracesDb2 := new(GetAllLogDrainsDeliveryVercelOtelTracesDb2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryVercelOtelTracesDb2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == internal) type GetAllLogDrainsDeliveryVercelOtelTracesDb2 within GetAllLogDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryVercelOtelTracesDb2 = getAllLogDrainsDeliveryVercelOtelTracesDb2
		u.Type = GetAllLogDrainsDeliveryUnion2TypeInternal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsDeliveryUnion2", string(data))
}

func (u GetAllLogDrainsDeliveryUnion2) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsDeliveryHTTP2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryHTTP2, "", true)
	}

	if u.GetAllLogDrainsDeliveryOtlphttp2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryOtlphttp2, "", true)
	}

	if u.GetAllLogDrainsDeliveryClickhouse2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryClickhouse2, "", true)
	}

	if u.GetAllLogDrainsDeliveryVercelOtelTracesDb2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryVercelOtelTracesDb2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsDeliveryUnion2: all fields are null")
}

type GetAllLogDrainsTypeHeadSampling2 string

const (
	GetAllLogDrainsTypeHeadSampling2HeadSampling GetAllLogDrainsTypeHeadSampling2 = "head_sampling"
)

func (e GetAllLogDrainsTypeHeadSampling2) ToPointer() *GetAllLogDrainsTypeHeadSampling2 {
	return &e
}
func (e *GetAllLogDrainsTypeHeadSampling2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "head_sampling":
		*e = GetAllLogDrainsTypeHeadSampling2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeHeadSampling2: %v", v)
	}
}

type GetAllLogDrainsEnv2 string

const (
	GetAllLogDrainsEnv2Production GetAllLogDrainsEnv2 = "production"
	GetAllLogDrainsEnv2Preview    GetAllLogDrainsEnv2 = "preview"
)

func (e GetAllLogDrainsEnv2) ToPointer() *GetAllLogDrainsEnv2 {
	return &e
}
func (e *GetAllLogDrainsEnv2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetAllLogDrainsEnv2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEnv2: %v", v)
	}
}

type GetAllLogDrainsSampling2 struct {
	Type        GetAllLogDrainsTypeHeadSampling2 `json:"type"`
	Rate        float64                          `json:"rate"`
	Env         *GetAllLogDrainsEnv2             `json:"env,omitempty"`
	RequestPath *string                          `json:"requestPath,omitempty"`
}

func (g GetAllLogDrainsSampling2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSampling2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "rate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSampling2) GetType() GetAllLogDrainsTypeHeadSampling2 {
	if o == nil {
		return GetAllLogDrainsTypeHeadSampling2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsSampling2) GetRate() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rate
}

func (o *GetAllLogDrainsSampling2) GetEnv() *GetAllLogDrainsEnv2 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetAllLogDrainsSampling2) GetRequestPath() *string {
	if o == nil {
		return nil
	}
	return o.RequestPath
}

type GetAllLogDrainsStatus2 string

const (
	GetAllLogDrainsStatus2Enabled  GetAllLogDrainsStatus2 = "enabled"
	GetAllLogDrainsStatus2Disabled GetAllLogDrainsStatus2 = "disabled"
	GetAllLogDrainsStatus2Errored  GetAllLogDrainsStatus2 = "errored"
)

func (e GetAllLogDrainsStatus2) ToPointer() *GetAllLogDrainsStatus2 {
	return &e
}
func (e *GetAllLogDrainsStatus2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		fallthrough
	case "errored":
		*e = GetAllLogDrainsStatus2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsStatus2: %v", v)
	}
}

type GetAllLogDrainsDisabledReason2 string

const (
	GetAllLogDrainsDisabledReason2DisabledByOwner      GetAllLogDrainsDisabledReason2 = "disabled-by-owner"
	GetAllLogDrainsDisabledReason2FeatureNotAvailable  GetAllLogDrainsDisabledReason2 = "feature-not-available"
	GetAllLogDrainsDisabledReason2AccountPlanDowngrade GetAllLogDrainsDisabledReason2 = "account-plan-downgrade"
	GetAllLogDrainsDisabledReason2DisabledByAdmin      GetAllLogDrainsDisabledReason2 = "disabled-by-admin"
)

func (e GetAllLogDrainsDisabledReason2) ToPointer() *GetAllLogDrainsDisabledReason2 {
	return &e
}
func (e *GetAllLogDrainsDisabledReason2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "account-plan-downgrade":
		fallthrough
	case "disabled-by-admin":
		*e = GetAllLogDrainsDisabledReason2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsDisabledReason2: %v", v)
	}
}

type GetAllLogDrainsKindIntegration2 string

const (
	GetAllLogDrainsKindIntegration2Integration GetAllLogDrainsKindIntegration2 = "integration"
)

func (e GetAllLogDrainsKindIntegration2) ToPointer() *GetAllLogDrainsKindIntegration2 {
	return &e
}
func (e *GetAllLogDrainsKindIntegration2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		*e = GetAllLogDrainsKindIntegration2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsKindIntegration2: %v", v)
	}
}

type GetAllLogDrainsSourceIntegration2 struct {
	Kind                       GetAllLogDrainsKindIntegration2 `json:"kind"`
	ResourceID                 *string                         `json:"resourceId,omitempty"`
	ExternalResourceID         *string                         `json:"externalResourceId,omitempty"`
	IntegrationID              string                          `json:"integrationId"`
	IntegrationConfigurationID string                          `json:"integrationConfigurationId"`
}

func (g GetAllLogDrainsSourceIntegration2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSourceIntegration2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind", "integrationId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSourceIntegration2) GetKind() GetAllLogDrainsKindIntegration2 {
	if o == nil {
		return GetAllLogDrainsKindIntegration2("")
	}
	return o.Kind
}

func (o *GetAllLogDrainsSourceIntegration2) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *GetAllLogDrainsSourceIntegration2) GetExternalResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalResourceID
}

func (o *GetAllLogDrainsSourceIntegration2) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetAllLogDrainsSourceIntegration2) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type GetAllLogDrainsKindSelfServed2 string

const (
	GetAllLogDrainsKindSelfServed2SelfServed GetAllLogDrainsKindSelfServed2 = "self-served"
)

func (e GetAllLogDrainsKindSelfServed2) ToPointer() *GetAllLogDrainsKindSelfServed2 {
	return &e
}
func (e *GetAllLogDrainsKindSelfServed2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "self-served":
		*e = GetAllLogDrainsKindSelfServed2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsKindSelfServed2: %v", v)
	}
}

type GetAllLogDrainsSourceSelfServed2 struct {
	Kind GetAllLogDrainsKindSelfServed2 `json:"kind"`
}

func (g GetAllLogDrainsSourceSelfServed2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSourceSelfServed2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSourceSelfServed2) GetKind() GetAllLogDrainsKindSelfServed2 {
	if o == nil {
		return GetAllLogDrainsKindSelfServed2("")
	}
	return o.Kind
}

type GetAllLogDrainsSourceUnion2Type string

const (
	GetAllLogDrainsSourceUnion2TypeSelfServed  GetAllLogDrainsSourceUnion2Type = "self-served"
	GetAllLogDrainsSourceUnion2TypeIntegration GetAllLogDrainsSourceUnion2Type = "integration"
)

type GetAllLogDrainsSourceUnion2 struct {
	GetAllLogDrainsSourceSelfServed2  *GetAllLogDrainsSourceSelfServed2  `queryParam:"inline"`
	GetAllLogDrainsSourceIntegration2 *GetAllLogDrainsSourceIntegration2 `queryParam:"inline"`

	Type GetAllLogDrainsSourceUnion2Type
}

func CreateGetAllLogDrainsSourceUnion2SelfServed(selfServed GetAllLogDrainsSourceSelfServed2) GetAllLogDrainsSourceUnion2 {
	typ := GetAllLogDrainsSourceUnion2TypeSelfServed

	typStr := GetAllLogDrainsKindSelfServed2(typ)
	selfServed.Kind = typStr

	return GetAllLogDrainsSourceUnion2{
		GetAllLogDrainsSourceSelfServed2: &selfServed,
		Type:                             typ,
	}
}

func CreateGetAllLogDrainsSourceUnion2Integration(integration GetAllLogDrainsSourceIntegration2) GetAllLogDrainsSourceUnion2 {
	typ := GetAllLogDrainsSourceUnion2TypeIntegration

	typStr := GetAllLogDrainsKindIntegration2(typ)
	integration.Kind = typStr

	return GetAllLogDrainsSourceUnion2{
		GetAllLogDrainsSourceIntegration2: &integration,
		Type:                              typ,
	}
}

func (u *GetAllLogDrainsSourceUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Kind string `json:"kind"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Kind {
	case "self-served":
		getAllLogDrainsSourceSelfServed2 := new(GetAllLogDrainsSourceSelfServed2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsSourceSelfServed2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == self-served) type GetAllLogDrainsSourceSelfServed2 within GetAllLogDrainsSourceUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsSourceSelfServed2 = getAllLogDrainsSourceSelfServed2
		u.Type = GetAllLogDrainsSourceUnion2TypeSelfServed
		return nil
	case "integration":
		getAllLogDrainsSourceIntegration2 := new(GetAllLogDrainsSourceIntegration2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsSourceIntegration2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == integration) type GetAllLogDrainsSourceIntegration2 within GetAllLogDrainsSourceUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsSourceIntegration2 = getAllLogDrainsSourceIntegration2
		u.Type = GetAllLogDrainsSourceUnion2TypeIntegration
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSourceUnion2", string(data))
}

func (u GetAllLogDrainsSourceUnion2) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsSourceSelfServed2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSourceSelfServed2, "", true)
	}

	if u.GetAllLogDrainsSourceIntegration2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSourceIntegration2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSourceUnion2: all fields are null")
}

type GetAllLogDrainsVersionV22 string

const (
	GetAllLogDrainsVersionV22V2 GetAllLogDrainsVersionV22 = "v2"
)

func (e GetAllLogDrainsVersionV22) ToPointer() *GetAllLogDrainsVersionV22 {
	return &e
}
func (e *GetAllLogDrainsVersionV22) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		*e = GetAllLogDrainsVersionV22(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsVersionV22: %v", v)
	}
}

type GetAllLogDrainsTypeOdata2 string

const (
	GetAllLogDrainsTypeOdata2Odata GetAllLogDrainsTypeOdata2 = "odata"
)

func (e GetAllLogDrainsTypeOdata2) ToPointer() *GetAllLogDrainsTypeOdata2 {
	return &e
}
func (e *GetAllLogDrainsTypeOdata2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "odata":
		*e = GetAllLogDrainsTypeOdata2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeOdata2: %v", v)
	}
}

type GetAllLogDrainsFilterOdata2 struct {
	Type GetAllLogDrainsTypeOdata2 `json:"type"`
	Text string                    `json:"text"`
}

func (g GetAllLogDrainsFilterOdata2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterOdata2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "text"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterOdata2) GetType() GetAllLogDrainsTypeOdata2 {
	if o == nil {
		return GetAllLogDrainsTypeOdata2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsFilterOdata2) GetText() string {
	if o == nil {
		return ""
	}
	return o.Text
}

type GetAllLogDrainsTypeBasic2 string

const (
	GetAllLogDrainsTypeBasic2Basic GetAllLogDrainsTypeBasic2 = "basic"
)

func (e GetAllLogDrainsTypeBasic2) ToPointer() *GetAllLogDrainsTypeBasic2 {
	return &e
}
func (e *GetAllLogDrainsTypeBasic2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = GetAllLogDrainsTypeBasic2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeBasic2: %v", v)
	}
}

type GetAllLogDrainsProject2 struct {
	Ids []string `json:"ids,omitempty"`
}

func (g GetAllLogDrainsProject2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsProject2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsProject2) GetIds() []string {
	if o == nil {
		return nil
	}
	return o.Ids
}

type GetAllLogDrainsFilterV2Source2 string

const (
	GetAllLogDrainsFilterV2Source2Build    GetAllLogDrainsFilterV2Source2 = "build"
	GetAllLogDrainsFilterV2Source2Edge     GetAllLogDrainsFilterV2Source2 = "edge"
	GetAllLogDrainsFilterV2Source2Lambda   GetAllLogDrainsFilterV2Source2 = "lambda"
	GetAllLogDrainsFilterV2Source2Static   GetAllLogDrainsFilterV2Source2 = "static"
	GetAllLogDrainsFilterV2Source2External GetAllLogDrainsFilterV2Source2 = "external"
	GetAllLogDrainsFilterV2Source2Firewall GetAllLogDrainsFilterV2Source2 = "firewall"
	GetAllLogDrainsFilterV2Source2Redirect GetAllLogDrainsFilterV2Source2 = "redirect"
)

func (e GetAllLogDrainsFilterV2Source2) ToPointer() *GetAllLogDrainsFilterV2Source2 {
	return &e
}
func (e *GetAllLogDrainsFilterV2Source2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "build":
		fallthrough
	case "edge":
		fallthrough
	case "lambda":
		fallthrough
	case "static":
		fallthrough
	case "external":
		fallthrough
	case "firewall":
		fallthrough
	case "redirect":
		*e = GetAllLogDrainsFilterV2Source2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsFilterV2Source2: %v", v)
	}
}

type GetAllLogDrainsFilterV2Log2 struct {
	Sources                            []GetAllLogDrainsFilterV2Source2 `json:"sources,omitempty"`
	LegacyExcludeCachedStaticAssetLogs *bool                            `json:"legacy_excludeCachedStaticAssetLogs,omitempty"`
}

func (g GetAllLogDrainsFilterV2Log2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2Log2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2Log2) GetSources() []GetAllLogDrainsFilterV2Source2 {
	if o == nil {
		return nil
	}
	return o.Sources
}

func (o *GetAllLogDrainsFilterV2Log2) GetLegacyExcludeCachedStaticAssetLogs() *bool {
	if o == nil {
		return nil
	}
	return o.LegacyExcludeCachedStaticAssetLogs
}

type GetAllLogDrainsEnvironment2 string

const (
	GetAllLogDrainsEnvironment2Production GetAllLogDrainsEnvironment2 = "production"
	GetAllLogDrainsEnvironment2Preview    GetAllLogDrainsEnvironment2 = "preview"
)

func (e GetAllLogDrainsEnvironment2) ToPointer() *GetAllLogDrainsEnvironment2 {
	return &e
}
func (e *GetAllLogDrainsEnvironment2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetAllLogDrainsEnvironment2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEnvironment2: %v", v)
	}
}

type GetAllLogDrainsDeployment2 struct {
	Environments []GetAllLogDrainsEnvironment2 `json:"environments,omitempty"`
}

func (g GetAllLogDrainsDeployment2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeployment2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeployment2) GetEnvironments() []GetAllLogDrainsEnvironment2 {
	if o == nil {
		return nil
	}
	return o.Environments
}

type GetAllLogDrainsFilterBasic2 struct {
	Type       GetAllLogDrainsTypeBasic2    `json:"type"`
	Project    *GetAllLogDrainsProject2     `json:"project,omitempty"`
	Log        *GetAllLogDrainsFilterV2Log2 `json:"log,omitempty"`
	Deployment *GetAllLogDrainsDeployment2  `json:"deployment,omitempty"`
}

func (g GetAllLogDrainsFilterBasic2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterBasic2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterBasic2) GetType() GetAllLogDrainsTypeBasic2 {
	if o == nil {
		return GetAllLogDrainsTypeBasic2("")
	}
	return o.Type
}

func (o *GetAllLogDrainsFilterBasic2) GetProject() *GetAllLogDrainsProject2 {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *GetAllLogDrainsFilterBasic2) GetLog() *GetAllLogDrainsFilterV2Log2 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetAllLogDrainsFilterBasic2) GetDeployment() *GetAllLogDrainsDeployment2 {
	if o == nil {
		return nil
	}
	return o.Deployment
}

type GetAllLogDrainsFilterUnion2Type string

const (
	GetAllLogDrainsFilterUnion2TypeBasic GetAllLogDrainsFilterUnion2Type = "basic"
	GetAllLogDrainsFilterUnion2TypeOdata GetAllLogDrainsFilterUnion2Type = "odata"
)

type GetAllLogDrainsFilterUnion2 struct {
	GetAllLogDrainsFilterBasic2 *GetAllLogDrainsFilterBasic2 `queryParam:"inline"`
	GetAllLogDrainsFilterOdata2 *GetAllLogDrainsFilterOdata2 `queryParam:"inline"`

	Type GetAllLogDrainsFilterUnion2Type
}

func CreateGetAllLogDrainsFilterUnion2Basic(basic GetAllLogDrainsFilterBasic2) GetAllLogDrainsFilterUnion2 {
	typ := GetAllLogDrainsFilterUnion2TypeBasic

	typStr := GetAllLogDrainsTypeBasic2(typ)
	basic.Type = typStr

	return GetAllLogDrainsFilterUnion2{
		GetAllLogDrainsFilterBasic2: &basic,
		Type:                        typ,
	}
}

func CreateGetAllLogDrainsFilterUnion2Odata(odata GetAllLogDrainsFilterOdata2) GetAllLogDrainsFilterUnion2 {
	typ := GetAllLogDrainsFilterUnion2TypeOdata

	typStr := GetAllLogDrainsTypeOdata2(typ)
	odata.Type = typStr

	return GetAllLogDrainsFilterUnion2{
		GetAllLogDrainsFilterOdata2: &odata,
		Type:                        typ,
	}
}

func (u *GetAllLogDrainsFilterUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "basic":
		getAllLogDrainsFilterBasic2 := new(GetAllLogDrainsFilterBasic2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterBasic2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == basic) type GetAllLogDrainsFilterBasic2 within GetAllLogDrainsFilterUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterBasic2 = getAllLogDrainsFilterBasic2
		u.Type = GetAllLogDrainsFilterUnion2TypeBasic
		return nil
	case "odata":
		getAllLogDrainsFilterOdata2 := new(GetAllLogDrainsFilterOdata2)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterOdata2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == odata) type GetAllLogDrainsFilterOdata2 within GetAllLogDrainsFilterUnion2: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterOdata2 = getAllLogDrainsFilterOdata2
		u.Type = GetAllLogDrainsFilterUnion2TypeOdata
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsFilterUnion2", string(data))
}

func (u GetAllLogDrainsFilterUnion2) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsFilterBasic2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterBasic2, "", true)
	}

	if u.GetAllLogDrainsFilterOdata2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterOdata2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsFilterUnion2: all fields are null")
}

type GetAllLogDrainsFilterV2V22 struct {
	Version GetAllLogDrainsVersionV22   `json:"version"`
	Filter  GetAllLogDrainsFilterUnion2 `json:"filter"`
}

func (g GetAllLogDrainsFilterV2V22) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2V22) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version", "filter"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2V22) GetVersion() GetAllLogDrainsVersionV22 {
	if o == nil {
		return GetAllLogDrainsVersionV22("")
	}
	return o.Version
}

func (o *GetAllLogDrainsFilterV2V22) GetFilter() GetAllLogDrainsFilterUnion2 {
	if o == nil {
		return GetAllLogDrainsFilterUnion2{}
	}
	return o.Filter
}

func (o *GetAllLogDrainsFilterV2V22) GetFilterBasic() *GetAllLogDrainsFilterBasic2 {
	return o.GetFilter().GetAllLogDrainsFilterBasic2
}

func (o *GetAllLogDrainsFilterV2V22) GetFilterOdata() *GetAllLogDrainsFilterOdata2 {
	return o.GetFilter().GetAllLogDrainsFilterOdata2
}

type GetAllLogDrainsVersionV12 string

const (
	GetAllLogDrainsVersionV12V1 GetAllLogDrainsVersionV12 = "v1"
)

func (e GetAllLogDrainsVersionV12) ToPointer() *GetAllLogDrainsVersionV12 {
	return &e
}
func (e *GetAllLogDrainsVersionV12) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		*e = GetAllLogDrainsVersionV12(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsVersionV12: %v", v)
	}
}

type GetAllLogDrainsFilterV2V12 struct {
	Version GetAllLogDrainsVersionV12 `json:"version"`
}

func (g GetAllLogDrainsFilterV2V12) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2V12) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2V12) GetVersion() GetAllLogDrainsVersionV12 {
	if o == nil {
		return GetAllLogDrainsVersionV12("")
	}
	return o.Version
}

type GetAllLogDrainsFilterV2Union2Type string

const (
	GetAllLogDrainsFilterV2Union2TypeV1 GetAllLogDrainsFilterV2Union2Type = "v1"
	GetAllLogDrainsFilterV2Union2TypeV2 GetAllLogDrainsFilterV2Union2Type = "v2"
)

type GetAllLogDrainsFilterV2Union2 struct {
	GetAllLogDrainsFilterV2V12 *GetAllLogDrainsFilterV2V12 `queryParam:"inline"`
	GetAllLogDrainsFilterV2V22 *GetAllLogDrainsFilterV2V22 `queryParam:"inline"`

	Type GetAllLogDrainsFilterV2Union2Type
}

func CreateGetAllLogDrainsFilterV2Union2V1(v1 GetAllLogDrainsFilterV2V12) GetAllLogDrainsFilterV2Union2 {
	typ := GetAllLogDrainsFilterV2Union2TypeV1

	typStr := GetAllLogDrainsVersionV12(typ)
	v1.Version = typStr

	return GetAllLogDrainsFilterV2Union2{
		GetAllLogDrainsFilterV2V12: &v1,
		Type:                       typ,
	}
}

func CreateGetAllLogDrainsFilterV2Union2V2(v2 GetAllLogDrainsFilterV2V22) GetAllLogDrainsFilterV2Union2 {
	typ := GetAllLogDrainsFilterV2Union2TypeV2

	typStr := GetAllLogDrainsVersionV22(typ)
	v2.Version = typStr

	return GetAllLogDrainsFilterV2Union2{
		GetAllLogDrainsFilterV2V22: &v2,
		Type:                       typ,
	}
}

func (u *GetAllLogDrainsFilterV2Union2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Version string `json:"version"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Version {
	case "v1":
		getAllLogDrainsFilterV2V12 := new(GetAllLogDrainsFilterV2V12)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterV2V12, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v1) type GetAllLogDrainsFilterV2V12 within GetAllLogDrainsFilterV2Union2: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterV2V12 = getAllLogDrainsFilterV2V12
		u.Type = GetAllLogDrainsFilterV2Union2TypeV1
		return nil
	case "v2":
		getAllLogDrainsFilterV2V22 := new(GetAllLogDrainsFilterV2V22)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterV2V22, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v2) type GetAllLogDrainsFilterV2V22 within GetAllLogDrainsFilterV2Union2: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterV2V22 = getAllLogDrainsFilterV2V22
		u.Type = GetAllLogDrainsFilterV2Union2TypeV2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsFilterV2Union2", string(data))
}

func (u GetAllLogDrainsFilterV2Union2) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsFilterV2V12 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterV2V12, "", true)
	}

	if u.GetAllLogDrainsFilterV2V22 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterV2V22, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsFilterV2Union2: all fields are null")
}

type GetAllLogDrainsAccessSome string

const (
	GetAllLogDrainsAccessSomeSome GetAllLogDrainsAccessSome = "some"
)

func (e GetAllLogDrainsAccessSome) ToPointer() *GetAllLogDrainsAccessSome {
	return &e
}
func (e *GetAllLogDrainsAccessSome) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "some":
		*e = GetAllLogDrainsAccessSome(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsAccessSome: %v", v)
	}
}

type GetAllLogDrainsProjectAccessSome struct {
	Access     GetAllLogDrainsAccessSome `json:"access"`
	ProjectIds []string                  `json:"projectIds"`
}

func (g GetAllLogDrainsProjectAccessSome) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsProjectAccessSome) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"access", "projectIds"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsProjectAccessSome) GetAccess() GetAllLogDrainsAccessSome {
	if o == nil {
		return GetAllLogDrainsAccessSome("")
	}
	return o.Access
}

func (o *GetAllLogDrainsProjectAccessSome) GetProjectIds() []string {
	if o == nil {
		return []string{}
	}
	return o.ProjectIds
}

type GetAllLogDrainsAccessAll string

const (
	GetAllLogDrainsAccessAllAll GetAllLogDrainsAccessAll = "all"
)

func (e GetAllLogDrainsAccessAll) ToPointer() *GetAllLogDrainsAccessAll {
	return &e
}
func (e *GetAllLogDrainsAccessAll) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		*e = GetAllLogDrainsAccessAll(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsAccessAll: %v", v)
	}
}

type GetAllLogDrainsProjectAccessAll struct {
	Access GetAllLogDrainsAccessAll `json:"access"`
}

func (g GetAllLogDrainsProjectAccessAll) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsProjectAccessAll) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"access"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsProjectAccessAll) GetAccess() GetAllLogDrainsAccessAll {
	if o == nil {
		return GetAllLogDrainsAccessAll("")
	}
	return o.Access
}

type GetAllLogDrainsProjectAccessUnionType string

const (
	GetAllLogDrainsProjectAccessUnionTypeAll  GetAllLogDrainsProjectAccessUnionType = "all"
	GetAllLogDrainsProjectAccessUnionTypeSome GetAllLogDrainsProjectAccessUnionType = "some"
)

type GetAllLogDrainsProjectAccessUnion struct {
	GetAllLogDrainsProjectAccessAll  *GetAllLogDrainsProjectAccessAll  `queryParam:"inline"`
	GetAllLogDrainsProjectAccessSome *GetAllLogDrainsProjectAccessSome `queryParam:"inline"`

	Type GetAllLogDrainsProjectAccessUnionType
}

func CreateGetAllLogDrainsProjectAccessUnionAll(all GetAllLogDrainsProjectAccessAll) GetAllLogDrainsProjectAccessUnion {
	typ := GetAllLogDrainsProjectAccessUnionTypeAll

	typStr := GetAllLogDrainsAccessAll(typ)
	all.Access = typStr

	return GetAllLogDrainsProjectAccessUnion{
		GetAllLogDrainsProjectAccessAll: &all,
		Type:                            typ,
	}
}

func CreateGetAllLogDrainsProjectAccessUnionSome(some GetAllLogDrainsProjectAccessSome) GetAllLogDrainsProjectAccessUnion {
	typ := GetAllLogDrainsProjectAccessUnionTypeSome

	typStr := GetAllLogDrainsAccessSome(typ)
	some.Access = typStr

	return GetAllLogDrainsProjectAccessUnion{
		GetAllLogDrainsProjectAccessSome: &some,
		Type:                             typ,
	}
}

func (u *GetAllLogDrainsProjectAccessUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Access string `json:"access"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Access {
	case "all":
		getAllLogDrainsProjectAccessAll := new(GetAllLogDrainsProjectAccessAll)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsProjectAccessAll, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Access == all) type GetAllLogDrainsProjectAccessAll within GetAllLogDrainsProjectAccessUnion: %w", string(data), err)
		}

		u.GetAllLogDrainsProjectAccessAll = getAllLogDrainsProjectAccessAll
		u.Type = GetAllLogDrainsProjectAccessUnionTypeAll
		return nil
	case "some":
		getAllLogDrainsProjectAccessSome := new(GetAllLogDrainsProjectAccessSome)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsProjectAccessSome, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Access == some) type GetAllLogDrainsProjectAccessSome within GetAllLogDrainsProjectAccessUnion: %w", string(data), err)
		}

		u.GetAllLogDrainsProjectAccessSome = getAllLogDrainsProjectAccessSome
		u.Type = GetAllLogDrainsProjectAccessUnionTypeSome
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsProjectAccessUnion", string(data))
}

func (u GetAllLogDrainsProjectAccessUnion) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsProjectAccessAll != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsProjectAccessAll, "", true)
	}

	if u.GetAllLogDrainsProjectAccessSome != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsProjectAccessSome, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsProjectAccessUnion: all fields are null")
}

type GetAllLogDrainsDrains2 struct {
	ID                          string                             `json:"id"`
	OwnerID                     string                             `json:"ownerId"`
	Name                        string                             `json:"name"`
	CreatedAt                   float64                            `json:"createdAt"`
	UpdatedAt                   float64                            `json:"updatedAt"`
	ProjectIds                  []string                           `json:"projectIds,omitempty"`
	Schemas                     *GetAllLogDrainsSchemas2           `json:"schemas,omitempty"`
	Delivery                    *GetAllLogDrainsDeliveryUnion2     `json:"delivery,omitempty"`
	Sampling                    []GetAllLogDrainsSampling2         `json:"sampling,omitempty"`
	TeamID                      *string                            `json:"teamId,omitempty"`
	Status                      *GetAllLogDrainsStatus2            `json:"status,omitempty"`
	DisabledAt                  *float64                           `json:"disabledAt,omitempty"`
	DisabledReason              *GetAllLogDrainsDisabledReason2    `json:"disabledReason,omitempty"`
	DisabledBy                  *string                            `json:"disabledBy,omitempty"`
	FirstErrorTimestamp         *float64                           `json:"firstErrorTimestamp,omitempty"`
	Source                      GetAllLogDrainsSourceUnion2        `json:"source"`
	Filter                      *string                            `json:"filter,omitempty"`
	FilterV2                    *GetAllLogDrainsFilterV2Union2     `json:"filterV2,omitempty"`
	IntegrationIcon             *string                            `json:"integrationIcon,omitempty"`
	IntegrationConfigurationURI *string                            `json:"integrationConfigurationUri,omitempty"`
	IntegrationWebsite          *string                            `json:"integrationWebsite,omitempty"`
	ProjectAccess               *GetAllLogDrainsProjectAccessUnion `json:"projectAccess,omitempty"`
}

func (g GetAllLogDrainsDrains2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDrains2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "ownerId", "name", "createdAt", "updatedAt", "source"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetAllLogDrainsDrains2) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetAllLogDrainsDrains2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetAllLogDrainsDrains2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetAllLogDrainsDrains2) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetAllLogDrainsDrains2) GetProjectIds() []string {
	if o == nil {
		return nil
	}
	return o.ProjectIds
}

func (o *GetAllLogDrainsDrains2) GetSchemas() *GetAllLogDrainsSchemas2 {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *GetAllLogDrainsDrains2) GetDelivery() *GetAllLogDrainsDeliveryUnion2 {
	if o == nil {
		return nil
	}
	return o.Delivery
}

func (o *GetAllLogDrainsDrains2) GetDeliveryHTTP() *GetAllLogDrainsDeliveryHTTP2 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryHTTP2
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetDeliveryOtlphttp() *GetAllLogDrainsDeliveryOtlphttp2 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryOtlphttp2
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetDeliveryClickhouse() *GetAllLogDrainsDeliveryClickhouse2 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryClickhouse2
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetDeliveryInternal() *GetAllLogDrainsDeliveryVercelOtelTracesDb2 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryVercelOtelTracesDb2
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetSampling() []GetAllLogDrainsSampling2 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *GetAllLogDrainsDrains2) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetAllLogDrainsDrains2) GetStatus() *GetAllLogDrainsStatus2 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *GetAllLogDrainsDrains2) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetAllLogDrainsDrains2) GetDisabledReason() *GetAllLogDrainsDisabledReason2 {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetAllLogDrainsDrains2) GetDisabledBy() *string {
	if o == nil {
		return nil
	}
	return o.DisabledBy
}

func (o *GetAllLogDrainsDrains2) GetFirstErrorTimestamp() *float64 {
	if o == nil {
		return nil
	}
	return o.FirstErrorTimestamp
}

func (o *GetAllLogDrainsDrains2) GetSource() GetAllLogDrainsSourceUnion2 {
	if o == nil {
		return GetAllLogDrainsSourceUnion2{}
	}
	return o.Source
}

func (o *GetAllLogDrainsDrains2) GetSourceSelfServed() *GetAllLogDrainsSourceSelfServed2 {
	return o.GetSource().GetAllLogDrainsSourceSelfServed2
}

func (o *GetAllLogDrainsDrains2) GetSourceIntegration() *GetAllLogDrainsSourceIntegration2 {
	return o.GetSource().GetAllLogDrainsSourceIntegration2
}

func (o *GetAllLogDrainsDrains2) GetFilter() *string {
	if o == nil {
		return nil
	}
	return o.Filter
}

func (o *GetAllLogDrainsDrains2) GetFilterV2() *GetAllLogDrainsFilterV2Union2 {
	if o == nil {
		return nil
	}
	return o.FilterV2
}

func (o *GetAllLogDrainsDrains2) GetFilterV2V1() *GetAllLogDrainsFilterV2V12 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetAllLogDrainsFilterV2V12
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetFilterV2V2() *GetAllLogDrainsFilterV2V22 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetAllLogDrainsFilterV2V22
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetIntegrationIcon() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationIcon
}

func (o *GetAllLogDrainsDrains2) GetIntegrationConfigurationURI() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationConfigurationURI
}

func (o *GetAllLogDrainsDrains2) GetIntegrationWebsite() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationWebsite
}

func (o *GetAllLogDrainsDrains2) GetProjectAccess() *GetAllLogDrainsProjectAccessUnion {
	if o == nil {
		return nil
	}
	return o.ProjectAccess
}

func (o *GetAllLogDrainsDrains2) GetProjectAccessAll() *GetAllLogDrainsProjectAccessAll {
	if v := o.GetProjectAccess(); v != nil {
		return v.GetAllLogDrainsProjectAccessAll
	}
	return nil
}

func (o *GetAllLogDrainsDrains2) GetProjectAccessSome() *GetAllLogDrainsProjectAccessSome {
	if v := o.GetProjectAccess(); v != nil {
		return v.GetAllLogDrainsProjectAccessSome
	}
	return nil
}

type GetAllLogDrainsSchemasLog1 struct {
}

func (g GetAllLogDrainsSchemasLog1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSchemasLog1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsTrace1 struct {
}

func (g GetAllLogDrainsTrace1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsTrace1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsAnalytics1 struct {
}

func (g GetAllLogDrainsAnalytics1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsAnalytics1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsSpeedInsights1 struct {
}

func (g GetAllLogDrainsSpeedInsights1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSpeedInsights1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetAllLogDrainsSchemas1 struct {
	Log           *GetAllLogDrainsSchemasLog1    `json:"log,omitempty"`
	Trace         *GetAllLogDrainsTrace1         `json:"trace,omitempty"`
	Analytics     *GetAllLogDrainsAnalytics1     `json:"analytics,omitempty"`
	SpeedInsights *GetAllLogDrainsSpeedInsights1 `json:"speed_insights,omitempty"`
}

func (g GetAllLogDrainsSchemas1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSchemas1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSchemas1) GetLog() *GetAllLogDrainsSchemasLog1 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetAllLogDrainsSchemas1) GetTrace() *GetAllLogDrainsTrace1 {
	if o == nil {
		return nil
	}
	return o.Trace
}

func (o *GetAllLogDrainsSchemas1) GetAnalytics() *GetAllLogDrainsAnalytics1 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetAllLogDrainsSchemas1) GetSpeedInsights() *GetAllLogDrainsSpeedInsights1 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

type GetAllLogDrainsTypeInternal1 string

const (
	GetAllLogDrainsTypeInternal1Internal GetAllLogDrainsTypeInternal1 = "internal"
)

func (e GetAllLogDrainsTypeInternal1) ToPointer() *GetAllLogDrainsTypeInternal1 {
	return &e
}
func (e *GetAllLogDrainsTypeInternal1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internal":
		*e = GetAllLogDrainsTypeInternal1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeInternal1: %v", v)
	}
}

type GetAllLogDrainsTarget1 string

const (
	GetAllLogDrainsTarget1VercelOtelTracesDb GetAllLogDrainsTarget1 = "vercel-otel-traces-db"
)

func (e GetAllLogDrainsTarget1) ToPointer() *GetAllLogDrainsTarget1 {
	return &e
}
func (e *GetAllLogDrainsTarget1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "vercel-otel-traces-db":
		*e = GetAllLogDrainsTarget1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTarget1: %v", v)
	}
}

type GetAllLogDrainsDeliveryVercelOtelTracesDb1 struct {
	Type   GetAllLogDrainsTypeInternal1 `json:"type"`
	Target GetAllLogDrainsTarget1       `json:"target"`
}

func (g GetAllLogDrainsDeliveryVercelOtelTracesDb1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryVercelOtelTracesDb1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryVercelOtelTracesDb1) GetType() GetAllLogDrainsTypeInternal1 {
	if o == nil {
		return GetAllLogDrainsTypeInternal1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryVercelOtelTracesDb1) GetTarget() GetAllLogDrainsTarget1 {
	if o == nil {
		return GetAllLogDrainsTarget1("")
	}
	return o.Target
}

type GetAllLogDrainsTypeClickhouse1 string

const (
	GetAllLogDrainsTypeClickhouse1Clickhouse GetAllLogDrainsTypeClickhouse1 = "clickhouse"
)

func (e GetAllLogDrainsTypeClickhouse1) ToPointer() *GetAllLogDrainsTypeClickhouse1 {
	return &e
}
func (e *GetAllLogDrainsTypeClickhouse1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "clickhouse":
		*e = GetAllLogDrainsTypeClickhouse1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeClickhouse1: %v", v)
	}
}

type GetAllLogDrainsDeliveryClickhouse1 struct {
	Type     GetAllLogDrainsTypeClickhouse1 `json:"type"`
	Endpoint string                         `json:"endpoint"`
	Table    string                         `json:"table"`
}

func (g GetAllLogDrainsDeliveryClickhouse1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryClickhouse1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "table"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryClickhouse1) GetType() GetAllLogDrainsTypeClickhouse1 {
	if o == nil {
		return GetAllLogDrainsTypeClickhouse1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryClickhouse1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryClickhouse1) GetTable() string {
	if o == nil {
		return ""
	}
	return o.Table
}

type GetAllLogDrainsTypeOtlphttp1 string

const (
	GetAllLogDrainsTypeOtlphttp1Otlphttp GetAllLogDrainsTypeOtlphttp1 = "otlphttp"
)

func (e GetAllLogDrainsTypeOtlphttp1) ToPointer() *GetAllLogDrainsTypeOtlphttp1 {
	return &e
}
func (e *GetAllLogDrainsTypeOtlphttp1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "otlphttp":
		*e = GetAllLogDrainsTypeOtlphttp1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeOtlphttp1: %v", v)
	}
}

type GetAllLogDrainsEndpoint1 struct {
	Traces string `json:"traces"`
}

func (g GetAllLogDrainsEndpoint1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsEndpoint1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"traces"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsEndpoint1) GetTraces() string {
	if o == nil {
		return ""
	}
	return o.Traces
}

type GetAllLogDrainsEncoding2 string

const (
	GetAllLogDrainsEncoding2JSON  GetAllLogDrainsEncoding2 = "json"
	GetAllLogDrainsEncoding2Proto GetAllLogDrainsEncoding2 = "proto"
)

func (e GetAllLogDrainsEncoding2) ToPointer() *GetAllLogDrainsEncoding2 {
	return &e
}
func (e *GetAllLogDrainsEncoding2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "proto":
		*e = GetAllLogDrainsEncoding2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEncoding2: %v", v)
	}
}

type GetAllLogDrainsSecretKind2 string

const (
	GetAllLogDrainsSecretKind2IntegrationSecret GetAllLogDrainsSecretKind2 = "INTEGRATION_SECRET"
)

func (e GetAllLogDrainsSecretKind2) ToPointer() *GetAllLogDrainsSecretKind2 {
	return &e
}
func (e *GetAllLogDrainsSecretKind2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetAllLogDrainsSecretKind2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsSecretKind2: %v", v)
	}
}

type GetAllLogDrainsSecretIntegrationSecret2 struct {
	Kind GetAllLogDrainsSecretKind2 `json:"kind"`
}

func (g GetAllLogDrainsSecretIntegrationSecret2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSecretIntegrationSecret2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSecretIntegrationSecret2) GetKind() GetAllLogDrainsSecretKind2 {
	if o == nil {
		return GetAllLogDrainsSecretKind2("")
	}
	return o.Kind
}

type GetAllLogDrainsSecretUnion2Type string

const (
	GetAllLogDrainsSecretUnion2TypeStr                                     GetAllLogDrainsSecretUnion2Type = "str"
	GetAllLogDrainsSecretUnion2TypeGetAllLogDrainsSecretIntegrationSecret2 GetAllLogDrainsSecretUnion2Type = "getAllLogDrains_secret_IntegrationSecret_2"
)

type GetAllLogDrainsSecretUnion2 struct {
	Str                                     *string                                  `queryParam:"inline"`
	GetAllLogDrainsSecretIntegrationSecret2 *GetAllLogDrainsSecretIntegrationSecret2 `queryParam:"inline"`

	Type GetAllLogDrainsSecretUnion2Type
}

func CreateGetAllLogDrainsSecretUnion2Str(str string) GetAllLogDrainsSecretUnion2 {
	typ := GetAllLogDrainsSecretUnion2TypeStr

	return GetAllLogDrainsSecretUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetAllLogDrainsSecretUnion2GetAllLogDrainsSecretIntegrationSecret2(getAllLogDrainsSecretIntegrationSecret2 GetAllLogDrainsSecretIntegrationSecret2) GetAllLogDrainsSecretUnion2 {
	typ := GetAllLogDrainsSecretUnion2TypeGetAllLogDrainsSecretIntegrationSecret2

	return GetAllLogDrainsSecretUnion2{
		GetAllLogDrainsSecretIntegrationSecret2: &getAllLogDrainsSecretIntegrationSecret2,
		Type:                                    typ,
	}
}

func (u *GetAllLogDrainsSecretUnion2) UnmarshalJSON(data []byte) error {

	var getAllLogDrainsSecretIntegrationSecret2 GetAllLogDrainsSecretIntegrationSecret2 = GetAllLogDrainsSecretIntegrationSecret2{}
	if err := utils.UnmarshalJSON(data, &getAllLogDrainsSecretIntegrationSecret2, "", true, nil); err == nil {
		u.GetAllLogDrainsSecretIntegrationSecret2 = &getAllLogDrainsSecretIntegrationSecret2
		u.Type = GetAllLogDrainsSecretUnion2TypeGetAllLogDrainsSecretIntegrationSecret2
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetAllLogDrainsSecretUnion2TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSecretUnion2", string(data))
}

func (u GetAllLogDrainsSecretUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetAllLogDrainsSecretIntegrationSecret2 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSecretIntegrationSecret2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSecretUnion2: all fields are null")
}

type GetAllLogDrainsDeliveryOtlphttp1 struct {
	Type     GetAllLogDrainsTypeOtlphttp1 `json:"type"`
	Endpoint GetAllLogDrainsEndpoint1     `json:"endpoint"`
	Encoding GetAllLogDrainsEncoding2     `json:"encoding"`
	Headers  map[string]string            `json:"headers"`
	Secret   *GetAllLogDrainsSecretUnion2 `json:"secret,omitempty"`
}

func (g GetAllLogDrainsDeliveryOtlphttp1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryOtlphttp1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryOtlphttp1) GetType() GetAllLogDrainsTypeOtlphttp1 {
	if o == nil {
		return GetAllLogDrainsTypeOtlphttp1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryOtlphttp1) GetEndpoint() GetAllLogDrainsEndpoint1 {
	if o == nil {
		return GetAllLogDrainsEndpoint1{}
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryOtlphttp1) GetEncoding() GetAllLogDrainsEncoding2 {
	if o == nil {
		return GetAllLogDrainsEncoding2("")
	}
	return o.Encoding
}

func (o *GetAllLogDrainsDeliveryOtlphttp1) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetAllLogDrainsDeliveryOtlphttp1) GetSecret() *GetAllLogDrainsSecretUnion2 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetAllLogDrainsTypeHTTP1 string

const (
	GetAllLogDrainsTypeHTTP1HTTP GetAllLogDrainsTypeHTTP1 = "http"
)

func (e GetAllLogDrainsTypeHTTP1) ToPointer() *GetAllLogDrainsTypeHTTP1 {
	return &e
}
func (e *GetAllLogDrainsTypeHTTP1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = GetAllLogDrainsTypeHTTP1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeHTTP1: %v", v)
	}
}

type GetAllLogDrainsEncoding1 string

const (
	GetAllLogDrainsEncoding1JSON   GetAllLogDrainsEncoding1 = "json"
	GetAllLogDrainsEncoding1Ndjson GetAllLogDrainsEncoding1 = "ndjson"
)

func (e GetAllLogDrainsEncoding1) ToPointer() *GetAllLogDrainsEncoding1 {
	return &e
}
func (e *GetAllLogDrainsEncoding1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "ndjson":
		*e = GetAllLogDrainsEncoding1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEncoding1: %v", v)
	}
}

type GetAllLogDrainsCompression1 string

const (
	GetAllLogDrainsCompression1Gzip GetAllLogDrainsCompression1 = "gzip"
	GetAllLogDrainsCompression1None GetAllLogDrainsCompression1 = "none"
)

func (e GetAllLogDrainsCompression1) ToPointer() *GetAllLogDrainsCompression1 {
	return &e
}
func (e *GetAllLogDrainsCompression1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = GetAllLogDrainsCompression1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsCompression1: %v", v)
	}
}

type GetAllLogDrainsSecretKind1 string

const (
	GetAllLogDrainsSecretKind1IntegrationSecret GetAllLogDrainsSecretKind1 = "INTEGRATION_SECRET"
)

func (e GetAllLogDrainsSecretKind1) ToPointer() *GetAllLogDrainsSecretKind1 {
	return &e
}
func (e *GetAllLogDrainsSecretKind1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetAllLogDrainsSecretKind1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsSecretKind1: %v", v)
	}
}

type GetAllLogDrainsSecretIntegrationSecret1 struct {
	Kind GetAllLogDrainsSecretKind1 `json:"kind"`
}

func (g GetAllLogDrainsSecretIntegrationSecret1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSecretIntegrationSecret1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSecretIntegrationSecret1) GetKind() GetAllLogDrainsSecretKind1 {
	if o == nil {
		return GetAllLogDrainsSecretKind1("")
	}
	return o.Kind
}

type GetAllLogDrainsSecretUnion1Type string

const (
	GetAllLogDrainsSecretUnion1TypeStr                                     GetAllLogDrainsSecretUnion1Type = "str"
	GetAllLogDrainsSecretUnion1TypeGetAllLogDrainsSecretIntegrationSecret1 GetAllLogDrainsSecretUnion1Type = "getAllLogDrains_secret_IntegrationSecret_1"
)

type GetAllLogDrainsSecretUnion1 struct {
	Str                                     *string                                  `queryParam:"inline"`
	GetAllLogDrainsSecretIntegrationSecret1 *GetAllLogDrainsSecretIntegrationSecret1 `queryParam:"inline"`

	Type GetAllLogDrainsSecretUnion1Type
}

func CreateGetAllLogDrainsSecretUnion1Str(str string) GetAllLogDrainsSecretUnion1 {
	typ := GetAllLogDrainsSecretUnion1TypeStr

	return GetAllLogDrainsSecretUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetAllLogDrainsSecretUnion1GetAllLogDrainsSecretIntegrationSecret1(getAllLogDrainsSecretIntegrationSecret1 GetAllLogDrainsSecretIntegrationSecret1) GetAllLogDrainsSecretUnion1 {
	typ := GetAllLogDrainsSecretUnion1TypeGetAllLogDrainsSecretIntegrationSecret1

	return GetAllLogDrainsSecretUnion1{
		GetAllLogDrainsSecretIntegrationSecret1: &getAllLogDrainsSecretIntegrationSecret1,
		Type:                                    typ,
	}
}

func (u *GetAllLogDrainsSecretUnion1) UnmarshalJSON(data []byte) error {

	var getAllLogDrainsSecretIntegrationSecret1 GetAllLogDrainsSecretIntegrationSecret1 = GetAllLogDrainsSecretIntegrationSecret1{}
	if err := utils.UnmarshalJSON(data, &getAllLogDrainsSecretIntegrationSecret1, "", true, nil); err == nil {
		u.GetAllLogDrainsSecretIntegrationSecret1 = &getAllLogDrainsSecretIntegrationSecret1
		u.Type = GetAllLogDrainsSecretUnion1TypeGetAllLogDrainsSecretIntegrationSecret1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetAllLogDrainsSecretUnion1TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSecretUnion1", string(data))
}

func (u GetAllLogDrainsSecretUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetAllLogDrainsSecretIntegrationSecret1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSecretIntegrationSecret1, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSecretUnion1: all fields are null")
}

type GetAllLogDrainsDeliveryHTTP1 struct {
	Type        GetAllLogDrainsTypeHTTP1     `json:"type"`
	Endpoint    string                       `json:"endpoint"`
	Encoding    GetAllLogDrainsEncoding1     `json:"encoding"`
	Compression *GetAllLogDrainsCompression1 `json:"compression,omitempty"`
	Headers     map[string]string            `json:"headers"`
	Secret      *GetAllLogDrainsSecretUnion1 `json:"secret,omitempty"`
}

func (g GetAllLogDrainsDeliveryHTTP1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeliveryHTTP1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetType() GetAllLogDrainsTypeHTTP1 {
	if o == nil {
		return GetAllLogDrainsTypeHTTP1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetEncoding() GetAllLogDrainsEncoding1 {
	if o == nil {
		return GetAllLogDrainsEncoding1("")
	}
	return o.Encoding
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetCompression() *GetAllLogDrainsCompression1 {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetAllLogDrainsDeliveryHTTP1) GetSecret() *GetAllLogDrainsSecretUnion1 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetAllLogDrainsDeliveryUnion1Type string

const (
	GetAllLogDrainsDeliveryUnion1TypeHTTP       GetAllLogDrainsDeliveryUnion1Type = "http"
	GetAllLogDrainsDeliveryUnion1TypeOtlphttp   GetAllLogDrainsDeliveryUnion1Type = "otlphttp"
	GetAllLogDrainsDeliveryUnion1TypeClickhouse GetAllLogDrainsDeliveryUnion1Type = "clickhouse"
	GetAllLogDrainsDeliveryUnion1TypeInternal   GetAllLogDrainsDeliveryUnion1Type = "internal"
)

type GetAllLogDrainsDeliveryUnion1 struct {
	GetAllLogDrainsDeliveryHTTP1               *GetAllLogDrainsDeliveryHTTP1               `queryParam:"inline"`
	GetAllLogDrainsDeliveryOtlphttp1           *GetAllLogDrainsDeliveryOtlphttp1           `queryParam:"inline"`
	GetAllLogDrainsDeliveryClickhouse1         *GetAllLogDrainsDeliveryClickhouse1         `queryParam:"inline"`
	GetAllLogDrainsDeliveryVercelOtelTracesDb1 *GetAllLogDrainsDeliveryVercelOtelTracesDb1 `queryParam:"inline"`

	Type GetAllLogDrainsDeliveryUnion1Type
}

func CreateGetAllLogDrainsDeliveryUnion1HTTP(http GetAllLogDrainsDeliveryHTTP1) GetAllLogDrainsDeliveryUnion1 {
	typ := GetAllLogDrainsDeliveryUnion1TypeHTTP

	typStr := GetAllLogDrainsTypeHTTP1(typ)
	http.Type = typStr

	return GetAllLogDrainsDeliveryUnion1{
		GetAllLogDrainsDeliveryHTTP1: &http,
		Type:                         typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion1Otlphttp(otlphttp GetAllLogDrainsDeliveryOtlphttp1) GetAllLogDrainsDeliveryUnion1 {
	typ := GetAllLogDrainsDeliveryUnion1TypeOtlphttp

	typStr := GetAllLogDrainsTypeOtlphttp1(typ)
	otlphttp.Type = typStr

	return GetAllLogDrainsDeliveryUnion1{
		GetAllLogDrainsDeliveryOtlphttp1: &otlphttp,
		Type:                             typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion1Clickhouse(clickhouse GetAllLogDrainsDeliveryClickhouse1) GetAllLogDrainsDeliveryUnion1 {
	typ := GetAllLogDrainsDeliveryUnion1TypeClickhouse

	typStr := GetAllLogDrainsTypeClickhouse1(typ)
	clickhouse.Type = typStr

	return GetAllLogDrainsDeliveryUnion1{
		GetAllLogDrainsDeliveryClickhouse1: &clickhouse,
		Type:                               typ,
	}
}

func CreateGetAllLogDrainsDeliveryUnion1Internal(internal GetAllLogDrainsDeliveryVercelOtelTracesDb1) GetAllLogDrainsDeliveryUnion1 {
	typ := GetAllLogDrainsDeliveryUnion1TypeInternal

	typStr := GetAllLogDrainsTypeInternal1(typ)
	internal.Type = typStr

	return GetAllLogDrainsDeliveryUnion1{
		GetAllLogDrainsDeliveryVercelOtelTracesDb1: &internal,
		Type: typ,
	}
}

func (u *GetAllLogDrainsDeliveryUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "http":
		getAllLogDrainsDeliveryHTTP1 := new(GetAllLogDrainsDeliveryHTTP1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryHTTP1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type GetAllLogDrainsDeliveryHTTP1 within GetAllLogDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryHTTP1 = getAllLogDrainsDeliveryHTTP1
		u.Type = GetAllLogDrainsDeliveryUnion1TypeHTTP
		return nil
	case "otlphttp":
		getAllLogDrainsDeliveryOtlphttp1 := new(GetAllLogDrainsDeliveryOtlphttp1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryOtlphttp1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == otlphttp) type GetAllLogDrainsDeliveryOtlphttp1 within GetAllLogDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryOtlphttp1 = getAllLogDrainsDeliveryOtlphttp1
		u.Type = GetAllLogDrainsDeliveryUnion1TypeOtlphttp
		return nil
	case "clickhouse":
		getAllLogDrainsDeliveryClickhouse1 := new(GetAllLogDrainsDeliveryClickhouse1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryClickhouse1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == clickhouse) type GetAllLogDrainsDeliveryClickhouse1 within GetAllLogDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryClickhouse1 = getAllLogDrainsDeliveryClickhouse1
		u.Type = GetAllLogDrainsDeliveryUnion1TypeClickhouse
		return nil
	case "internal":
		getAllLogDrainsDeliveryVercelOtelTracesDb1 := new(GetAllLogDrainsDeliveryVercelOtelTracesDb1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsDeliveryVercelOtelTracesDb1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == internal) type GetAllLogDrainsDeliveryVercelOtelTracesDb1 within GetAllLogDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsDeliveryVercelOtelTracesDb1 = getAllLogDrainsDeliveryVercelOtelTracesDb1
		u.Type = GetAllLogDrainsDeliveryUnion1TypeInternal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsDeliveryUnion1", string(data))
}

func (u GetAllLogDrainsDeliveryUnion1) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsDeliveryHTTP1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryHTTP1, "", true)
	}

	if u.GetAllLogDrainsDeliveryOtlphttp1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryOtlphttp1, "", true)
	}

	if u.GetAllLogDrainsDeliveryClickhouse1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryClickhouse1, "", true)
	}

	if u.GetAllLogDrainsDeliveryVercelOtelTracesDb1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsDeliveryVercelOtelTracesDb1, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsDeliveryUnion1: all fields are null")
}

type GetAllLogDrainsTypeHeadSampling1 string

const (
	GetAllLogDrainsTypeHeadSampling1HeadSampling GetAllLogDrainsTypeHeadSampling1 = "head_sampling"
)

func (e GetAllLogDrainsTypeHeadSampling1) ToPointer() *GetAllLogDrainsTypeHeadSampling1 {
	return &e
}
func (e *GetAllLogDrainsTypeHeadSampling1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "head_sampling":
		*e = GetAllLogDrainsTypeHeadSampling1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeHeadSampling1: %v", v)
	}
}

type GetAllLogDrainsEnv1 string

const (
	GetAllLogDrainsEnv1Production GetAllLogDrainsEnv1 = "production"
	GetAllLogDrainsEnv1Preview    GetAllLogDrainsEnv1 = "preview"
)

func (e GetAllLogDrainsEnv1) ToPointer() *GetAllLogDrainsEnv1 {
	return &e
}
func (e *GetAllLogDrainsEnv1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetAllLogDrainsEnv1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEnv1: %v", v)
	}
}

type GetAllLogDrainsSampling1 struct {
	Type        GetAllLogDrainsTypeHeadSampling1 `json:"type"`
	Rate        float64                          `json:"rate"`
	Env         *GetAllLogDrainsEnv1             `json:"env,omitempty"`
	RequestPath *string                          `json:"requestPath,omitempty"`
}

func (g GetAllLogDrainsSampling1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSampling1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "rate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSampling1) GetType() GetAllLogDrainsTypeHeadSampling1 {
	if o == nil {
		return GetAllLogDrainsTypeHeadSampling1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsSampling1) GetRate() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rate
}

func (o *GetAllLogDrainsSampling1) GetEnv() *GetAllLogDrainsEnv1 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetAllLogDrainsSampling1) GetRequestPath() *string {
	if o == nil {
		return nil
	}
	return o.RequestPath
}

type GetAllLogDrainsStatus1 string

const (
	GetAllLogDrainsStatus1Enabled  GetAllLogDrainsStatus1 = "enabled"
	GetAllLogDrainsStatus1Disabled GetAllLogDrainsStatus1 = "disabled"
	GetAllLogDrainsStatus1Errored  GetAllLogDrainsStatus1 = "errored"
)

func (e GetAllLogDrainsStatus1) ToPointer() *GetAllLogDrainsStatus1 {
	return &e
}
func (e *GetAllLogDrainsStatus1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		fallthrough
	case "errored":
		*e = GetAllLogDrainsStatus1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsStatus1: %v", v)
	}
}

type GetAllLogDrainsDisabledReason1 string

const (
	GetAllLogDrainsDisabledReason1DisabledByOwner      GetAllLogDrainsDisabledReason1 = "disabled-by-owner"
	GetAllLogDrainsDisabledReason1FeatureNotAvailable  GetAllLogDrainsDisabledReason1 = "feature-not-available"
	GetAllLogDrainsDisabledReason1AccountPlanDowngrade GetAllLogDrainsDisabledReason1 = "account-plan-downgrade"
	GetAllLogDrainsDisabledReason1DisabledByAdmin      GetAllLogDrainsDisabledReason1 = "disabled-by-admin"
)

func (e GetAllLogDrainsDisabledReason1) ToPointer() *GetAllLogDrainsDisabledReason1 {
	return &e
}
func (e *GetAllLogDrainsDisabledReason1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "account-plan-downgrade":
		fallthrough
	case "disabled-by-admin":
		*e = GetAllLogDrainsDisabledReason1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsDisabledReason1: %v", v)
	}
}

type GetAllLogDrainsKindIntegration1 string

const (
	GetAllLogDrainsKindIntegration1Integration GetAllLogDrainsKindIntegration1 = "integration"
)

func (e GetAllLogDrainsKindIntegration1) ToPointer() *GetAllLogDrainsKindIntegration1 {
	return &e
}
func (e *GetAllLogDrainsKindIntegration1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		*e = GetAllLogDrainsKindIntegration1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsKindIntegration1: %v", v)
	}
}

type GetAllLogDrainsSourceIntegration1 struct {
	Kind                       GetAllLogDrainsKindIntegration1 `json:"kind"`
	ResourceID                 *string                         `json:"resourceId,omitempty"`
	ExternalResourceID         *string                         `json:"externalResourceId,omitempty"`
	IntegrationID              string                          `json:"integrationId"`
	IntegrationConfigurationID string                          `json:"integrationConfigurationId"`
}

func (g GetAllLogDrainsSourceIntegration1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSourceIntegration1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind", "integrationId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSourceIntegration1) GetKind() GetAllLogDrainsKindIntegration1 {
	if o == nil {
		return GetAllLogDrainsKindIntegration1("")
	}
	return o.Kind
}

func (o *GetAllLogDrainsSourceIntegration1) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *GetAllLogDrainsSourceIntegration1) GetExternalResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalResourceID
}

func (o *GetAllLogDrainsSourceIntegration1) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetAllLogDrainsSourceIntegration1) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type GetAllLogDrainsKindSelfServed1 string

const (
	GetAllLogDrainsKindSelfServed1SelfServed GetAllLogDrainsKindSelfServed1 = "self-served"
)

func (e GetAllLogDrainsKindSelfServed1) ToPointer() *GetAllLogDrainsKindSelfServed1 {
	return &e
}
func (e *GetAllLogDrainsKindSelfServed1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "self-served":
		*e = GetAllLogDrainsKindSelfServed1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsKindSelfServed1: %v", v)
	}
}

type GetAllLogDrainsSourceSelfServed1 struct {
	Kind GetAllLogDrainsKindSelfServed1 `json:"kind"`
}

func (g GetAllLogDrainsSourceSelfServed1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsSourceSelfServed1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsSourceSelfServed1) GetKind() GetAllLogDrainsKindSelfServed1 {
	if o == nil {
		return GetAllLogDrainsKindSelfServed1("")
	}
	return o.Kind
}

type GetAllLogDrainsSourceUnion1Type string

const (
	GetAllLogDrainsSourceUnion1TypeSelfServed  GetAllLogDrainsSourceUnion1Type = "self-served"
	GetAllLogDrainsSourceUnion1TypeIntegration GetAllLogDrainsSourceUnion1Type = "integration"
)

type GetAllLogDrainsSourceUnion1 struct {
	GetAllLogDrainsSourceSelfServed1  *GetAllLogDrainsSourceSelfServed1  `queryParam:"inline"`
	GetAllLogDrainsSourceIntegration1 *GetAllLogDrainsSourceIntegration1 `queryParam:"inline"`

	Type GetAllLogDrainsSourceUnion1Type
}

func CreateGetAllLogDrainsSourceUnion1SelfServed(selfServed GetAllLogDrainsSourceSelfServed1) GetAllLogDrainsSourceUnion1 {
	typ := GetAllLogDrainsSourceUnion1TypeSelfServed

	typStr := GetAllLogDrainsKindSelfServed1(typ)
	selfServed.Kind = typStr

	return GetAllLogDrainsSourceUnion1{
		GetAllLogDrainsSourceSelfServed1: &selfServed,
		Type:                             typ,
	}
}

func CreateGetAllLogDrainsSourceUnion1Integration(integration GetAllLogDrainsSourceIntegration1) GetAllLogDrainsSourceUnion1 {
	typ := GetAllLogDrainsSourceUnion1TypeIntegration

	typStr := GetAllLogDrainsKindIntegration1(typ)
	integration.Kind = typStr

	return GetAllLogDrainsSourceUnion1{
		GetAllLogDrainsSourceIntegration1: &integration,
		Type:                              typ,
	}
}

func (u *GetAllLogDrainsSourceUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Kind string `json:"kind"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Kind {
	case "self-served":
		getAllLogDrainsSourceSelfServed1 := new(GetAllLogDrainsSourceSelfServed1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsSourceSelfServed1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == self-served) type GetAllLogDrainsSourceSelfServed1 within GetAllLogDrainsSourceUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsSourceSelfServed1 = getAllLogDrainsSourceSelfServed1
		u.Type = GetAllLogDrainsSourceUnion1TypeSelfServed
		return nil
	case "integration":
		getAllLogDrainsSourceIntegration1 := new(GetAllLogDrainsSourceIntegration1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsSourceIntegration1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == integration) type GetAllLogDrainsSourceIntegration1 within GetAllLogDrainsSourceUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsSourceIntegration1 = getAllLogDrainsSourceIntegration1
		u.Type = GetAllLogDrainsSourceUnion1TypeIntegration
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsSourceUnion1", string(data))
}

func (u GetAllLogDrainsSourceUnion1) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsSourceSelfServed1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSourceSelfServed1, "", true)
	}

	if u.GetAllLogDrainsSourceIntegration1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsSourceIntegration1, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsSourceUnion1: all fields are null")
}

type GetAllLogDrainsVersionV21 string

const (
	GetAllLogDrainsVersionV21V2 GetAllLogDrainsVersionV21 = "v2"
)

func (e GetAllLogDrainsVersionV21) ToPointer() *GetAllLogDrainsVersionV21 {
	return &e
}
func (e *GetAllLogDrainsVersionV21) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		*e = GetAllLogDrainsVersionV21(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsVersionV21: %v", v)
	}
}

type GetAllLogDrainsTypeOdata1 string

const (
	GetAllLogDrainsTypeOdata1Odata GetAllLogDrainsTypeOdata1 = "odata"
)

func (e GetAllLogDrainsTypeOdata1) ToPointer() *GetAllLogDrainsTypeOdata1 {
	return &e
}
func (e *GetAllLogDrainsTypeOdata1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "odata":
		*e = GetAllLogDrainsTypeOdata1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeOdata1: %v", v)
	}
}

type GetAllLogDrainsFilterOdata1 struct {
	Type GetAllLogDrainsTypeOdata1 `json:"type"`
	Text string                    `json:"text"`
}

func (g GetAllLogDrainsFilterOdata1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterOdata1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "text"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterOdata1) GetType() GetAllLogDrainsTypeOdata1 {
	if o == nil {
		return GetAllLogDrainsTypeOdata1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsFilterOdata1) GetText() string {
	if o == nil {
		return ""
	}
	return o.Text
}

type GetAllLogDrainsTypeBasic1 string

const (
	GetAllLogDrainsTypeBasic1Basic GetAllLogDrainsTypeBasic1 = "basic"
)

func (e GetAllLogDrainsTypeBasic1) ToPointer() *GetAllLogDrainsTypeBasic1 {
	return &e
}
func (e *GetAllLogDrainsTypeBasic1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = GetAllLogDrainsTypeBasic1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsTypeBasic1: %v", v)
	}
}

type GetAllLogDrainsProject1 struct {
	Ids []string `json:"ids,omitempty"`
}

func (g GetAllLogDrainsProject1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsProject1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsProject1) GetIds() []string {
	if o == nil {
		return nil
	}
	return o.Ids
}

type GetAllLogDrainsFilterV2Source1 string

const (
	GetAllLogDrainsFilterV2Source1Build    GetAllLogDrainsFilterV2Source1 = "build"
	GetAllLogDrainsFilterV2Source1Edge     GetAllLogDrainsFilterV2Source1 = "edge"
	GetAllLogDrainsFilterV2Source1Lambda   GetAllLogDrainsFilterV2Source1 = "lambda"
	GetAllLogDrainsFilterV2Source1Static   GetAllLogDrainsFilterV2Source1 = "static"
	GetAllLogDrainsFilterV2Source1External GetAllLogDrainsFilterV2Source1 = "external"
	GetAllLogDrainsFilterV2Source1Firewall GetAllLogDrainsFilterV2Source1 = "firewall"
	GetAllLogDrainsFilterV2Source1Redirect GetAllLogDrainsFilterV2Source1 = "redirect"
)

func (e GetAllLogDrainsFilterV2Source1) ToPointer() *GetAllLogDrainsFilterV2Source1 {
	return &e
}
func (e *GetAllLogDrainsFilterV2Source1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "build":
		fallthrough
	case "edge":
		fallthrough
	case "lambda":
		fallthrough
	case "static":
		fallthrough
	case "external":
		fallthrough
	case "firewall":
		fallthrough
	case "redirect":
		*e = GetAllLogDrainsFilterV2Source1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsFilterV2Source1: %v", v)
	}
}

type GetAllLogDrainsFilterV2Log1 struct {
	Sources                            []GetAllLogDrainsFilterV2Source1 `json:"sources,omitempty"`
	LegacyExcludeCachedStaticAssetLogs *bool                            `json:"legacy_excludeCachedStaticAssetLogs,omitempty"`
}

func (g GetAllLogDrainsFilterV2Log1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2Log1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2Log1) GetSources() []GetAllLogDrainsFilterV2Source1 {
	if o == nil {
		return nil
	}
	return o.Sources
}

func (o *GetAllLogDrainsFilterV2Log1) GetLegacyExcludeCachedStaticAssetLogs() *bool {
	if o == nil {
		return nil
	}
	return o.LegacyExcludeCachedStaticAssetLogs
}

type GetAllLogDrainsEnvironment1 string

const (
	GetAllLogDrainsEnvironment1Production GetAllLogDrainsEnvironment1 = "production"
	GetAllLogDrainsEnvironment1Preview    GetAllLogDrainsEnvironment1 = "preview"
)

func (e GetAllLogDrainsEnvironment1) ToPointer() *GetAllLogDrainsEnvironment1 {
	return &e
}
func (e *GetAllLogDrainsEnvironment1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetAllLogDrainsEnvironment1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsEnvironment1: %v", v)
	}
}

type GetAllLogDrainsDeployment1 struct {
	Environments []GetAllLogDrainsEnvironment1 `json:"environments,omitempty"`
}

func (g GetAllLogDrainsDeployment1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDeployment1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDeployment1) GetEnvironments() []GetAllLogDrainsEnvironment1 {
	if o == nil {
		return nil
	}
	return o.Environments
}

type GetAllLogDrainsFilterBasic1 struct {
	Type       GetAllLogDrainsTypeBasic1    `json:"type"`
	Project    *GetAllLogDrainsProject1     `json:"project,omitempty"`
	Log        *GetAllLogDrainsFilterV2Log1 `json:"log,omitempty"`
	Deployment *GetAllLogDrainsDeployment1  `json:"deployment,omitempty"`
}

func (g GetAllLogDrainsFilterBasic1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterBasic1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterBasic1) GetType() GetAllLogDrainsTypeBasic1 {
	if o == nil {
		return GetAllLogDrainsTypeBasic1("")
	}
	return o.Type
}

func (o *GetAllLogDrainsFilterBasic1) GetProject() *GetAllLogDrainsProject1 {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *GetAllLogDrainsFilterBasic1) GetLog() *GetAllLogDrainsFilterV2Log1 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetAllLogDrainsFilterBasic1) GetDeployment() *GetAllLogDrainsDeployment1 {
	if o == nil {
		return nil
	}
	return o.Deployment
}

type GetAllLogDrainsFilterUnion1Type string

const (
	GetAllLogDrainsFilterUnion1TypeBasic GetAllLogDrainsFilterUnion1Type = "basic"
	GetAllLogDrainsFilterUnion1TypeOdata GetAllLogDrainsFilterUnion1Type = "odata"
)

type GetAllLogDrainsFilterUnion1 struct {
	GetAllLogDrainsFilterBasic1 *GetAllLogDrainsFilterBasic1 `queryParam:"inline"`
	GetAllLogDrainsFilterOdata1 *GetAllLogDrainsFilterOdata1 `queryParam:"inline"`

	Type GetAllLogDrainsFilterUnion1Type
}

func CreateGetAllLogDrainsFilterUnion1Basic(basic GetAllLogDrainsFilterBasic1) GetAllLogDrainsFilterUnion1 {
	typ := GetAllLogDrainsFilterUnion1TypeBasic

	typStr := GetAllLogDrainsTypeBasic1(typ)
	basic.Type = typStr

	return GetAllLogDrainsFilterUnion1{
		GetAllLogDrainsFilterBasic1: &basic,
		Type:                        typ,
	}
}

func CreateGetAllLogDrainsFilterUnion1Odata(odata GetAllLogDrainsFilterOdata1) GetAllLogDrainsFilterUnion1 {
	typ := GetAllLogDrainsFilterUnion1TypeOdata

	typStr := GetAllLogDrainsTypeOdata1(typ)
	odata.Type = typStr

	return GetAllLogDrainsFilterUnion1{
		GetAllLogDrainsFilterOdata1: &odata,
		Type:                        typ,
	}
}

func (u *GetAllLogDrainsFilterUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "basic":
		getAllLogDrainsFilterBasic1 := new(GetAllLogDrainsFilterBasic1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterBasic1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == basic) type GetAllLogDrainsFilterBasic1 within GetAllLogDrainsFilterUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterBasic1 = getAllLogDrainsFilterBasic1
		u.Type = GetAllLogDrainsFilterUnion1TypeBasic
		return nil
	case "odata":
		getAllLogDrainsFilterOdata1 := new(GetAllLogDrainsFilterOdata1)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterOdata1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == odata) type GetAllLogDrainsFilterOdata1 within GetAllLogDrainsFilterUnion1: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterOdata1 = getAllLogDrainsFilterOdata1
		u.Type = GetAllLogDrainsFilterUnion1TypeOdata
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsFilterUnion1", string(data))
}

func (u GetAllLogDrainsFilterUnion1) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsFilterBasic1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterBasic1, "", true)
	}

	if u.GetAllLogDrainsFilterOdata1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterOdata1, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsFilterUnion1: all fields are null")
}

type GetAllLogDrainsFilterV2V21 struct {
	Version GetAllLogDrainsVersionV21   `json:"version"`
	Filter  GetAllLogDrainsFilterUnion1 `json:"filter"`
}

func (g GetAllLogDrainsFilterV2V21) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2V21) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version", "filter"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2V21) GetVersion() GetAllLogDrainsVersionV21 {
	if o == nil {
		return GetAllLogDrainsVersionV21("")
	}
	return o.Version
}

func (o *GetAllLogDrainsFilterV2V21) GetFilter() GetAllLogDrainsFilterUnion1 {
	if o == nil {
		return GetAllLogDrainsFilterUnion1{}
	}
	return o.Filter
}

func (o *GetAllLogDrainsFilterV2V21) GetFilterBasic() *GetAllLogDrainsFilterBasic1 {
	return o.GetFilter().GetAllLogDrainsFilterBasic1
}

func (o *GetAllLogDrainsFilterV2V21) GetFilterOdata() *GetAllLogDrainsFilterOdata1 {
	return o.GetFilter().GetAllLogDrainsFilterOdata1
}

type GetAllLogDrainsVersionV11 string

const (
	GetAllLogDrainsVersionV11V1 GetAllLogDrainsVersionV11 = "v1"
)

func (e GetAllLogDrainsVersionV11) ToPointer() *GetAllLogDrainsVersionV11 {
	return &e
}
func (e *GetAllLogDrainsVersionV11) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		*e = GetAllLogDrainsVersionV11(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetAllLogDrainsVersionV11: %v", v)
	}
}

type GetAllLogDrainsFilterV2V11 struct {
	Version GetAllLogDrainsVersionV11 `json:"version"`
}

func (g GetAllLogDrainsFilterV2V11) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsFilterV2V11) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsFilterV2V11) GetVersion() GetAllLogDrainsVersionV11 {
	if o == nil {
		return GetAllLogDrainsVersionV11("")
	}
	return o.Version
}

type GetAllLogDrainsFilterV2Union1Type string

const (
	GetAllLogDrainsFilterV2Union1TypeV1 GetAllLogDrainsFilterV2Union1Type = "v1"
	GetAllLogDrainsFilterV2Union1TypeV2 GetAllLogDrainsFilterV2Union1Type = "v2"
)

type GetAllLogDrainsFilterV2Union1 struct {
	GetAllLogDrainsFilterV2V11 *GetAllLogDrainsFilterV2V11 `queryParam:"inline"`
	GetAllLogDrainsFilterV2V21 *GetAllLogDrainsFilterV2V21 `queryParam:"inline"`

	Type GetAllLogDrainsFilterV2Union1Type
}

func CreateGetAllLogDrainsFilterV2Union1V1(v1 GetAllLogDrainsFilterV2V11) GetAllLogDrainsFilterV2Union1 {
	typ := GetAllLogDrainsFilterV2Union1TypeV1

	typStr := GetAllLogDrainsVersionV11(typ)
	v1.Version = typStr

	return GetAllLogDrainsFilterV2Union1{
		GetAllLogDrainsFilterV2V11: &v1,
		Type:                       typ,
	}
}

func CreateGetAllLogDrainsFilterV2Union1V2(v2 GetAllLogDrainsFilterV2V21) GetAllLogDrainsFilterV2Union1 {
	typ := GetAllLogDrainsFilterV2Union1TypeV2

	typStr := GetAllLogDrainsVersionV21(typ)
	v2.Version = typStr

	return GetAllLogDrainsFilterV2Union1{
		GetAllLogDrainsFilterV2V21: &v2,
		Type:                       typ,
	}
}

func (u *GetAllLogDrainsFilterV2Union1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Version string `json:"version"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Version {
	case "v1":
		getAllLogDrainsFilterV2V11 := new(GetAllLogDrainsFilterV2V11)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterV2V11, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v1) type GetAllLogDrainsFilterV2V11 within GetAllLogDrainsFilterV2Union1: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterV2V11 = getAllLogDrainsFilterV2V11
		u.Type = GetAllLogDrainsFilterV2Union1TypeV1
		return nil
	case "v2":
		getAllLogDrainsFilterV2V21 := new(GetAllLogDrainsFilterV2V21)
		if err := utils.UnmarshalJSON(data, &getAllLogDrainsFilterV2V21, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v2) type GetAllLogDrainsFilterV2V21 within GetAllLogDrainsFilterV2Union1: %w", string(data), err)
		}

		u.GetAllLogDrainsFilterV2V21 = getAllLogDrainsFilterV2V21
		u.Type = GetAllLogDrainsFilterV2Union1TypeV2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsFilterV2Union1", string(data))
}

func (u GetAllLogDrainsFilterV2Union1) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsFilterV2V11 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterV2V11, "", true)
	}

	if u.GetAllLogDrainsFilterV2V21 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsFilterV2V21, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsFilterV2Union1: all fields are null")
}

type GetAllLogDrainsDrains1 struct {
	ID                  string                          `json:"id"`
	OwnerID             string                          `json:"ownerId"`
	Name                string                          `json:"name"`
	CreatedAt           float64                         `json:"createdAt"`
	UpdatedAt           float64                         `json:"updatedAt"`
	ProjectIds          []string                        `json:"projectIds,omitempty"`
	Schemas             *GetAllLogDrainsSchemas1        `json:"schemas,omitempty"`
	Delivery            *GetAllLogDrainsDeliveryUnion1  `json:"delivery,omitempty"`
	Sampling            []GetAllLogDrainsSampling1      `json:"sampling,omitempty"`
	TeamID              *string                         `json:"teamId,omitempty"`
	Status              *GetAllLogDrainsStatus1         `json:"status,omitempty"`
	DisabledAt          *float64                        `json:"disabledAt,omitempty"`
	DisabledReason      *GetAllLogDrainsDisabledReason1 `json:"disabledReason,omitempty"`
	DisabledBy          *string                         `json:"disabledBy,omitempty"`
	FirstErrorTimestamp *float64                        `json:"firstErrorTimestamp,omitempty"`
	Source              GetAllLogDrainsSourceUnion1     `json:"source"`
	Filter              *string                         `json:"filter,omitempty"`
	FilterV2            *GetAllLogDrainsFilterV2Union1  `json:"filterV2,omitempty"`
}

func (g GetAllLogDrainsDrains1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsDrains1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "ownerId", "name", "createdAt", "updatedAt", "source"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetAllLogDrainsDrains1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *GetAllLogDrainsDrains1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetAllLogDrainsDrains1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetAllLogDrainsDrains1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetAllLogDrainsDrains1) GetProjectIds() []string {
	if o == nil {
		return nil
	}
	return o.ProjectIds
}

func (o *GetAllLogDrainsDrains1) GetSchemas() *GetAllLogDrainsSchemas1 {
	if o == nil {
		return nil
	}
	return o.Schemas
}

func (o *GetAllLogDrainsDrains1) GetDelivery() *GetAllLogDrainsDeliveryUnion1 {
	if o == nil {
		return nil
	}
	return o.Delivery
}

func (o *GetAllLogDrainsDrains1) GetDeliveryHTTP() *GetAllLogDrainsDeliveryHTTP1 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryHTTP1
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetDeliveryOtlphttp() *GetAllLogDrainsDeliveryOtlphttp1 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryOtlphttp1
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetDeliveryClickhouse() *GetAllLogDrainsDeliveryClickhouse1 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryClickhouse1
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetDeliveryInternal() *GetAllLogDrainsDeliveryVercelOtelTracesDb1 {
	if v := o.GetDelivery(); v != nil {
		return v.GetAllLogDrainsDeliveryVercelOtelTracesDb1
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetSampling() []GetAllLogDrainsSampling1 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *GetAllLogDrainsDrains1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetAllLogDrainsDrains1) GetStatus() *GetAllLogDrainsStatus1 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *GetAllLogDrainsDrains1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetAllLogDrainsDrains1) GetDisabledReason() *GetAllLogDrainsDisabledReason1 {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *GetAllLogDrainsDrains1) GetDisabledBy() *string {
	if o == nil {
		return nil
	}
	return o.DisabledBy
}

func (o *GetAllLogDrainsDrains1) GetFirstErrorTimestamp() *float64 {
	if o == nil {
		return nil
	}
	return o.FirstErrorTimestamp
}

func (o *GetAllLogDrainsDrains1) GetSource() GetAllLogDrainsSourceUnion1 {
	if o == nil {
		return GetAllLogDrainsSourceUnion1{}
	}
	return o.Source
}

func (o *GetAllLogDrainsDrains1) GetSourceSelfServed() *GetAllLogDrainsSourceSelfServed1 {
	return o.GetSource().GetAllLogDrainsSourceSelfServed1
}

func (o *GetAllLogDrainsDrains1) GetSourceIntegration() *GetAllLogDrainsSourceIntegration1 {
	return o.GetSource().GetAllLogDrainsSourceIntegration1
}

func (o *GetAllLogDrainsDrains1) GetFilter() *string {
	if o == nil {
		return nil
	}
	return o.Filter
}

func (o *GetAllLogDrainsDrains1) GetFilterV2() *GetAllLogDrainsFilterV2Union1 {
	if o == nil {
		return nil
	}
	return o.FilterV2
}

func (o *GetAllLogDrainsDrains1) GetFilterV2V1() *GetAllLogDrainsFilterV2V11 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetAllLogDrainsFilterV2V11
	}
	return nil
}

func (o *GetAllLogDrainsDrains1) GetFilterV2V2() *GetAllLogDrainsFilterV2V21 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetAllLogDrainsFilterV2V21
	}
	return nil
}

type GetAllLogDrainsDrainsUnionType string

const (
	GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains1 GetAllLogDrainsDrainsUnionType = "arrayOfGetAllLogDrainsDrains1"
	GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains2 GetAllLogDrainsDrainsUnionType = "arrayOfGetAllLogDrainsDrains2"
)

type GetAllLogDrainsDrainsUnion struct {
	ArrayOfGetAllLogDrainsDrains1 []GetAllLogDrainsDrains1 `queryParam:"inline"`
	ArrayOfGetAllLogDrainsDrains2 []GetAllLogDrainsDrains2 `queryParam:"inline"`

	Type GetAllLogDrainsDrainsUnionType
}

func CreateGetAllLogDrainsDrainsUnionArrayOfGetAllLogDrainsDrains1(arrayOfGetAllLogDrainsDrains1 []GetAllLogDrainsDrains1) GetAllLogDrainsDrainsUnion {
	typ := GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains1

	return GetAllLogDrainsDrainsUnion{
		ArrayOfGetAllLogDrainsDrains1: arrayOfGetAllLogDrainsDrains1,
		Type:                          typ,
	}
}

func CreateGetAllLogDrainsDrainsUnionArrayOfGetAllLogDrainsDrains2(arrayOfGetAllLogDrainsDrains2 []GetAllLogDrainsDrains2) GetAllLogDrainsDrainsUnion {
	typ := GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains2

	return GetAllLogDrainsDrainsUnion{
		ArrayOfGetAllLogDrainsDrains2: arrayOfGetAllLogDrainsDrains2,
		Type:                          typ,
	}
}

func (u *GetAllLogDrainsDrainsUnion) UnmarshalJSON(data []byte) error {

	var arrayOfGetAllLogDrainsDrains1 []GetAllLogDrainsDrains1 = []GetAllLogDrainsDrains1{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetAllLogDrainsDrains1, "", true, nil); err == nil {
		u.ArrayOfGetAllLogDrainsDrains1 = arrayOfGetAllLogDrainsDrains1
		u.Type = GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains1
		return nil
	}

	var arrayOfGetAllLogDrainsDrains2 []GetAllLogDrainsDrains2 = []GetAllLogDrainsDrains2{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetAllLogDrainsDrains2, "", true, nil); err == nil {
		u.ArrayOfGetAllLogDrainsDrains2 = arrayOfGetAllLogDrainsDrains2
		u.Type = GetAllLogDrainsDrainsUnionTypeArrayOfGetAllLogDrainsDrains2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsDrainsUnion", string(data))
}

func (u GetAllLogDrainsDrainsUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfGetAllLogDrainsDrains1 != nil {
		return utils.MarshalJSON(u.ArrayOfGetAllLogDrainsDrains1, "", true)
	}

	if u.ArrayOfGetAllLogDrainsDrains2 != nil {
		return utils.MarshalJSON(u.ArrayOfGetAllLogDrainsDrains2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsDrainsUnion: all fields are null")
}

type GetAllLogDrainsResponseBody1 struct {
	Drains GetAllLogDrainsDrainsUnion `json:"drains"`
}

func (g GetAllLogDrainsResponseBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetAllLogDrainsResponseBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"drains"}); err != nil {
		return err
	}
	return nil
}

func (o *GetAllLogDrainsResponseBody1) GetDrains() GetAllLogDrainsDrainsUnion {
	if o == nil {
		return GetAllLogDrainsDrainsUnion{}
	}
	return o.Drains
}

type GetAllLogDrainsResponseBodyType string

const (
	GetAllLogDrainsResponseBodyTypeGetAllLogDrainsResponseBody1        GetAllLogDrainsResponseBodyType = "getAllLogDrains_ResponseBody_1"
	GetAllLogDrainsResponseBodyTypeArrayOfGetAllLogDrainsResponseBody2 GetAllLogDrainsResponseBodyType = "arrayOfGetAllLogDrainsResponseBody2"
)

type GetAllLogDrainsResponseBody struct {
	GetAllLogDrainsResponseBody1        *GetAllLogDrainsResponseBody1  `queryParam:"inline"`
	ArrayOfGetAllLogDrainsResponseBody2 []GetAllLogDrainsResponseBody2 `queryParam:"inline"`

	Type GetAllLogDrainsResponseBodyType
}

func CreateGetAllLogDrainsResponseBodyGetAllLogDrainsResponseBody1(getAllLogDrainsResponseBody1 GetAllLogDrainsResponseBody1) GetAllLogDrainsResponseBody {
	typ := GetAllLogDrainsResponseBodyTypeGetAllLogDrainsResponseBody1

	return GetAllLogDrainsResponseBody{
		GetAllLogDrainsResponseBody1: &getAllLogDrainsResponseBody1,
		Type:                         typ,
	}
}

func CreateGetAllLogDrainsResponseBodyArrayOfGetAllLogDrainsResponseBody2(arrayOfGetAllLogDrainsResponseBody2 []GetAllLogDrainsResponseBody2) GetAllLogDrainsResponseBody {
	typ := GetAllLogDrainsResponseBodyTypeArrayOfGetAllLogDrainsResponseBody2

	return GetAllLogDrainsResponseBody{
		ArrayOfGetAllLogDrainsResponseBody2: arrayOfGetAllLogDrainsResponseBody2,
		Type:                                typ,
	}
}

func (u *GetAllLogDrainsResponseBody) UnmarshalJSON(data []byte) error {

	var getAllLogDrainsResponseBody1 GetAllLogDrainsResponseBody1 = GetAllLogDrainsResponseBody1{}
	if err := utils.UnmarshalJSON(data, &getAllLogDrainsResponseBody1, "", true, nil); err == nil {
		u.GetAllLogDrainsResponseBody1 = &getAllLogDrainsResponseBody1
		u.Type = GetAllLogDrainsResponseBodyTypeGetAllLogDrainsResponseBody1
		return nil
	}

	var arrayOfGetAllLogDrainsResponseBody2 []GetAllLogDrainsResponseBody2 = []GetAllLogDrainsResponseBody2{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetAllLogDrainsResponseBody2, "", true, nil); err == nil {
		u.ArrayOfGetAllLogDrainsResponseBody2 = arrayOfGetAllLogDrainsResponseBody2
		u.Type = GetAllLogDrainsResponseBodyTypeArrayOfGetAllLogDrainsResponseBody2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetAllLogDrainsResponseBody", string(data))
}

func (u GetAllLogDrainsResponseBody) MarshalJSON() ([]byte, error) {
	if u.GetAllLogDrainsResponseBody1 != nil {
		return utils.MarshalJSON(u.GetAllLogDrainsResponseBody1, "", true)
	}

	if u.ArrayOfGetAllLogDrainsResponseBody2 != nil {
		return utils.MarshalJSON(u.ArrayOfGetAllLogDrainsResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type GetAllLogDrainsResponseBody: all fields are null")
}

type GetAllLogDrainsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *GetAllLogDrainsResponseBody
}

func (o *GetAllLogDrainsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetAllLogDrainsResponse) GetOneOf() *GetAllLogDrainsResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
