// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

// GetDeploymentPlatform - Metadata about the source platform that triggered the deployment. Allows us to map a deployment back to a platform (e.g. the chat that created it)
type GetDeploymentPlatform struct {
	Source GetDeploymentPlatformSource `json:"source"`
	Origin GetDeploymentOrigin         `json:"origin"`
	Meta   map[string]string           `json:"meta,omitempty"`
}

func (g GetDeploymentPlatform) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentPlatform) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"source", "origin"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentPlatform) GetSource() GetDeploymentPlatformSource {
	if o == nil {
		return GetDeploymentPlatformSource{}
	}
	return o.Source
}

func (o *GetDeploymentPlatform) GetOrigin() GetDeploymentOrigin {
	if o == nil {
		return GetDeploymentOrigin{}
	}
	return o.Origin
}

func (o *GetDeploymentPlatform) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

type GetDeploymentCron struct {
	Schedule string `json:"schedule"`
	Path     string `json:"path"`
}

func (g GetDeploymentCron) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentCron) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"schedule", "path"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentCron) GetSchedule() string {
	if o == nil {
		return ""
	}
	return o.Schedule
}

func (o *GetDeploymentCron) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

type GetDeploymentArchitecture string

const (
	GetDeploymentArchitectureX8664 GetDeploymentArchitecture = "x86_64"
	GetDeploymentArchitectureArm64 GetDeploymentArchitecture = "arm64"
)

func (e GetDeploymentArchitecture) ToPointer() *GetDeploymentArchitecture {
	return &e
}
func (e *GetDeploymentArchitecture) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x86_64":
		fallthrough
	case "arm64":
		*e = GetDeploymentArchitecture(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentArchitecture: %v", v)
	}
}

// GetDeploymentTypeQueueV2beta - Event type - must be "queue/v2beta" (REQUIRED)
type GetDeploymentTypeQueueV2beta string

const (
	GetDeploymentTypeQueueV2betaQueueV2beta GetDeploymentTypeQueueV2beta = "queue/v2beta"
)

func (e GetDeploymentTypeQueueV2beta) ToPointer() *GetDeploymentTypeQueueV2beta {
	return &e
}
func (e *GetDeploymentTypeQueueV2beta) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue/v2beta":
		*e = GetDeploymentTypeQueueV2beta(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentTypeQueueV2beta: %v", v)
	}
}

// GetDeploymentExperimentalTriggerQueueV2beta - Queue trigger input event for v2beta (from vercel.json config). Consumer name is implicitly derived from the function path. Only one trigger per function is allowed.
type GetDeploymentExperimentalTriggerQueueV2beta struct {
	// Event type - must be "queue/v2beta" (REQUIRED)
	Type GetDeploymentTypeQueueV2beta `json:"type"`
	// Name of the queue topic to consume from (REQUIRED)
	Topic string `json:"topic"`
	// Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
	MaxDeliveries *float64 `json:"maxDeliveries,omitempty"`
	// Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
	RetryAfterSeconds *float64 `json:"retryAfterSeconds,omitempty"`
	// Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty"`
	// Maximum number of concurrent executions for this consumer (OPTIONAL) Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
	MaxConcurrency *float64 `json:"maxConcurrency,omitempty"`
}

func (g GetDeploymentExperimentalTriggerQueueV2beta) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentExperimentalTriggerQueueV2beta) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "topic"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetType() GetDeploymentTypeQueueV2beta {
	if o == nil {
		return GetDeploymentTypeQueueV2beta("")
	}
	return o.Type
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetTopic() string {
	if o == nil {
		return ""
	}
	return o.Topic
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetMaxDeliveries() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDeliveries
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetRetryAfterSeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.RetryAfterSeconds
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetInitialDelaySeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.InitialDelaySeconds
}

func (o *GetDeploymentExperimentalTriggerQueueV2beta) GetMaxConcurrency() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxConcurrency
}

// GetDeploymentTypeQueueV1beta - Event type - must be "queue/v1beta" (REQUIRED)
type GetDeploymentTypeQueueV1beta string

const (
	GetDeploymentTypeQueueV1betaQueueV1beta GetDeploymentTypeQueueV1beta = "queue/v1beta"
)

func (e GetDeploymentTypeQueueV1beta) ToPointer() *GetDeploymentTypeQueueV1beta {
	return &e
}
func (e *GetDeploymentTypeQueueV1beta) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queue/v1beta":
		*e = GetDeploymentTypeQueueV1beta(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentTypeQueueV1beta: %v", v)
	}
}

// GetDeploymentExperimentalTriggerQueueV1beta - Queue trigger input event for v1beta (from vercel.json config). Requires explicit consumer name.
type GetDeploymentExperimentalTriggerQueueV1beta struct {
	// Event type - must be "queue/v1beta" (REQUIRED)
	Type GetDeploymentTypeQueueV1beta `json:"type"`
	// Name of the consumer group for this trigger (REQUIRED)
	Consumer string `json:"consumer"`
	// Name of the queue topic to consume from (REQUIRED)
	Topic string `json:"topic"`
	// Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
	MaxDeliveries *float64 `json:"maxDeliveries,omitempty"`
	// Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
	RetryAfterSeconds *float64 `json:"retryAfterSeconds,omitempty"`
	// Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
	InitialDelaySeconds *float64 `json:"initialDelaySeconds,omitempty"`
	// Maximum number of concurrent executions for this consumer (OPTIONAL) Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
	MaxConcurrency *float64 `json:"maxConcurrency,omitempty"`
}

func (g GetDeploymentExperimentalTriggerQueueV1beta) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentExperimentalTriggerQueueV1beta) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "consumer", "topic"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetType() GetDeploymentTypeQueueV1beta {
	if o == nil {
		return GetDeploymentTypeQueueV1beta("")
	}
	return o.Type
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetConsumer() string {
	if o == nil {
		return ""
	}
	return o.Consumer
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetTopic() string {
	if o == nil {
		return ""
	}
	return o.Topic
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetMaxDeliveries() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDeliveries
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetRetryAfterSeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.RetryAfterSeconds
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetInitialDelaySeconds() *float64 {
	if o == nil {
		return nil
	}
	return o.InitialDelaySeconds
}

func (o *GetDeploymentExperimentalTriggerQueueV1beta) GetMaxConcurrency() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxConcurrency
}

type GetDeploymentExperimentalTriggerUnionType string

const (
	GetDeploymentExperimentalTriggerUnionTypeQueueV1beta GetDeploymentExperimentalTriggerUnionType = "queue/v1beta"
	GetDeploymentExperimentalTriggerUnionTypeQueueV2beta GetDeploymentExperimentalTriggerUnionType = "queue/v2beta"
)

type GetDeploymentExperimentalTriggerUnion struct {
	GetDeploymentExperimentalTriggerQueueV1beta *GetDeploymentExperimentalTriggerQueueV1beta `queryParam:"inline"`
	GetDeploymentExperimentalTriggerQueueV2beta *GetDeploymentExperimentalTriggerQueueV2beta `queryParam:"inline"`

	Type GetDeploymentExperimentalTriggerUnionType
}

func CreateGetDeploymentExperimentalTriggerUnionQueueV1beta(queueV1beta GetDeploymentExperimentalTriggerQueueV1beta) GetDeploymentExperimentalTriggerUnion {
	typ := GetDeploymentExperimentalTriggerUnionTypeQueueV1beta

	typStr := GetDeploymentTypeQueueV1beta(typ)
	queueV1beta.Type = typStr

	return GetDeploymentExperimentalTriggerUnion{
		GetDeploymentExperimentalTriggerQueueV1beta: &queueV1beta,
		Type: typ,
	}
}

func CreateGetDeploymentExperimentalTriggerUnionQueueV2beta(queueV2beta GetDeploymentExperimentalTriggerQueueV2beta) GetDeploymentExperimentalTriggerUnion {
	typ := GetDeploymentExperimentalTriggerUnionTypeQueueV2beta

	typStr := GetDeploymentTypeQueueV2beta(typ)
	queueV2beta.Type = typStr

	return GetDeploymentExperimentalTriggerUnion{
		GetDeploymentExperimentalTriggerQueueV2beta: &queueV2beta,
		Type: typ,
	}
}

func (u *GetDeploymentExperimentalTriggerUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "queue/v1beta":
		getDeploymentExperimentalTriggerQueueV1beta := new(GetDeploymentExperimentalTriggerQueueV1beta)
		if err := utils.UnmarshalJSON(data, &getDeploymentExperimentalTriggerQueueV1beta, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == queue/v1beta) type GetDeploymentExperimentalTriggerQueueV1beta within GetDeploymentExperimentalTriggerUnion: %w", string(data), err)
		}

		u.GetDeploymentExperimentalTriggerQueueV1beta = getDeploymentExperimentalTriggerQueueV1beta
		u.Type = GetDeploymentExperimentalTriggerUnionTypeQueueV1beta
		return nil
	case "queue/v2beta":
		getDeploymentExperimentalTriggerQueueV2beta := new(GetDeploymentExperimentalTriggerQueueV2beta)
		if err := utils.UnmarshalJSON(data, &getDeploymentExperimentalTriggerQueueV2beta, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == queue/v2beta) type GetDeploymentExperimentalTriggerQueueV2beta within GetDeploymentExperimentalTriggerUnion: %w", string(data), err)
		}

		u.GetDeploymentExperimentalTriggerQueueV2beta = getDeploymentExperimentalTriggerQueueV2beta
		u.Type = GetDeploymentExperimentalTriggerUnionTypeQueueV2beta
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentExperimentalTriggerUnion", string(data))
}

func (u GetDeploymentExperimentalTriggerUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentExperimentalTriggerQueueV1beta != nil {
		return utils.MarshalJSON(u.GetDeploymentExperimentalTriggerQueueV1beta, "", true)
	}

	if u.GetDeploymentExperimentalTriggerQueueV2beta != nil {
		return utils.MarshalJSON(u.GetDeploymentExperimentalTriggerQueueV2beta, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentExperimentalTriggerUnion: all fields are null")
}

type GetDeploymentFunctions struct {
	Architecture            *GetDeploymentArchitecture              `json:"architecture,omitempty"`
	Memory                  *float64                                `json:"memory,omitempty"`
	MaxDuration             *float64                                `json:"maxDuration,omitempty"`
	Regions                 []string                                `json:"regions,omitempty"`
	FunctionFailoverRegions []string                                `json:"functionFailoverRegions,omitempty"`
	Runtime                 *string                                 `json:"runtime,omitempty"`
	IncludeFiles            *string                                 `json:"includeFiles,omitempty"`
	ExcludeFiles            *string                                 `json:"excludeFiles,omitempty"`
	ExperimentalTriggers    []GetDeploymentExperimentalTriggerUnion `json:"experimentalTriggers,omitempty"`
	SupportsCancellation    *bool                                   `json:"supportsCancellation,omitempty"`
}

func (g GetDeploymentFunctions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentFunctions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentFunctions) GetArchitecture() *GetDeploymentArchitecture {
	if o == nil {
		return nil
	}
	return o.Architecture
}

func (o *GetDeploymentFunctions) GetMemory() *float64 {
	if o == nil {
		return nil
	}
	return o.Memory
}

func (o *GetDeploymentFunctions) GetMaxDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.MaxDuration
}

func (o *GetDeploymentFunctions) GetRegions() []string {
	if o == nil {
		return nil
	}
	return o.Regions
}

func (o *GetDeploymentFunctions) GetFunctionFailoverRegions() []string {
	if o == nil {
		return nil
	}
	return o.FunctionFailoverRegions
}

func (o *GetDeploymentFunctions) GetRuntime() *string {
	if o == nil {
		return nil
	}
	return o.Runtime
}

func (o *GetDeploymentFunctions) GetIncludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.IncludeFiles
}

func (o *GetDeploymentFunctions) GetExcludeFiles() *string {
	if o == nil {
		return nil
	}
	return o.ExcludeFiles
}

func (o *GetDeploymentFunctions) GetExperimentalTriggers() []GetDeploymentExperimentalTriggerUnion {
	if o == nil {
		return nil
	}
	return o.ExperimentalTriggers
}

func (o *GetDeploymentFunctions) GetSupportsCancellation() *bool {
	if o == nil {
		return nil
	}
	return o.SupportsCancellation
}

type GetDeploymentRoute3 struct {
	Src        string  `json:"src"`
	Continue   bool    `json:"continue"`
	Middleware float64 `json:"middleware"`
}

func (g GetDeploymentRoute3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentRoute3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"src", "continue", "middleware"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentRoute3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *GetDeploymentRoute3) GetContinue() bool {
	if o == nil {
		return false
	}
	return o.Continue
}

func (o *GetDeploymentRoute3) GetMiddleware() float64 {
	if o == nil {
		return 0.0
	}
	return o.Middleware
}

type GetDeploymentHandle string

const (
	GetDeploymentHandleError      GetDeploymentHandle = "error"
	GetDeploymentHandleFilesystem GetDeploymentHandle = "filesystem"
	GetDeploymentHandleHit        GetDeploymentHandle = "hit"
	GetDeploymentHandleMiss       GetDeploymentHandle = "miss"
	GetDeploymentHandleRewrite    GetDeploymentHandle = "rewrite"
	GetDeploymentHandleResource   GetDeploymentHandle = "resource"
)

func (e GetDeploymentHandle) ToPointer() *GetDeploymentHandle {
	return &e
}
func (e *GetDeploymentHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "error":
		fallthrough
	case "filesystem":
		fallthrough
	case "hit":
		fallthrough
	case "miss":
		fallthrough
	case "rewrite":
		fallthrough
	case "resource":
		*e = GetDeploymentHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentHandle: %v", v)
	}
}

type GetDeploymentRoute2 struct {
	Handle GetDeploymentHandle `json:"handle"`
	Src    *string             `json:"src,omitempty"`
	Dest   *string             `json:"dest,omitempty"`
	Status *float64            `json:"status,omitempty"`
}

func (g GetDeploymentRoute2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentRoute2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"handle"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentRoute2) GetHandle() GetDeploymentHandle {
	if o == nil {
		return GetDeploymentHandle("")
	}
	return o.Handle
}

func (o *GetDeploymentRoute2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *GetDeploymentRoute2) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *GetDeploymentRoute2) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

type GetDeploymentHasType string

const (
	GetDeploymentHasTypeHeader GetDeploymentHasType = "header"
	GetDeploymentHasTypeCookie GetDeploymentHasType = "cookie"
	GetDeploymentHasTypeQuery  GetDeploymentHasType = "query"
)

func (e GetDeploymentHasType) ToPointer() *GetDeploymentHasType {
	return &e
}
func (e *GetDeploymentHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = GetDeploymentHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentHasType: %v", v)
	}
}

type GetDeploymentHasEq2Type string

const (
	GetDeploymentHasEq2TypeStr    GetDeploymentHasEq2Type = "str"
	GetDeploymentHasEq2TypeNumber GetDeploymentHasEq2Type = "number"
)

type GetDeploymentHasEq2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type GetDeploymentHasEq2Type
}

func CreateGetDeploymentHasEq2Str(str string) GetDeploymentHasEq2 {
	typ := GetDeploymentHasEq2TypeStr

	return GetDeploymentHasEq2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentHasEq2Number(number float64) GetDeploymentHasEq2 {
	typ := GetDeploymentHasEq2TypeNumber

	return GetDeploymentHasEq2{
		Number: &number,
		Type:   typ,
	}
}

func (u *GetDeploymentHasEq2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentHasEq2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetDeploymentHasEq2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentHasEq2", string(data))
}

func (u GetDeploymentHasEq2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentHasEq2: all fields are null")
}

type GetDeploymentHasValue2 struct {
	Eq   *GetDeploymentHasEq2 `json:"eq,omitempty"`
	Neq  *string              `json:"neq,omitempty"`
	Inc  []string             `json:"inc,omitempty"`
	Ninc []string             `json:"ninc,omitempty"`
	Pre  *string              `json:"pre,omitempty"`
	Suf  *string              `json:"suf,omitempty"`
	Re   *string              `json:"re,omitempty"`
	Gt   *float64             `json:"gt,omitempty"`
	Gte  *float64             `json:"gte,omitempty"`
	Lt   *float64             `json:"lt,omitempty"`
	Lte  *float64             `json:"lte,omitempty"`
}

func (g GetDeploymentHasValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentHasValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentHasValue2) GetEq() *GetDeploymentHasEq2 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *GetDeploymentHasValue2) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *GetDeploymentHasValue2) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *GetDeploymentHasValue2) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *GetDeploymentHasValue2) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *GetDeploymentHasValue2) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *GetDeploymentHasValue2) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *GetDeploymentHasValue2) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetDeploymentHasValue2) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetDeploymentHasValue2) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *GetDeploymentHasValue2) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetDeploymentHasValueUnion2Type string

const (
	GetDeploymentHasValueUnion2TypeStr                    GetDeploymentHasValueUnion2Type = "str"
	GetDeploymentHasValueUnion2TypeGetDeploymentHasValue2 GetDeploymentHasValueUnion2Type = "getDeployment_has_value_2"
)

type GetDeploymentHasValueUnion2 struct {
	Str                    *string                 `queryParam:"inline"`
	GetDeploymentHasValue2 *GetDeploymentHasValue2 `queryParam:"inline"`

	Type GetDeploymentHasValueUnion2Type
}

func CreateGetDeploymentHasValueUnion2Str(str string) GetDeploymentHasValueUnion2 {
	typ := GetDeploymentHasValueUnion2TypeStr

	return GetDeploymentHasValueUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentHasValueUnion2GetDeploymentHasValue2(getDeploymentHasValue2 GetDeploymentHasValue2) GetDeploymentHasValueUnion2 {
	typ := GetDeploymentHasValueUnion2TypeGetDeploymentHasValue2

	return GetDeploymentHasValueUnion2{
		GetDeploymentHasValue2: &getDeploymentHasValue2,
		Type:                   typ,
	}
}

func (u *GetDeploymentHasValueUnion2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentHasValueUnion2TypeStr
		return nil
	}

	var getDeploymentHasValue2 GetDeploymentHasValue2 = GetDeploymentHasValue2{}
	if err := utils.UnmarshalJSON(data, &getDeploymentHasValue2, "", true, nil); err == nil {
		u.GetDeploymentHasValue2 = &getDeploymentHasValue2
		u.Type = GetDeploymentHasValueUnion2TypeGetDeploymentHasValue2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentHasValueUnion2", string(data))
}

func (u GetDeploymentHasValueUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDeploymentHasValue2 != nil {
		return utils.MarshalJSON(u.GetDeploymentHasValue2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentHasValueUnion2: all fields are null")
}

type GetDeploymentHas struct {
	Type  GetDeploymentHasType         `json:"type"`
	Key   string                       `json:"key"`
	Value *GetDeploymentHasValueUnion2 `json:"value,omitempty"`
}

func (g GetDeploymentHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentHas) GetType() GetDeploymentHasType {
	if o == nil {
		return GetDeploymentHasType("")
	}
	return o.Type
}

func (o *GetDeploymentHas) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *GetDeploymentHas) GetValue() *GetDeploymentHasValueUnion2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type GetDeploymentHasTypeHost string

const (
	GetDeploymentHasTypeHostHost GetDeploymentHasTypeHost = "host"
)

func (e GetDeploymentHasTypeHost) ToPointer() *GetDeploymentHasTypeHost {
	return &e
}
func (e *GetDeploymentHasTypeHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = GetDeploymentHasTypeHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentHasTypeHost: %v", v)
	}
}

type GetDeploymentHasEq1Type string

const (
	GetDeploymentHasEq1TypeStr    GetDeploymentHasEq1Type = "str"
	GetDeploymentHasEq1TypeNumber GetDeploymentHasEq1Type = "number"
)

type GetDeploymentHasEq1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type GetDeploymentHasEq1Type
}

func CreateGetDeploymentHasEq1Str(str string) GetDeploymentHasEq1 {
	typ := GetDeploymentHasEq1TypeStr

	return GetDeploymentHasEq1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentHasEq1Number(number float64) GetDeploymentHasEq1 {
	typ := GetDeploymentHasEq1TypeNumber

	return GetDeploymentHasEq1{
		Number: &number,
		Type:   typ,
	}
}

func (u *GetDeploymentHasEq1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentHasEq1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetDeploymentHasEq1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentHasEq1", string(data))
}

func (u GetDeploymentHasEq1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentHasEq1: all fields are null")
}

type GetDeploymentHasValue1 struct {
	Eq   *GetDeploymentHasEq1 `json:"eq,omitempty"`
	Neq  *string              `json:"neq,omitempty"`
	Inc  []string             `json:"inc,omitempty"`
	Ninc []string             `json:"ninc,omitempty"`
	Pre  *string              `json:"pre,omitempty"`
	Suf  *string              `json:"suf,omitempty"`
	Re   *string              `json:"re,omitempty"`
	Gt   *float64             `json:"gt,omitempty"`
	Gte  *float64             `json:"gte,omitempty"`
	Lt   *float64             `json:"lt,omitempty"`
	Lte  *float64             `json:"lte,omitempty"`
}

func (g GetDeploymentHasValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentHasValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentHasValue1) GetEq() *GetDeploymentHasEq1 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *GetDeploymentHasValue1) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *GetDeploymentHasValue1) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *GetDeploymentHasValue1) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *GetDeploymentHasValue1) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *GetDeploymentHasValue1) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *GetDeploymentHasValue1) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *GetDeploymentHasValue1) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetDeploymentHasValue1) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetDeploymentHasValue1) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *GetDeploymentHasValue1) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetDeploymentHasValueUnion1Type string

const (
	GetDeploymentHasValueUnion1TypeStr                    GetDeploymentHasValueUnion1Type = "str"
	GetDeploymentHasValueUnion1TypeGetDeploymentHasValue1 GetDeploymentHasValueUnion1Type = "getDeployment_has_value_1"
)

type GetDeploymentHasValueUnion1 struct {
	Str                    *string                 `queryParam:"inline"`
	GetDeploymentHasValue1 *GetDeploymentHasValue1 `queryParam:"inline"`

	Type GetDeploymentHasValueUnion1Type
}

func CreateGetDeploymentHasValueUnion1Str(str string) GetDeploymentHasValueUnion1 {
	typ := GetDeploymentHasValueUnion1TypeStr

	return GetDeploymentHasValueUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentHasValueUnion1GetDeploymentHasValue1(getDeploymentHasValue1 GetDeploymentHasValue1) GetDeploymentHasValueUnion1 {
	typ := GetDeploymentHasValueUnion1TypeGetDeploymentHasValue1

	return GetDeploymentHasValueUnion1{
		GetDeploymentHasValue1: &getDeploymentHasValue1,
		Type:                   typ,
	}
}

func (u *GetDeploymentHasValueUnion1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentHasValueUnion1TypeStr
		return nil
	}

	var getDeploymentHasValue1 GetDeploymentHasValue1 = GetDeploymentHasValue1{}
	if err := utils.UnmarshalJSON(data, &getDeploymentHasValue1, "", true, nil); err == nil {
		u.GetDeploymentHasValue1 = &getDeploymentHasValue1
		u.Type = GetDeploymentHasValueUnion1TypeGetDeploymentHasValue1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentHasValueUnion1", string(data))
}

func (u GetDeploymentHasValueUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDeploymentHasValue1 != nil {
		return utils.MarshalJSON(u.GetDeploymentHasValue1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentHasValueUnion1: all fields are null")
}

type GetDeploymentHasHost struct {
	Type  GetDeploymentHasTypeHost    `json:"type"`
	Value GetDeploymentHasValueUnion1 `json:"value"`
}

func (g GetDeploymentHasHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentHasHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentHasHost) GetType() GetDeploymentHasTypeHost {
	if o == nil {
		return GetDeploymentHasTypeHost("")
	}
	return o.Type
}

func (o *GetDeploymentHasHost) GetValue() GetDeploymentHasValueUnion1 {
	if o == nil {
		return GetDeploymentHasValueUnion1{}
	}
	return o.Value
}

type GetDeploymentHasUnionType string

const (
	GetDeploymentHasUnionTypeHost   GetDeploymentHasUnionType = "host"
	GetDeploymentHasUnionTypeHeader GetDeploymentHasUnionType = "header"
	GetDeploymentHasUnionTypeCookie GetDeploymentHasUnionType = "cookie"
	GetDeploymentHasUnionTypeQuery  GetDeploymentHasUnionType = "query"
)

type GetDeploymentHasUnion struct {
	GetDeploymentHasHost *GetDeploymentHasHost `queryParam:"inline"`
	GetDeploymentHas     *GetDeploymentHas     `queryParam:"inline"`

	Type GetDeploymentHasUnionType
}

func CreateGetDeploymentHasUnionHost(host GetDeploymentHasHost) GetDeploymentHasUnion {
	typ := GetDeploymentHasUnionTypeHost

	typStr := GetDeploymentHasTypeHost(typ)
	host.Type = typStr

	return GetDeploymentHasUnion{
		GetDeploymentHasHost: &host,
		Type:                 typ,
	}
}

func CreateGetDeploymentHasUnionHeader(header GetDeploymentHas) GetDeploymentHasUnion {
	typ := GetDeploymentHasUnionTypeHeader

	typStr := GetDeploymentHasType(typ)
	header.Type = typStr

	return GetDeploymentHasUnion{
		GetDeploymentHas: &header,
		Type:             typ,
	}
}

func CreateGetDeploymentHasUnionCookie(cookie GetDeploymentHas) GetDeploymentHasUnion {
	typ := GetDeploymentHasUnionTypeCookie

	typStr := GetDeploymentHasType(typ)
	cookie.Type = typStr

	return GetDeploymentHasUnion{
		GetDeploymentHas: &cookie,
		Type:             typ,
	}
}

func CreateGetDeploymentHasUnionQuery(query GetDeploymentHas) GetDeploymentHasUnion {
	typ := GetDeploymentHasUnionTypeQuery

	typStr := GetDeploymentHasType(typ)
	query.Type = typStr

	return GetDeploymentHasUnion{
		GetDeploymentHas: &query,
		Type:             typ,
	}
}

func (u *GetDeploymentHasUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "host":
		getDeploymentHasHost := new(GetDeploymentHasHost)
		if err := utils.UnmarshalJSON(data, &getDeploymentHasHost, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type GetDeploymentHasHost within GetDeploymentHasUnion: %w", string(data), err)
		}

		u.GetDeploymentHasHost = getDeploymentHasHost
		u.Type = GetDeploymentHasUnionTypeHost
		return nil
	case "header":
		getDeploymentHas := new(GetDeploymentHas)
		if err := utils.UnmarshalJSON(data, &getDeploymentHas, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type GetDeploymentHas within GetDeploymentHasUnion: %w", string(data), err)
		}

		u.GetDeploymentHas = getDeploymentHas
		u.Type = GetDeploymentHasUnionTypeHeader
		return nil
	case "cookie":
		getDeploymentHas := new(GetDeploymentHas)
		if err := utils.UnmarshalJSON(data, &getDeploymentHas, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cookie) type GetDeploymentHas within GetDeploymentHasUnion: %w", string(data), err)
		}

		u.GetDeploymentHas = getDeploymentHas
		u.Type = GetDeploymentHasUnionTypeCookie
		return nil
	case "query":
		getDeploymentHas := new(GetDeploymentHas)
		if err := utils.UnmarshalJSON(data, &getDeploymentHas, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == query) type GetDeploymentHas within GetDeploymentHasUnion: %w", string(data), err)
		}

		u.GetDeploymentHas = getDeploymentHas
		u.Type = GetDeploymentHasUnionTypeQuery
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentHasUnion", string(data))
}

func (u GetDeploymentHasUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentHasHost != nil {
		return utils.MarshalJSON(u.GetDeploymentHasHost, "", true)
	}

	if u.GetDeploymentHas != nil {
		return utils.MarshalJSON(u.GetDeploymentHas, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentHasUnion: all fields are null")
}

type GetDeploymentMissingType string

const (
	GetDeploymentMissingTypeHeader GetDeploymentMissingType = "header"
	GetDeploymentMissingTypeCookie GetDeploymentMissingType = "cookie"
	GetDeploymentMissingTypeQuery  GetDeploymentMissingType = "query"
)

func (e GetDeploymentMissingType) ToPointer() *GetDeploymentMissingType {
	return &e
}
func (e *GetDeploymentMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "query":
		*e = GetDeploymentMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentMissingType: %v", v)
	}
}

type GetDeploymentMissingEq2Type string

const (
	GetDeploymentMissingEq2TypeStr    GetDeploymentMissingEq2Type = "str"
	GetDeploymentMissingEq2TypeNumber GetDeploymentMissingEq2Type = "number"
)

type GetDeploymentMissingEq2 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type GetDeploymentMissingEq2Type
}

func CreateGetDeploymentMissingEq2Str(str string) GetDeploymentMissingEq2 {
	typ := GetDeploymentMissingEq2TypeStr

	return GetDeploymentMissingEq2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentMissingEq2Number(number float64) GetDeploymentMissingEq2 {
	typ := GetDeploymentMissingEq2TypeNumber

	return GetDeploymentMissingEq2{
		Number: &number,
		Type:   typ,
	}
}

func (u *GetDeploymentMissingEq2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentMissingEq2TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetDeploymentMissingEq2TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMissingEq2", string(data))
}

func (u GetDeploymentMissingEq2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMissingEq2: all fields are null")
}

type GetDeploymentMissingValue2 struct {
	Eq   *GetDeploymentMissingEq2 `json:"eq,omitempty"`
	Neq  *string                  `json:"neq,omitempty"`
	Inc  []string                 `json:"inc,omitempty"`
	Ninc []string                 `json:"ninc,omitempty"`
	Pre  *string                  `json:"pre,omitempty"`
	Suf  *string                  `json:"suf,omitempty"`
	Re   *string                  `json:"re,omitempty"`
	Gt   *float64                 `json:"gt,omitempty"`
	Gte  *float64                 `json:"gte,omitempty"`
	Lt   *float64                 `json:"lt,omitempty"`
	Lte  *float64                 `json:"lte,omitempty"`
}

func (g GetDeploymentMissingValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMissingValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMissingValue2) GetEq() *GetDeploymentMissingEq2 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *GetDeploymentMissingValue2) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *GetDeploymentMissingValue2) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *GetDeploymentMissingValue2) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *GetDeploymentMissingValue2) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *GetDeploymentMissingValue2) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *GetDeploymentMissingValue2) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *GetDeploymentMissingValue2) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetDeploymentMissingValue2) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetDeploymentMissingValue2) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *GetDeploymentMissingValue2) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetDeploymentMissingValueUnion2Type string

const (
	GetDeploymentMissingValueUnion2TypeStr                        GetDeploymentMissingValueUnion2Type = "str"
	GetDeploymentMissingValueUnion2TypeGetDeploymentMissingValue2 GetDeploymentMissingValueUnion2Type = "getDeployment_missing_value_2"
)

type GetDeploymentMissingValueUnion2 struct {
	Str                        *string                     `queryParam:"inline"`
	GetDeploymentMissingValue2 *GetDeploymentMissingValue2 `queryParam:"inline"`

	Type GetDeploymentMissingValueUnion2Type
}

func CreateGetDeploymentMissingValueUnion2Str(str string) GetDeploymentMissingValueUnion2 {
	typ := GetDeploymentMissingValueUnion2TypeStr

	return GetDeploymentMissingValueUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentMissingValueUnion2GetDeploymentMissingValue2(getDeploymentMissingValue2 GetDeploymentMissingValue2) GetDeploymentMissingValueUnion2 {
	typ := GetDeploymentMissingValueUnion2TypeGetDeploymentMissingValue2

	return GetDeploymentMissingValueUnion2{
		GetDeploymentMissingValue2: &getDeploymentMissingValue2,
		Type:                       typ,
	}
}

func (u *GetDeploymentMissingValueUnion2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentMissingValueUnion2TypeStr
		return nil
	}

	var getDeploymentMissingValue2 GetDeploymentMissingValue2 = GetDeploymentMissingValue2{}
	if err := utils.UnmarshalJSON(data, &getDeploymentMissingValue2, "", true, nil); err == nil {
		u.GetDeploymentMissingValue2 = &getDeploymentMissingValue2
		u.Type = GetDeploymentMissingValueUnion2TypeGetDeploymentMissingValue2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMissingValueUnion2", string(data))
}

func (u GetDeploymentMissingValueUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDeploymentMissingValue2 != nil {
		return utils.MarshalJSON(u.GetDeploymentMissingValue2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMissingValueUnion2: all fields are null")
}

type GetDeploymentMissing struct {
	Type  GetDeploymentMissingType         `json:"type"`
	Key   string                           `json:"key"`
	Value *GetDeploymentMissingValueUnion2 `json:"value,omitempty"`
}

func (g GetDeploymentMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMissing) GetType() GetDeploymentMissingType {
	if o == nil {
		return GetDeploymentMissingType("")
	}
	return o.Type
}

func (o *GetDeploymentMissing) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *GetDeploymentMissing) GetValue() *GetDeploymentMissingValueUnion2 {
	if o == nil {
		return nil
	}
	return o.Value
}

type GetDeploymentMissingTypeHost string

const (
	GetDeploymentMissingTypeHostHost GetDeploymentMissingTypeHost = "host"
)

func (e GetDeploymentMissingTypeHost) ToPointer() *GetDeploymentMissingTypeHost {
	return &e
}
func (e *GetDeploymentMissingTypeHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = GetDeploymentMissingTypeHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentMissingTypeHost: %v", v)
	}
}

type GetDeploymentMissingEq1Type string

const (
	GetDeploymentMissingEq1TypeStr    GetDeploymentMissingEq1Type = "str"
	GetDeploymentMissingEq1TypeNumber GetDeploymentMissingEq1Type = "number"
)

type GetDeploymentMissingEq1 struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type GetDeploymentMissingEq1Type
}

func CreateGetDeploymentMissingEq1Str(str string) GetDeploymentMissingEq1 {
	typ := GetDeploymentMissingEq1TypeStr

	return GetDeploymentMissingEq1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentMissingEq1Number(number float64) GetDeploymentMissingEq1 {
	typ := GetDeploymentMissingEq1TypeNumber

	return GetDeploymentMissingEq1{
		Number: &number,
		Type:   typ,
	}
}

func (u *GetDeploymentMissingEq1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentMissingEq1TypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetDeploymentMissingEq1TypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMissingEq1", string(data))
}

func (u GetDeploymentMissingEq1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMissingEq1: all fields are null")
}

type GetDeploymentMissingValue1 struct {
	Eq   *GetDeploymentMissingEq1 `json:"eq,omitempty"`
	Neq  *string                  `json:"neq,omitempty"`
	Inc  []string                 `json:"inc,omitempty"`
	Ninc []string                 `json:"ninc,omitempty"`
	Pre  *string                  `json:"pre,omitempty"`
	Suf  *string                  `json:"suf,omitempty"`
	Re   *string                  `json:"re,omitempty"`
	Gt   *float64                 `json:"gt,omitempty"`
	Gte  *float64                 `json:"gte,omitempty"`
	Lt   *float64                 `json:"lt,omitempty"`
	Lte  *float64                 `json:"lte,omitempty"`
}

func (g GetDeploymentMissingValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMissingValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMissingValue1) GetEq() *GetDeploymentMissingEq1 {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *GetDeploymentMissingValue1) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *GetDeploymentMissingValue1) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *GetDeploymentMissingValue1) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *GetDeploymentMissingValue1) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *GetDeploymentMissingValue1) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *GetDeploymentMissingValue1) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *GetDeploymentMissingValue1) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetDeploymentMissingValue1) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetDeploymentMissingValue1) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *GetDeploymentMissingValue1) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetDeploymentMissingValueUnion1Type string

const (
	GetDeploymentMissingValueUnion1TypeStr                        GetDeploymentMissingValueUnion1Type = "str"
	GetDeploymentMissingValueUnion1TypeGetDeploymentMissingValue1 GetDeploymentMissingValueUnion1Type = "getDeployment_missing_value_1"
)

type GetDeploymentMissingValueUnion1 struct {
	Str                        *string                     `queryParam:"inline"`
	GetDeploymentMissingValue1 *GetDeploymentMissingValue1 `queryParam:"inline"`

	Type GetDeploymentMissingValueUnion1Type
}

func CreateGetDeploymentMissingValueUnion1Str(str string) GetDeploymentMissingValueUnion1 {
	typ := GetDeploymentMissingValueUnion1TypeStr

	return GetDeploymentMissingValueUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentMissingValueUnion1GetDeploymentMissingValue1(getDeploymentMissingValue1 GetDeploymentMissingValue1) GetDeploymentMissingValueUnion1 {
	typ := GetDeploymentMissingValueUnion1TypeGetDeploymentMissingValue1

	return GetDeploymentMissingValueUnion1{
		GetDeploymentMissingValue1: &getDeploymentMissingValue1,
		Type:                       typ,
	}
}

func (u *GetDeploymentMissingValueUnion1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentMissingValueUnion1TypeStr
		return nil
	}

	var getDeploymentMissingValue1 GetDeploymentMissingValue1 = GetDeploymentMissingValue1{}
	if err := utils.UnmarshalJSON(data, &getDeploymentMissingValue1, "", true, nil); err == nil {
		u.GetDeploymentMissingValue1 = &getDeploymentMissingValue1
		u.Type = GetDeploymentMissingValueUnion1TypeGetDeploymentMissingValue1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMissingValueUnion1", string(data))
}

func (u GetDeploymentMissingValueUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDeploymentMissingValue1 != nil {
		return utils.MarshalJSON(u.GetDeploymentMissingValue1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMissingValueUnion1: all fields are null")
}

type GetDeploymentMissingHost struct {
	Type  GetDeploymentMissingTypeHost    `json:"type"`
	Value GetDeploymentMissingValueUnion1 `json:"value"`
}

func (g GetDeploymentMissingHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMissingHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMissingHost) GetType() GetDeploymentMissingTypeHost {
	if o == nil {
		return GetDeploymentMissingTypeHost("")
	}
	return o.Type
}

func (o *GetDeploymentMissingHost) GetValue() GetDeploymentMissingValueUnion1 {
	if o == nil {
		return GetDeploymentMissingValueUnion1{}
	}
	return o.Value
}

type GetDeploymentMissingUnionType string

const (
	GetDeploymentMissingUnionTypeHost   GetDeploymentMissingUnionType = "host"
	GetDeploymentMissingUnionTypeHeader GetDeploymentMissingUnionType = "header"
	GetDeploymentMissingUnionTypeCookie GetDeploymentMissingUnionType = "cookie"
	GetDeploymentMissingUnionTypeQuery  GetDeploymentMissingUnionType = "query"
)

type GetDeploymentMissingUnion struct {
	GetDeploymentMissingHost *GetDeploymentMissingHost `queryParam:"inline"`
	GetDeploymentMissing     *GetDeploymentMissing     `queryParam:"inline"`

	Type GetDeploymentMissingUnionType
}

func CreateGetDeploymentMissingUnionHost(host GetDeploymentMissingHost) GetDeploymentMissingUnion {
	typ := GetDeploymentMissingUnionTypeHost

	typStr := GetDeploymentMissingTypeHost(typ)
	host.Type = typStr

	return GetDeploymentMissingUnion{
		GetDeploymentMissingHost: &host,
		Type:                     typ,
	}
}

func CreateGetDeploymentMissingUnionHeader(header GetDeploymentMissing) GetDeploymentMissingUnion {
	typ := GetDeploymentMissingUnionTypeHeader

	typStr := GetDeploymentMissingType(typ)
	header.Type = typStr

	return GetDeploymentMissingUnion{
		GetDeploymentMissing: &header,
		Type:                 typ,
	}
}

func CreateGetDeploymentMissingUnionCookie(cookie GetDeploymentMissing) GetDeploymentMissingUnion {
	typ := GetDeploymentMissingUnionTypeCookie

	typStr := GetDeploymentMissingType(typ)
	cookie.Type = typStr

	return GetDeploymentMissingUnion{
		GetDeploymentMissing: &cookie,
		Type:                 typ,
	}
}

func CreateGetDeploymentMissingUnionQuery(query GetDeploymentMissing) GetDeploymentMissingUnion {
	typ := GetDeploymentMissingUnionTypeQuery

	typStr := GetDeploymentMissingType(typ)
	query.Type = typStr

	return GetDeploymentMissingUnion{
		GetDeploymentMissing: &query,
		Type:                 typ,
	}
}

func (u *GetDeploymentMissingUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "host":
		getDeploymentMissingHost := new(GetDeploymentMissingHost)
		if err := utils.UnmarshalJSON(data, &getDeploymentMissingHost, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type GetDeploymentMissingHost within GetDeploymentMissingUnion: %w", string(data), err)
		}

		u.GetDeploymentMissingHost = getDeploymentMissingHost
		u.Type = GetDeploymentMissingUnionTypeHost
		return nil
	case "header":
		getDeploymentMissing := new(GetDeploymentMissing)
		if err := utils.UnmarshalJSON(data, &getDeploymentMissing, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type GetDeploymentMissing within GetDeploymentMissingUnion: %w", string(data), err)
		}

		u.GetDeploymentMissing = getDeploymentMissing
		u.Type = GetDeploymentMissingUnionTypeHeader
		return nil
	case "cookie":
		getDeploymentMissing := new(GetDeploymentMissing)
		if err := utils.UnmarshalJSON(data, &getDeploymentMissing, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == cookie) type GetDeploymentMissing within GetDeploymentMissingUnion: %w", string(data), err)
		}

		u.GetDeploymentMissing = getDeploymentMissing
		u.Type = GetDeploymentMissingUnionTypeCookie
		return nil
	case "query":
		getDeploymentMissing := new(GetDeploymentMissing)
		if err := utils.UnmarshalJSON(data, &getDeploymentMissing, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == query) type GetDeploymentMissing within GetDeploymentMissingUnion: %w", string(data), err)
		}

		u.GetDeploymentMissing = getDeploymentMissing
		u.Type = GetDeploymentMissingUnionTypeQuery
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMissingUnion", string(data))
}

func (u GetDeploymentMissingUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentMissingHost != nil {
		return utils.MarshalJSON(u.GetDeploymentMissingHost, "", true)
	}

	if u.GetDeploymentMissing != nil {
		return utils.MarshalJSON(u.GetDeploymentMissing, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMissingUnion: all fields are null")
}

type GetDeploymentAction string

const (
	GetDeploymentActionChallenge GetDeploymentAction = "challenge"
	GetDeploymentActionDeny      GetDeploymentAction = "deny"
)

func (e GetDeploymentAction) ToPointer() *GetDeploymentAction {
	return &e
}
func (e *GetDeploymentAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "challenge":
		fallthrough
	case "deny":
		*e = GetDeploymentAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentAction: %v", v)
	}
}

type GetDeploymentMitigate struct {
	Action GetDeploymentAction `json:"action"`
}

func (g GetDeploymentMitigate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMitigate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMitigate) GetAction() GetDeploymentAction {
	if o == nil {
		return GetDeploymentAction("")
	}
	return o.Action
}

type GetDeploymentTransformType string

const (
	GetDeploymentTransformTypeRequestHeaders  GetDeploymentTransformType = "request.headers"
	GetDeploymentTransformTypeRequestQuery    GetDeploymentTransformType = "request.query"
	GetDeploymentTransformTypeResponseHeaders GetDeploymentTransformType = "response.headers"
)

func (e GetDeploymentTransformType) ToPointer() *GetDeploymentTransformType {
	return &e
}
func (e *GetDeploymentTransformType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "request.headers":
		fallthrough
	case "request.query":
		fallthrough
	case "response.headers":
		*e = GetDeploymentTransformType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentTransformType: %v", v)
	}
}

type GetDeploymentOp string

const (
	GetDeploymentOpAppend GetDeploymentOp = "append"
	GetDeploymentOpSet    GetDeploymentOp = "set"
	GetDeploymentOpDelete GetDeploymentOp = "delete"
)

func (e GetDeploymentOp) ToPointer() *GetDeploymentOp {
	return &e
}
func (e *GetDeploymentOp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "append":
		fallthrough
	case "set":
		fallthrough
	case "delete":
		*e = GetDeploymentOp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentOp: %v", v)
	}
}

type GetDeploymentKeyEqType string

const (
	GetDeploymentKeyEqTypeStr    GetDeploymentKeyEqType = "str"
	GetDeploymentKeyEqTypeNumber GetDeploymentKeyEqType = "number"
)

type GetDeploymentKeyEq struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type GetDeploymentKeyEqType
}

func CreateGetDeploymentKeyEqStr(str string) GetDeploymentKeyEq {
	typ := GetDeploymentKeyEqTypeStr

	return GetDeploymentKeyEq{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentKeyEqNumber(number float64) GetDeploymentKeyEq {
	typ := GetDeploymentKeyEqTypeNumber

	return GetDeploymentKeyEq{
		Number: &number,
		Type:   typ,
	}
}

func (u *GetDeploymentKeyEq) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentKeyEqTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetDeploymentKeyEqTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentKeyEq", string(data))
}

func (u GetDeploymentKeyEq) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentKeyEq: all fields are null")
}

type GetDeploymentKey struct {
	Eq   *GetDeploymentKeyEq `json:"eq,omitempty"`
	Neq  *string             `json:"neq,omitempty"`
	Inc  []string            `json:"inc,omitempty"`
	Ninc []string            `json:"ninc,omitempty"`
	Pre  *string             `json:"pre,omitempty"`
	Suf  *string             `json:"suf,omitempty"`
	Gt   *float64            `json:"gt,omitempty"`
	Gte  *float64            `json:"gte,omitempty"`
	Lt   *float64            `json:"lt,omitempty"`
	Lte  *float64            `json:"lte,omitempty"`
}

func (g GetDeploymentKey) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentKey) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentKey) GetEq() *GetDeploymentKeyEq {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *GetDeploymentKey) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *GetDeploymentKey) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *GetDeploymentKey) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *GetDeploymentKey) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *GetDeploymentKey) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *GetDeploymentKey) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *GetDeploymentKey) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *GetDeploymentKey) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *GetDeploymentKey) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type GetDeploymentKeyUnionType string

const (
	GetDeploymentKeyUnionTypeStr              GetDeploymentKeyUnionType = "str"
	GetDeploymentKeyUnionTypeGetDeploymentKey GetDeploymentKeyUnionType = "getDeployment_key"
)

type GetDeploymentKeyUnion struct {
	Str              *string           `queryParam:"inline"`
	GetDeploymentKey *GetDeploymentKey `queryParam:"inline"`

	Type GetDeploymentKeyUnionType
}

func CreateGetDeploymentKeyUnionStr(str string) GetDeploymentKeyUnion {
	typ := GetDeploymentKeyUnionTypeStr

	return GetDeploymentKeyUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentKeyUnionGetDeploymentKey(getDeploymentKey GetDeploymentKey) GetDeploymentKeyUnion {
	typ := GetDeploymentKeyUnionTypeGetDeploymentKey

	return GetDeploymentKeyUnion{
		GetDeploymentKey: &getDeploymentKey,
		Type:             typ,
	}
}

func (u *GetDeploymentKeyUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentKeyUnionTypeStr
		return nil
	}

	var getDeploymentKey GetDeploymentKey = GetDeploymentKey{}
	if err := utils.UnmarshalJSON(data, &getDeploymentKey, "", true, nil); err == nil {
		u.GetDeploymentKey = &getDeploymentKey
		u.Type = GetDeploymentKeyUnionTypeGetDeploymentKey
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentKeyUnion", string(data))
}

func (u GetDeploymentKeyUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDeploymentKey != nil {
		return utils.MarshalJSON(u.GetDeploymentKey, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentKeyUnion: all fields are null")
}

type GetDeploymentRouteTarget struct {
	Key GetDeploymentKeyUnion `json:"key"`
}

func (g GetDeploymentRouteTarget) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentRouteTarget) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"key"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentRouteTarget) GetKey() GetDeploymentKeyUnion {
	if o == nil {
		return GetDeploymentKeyUnion{}
	}
	return o.Key
}

type GetDeploymentArgsType string

const (
	GetDeploymentArgsTypeStr        GetDeploymentArgsType = "str"
	GetDeploymentArgsTypeArrayOfStr GetDeploymentArgsType = "arrayOfStr"
)

type GetDeploymentArgs struct {
	Str        *string  `queryParam:"inline"`
	ArrayOfStr []string `queryParam:"inline"`

	Type GetDeploymentArgsType
}

func CreateGetDeploymentArgsStr(str string) GetDeploymentArgs {
	typ := GetDeploymentArgsTypeStr

	return GetDeploymentArgs{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDeploymentArgsArrayOfStr(arrayOfStr []string) GetDeploymentArgs {
	typ := GetDeploymentArgsTypeArrayOfStr

	return GetDeploymentArgs{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func (u *GetDeploymentArgs) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDeploymentArgsTypeStr
		return nil
	}

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = GetDeploymentArgsTypeArrayOfStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentArgs", string(data))
}

func (u GetDeploymentArgs) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentArgs: all fields are null")
}

type GetDeploymentTransform struct {
	Type   GetDeploymentTransformType `json:"type"`
	Op     GetDeploymentOp            `json:"op"`
	Target GetDeploymentRouteTarget   `json:"target"`
	Args   *GetDeploymentArgs         `json:"args,omitempty"`
	Env    []string                   `json:"env,omitempty"`
}

func (g GetDeploymentTransform) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentTransform) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "op", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentTransform) GetType() GetDeploymentTransformType {
	if o == nil {
		return GetDeploymentTransformType("")
	}
	return o.Type
}

func (o *GetDeploymentTransform) GetOp() GetDeploymentOp {
	if o == nil {
		return GetDeploymentOp("")
	}
	return o.Op
}

func (o *GetDeploymentTransform) GetTarget() GetDeploymentRouteTarget {
	if o == nil {
		return GetDeploymentRouteTarget{}
	}
	return o.Target
}

func (o *GetDeploymentTransform) GetArgs() *GetDeploymentArgs {
	if o == nil {
		return nil
	}
	return o.Args
}

func (o *GetDeploymentTransform) GetEnv() []string {
	if o == nil {
		return nil
	}
	return o.Env
}

type GetDeploymentLocale struct {
	Redirect map[string]string `json:"redirect,omitempty"`
	Cookie   *string           `json:"cookie,omitempty"`
}

func (g GetDeploymentLocale) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentLocale) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentLocale) GetRedirect() map[string]string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *GetDeploymentLocale) GetCookie() *string {
	if o == nil {
		return nil
	}
	return o.Cookie
}

type GetDeploymentRoute1 struct {
	Src           string                      `json:"src"`
	Dest          *string                     `json:"dest,omitempty"`
	Headers       map[string]string           `json:"headers,omitempty"`
	Methods       []string                    `json:"methods,omitempty"`
	Continue      *bool                       `json:"continue,omitempty"`
	Override      *bool                       `json:"override,omitempty"`
	CaseSensitive *bool                       `json:"caseSensitive,omitempty"`
	Check         *bool                       `json:"check,omitempty"`
	Important     *bool                       `json:"important,omitempty"`
	Status        *float64                    `json:"status,omitempty"`
	Has           []GetDeploymentHasUnion     `json:"has,omitempty"`
	Missing       []GetDeploymentMissingUnion `json:"missing,omitempty"`
	Mitigate      *GetDeploymentMitigate      `json:"mitigate,omitempty"`
	Transforms    []GetDeploymentTransform    `json:"transforms,omitempty"`
	Env           []string                    `json:"env,omitempty"`
	Locale        *GetDeploymentLocale        `json:"locale,omitempty"`
	// A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
	MiddlewarePath *string `json:"middlewarePath,omitempty"`
	// The original middleware matchers.
	MiddlewareRawSrc []string `json:"middlewareRawSrc,omitempty"`
	// A middleware index in the `middleware` key under the build result
	Middleware                *float64 `json:"middleware,omitempty"`
	RespectOriginCacheControl *bool    `json:"respectOriginCacheControl,omitempty"`
}

func (g GetDeploymentRoute1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentRoute1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"src"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentRoute1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *GetDeploymentRoute1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *GetDeploymentRoute1) GetHeaders() map[string]string {
	if o == nil {
		return nil
	}
	return o.Headers
}

func (o *GetDeploymentRoute1) GetMethods() []string {
	if o == nil {
		return nil
	}
	return o.Methods
}

func (o *GetDeploymentRoute1) GetContinue() *bool {
	if o == nil {
		return nil
	}
	return o.Continue
}

func (o *GetDeploymentRoute1) GetOverride() *bool {
	if o == nil {
		return nil
	}
	return o.Override
}

func (o *GetDeploymentRoute1) GetCaseSensitive() *bool {
	if o == nil {
		return nil
	}
	return o.CaseSensitive
}

func (o *GetDeploymentRoute1) GetCheck() *bool {
	if o == nil {
		return nil
	}
	return o.Check
}

func (o *GetDeploymentRoute1) GetImportant() *bool {
	if o == nil {
		return nil
	}
	return o.Important
}

func (o *GetDeploymentRoute1) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *GetDeploymentRoute1) GetHas() []GetDeploymentHasUnion {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *GetDeploymentRoute1) GetMissing() []GetDeploymentMissingUnion {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *GetDeploymentRoute1) GetMitigate() *GetDeploymentMitigate {
	if o == nil {
		return nil
	}
	return o.Mitigate
}

func (o *GetDeploymentRoute1) GetTransforms() []GetDeploymentTransform {
	if o == nil {
		return nil
	}
	return o.Transforms
}

func (o *GetDeploymentRoute1) GetEnv() []string {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetDeploymentRoute1) GetLocale() *GetDeploymentLocale {
	if o == nil {
		return nil
	}
	return o.Locale
}

func (o *GetDeploymentRoute1) GetMiddlewarePath() *string {
	if o == nil {
		return nil
	}
	return o.MiddlewarePath
}

func (o *GetDeploymentRoute1) GetMiddlewareRawSrc() []string {
	if o == nil {
		return nil
	}
	return o.MiddlewareRawSrc
}

func (o *GetDeploymentRoute1) GetMiddleware() *float64 {
	if o == nil {
		return nil
	}
	return o.Middleware
}

func (o *GetDeploymentRoute1) GetRespectOriginCacheControl() *bool {
	if o == nil {
		return nil
	}
	return o.RespectOriginCacheControl
}

type GetDeploymentRouteUnionType string

const (
	GetDeploymentRouteUnionTypeGetDeploymentRoute1 GetDeploymentRouteUnionType = "getDeployment_route_1"
	GetDeploymentRouteUnionTypeGetDeploymentRoute2 GetDeploymentRouteUnionType = "getDeployment_route_2"
	GetDeploymentRouteUnionTypeGetDeploymentRoute3 GetDeploymentRouteUnionType = "getDeployment_route_3"
)

type GetDeploymentRouteUnion struct {
	GetDeploymentRoute1 *GetDeploymentRoute1 `queryParam:"inline"`
	GetDeploymentRoute2 *GetDeploymentRoute2 `queryParam:"inline"`
	GetDeploymentRoute3 *GetDeploymentRoute3 `queryParam:"inline"`

	Type GetDeploymentRouteUnionType
}

func CreateGetDeploymentRouteUnionGetDeploymentRoute1(getDeploymentRoute1 GetDeploymentRoute1) GetDeploymentRouteUnion {
	typ := GetDeploymentRouteUnionTypeGetDeploymentRoute1

	return GetDeploymentRouteUnion{
		GetDeploymentRoute1: &getDeploymentRoute1,
		Type:                typ,
	}
}

func CreateGetDeploymentRouteUnionGetDeploymentRoute2(getDeploymentRoute2 GetDeploymentRoute2) GetDeploymentRouteUnion {
	typ := GetDeploymentRouteUnionTypeGetDeploymentRoute2

	return GetDeploymentRouteUnion{
		GetDeploymentRoute2: &getDeploymentRoute2,
		Type:                typ,
	}
}

func CreateGetDeploymentRouteUnionGetDeploymentRoute3(getDeploymentRoute3 GetDeploymentRoute3) GetDeploymentRouteUnion {
	typ := GetDeploymentRouteUnionTypeGetDeploymentRoute3

	return GetDeploymentRouteUnion{
		GetDeploymentRoute3: &getDeploymentRoute3,
		Type:                typ,
	}
}

func (u *GetDeploymentRouteUnion) UnmarshalJSON(data []byte) error {

	var getDeploymentRoute3 GetDeploymentRoute3 = GetDeploymentRoute3{}
	if err := utils.UnmarshalJSON(data, &getDeploymentRoute3, "", true, nil); err == nil {
		u.GetDeploymentRoute3 = &getDeploymentRoute3
		u.Type = GetDeploymentRouteUnionTypeGetDeploymentRoute3
		return nil
	}

	var getDeploymentRoute1 GetDeploymentRoute1 = GetDeploymentRoute1{}
	if err := utils.UnmarshalJSON(data, &getDeploymentRoute1, "", true, nil); err == nil {
		u.GetDeploymentRoute1 = &getDeploymentRoute1
		u.Type = GetDeploymentRouteUnionTypeGetDeploymentRoute1
		return nil
	}

	var getDeploymentRoute2 GetDeploymentRoute2 = GetDeploymentRoute2{}
	if err := utils.UnmarshalJSON(data, &getDeploymentRoute2, "", true, nil); err == nil {
		u.GetDeploymentRoute2 = &getDeploymentRoute2
		u.Type = GetDeploymentRouteUnionTypeGetDeploymentRoute2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentRouteUnion", string(data))
}

func (u GetDeploymentRouteUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentRoute1 != nil {
		return utils.MarshalJSON(u.GetDeploymentRoute1, "", true)
	}

	if u.GetDeploymentRoute2 != nil {
		return utils.MarshalJSON(u.GetDeploymentRoute2, "", true)
	}

	if u.GetDeploymentRoute3 != nil {
		return utils.MarshalJSON(u.GetDeploymentRoute3, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentRouteUnion: all fields are null")
}

type GetDeploymentGitRepoTypeBitbucket string

const (
	GetDeploymentGitRepoTypeBitbucketBitbucket GetDeploymentGitRepoTypeBitbucket = "bitbucket"
)

func (e GetDeploymentGitRepoTypeBitbucket) ToPointer() *GetDeploymentGitRepoTypeBitbucket {
	return &e
}
func (e *GetDeploymentGitRepoTypeBitbucket) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = GetDeploymentGitRepoTypeBitbucket(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentGitRepoTypeBitbucket: %v", v)
	}
}

type GetDeploymentOwnerType3 string

const (
	GetDeploymentOwnerType3Team GetDeploymentOwnerType3 = "team"
	GetDeploymentOwnerType3User GetDeploymentOwnerType3 = "user"
)

func (e GetDeploymentOwnerType3) ToPointer() *GetDeploymentOwnerType3 {
	return &e
}
func (e *GetDeploymentOwnerType3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = GetDeploymentOwnerType3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentOwnerType3: %v", v)
	}
}

type GetDeploymentGitRepoBitbucket struct {
	Owner         string                            `json:"owner"`
	RepoUUID      string                            `json:"repoUuid"`
	Slug          string                            `json:"slug"`
	Type          GetDeploymentGitRepoTypeBitbucket `json:"type"`
	WorkspaceUUID string                            `json:"workspaceUuid"`
	Path          string                            `json:"path"`
	DefaultBranch string                            `json:"defaultBranch"`
	Name          string                            `json:"name"`
	Private       bool                              `json:"private"`
	OwnerType     GetDeploymentOwnerType3           `json:"ownerType"`
}

func (g GetDeploymentGitRepoBitbucket) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentGitRepoBitbucket) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"owner", "repoUuid", "slug", "type", "workspaceUuid", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentGitRepoBitbucket) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GetDeploymentGitRepoBitbucket) GetRepoUUID() string {
	if o == nil {
		return ""
	}
	return o.RepoUUID
}

func (o *GetDeploymentGitRepoBitbucket) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetDeploymentGitRepoBitbucket) GetType() GetDeploymentGitRepoTypeBitbucket {
	if o == nil {
		return GetDeploymentGitRepoTypeBitbucket("")
	}
	return o.Type
}

func (o *GetDeploymentGitRepoBitbucket) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *GetDeploymentGitRepoBitbucket) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GetDeploymentGitRepoBitbucket) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GetDeploymentGitRepoBitbucket) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetDeploymentGitRepoBitbucket) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetDeploymentGitRepoBitbucket) GetOwnerType() GetDeploymentOwnerType3 {
	if o == nil {
		return GetDeploymentOwnerType3("")
	}
	return o.OwnerType
}

type GetDeploymentGitRepoTypeGithub string

const (
	GetDeploymentGitRepoTypeGithubGithub GetDeploymentGitRepoTypeGithub = "github"
)

func (e GetDeploymentGitRepoTypeGithub) ToPointer() *GetDeploymentGitRepoTypeGithub {
	return &e
}
func (e *GetDeploymentGitRepoTypeGithub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = GetDeploymentGitRepoTypeGithub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentGitRepoTypeGithub: %v", v)
	}
}

type GetDeploymentOwnerType2 string

const (
	GetDeploymentOwnerType2Team GetDeploymentOwnerType2 = "team"
	GetDeploymentOwnerType2User GetDeploymentOwnerType2 = "user"
)

func (e GetDeploymentOwnerType2) ToPointer() *GetDeploymentOwnerType2 {
	return &e
}
func (e *GetDeploymentOwnerType2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = GetDeploymentOwnerType2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentOwnerType2: %v", v)
	}
}

type GetDeploymentGitRepoGithub struct {
	Org           string                         `json:"org"`
	Repo          string                         `json:"repo"`
	RepoID        float64                        `json:"repoId"`
	Type          GetDeploymentGitRepoTypeGithub `json:"type"`
	RepoOwnerID   float64                        `json:"repoOwnerId"`
	Path          string                         `json:"path"`
	DefaultBranch string                         `json:"defaultBranch"`
	Name          string                         `json:"name"`
	Private       bool                           `json:"private"`
	OwnerType     GetDeploymentOwnerType2        `json:"ownerType"`
}

func (g GetDeploymentGitRepoGithub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentGitRepoGithub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"org", "repo", "repoId", "type", "repoOwnerId", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentGitRepoGithub) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GetDeploymentGitRepoGithub) GetRepo() string {
	if o == nil {
		return ""
	}
	return o.Repo
}

func (o *GetDeploymentGitRepoGithub) GetRepoID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoID
}

func (o *GetDeploymentGitRepoGithub) GetType() GetDeploymentGitRepoTypeGithub {
	if o == nil {
		return GetDeploymentGitRepoTypeGithub("")
	}
	return o.Type
}

func (o *GetDeploymentGitRepoGithub) GetRepoOwnerID() float64 {
	if o == nil {
		return 0.0
	}
	return o.RepoOwnerID
}

func (o *GetDeploymentGitRepoGithub) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GetDeploymentGitRepoGithub) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GetDeploymentGitRepoGithub) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetDeploymentGitRepoGithub) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetDeploymentGitRepoGithub) GetOwnerType() GetDeploymentOwnerType2 {
	if o == nil {
		return GetDeploymentOwnerType2("")
	}
	return o.OwnerType
}

type GetDeploymentGitRepoTypeGitlab string

const (
	GetDeploymentGitRepoTypeGitlabGitlab GetDeploymentGitRepoTypeGitlab = "gitlab"
)

func (e GetDeploymentGitRepoTypeGitlab) ToPointer() *GetDeploymentGitRepoTypeGitlab {
	return &e
}
func (e *GetDeploymentGitRepoTypeGitlab) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = GetDeploymentGitRepoTypeGitlab(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentGitRepoTypeGitlab: %v", v)
	}
}

type GetDeploymentOwnerType1 string

const (
	GetDeploymentOwnerType1Team GetDeploymentOwnerType1 = "team"
	GetDeploymentOwnerType1User GetDeploymentOwnerType1 = "user"
)

func (e GetDeploymentOwnerType1) ToPointer() *GetDeploymentOwnerType1 {
	return &e
}
func (e *GetDeploymentOwnerType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "user":
		*e = GetDeploymentOwnerType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentOwnerType1: %v", v)
	}
}

type GetDeploymentGitRepoGitlab struct {
	Namespace     string                         `json:"namespace"`
	ProjectID     float64                        `json:"projectId"`
	Type          GetDeploymentGitRepoTypeGitlab `json:"type"`
	URL           string                         `json:"url"`
	Path          string                         `json:"path"`
	DefaultBranch string                         `json:"defaultBranch"`
	Name          string                         `json:"name"`
	Private       bool                           `json:"private"`
	OwnerType     GetDeploymentOwnerType1        `json:"ownerType"`
}

func (g GetDeploymentGitRepoGitlab) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentGitRepoGitlab) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"namespace", "projectId", "type", "url", "path", "defaultBranch", "name", "private", "ownerType"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentGitRepoGitlab) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *GetDeploymentGitRepoGitlab) GetProjectID() float64 {
	if o == nil {
		return 0.0
	}
	return o.ProjectID
}

func (o *GetDeploymentGitRepoGitlab) GetType() GetDeploymentGitRepoTypeGitlab {
	if o == nil {
		return GetDeploymentGitRepoTypeGitlab("")
	}
	return o.Type
}

func (o *GetDeploymentGitRepoGitlab) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GetDeploymentGitRepoGitlab) GetPath() string {
	if o == nil {
		return ""
	}
	return o.Path
}

func (o *GetDeploymentGitRepoGitlab) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *GetDeploymentGitRepoGitlab) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetDeploymentGitRepoGitlab) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetDeploymentGitRepoGitlab) GetOwnerType() GetDeploymentOwnerType1 {
	if o == nil {
		return GetDeploymentOwnerType1("")
	}
	return o.OwnerType
}

type GetDeploymentGitRepoUnionType string

const (
	GetDeploymentGitRepoUnionTypeGitlab    GetDeploymentGitRepoUnionType = "gitlab"
	GetDeploymentGitRepoUnionTypeGithub    GetDeploymentGitRepoUnionType = "github"
	GetDeploymentGitRepoUnionTypeBitbucket GetDeploymentGitRepoUnionType = "bitbucket"
)

type GetDeploymentGitRepoUnion struct {
	GetDeploymentGitRepoGitlab    *GetDeploymentGitRepoGitlab    `queryParam:"inline"`
	GetDeploymentGitRepoGithub    *GetDeploymentGitRepoGithub    `queryParam:"inline"`
	GetDeploymentGitRepoBitbucket *GetDeploymentGitRepoBitbucket `queryParam:"inline"`

	Type GetDeploymentGitRepoUnionType
}

func CreateGetDeploymentGitRepoUnionGitlab(gitlab GetDeploymentGitRepoGitlab) GetDeploymentGitRepoUnion {
	typ := GetDeploymentGitRepoUnionTypeGitlab

	typStr := GetDeploymentGitRepoTypeGitlab(typ)
	gitlab.Type = typStr

	return GetDeploymentGitRepoUnion{
		GetDeploymentGitRepoGitlab: &gitlab,
		Type:                       typ,
	}
}

func CreateGetDeploymentGitRepoUnionGithub(github GetDeploymentGitRepoGithub) GetDeploymentGitRepoUnion {
	typ := GetDeploymentGitRepoUnionTypeGithub

	typStr := GetDeploymentGitRepoTypeGithub(typ)
	github.Type = typStr

	return GetDeploymentGitRepoUnion{
		GetDeploymentGitRepoGithub: &github,
		Type:                       typ,
	}
}

func CreateGetDeploymentGitRepoUnionBitbucket(bitbucket GetDeploymentGitRepoBitbucket) GetDeploymentGitRepoUnion {
	typ := GetDeploymentGitRepoUnionTypeBitbucket

	typStr := GetDeploymentGitRepoTypeBitbucket(typ)
	bitbucket.Type = typStr

	return GetDeploymentGitRepoUnion{
		GetDeploymentGitRepoBitbucket: &bitbucket,
		Type:                          typ,
	}
}

func (u *GetDeploymentGitRepoUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "gitlab":
		getDeploymentGitRepoGitlab := new(GetDeploymentGitRepoGitlab)
		if err := utils.UnmarshalJSON(data, &getDeploymentGitRepoGitlab, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == gitlab) type GetDeploymentGitRepoGitlab within GetDeploymentGitRepoUnion: %w", string(data), err)
		}

		u.GetDeploymentGitRepoGitlab = getDeploymentGitRepoGitlab
		u.Type = GetDeploymentGitRepoUnionTypeGitlab
		return nil
	case "github":
		getDeploymentGitRepoGithub := new(GetDeploymentGitRepoGithub)
		if err := utils.UnmarshalJSON(data, &getDeploymentGitRepoGithub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github) type GetDeploymentGitRepoGithub within GetDeploymentGitRepoUnion: %w", string(data), err)
		}

		u.GetDeploymentGitRepoGithub = getDeploymentGitRepoGithub
		u.Type = GetDeploymentGitRepoUnionTypeGithub
		return nil
	case "bitbucket":
		getDeploymentGitRepoBitbucket := new(GetDeploymentGitRepoBitbucket)
		if err := utils.UnmarshalJSON(data, &getDeploymentGitRepoBitbucket, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == bitbucket) type GetDeploymentGitRepoBitbucket within GetDeploymentGitRepoUnion: %w", string(data), err)
		}

		u.GetDeploymentGitRepoBitbucket = getDeploymentGitRepoBitbucket
		u.Type = GetDeploymentGitRepoUnionTypeBitbucket
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentGitRepoUnion", string(data))
}

func (u GetDeploymentGitRepoUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentGitRepoGitlab != nil {
		return utils.MarshalJSON(u.GetDeploymentGitRepoGitlab, "", true)
	}

	if u.GetDeploymentGitRepoGithub != nil {
		return utils.MarshalJSON(u.GetDeploymentGitRepoGithub, "", true)
	}

	if u.GetDeploymentGitRepoBitbucket != nil {
		return utils.MarshalJSON(u.GetDeploymentGitRepoBitbucket, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentGitRepoUnion: all fields are null")
}

// GetDeploymentFlags2 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type GetDeploymentFlags2 struct {
}

func (g GetDeploymentFlags2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentFlags2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDeploymentOption struct {
	Value *components.FlagJSONValue `json:"value"`
	Label *string                   `json:"label,omitempty"`
}

func (g GetDeploymentOption) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentOption) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentOption) GetValue() *components.FlagJSONValue {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *GetDeploymentOption) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

type GetDeploymentDefinitions struct {
	Options     []GetDeploymentOption `json:"options,omitempty"`
	URL         *string               `json:"url,omitempty"`
	Description *string               `json:"description,omitempty"`
}

func (g GetDeploymentDefinitions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentDefinitions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentDefinitions) GetOptions() []GetDeploymentOption {
	if o == nil {
		return nil
	}
	return o.Options
}

func (o *GetDeploymentDefinitions) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *GetDeploymentDefinitions) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

// GetDeploymentFlags1 - Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
type GetDeploymentFlags1 struct {
	Definitions map[string]GetDeploymentDefinitions `json:"definitions"`
}

func (g GetDeploymentFlags1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentFlags1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"definitions"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentFlags1) GetDefinitions() map[string]GetDeploymentDefinitions {
	if o == nil {
		return map[string]GetDeploymentDefinitions{}
	}
	return o.Definitions
}

type GetDeploymentFlagsUnionType string

const (
	GetDeploymentFlagsUnionTypeGetDeploymentFlags1        GetDeploymentFlagsUnionType = "getDeployment_flags_1"
	GetDeploymentFlagsUnionTypeArrayOfGetDeploymentFlags2 GetDeploymentFlagsUnionType = "arrayOfGetDeploymentFlags2"
)

type GetDeploymentFlagsUnion struct {
	GetDeploymentFlags1        *GetDeploymentFlags1  `queryParam:"inline"`
	ArrayOfGetDeploymentFlags2 []GetDeploymentFlags2 `queryParam:"inline"`

	Type GetDeploymentFlagsUnionType
}

func CreateGetDeploymentFlagsUnionGetDeploymentFlags1(getDeploymentFlags1 GetDeploymentFlags1) GetDeploymentFlagsUnion {
	typ := GetDeploymentFlagsUnionTypeGetDeploymentFlags1

	return GetDeploymentFlagsUnion{
		GetDeploymentFlags1: &getDeploymentFlags1,
		Type:                typ,
	}
}

func CreateGetDeploymentFlagsUnionArrayOfGetDeploymentFlags2(arrayOfGetDeploymentFlags2 []GetDeploymentFlags2) GetDeploymentFlagsUnion {
	typ := GetDeploymentFlagsUnionTypeArrayOfGetDeploymentFlags2

	return GetDeploymentFlagsUnion{
		ArrayOfGetDeploymentFlags2: arrayOfGetDeploymentFlags2,
		Type:                       typ,
	}
}

func (u *GetDeploymentFlagsUnion) UnmarshalJSON(data []byte) error {

	var getDeploymentFlags1 GetDeploymentFlags1 = GetDeploymentFlags1{}
	if err := utils.UnmarshalJSON(data, &getDeploymentFlags1, "", true, nil); err == nil {
		u.GetDeploymentFlags1 = &getDeploymentFlags1
		u.Type = GetDeploymentFlagsUnionTypeGetDeploymentFlags1
		return nil
	}

	var arrayOfGetDeploymentFlags2 []GetDeploymentFlags2 = []GetDeploymentFlags2{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetDeploymentFlags2, "", true, nil); err == nil {
		u.ArrayOfGetDeploymentFlags2 = arrayOfGetDeploymentFlags2
		u.Type = GetDeploymentFlagsUnionTypeArrayOfGetDeploymentFlags2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentFlagsUnion", string(data))
}

func (u GetDeploymentFlagsUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentFlags1 != nil {
		return utils.MarshalJSON(u.GetDeploymentFlags1, "", true)
	}

	if u.ArrayOfGetDeploymentFlags2 != nil {
		return utils.MarshalJSON(u.ArrayOfGetDeploymentFlags2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentFlagsUnion: all fields are null")
}

// GetDeploymentMfeConfigUploadState - The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
type GetDeploymentMfeConfigUploadState string

const (
	GetDeploymentMfeConfigUploadStateSuccess        GetDeploymentMfeConfigUploadState = "success"
	GetDeploymentMfeConfigUploadStateWaitingOnBuild GetDeploymentMfeConfigUploadState = "waiting_on_build"
	GetDeploymentMfeConfigUploadStateNoConfig       GetDeploymentMfeConfigUploadState = "no_config"
)

func (e GetDeploymentMfeConfigUploadState) ToPointer() *GetDeploymentMfeConfigUploadState {
	return &e
}
func (e *GetDeploymentMfeConfigUploadState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "success":
		fallthrough
	case "waiting_on_build":
		fallthrough
	case "no_config":
		*e = GetDeploymentMfeConfigUploadState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentMfeConfigUploadState: %v", v)
	}
}

type GetDeploymentMicrofrontends2 struct {
	IsDefaultApp bool `json:"isDefaultApp"`
	// The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
	MfeConfigUploadState *GetDeploymentMfeConfigUploadState `json:"mfeConfigUploadState,omitempty"`
	// The project name of the default app of this deployment's microfrontends group.
	DefaultAppProjectName string `json:"defaultAppProjectName"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
}

func (g GetDeploymentMicrofrontends2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMicrofrontends2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"isDefaultApp", "defaultAppProjectName", "groupIds"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMicrofrontends2) GetIsDefaultApp() bool {
	if o == nil {
		return false
	}
	return o.IsDefaultApp
}

func (o *GetDeploymentMicrofrontends2) GetMfeConfigUploadState() *GetDeploymentMfeConfigUploadState {
	if o == nil {
		return nil
	}
	return o.MfeConfigUploadState
}

func (o *GetDeploymentMicrofrontends2) GetDefaultAppProjectName() string {
	if o == nil {
		return ""
	}
	return o.DefaultAppProjectName
}

func (o *GetDeploymentMicrofrontends2) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *GetDeploymentMicrofrontends2) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

type GetDeploymentMicrofrontends1 struct {
	IsDefaultApp *bool `json:"isDefaultApp,omitempty"`
	// The project name of the default app of this deployment's microfrontends group.
	DefaultAppProjectName string `json:"defaultAppProjectName"`
	// A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
	DefaultRoute *string `json:"defaultRoute,omitempty"`
	// The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
	GroupIds []string `json:"groupIds"`
}

func (g GetDeploymentMicrofrontends1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentMicrofrontends1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"defaultAppProjectName", "groupIds"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentMicrofrontends1) GetIsDefaultApp() *bool {
	if o == nil {
		return nil
	}
	return o.IsDefaultApp
}

func (o *GetDeploymentMicrofrontends1) GetDefaultAppProjectName() string {
	if o == nil {
		return ""
	}
	return o.DefaultAppProjectName
}

func (o *GetDeploymentMicrofrontends1) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *GetDeploymentMicrofrontends1) GetGroupIds() []string {
	if o == nil {
		return []string{}
	}
	return o.GroupIds
}

type GetDeploymentMicrofrontendsUnionType string

const (
	GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends1 GetDeploymentMicrofrontendsUnionType = "getDeployment_microfrontends_1"
	GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends2 GetDeploymentMicrofrontendsUnionType = "getDeployment_microfrontends_2"
)

type GetDeploymentMicrofrontendsUnion struct {
	GetDeploymentMicrofrontends1 *GetDeploymentMicrofrontends1 `queryParam:"inline"`
	GetDeploymentMicrofrontends2 *GetDeploymentMicrofrontends2 `queryParam:"inline"`

	Type GetDeploymentMicrofrontendsUnionType
}

func CreateGetDeploymentMicrofrontendsUnionGetDeploymentMicrofrontends1(getDeploymentMicrofrontends1 GetDeploymentMicrofrontends1) GetDeploymentMicrofrontendsUnion {
	typ := GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends1

	return GetDeploymentMicrofrontendsUnion{
		GetDeploymentMicrofrontends1: &getDeploymentMicrofrontends1,
		Type:                         typ,
	}
}

func CreateGetDeploymentMicrofrontendsUnionGetDeploymentMicrofrontends2(getDeploymentMicrofrontends2 GetDeploymentMicrofrontends2) GetDeploymentMicrofrontendsUnion {
	typ := GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends2

	return GetDeploymentMicrofrontendsUnion{
		GetDeploymentMicrofrontends2: &getDeploymentMicrofrontends2,
		Type:                         typ,
	}
}

func (u *GetDeploymentMicrofrontendsUnion) UnmarshalJSON(data []byte) error {

	var getDeploymentMicrofrontends2 GetDeploymentMicrofrontends2 = GetDeploymentMicrofrontends2{}
	if err := utils.UnmarshalJSON(data, &getDeploymentMicrofrontends2, "", true, nil); err == nil {
		u.GetDeploymentMicrofrontends2 = &getDeploymentMicrofrontends2
		u.Type = GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends2
		return nil
	}

	var getDeploymentMicrofrontends1 GetDeploymentMicrofrontends1 = GetDeploymentMicrofrontends1{}
	if err := utils.UnmarshalJSON(data, &getDeploymentMicrofrontends1, "", true, nil); err == nil {
		u.GetDeploymentMicrofrontends1 = &getDeploymentMicrofrontends1
		u.Type = GetDeploymentMicrofrontendsUnionTypeGetDeploymentMicrofrontends1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentMicrofrontendsUnion", string(data))
}

func (u GetDeploymentMicrofrontendsUnion) MarshalJSON() ([]byte, error) {
	if u.GetDeploymentMicrofrontends1 != nil {
		return utils.MarshalJSON(u.GetDeploymentMicrofrontends1, "", true)
	}

	if u.GetDeploymentMicrofrontends2 != nil {
		return utils.MarshalJSON(u.GetDeploymentMicrofrontends2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentMicrofrontendsUnion: all fields are null")
}

type GetDeploymentFunctionType string

const (
	GetDeploymentFunctionTypeStandard GetDeploymentFunctionType = "standard"
	GetDeploymentFunctionTypeFluid    GetDeploymentFunctionType = "fluid"
)

func (e GetDeploymentFunctionType) ToPointer() *GetDeploymentFunctionType {
	return &e
}
func (e *GetDeploymentFunctionType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "fluid":
		*e = GetDeploymentFunctionType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentFunctionType: %v", v)
	}
}

type GetDeploymentFunctionMemoryType string

const (
	GetDeploymentFunctionMemoryTypeStandard       GetDeploymentFunctionMemoryType = "standard"
	GetDeploymentFunctionMemoryTypeStandardLegacy GetDeploymentFunctionMemoryType = "standard_legacy"
	GetDeploymentFunctionMemoryTypePerformance    GetDeploymentFunctionMemoryType = "performance"
)

func (e GetDeploymentFunctionMemoryType) ToPointer() *GetDeploymentFunctionMemoryType {
	return &e
}
func (e *GetDeploymentFunctionMemoryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "standard_legacy":
		fallthrough
	case "performance":
		*e = GetDeploymentFunctionMemoryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentFunctionMemoryType: %v", v)
	}
}

// GetDeploymentConfiguration - Build resource configuration snapshot for this deployment.
type GetDeploymentConfiguration string

const (
	GetDeploymentConfigurationSkipNamespaceQueue    GetDeploymentConfiguration = "SKIP_NAMESPACE_QUEUE"
	GetDeploymentConfigurationWaitForNamespaceQueue GetDeploymentConfiguration = "WAIT_FOR_NAMESPACE_QUEUE"
)

func (e GetDeploymentConfiguration) ToPointer() *GetDeploymentConfiguration {
	return &e
}
func (e *GetDeploymentConfiguration) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SKIP_NAMESPACE_QUEUE":
		fallthrough
	case "WAIT_FOR_NAMESPACE_QUEUE":
		*e = GetDeploymentConfiguration(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentConfiguration: %v", v)
	}
}

// GetDeploymentBuildQueue - Build resource configuration snapshot for this deployment.
type GetDeploymentBuildQueue struct {
	// Build resource configuration snapshot for this deployment.
	Configuration *GetDeploymentConfiguration `json:"configuration,omitempty"`
}

func (g GetDeploymentBuildQueue) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentBuildQueue) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentBuildQueue) GetConfiguration() *GetDeploymentConfiguration {
	if o == nil {
		return nil
	}
	return o.Configuration
}

// GetDeploymentElasticConcurrency - When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
type GetDeploymentElasticConcurrency string

const (
	GetDeploymentElasticConcurrencyTeamSetting    GetDeploymentElasticConcurrency = "TEAM_SETTING"
	GetDeploymentElasticConcurrencyProjectSetting GetDeploymentElasticConcurrency = "PROJECT_SETTING"
	GetDeploymentElasticConcurrencySkipQueue      GetDeploymentElasticConcurrency = "SKIP_QUEUE"
)

func (e GetDeploymentElasticConcurrency) ToPointer() *GetDeploymentElasticConcurrency {
	return &e
}
func (e *GetDeploymentElasticConcurrency) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TEAM_SETTING":
		fallthrough
	case "PROJECT_SETTING":
		fallthrough
	case "SKIP_QUEUE":
		*e = GetDeploymentElasticConcurrency(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentElasticConcurrency: %v", v)
	}
}

// GetDeploymentPurchaseType - Machine type that was used for the build.
type GetDeploymentPurchaseType string

const (
	GetDeploymentPurchaseTypeStandard GetDeploymentPurchaseType = "standard"
	GetDeploymentPurchaseTypeEnhanced GetDeploymentPurchaseType = "enhanced"
	GetDeploymentPurchaseTypeTurbo    GetDeploymentPurchaseType = "turbo"
)

func (e GetDeploymentPurchaseType) ToPointer() *GetDeploymentPurchaseType {
	return &e
}
func (e *GetDeploymentPurchaseType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "enhanced":
		fallthrough
	case "turbo":
		*e = GetDeploymentPurchaseType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentPurchaseType: %v", v)
	}
}

type GetDeploymentBuildMachine struct {
	// Machine type that was used for the build.
	PurchaseType *GetDeploymentPurchaseType `json:"purchaseType,omitempty"`
}

func (g GetDeploymentBuildMachine) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentBuildMachine) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentBuildMachine) GetPurchaseType() *GetDeploymentPurchaseType {
	if o == nil {
		return nil
	}
	return o.PurchaseType
}

// GetDeploymentResourceConfig - Build resource configuration snapshot for this deployment.
type GetDeploymentResourceConfig struct {
	// Build resource configuration snapshot for this deployment.
	BuildQueue *GetDeploymentBuildQueue `json:"buildQueue,omitempty"`
	// When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
	ElasticConcurrency *GetDeploymentElasticConcurrency `json:"elasticConcurrency,omitempty"`
	BuildMachine       *GetDeploymentBuildMachine       `json:"buildMachine,omitempty"`
}

func (g GetDeploymentResourceConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentResourceConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentResourceConfig) GetBuildQueue() *GetDeploymentBuildQueue {
	if o == nil {
		return nil
	}
	return o.BuildQueue
}

func (o *GetDeploymentResourceConfig) GetElasticConcurrency() *GetDeploymentElasticConcurrency {
	if o == nil {
		return nil
	}
	return o.ElasticConcurrency
}

func (o *GetDeploymentResourceConfig) GetBuildMachine() *GetDeploymentBuildMachine {
	if o == nil {
		return nil
	}
	return o.BuildMachine
}

// GetDeploymentConfig - Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
type GetDeploymentConfig struct {
	Version                     *float64                        `json:"version,omitempty"`
	FunctionType                GetDeploymentFunctionType       `json:"functionType"`
	FunctionMemoryType          GetDeploymentFunctionMemoryType `json:"functionMemoryType"`
	FunctionTimeout             *float64                        `json:"functionTimeout"`
	SecureComputePrimaryRegion  *string                         `json:"secureComputePrimaryRegion"`
	SecureComputeFallbackRegion *string                         `json:"secureComputeFallbackRegion"`
	IsUsingActiveCPU            *bool                           `json:"isUsingActiveCPU,omitempty"`
	// Build resource configuration snapshot for this deployment.
	ResourceConfig *GetDeploymentResourceConfig `json:"resourceConfig,omitempty"`
}

func (g GetDeploymentConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"functionType", "functionMemoryType", "functionTimeout", "secureComputePrimaryRegion", "secureComputeFallbackRegion"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentConfig) GetVersion() *float64 {
	if o == nil {
		return nil
	}
	return o.Version
}

func (o *GetDeploymentConfig) GetFunctionType() GetDeploymentFunctionType {
	if o == nil {
		return GetDeploymentFunctionType("")
	}
	return o.FunctionType
}

func (o *GetDeploymentConfig) GetFunctionMemoryType() GetDeploymentFunctionMemoryType {
	if o == nil {
		return GetDeploymentFunctionMemoryType("")
	}
	return o.FunctionMemoryType
}

func (o *GetDeploymentConfig) GetFunctionTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.FunctionTimeout
}

func (o *GetDeploymentConfig) GetSecureComputePrimaryRegion() *string {
	if o == nil {
		return nil
	}
	return o.SecureComputePrimaryRegion
}

func (o *GetDeploymentConfig) GetSecureComputeFallbackRegion() *string {
	if o == nil {
		return nil
	}
	return o.SecureComputeFallbackRegion
}

func (o *GetDeploymentConfig) GetIsUsingActiveCPU() *bool {
	if o == nil {
		return nil
	}
	return o.IsUsingActiveCPU
}

func (o *GetDeploymentConfig) GetResourceConfig() *GetDeploymentResourceConfig {
	if o == nil {
		return nil
	}
	return o.ResourceConfig
}

type GetDeploymentDeploymentAliasState string

const (
	GetDeploymentDeploymentAliasStateSucceeded GetDeploymentDeploymentAliasState = "succeeded"
	GetDeploymentDeploymentAliasStateFailed    GetDeploymentDeploymentAliasState = "failed"
	GetDeploymentDeploymentAliasStatePending   GetDeploymentDeploymentAliasState = "pending"
)

func (e GetDeploymentDeploymentAliasState) ToPointer() *GetDeploymentDeploymentAliasState {
	return &e
}
func (e *GetDeploymentDeploymentAliasState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "succeeded":
		fallthrough
	case "failed":
		fallthrough
	case "pending":
		*e = GetDeploymentDeploymentAliasState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentDeploymentAliasState: %v", v)
	}
}

// GetDeploymentDeploymentAlias - Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
type GetDeploymentDeploymentAlias struct {
	State       GetDeploymentDeploymentAliasState `json:"state"`
	StartedAt   float64                           `json:"startedAt"`
	CompletedAt *float64                          `json:"completedAt,omitempty"`
}

func (g GetDeploymentDeploymentAlias) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentDeploymentAlias) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"state", "startedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentDeploymentAlias) GetState() GetDeploymentDeploymentAliasState {
	if o == nil {
		return GetDeploymentDeploymentAliasState("")
	}
	return o.State
}

func (o *GetDeploymentDeploymentAlias) GetStartedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.StartedAt
}

func (o *GetDeploymentDeploymentAlias) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

type GetDeploymentChecks struct {
	// Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
	DeploymentAlias GetDeploymentDeploymentAlias `json:"deployment-alias"`
}

func (g GetDeploymentChecks) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentChecks) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"deployment-alias"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentChecks) GetDeploymentAlias() GetDeploymentDeploymentAlias {
	if o == nil {
		return GetDeploymentDeploymentAlias{}
	}
	return o.DeploymentAlias
}

// GetDeploymentBlockCode - The NSNB decision code for the seat block. TODO: We should consolidate block types.
type GetDeploymentBlockCode string

const (
	GetDeploymentBlockCodeTeamAccessRequired   GetDeploymentBlockCode = "TEAM_ACCESS_REQUIRED"
	GetDeploymentBlockCodeCommitAuthorRequired GetDeploymentBlockCode = "COMMIT_AUTHOR_REQUIRED"
)

func (e GetDeploymentBlockCode) ToPointer() *GetDeploymentBlockCode {
	return &e
}
func (e *GetDeploymentBlockCode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "TEAM_ACCESS_REQUIRED":
		fallthrough
	case "COMMIT_AUTHOR_REQUIRED":
		*e = GetDeploymentBlockCode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDeploymentBlockCode: %v", v)
	}
}

// GetDeploymentSeatBlock - NSNB Blocked metadata
type GetDeploymentSeatBlock struct {
	// The NSNB decision code for the seat block. TODO: We should consolidate block types.
	BlockCode GetDeploymentBlockCode `json:"blockCode"`
	// The blocked vercel user ID.
	UserID *string `json:"userId,omitempty"`
}

func (g GetDeploymentSeatBlock) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDeploymentSeatBlock) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"blockCode"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDeploymentSeatBlock) GetBlockCode() GetDeploymentBlockCode {
	if o == nil {
		return GetDeploymentBlockCode("")
	}
	return o.BlockCode
}

func (o *GetDeploymentSeatBlock) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

// Lambdas1 - The deployment including both public and private information
type Lambdas1 struct {
	AliasAssignedAt           *GetDeploymentAliasAssignedAt `json:"aliasAssignedAt,omitempty"`
	AlwaysRefuseToBuild       *bool                         `json:"alwaysRefuseToBuild,omitempty"`
	Build                     GetDeploymentBuild1           `json:"build"`
	BuildArtifactUrls         []string                      `json:"buildArtifactUrls,omitempty"`
	Builds                    []GetDeploymentBuild2         `json:"builds,omitempty"`
	Env                       []string                      `json:"env"`
	InspectorURL              *string                       `json:"inspectorUrl"`
	IsInConcurrentBuildsQueue bool                          `json:"isInConcurrentBuildsQueue"`
	IsInSystemBuildsQueue     bool                          `json:"isInSystemBuildsQueue"`
	ProjectSettings           GetDeploymentProjectSettings  `json:"projectSettings"`
	ReadyStateReason          *string                       `json:"readyStateReason,omitempty"`
	Integrations              *GetDeploymentIntegrations    `json:"integrations,omitempty"`
	Images                    *GetDeploymentImages          `json:"images,omitempty"`
	// A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
	Alias []string `json:"alias,omitempty"`
	// A boolean that will be true when the aliases from the alias property were assigned successfully
	AliasAssigned bool    `json:"aliasAssigned"`
	BootedAt      float64 `json:"bootedAt"`
	BuildingAt    float64 `json:"buildingAt"`
	// Since April 2025 it necessary for On-Demand Concurrency Minutes calculation
	BuildContainerFinishedAt *float64 `json:"buildContainerFinishedAt,omitempty"`
	BuildSkipped             bool     `json:"buildSkipped"`
	// Information about the deployment creator
	Creator                 GetDeploymentCreator1  `json:"creator"`
	InitReadyAt             *float64               `json:"initReadyAt,omitempty"`
	IsFirstBranchDeployment *bool                  `json:"isFirstBranchDeployment,omitempty"`
	Lambdas                 []GetDeploymentLambda1 `json:"lambdas,omitempty"`
	// A boolean representing if the deployment is public or not. By default this is `false`
	Public bool                 `json:"public"`
	Ready  *float64             `json:"ready,omitempty"`
	Status GetDeploymentStatus1 `json:"status"`
	// The team that owns the deployment if any
	Team *GetDeploymentTeam1 `json:"team,omitempty"`
	// An array of domains that were provided by the user when creating the Deployment.
	UserAliases []string `json:"userAliases,omitempty"`
	// Whether or not preview comments are enabled for the deployment
	PreviewCommentsEnabled *bool                                 `json:"previewCommentsEnabled,omitempty"`
	TtyBuildLogs           *bool                                 `json:"ttyBuildLogs,omitempty"`
	CustomEnvironment      *GetDeploymentCustomEnvironmentUnion1 `json:"customEnvironment,omitempty"`
	OomReport              *GetDeploymentOomReport1              `json:"oomReport,omitempty"`
	AliasWarning           *GetDeploymentAliasWarning1           `json:"aliasWarning,omitempty"`
	// A string holding the unique ID of the deployment
	ID string `json:"id"`
	// A number containing the date when the deployment was created in milliseconds
	CreatedAt float64 `json:"createdAt"`
	// The state of the deployment depending on the process of deploying, or if it is ready or in an error state
	ReadyState GetDeploymentReadyState1 `json:"readyState"`
	// The name of the project associated with the deployment at the time that the deployment was created
	Name string                    `json:"name"`
	Type GetDeploymentTypeLambdas1 `json:"type"`
	// An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
	AliasError *GetDeploymentAliasError1 `json:"aliasError,omitempty"`
	AliasFinal *string                   `json:"aliasFinal,omitempty"`
	// applies to custom domains only, defaults to `true`
	AutoAssignCustomDomains *bool                           `json:"autoAssignCustomDomains,omitempty"`
	AutomaticAliases        []string                        `json:"automaticAliases,omitempty"`
	BuildErrorAt            *float64                        `json:"buildErrorAt,omitempty"`
	ChecksState             *GetDeploymentChecksState1      `json:"checksState,omitempty"`
	ChecksConclusion        *GetDeploymentChecksConclusion1 `json:"checksConclusion,omitempty"`
	// A number containing the date when the deployment was deleted at milliseconds
	DeletedAt *float64 `json:"deletedAt,omitempty"`
	// Computed field that is only available for deployments with a microfrontend configuration.
	DefaultRoute *string  `json:"defaultRoute,omitempty"`
	CanceledAt   *float64 `json:"canceledAt,omitempty"`
	ErrorCode    *string  `json:"errorCode,omitempty"`
	ErrorLink    *string  `json:"errorLink,omitempty"`
	ErrorMessage *string  `json:"errorMessage,omitempty"`
	ErrorStep    *string  `json:"errorStep,omitempty"`
	// Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
	PassiveRegions []string                      `json:"passiveRegions,omitempty"`
	GitSource      *GetDeploymentGitSourceUnion1 `json:"gitSource,omitempty"`
	// Present when deployment was created with VERCEL_MANUAL_PROVISIONING=true. The deployment stays in INITIALIZING until /continue is called.
	ManualProvisioning *GetDeploymentManualProvisioning1 `json:"manualProvisioning,omitempty"`
	Meta               map[string]string                 `json:"meta"`
	OriginCacheRegion  *string                           `json:"originCacheRegion,omitempty"`
	// If set it overrides the `projectSettings.nodeVersion` for this deployment.
	NodeVersion *GetDeploymentNodeVersion1 `json:"nodeVersion,omitempty"`
	// The public project information associated with the deployment.
	Project  *GetDeploymentProject1 `json:"project,omitempty"`
	Prebuilt *bool                  `json:"prebuilt,omitempty"`
	// Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
	ReadySubstate *GetDeploymentReadySubstate1 `json:"readySubstate,omitempty"`
	// The regions the deployment exists in
	Regions []string `json:"regions"`
	// flag to indicate if the deployment was deleted by retention policy
	SoftDeletedByRetention *bool `json:"softDeletedByRetention,omitempty"`
	// Where was the deployment created from
	Source *GetDeploymentSourceEnum1 `json:"source,omitempty"`
	// If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
	Target *GetDeploymentTargetEnum1 `json:"target,omitempty"`
	// A number containing the date when the deployment was undeleted at milliseconds
	UndeletedAt *float64 `json:"undeletedAt,omitempty"`
	// A string with the unique URL of the deployment
	URL string `json:"url"`
	// Since January 2025 User-configured deployment ID for skew protection with pre-built deployments. This is set when users configure a custom deploymentId in their next.config.js file. This allows Next.js to use skew protection even when deployments are pre-built outside of Vercel's build system.
	UserConfiguredDeploymentID *string `json:"userConfiguredDeploymentId,omitempty"`
	// The platform version that was used to create the deployment.
	Version         float64                        `json:"version"`
	OidcTokenClaims *GetDeploymentOidcTokenClaims1 `json:"oidcTokenClaims,omitempty"`
	ProjectID       string                         `json:"projectId"`
	Plan            GetDeploymentPlan              `json:"plan"`
	// Metadata about the source platform that triggered the deployment. Allows us to map a deployment back to a platform (e.g. the chat that created it)
	Platform               *GetDeploymentPlatform            `json:"platform,omitempty"`
	ConnectBuildsEnabled   *bool                             `json:"connectBuildsEnabled,omitempty"`
	ConnectConfigurationID *string                           `json:"connectConfigurationId,omitempty"`
	CreatedIn              string                            `json:"createdIn"`
	Crons                  []GetDeploymentCron               `json:"crons,omitempty"`
	Functions              map[string]GetDeploymentFunctions `json:"functions,omitempty"`
	MonorepoManager        *string                           `json:"monorepoManager,omitempty"`
	OwnerID                string                            `json:"ownerId"`
	// Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)
	PassiveConnectConfigurationID *string                           `json:"passiveConnectConfigurationId,omitempty"`
	Routes                        []GetDeploymentRouteUnion         `json:"routes"`
	GitRepo                       *GetDeploymentGitRepoUnion        `json:"gitRepo,omitempty"`
	Flags                         *GetDeploymentFlagsUnion          `json:"flags,omitempty"`
	Microfrontends                *GetDeploymentMicrofrontendsUnion `json:"microfrontends,omitempty"`
	// Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
	Config *GetDeploymentConfig `json:"config,omitempty"`
	Checks *GetDeploymentChecks `json:"checks,omitempty"`
	// NSNB Blocked metadata
	SeatBlock *GetDeploymentSeatBlock `json:"seatBlock,omitempty"`
}

func (l Lambdas1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *Lambdas1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"build", "env", "inspectorUrl", "isInConcurrentBuildsQueue", "isInSystemBuildsQueue", "projectSettings", "aliasAssigned", "bootedAt", "buildingAt", "buildSkipped", "creator", "public", "status", "id", "createdAt", "readyState", "name", "type", "meta", "regions", "url", "version", "projectId", "plan", "createdIn", "ownerId", "routes"}); err != nil {
		return err
	}
	return nil
}

func (o *Lambdas1) GetAliasAssignedAt() *GetDeploymentAliasAssignedAt {
	if o == nil {
		return nil
	}
	return o.AliasAssignedAt
}

func (o *Lambdas1) GetAlwaysRefuseToBuild() *bool {
	if o == nil {
		return nil
	}
	return o.AlwaysRefuseToBuild
}

func (o *Lambdas1) GetBuild() GetDeploymentBuild1 {
	if o == nil {
		return GetDeploymentBuild1{}
	}
	return o.Build
}

func (o *Lambdas1) GetBuildArtifactUrls() []string {
	if o == nil {
		return nil
	}
	return o.BuildArtifactUrls
}

func (o *Lambdas1) GetBuilds() []GetDeploymentBuild2 {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *Lambdas1) GetEnv() []string {
	if o == nil {
		return []string{}
	}
	return o.Env
}

func (o *Lambdas1) GetInspectorURL() *string {
	if o == nil {
		return nil
	}
	return o.InspectorURL
}

func (o *Lambdas1) GetIsInConcurrentBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInConcurrentBuildsQueue
}

func (o *Lambdas1) GetIsInSystemBuildsQueue() bool {
	if o == nil {
		return false
	}
	return o.IsInSystemBuildsQueue
}

func (o *Lambdas1) GetProjectSettings() GetDeploymentProjectSettings {
	if o == nil {
		return GetDeploymentProjectSettings{}
	}
	return o.ProjectSettings
}

func (o *Lambdas1) GetReadyStateReason() *string {
	if o == nil {
		return nil
	}
	return o.ReadyStateReason
}

func (o *Lambdas1) GetIntegrations() *GetDeploymentIntegrations {
	if o == nil {
		return nil
	}
	return o.Integrations
}

func (o *Lambdas1) GetImages() *GetDeploymentImages {
	if o == nil {
		return nil
	}
	return o.Images
}

func (o *Lambdas1) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *Lambdas1) GetAliasAssigned() bool {
	if o == nil {
		return false
	}
	return o.AliasAssigned
}

func (o *Lambdas1) GetBootedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BootedAt
}

func (o *Lambdas1) GetBuildingAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.BuildingAt
}

func (o *Lambdas1) GetBuildContainerFinishedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildContainerFinishedAt
}

func (o *Lambdas1) GetBuildSkipped() bool {
	if o == nil {
		return false
	}
	return o.BuildSkipped
}

func (o *Lambdas1) GetCreator() GetDeploymentCreator1 {
	if o == nil {
		return GetDeploymentCreator1{}
	}
	return o.Creator
}

func (o *Lambdas1) GetInitReadyAt() *float64 {
	if o == nil {
		return nil
	}
	return o.InitReadyAt
}

func (o *Lambdas1) GetIsFirstBranchDeployment() *bool {
	if o == nil {
		return nil
	}
	return o.IsFirstBranchDeployment
}

func (o *Lambdas1) GetLambdas() []GetDeploymentLambda1 {
	if o == nil {
		return nil
	}
	return o.Lambdas
}

func (o *Lambdas1) GetPublic() bool {
	if o == nil {
		return false
	}
	return o.Public
}

func (o *Lambdas1) GetReady() *float64 {
	if o == nil {
		return nil
	}
	return o.Ready
}

func (o *Lambdas1) GetStatus() GetDeploymentStatus1 {
	if o == nil {
		return GetDeploymentStatus1("")
	}
	return o.Status
}

func (o *Lambdas1) GetTeam() *GetDeploymentTeam1 {
	if o == nil {
		return nil
	}
	return o.Team
}

func (o *Lambdas1) GetUserAliases() []string {
	if o == nil {
		return nil
	}
	return o.UserAliases
}

func (o *Lambdas1) GetPreviewCommentsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.PreviewCommentsEnabled
}

func (o *Lambdas1) GetTtyBuildLogs() *bool {
	if o == nil {
		return nil
	}
	return o.TtyBuildLogs
}

func (o *Lambdas1) GetCustomEnvironment() *GetDeploymentCustomEnvironmentUnion1 {
	if o == nil {
		return nil
	}
	return o.CustomEnvironment
}

func (o *Lambdas1) GetOomReport() *GetDeploymentOomReport1 {
	if o == nil {
		return nil
	}
	return o.OomReport
}

func (o *Lambdas1) GetAliasWarning() *GetDeploymentAliasWarning1 {
	if o == nil {
		return nil
	}
	return o.AliasWarning
}

func (o *Lambdas1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *Lambdas1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *Lambdas1) GetReadyState() GetDeploymentReadyState1 {
	if o == nil {
		return GetDeploymentReadyState1("")
	}
	return o.ReadyState
}

func (o *Lambdas1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Lambdas1) GetType() GetDeploymentTypeLambdas1 {
	if o == nil {
		return GetDeploymentTypeLambdas1("")
	}
	return o.Type
}

func (o *Lambdas1) GetAliasError() *GetDeploymentAliasError1 {
	if o == nil {
		return nil
	}
	return o.AliasError
}

func (o *Lambdas1) GetAliasFinal() *string {
	if o == nil {
		return nil
	}
	return o.AliasFinal
}

func (o *Lambdas1) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *Lambdas1) GetAutomaticAliases() []string {
	if o == nil {
		return nil
	}
	return o.AutomaticAliases
}

func (o *Lambdas1) GetBuildErrorAt() *float64 {
	if o == nil {
		return nil
	}
	return o.BuildErrorAt
}

func (o *Lambdas1) GetChecksState() *GetDeploymentChecksState1 {
	if o == nil {
		return nil
	}
	return o.ChecksState
}

func (o *Lambdas1) GetChecksConclusion() *GetDeploymentChecksConclusion1 {
	if o == nil {
		return nil
	}
	return o.ChecksConclusion
}

func (o *Lambdas1) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *Lambdas1) GetDefaultRoute() *string {
	if o == nil {
		return nil
	}
	return o.DefaultRoute
}

func (o *Lambdas1) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *Lambdas1) GetErrorCode() *string {
	if o == nil {
		return nil
	}
	return o.ErrorCode
}

func (o *Lambdas1) GetErrorLink() *string {
	if o == nil {
		return nil
	}
	return o.ErrorLink
}

func (o *Lambdas1) GetErrorMessage() *string {
	if o == nil {
		return nil
	}
	return o.ErrorMessage
}

func (o *Lambdas1) GetErrorStep() *string {
	if o == nil {
		return nil
	}
	return o.ErrorStep
}

func (o *Lambdas1) GetPassiveRegions() []string {
	if o == nil {
		return nil
	}
	return o.PassiveRegions
}

func (o *Lambdas1) GetGitSource() *GetDeploymentGitSourceUnion1 {
	if o == nil {
		return nil
	}
	return o.GitSource
}

func (o *Lambdas1) GetManualProvisioning() *GetDeploymentManualProvisioning1 {
	if o == nil {
		return nil
	}
	return o.ManualProvisioning
}

func (o *Lambdas1) GetMeta() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Meta
}

func (o *Lambdas1) GetOriginCacheRegion() *string {
	if o == nil {
		return nil
	}
	return o.OriginCacheRegion
}

func (o *Lambdas1) GetNodeVersion() *GetDeploymentNodeVersion1 {
	if o == nil {
		return nil
	}
	return o.NodeVersion
}

func (o *Lambdas1) GetProject() *GetDeploymentProject1 {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *Lambdas1) GetPrebuilt() *bool {
	if o == nil {
		return nil
	}
	return o.Prebuilt
}

func (o *Lambdas1) GetReadySubstate() *GetDeploymentReadySubstate1 {
	if o == nil {
		return nil
	}
	return o.ReadySubstate
}

func (o *Lambdas1) GetRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.Regions
}

func (o *Lambdas1) GetSoftDeletedByRetention() *bool {
	if o == nil {
		return nil
	}
	return o.SoftDeletedByRetention
}

func (o *Lambdas1) GetSource() *GetDeploymentSourceEnum1 {
	if o == nil {
		return nil
	}
	return o.Source
}

func (o *Lambdas1) GetTarget() *GetDeploymentTargetEnum1 {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *Lambdas1) GetUndeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UndeletedAt
}

func (o *Lambdas1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *Lambdas1) GetUserConfiguredDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.UserConfiguredDeploymentID
}

func (o *Lambdas1) GetVersion() float64 {
	if o == nil {
		return 0.0
	}
	return o.Version
}

func (o *Lambdas1) GetOidcTokenClaims() *GetDeploymentOidcTokenClaims1 {
	if o == nil {
		return nil
	}
	return o.OidcTokenClaims
}

func (o *Lambdas1) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *Lambdas1) GetPlan() GetDeploymentPlan {
	if o == nil {
		return GetDeploymentPlan("")
	}
	return o.Plan
}

func (o *Lambdas1) GetPlatform() *GetDeploymentPlatform {
	if o == nil {
		return nil
	}
	return o.Platform
}

func (o *Lambdas1) GetConnectBuildsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ConnectBuildsEnabled
}

func (o *Lambdas1) GetConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurationID
}

func (o *Lambdas1) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *Lambdas1) GetCrons() []GetDeploymentCron {
	if o == nil {
		return nil
	}
	return o.Crons
}

func (o *Lambdas1) GetFunctions() map[string]GetDeploymentFunctions {
	if o == nil {
		return nil
	}
	return o.Functions
}

func (o *Lambdas1) GetMonorepoManager() *string {
	if o == nil {
		return nil
	}
	return o.MonorepoManager
}

func (o *Lambdas1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *Lambdas1) GetPassiveConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.PassiveConnectConfigurationID
}

func (o *Lambdas1) GetRoutes() []GetDeploymentRouteUnion {
	if o == nil {
		return nil
	}
	return o.Routes
}

func (o *Lambdas1) GetGitRepo() *GetDeploymentGitRepoUnion {
	if o == nil {
		return nil
	}
	return o.GitRepo
}

func (o *Lambdas1) GetGitRepoGitlab() *GetDeploymentGitRepoGitlab {
	if v := o.GetGitRepo(); v != nil {
		return v.GetDeploymentGitRepoGitlab
	}
	return nil
}

func (o *Lambdas1) GetGitRepoGithub() *GetDeploymentGitRepoGithub {
	if v := o.GetGitRepo(); v != nil {
		return v.GetDeploymentGitRepoGithub
	}
	return nil
}

func (o *Lambdas1) GetGitRepoBitbucket() *GetDeploymentGitRepoBitbucket {
	if v := o.GetGitRepo(); v != nil {
		return v.GetDeploymentGitRepoBitbucket
	}
	return nil
}

func (o *Lambdas1) GetFlags() *GetDeploymentFlagsUnion {
	if o == nil {
		return nil
	}
	return o.Flags
}

func (o *Lambdas1) GetMicrofrontends() *GetDeploymentMicrofrontendsUnion {
	if o == nil {
		return nil
	}
	return o.Microfrontends
}

func (o *Lambdas1) GetConfig() *GetDeploymentConfig {
	if o == nil {
		return nil
	}
	return o.Config
}

func (o *Lambdas1) GetChecks() *GetDeploymentChecks {
	if o == nil {
		return nil
	}
	return o.Checks
}

func (o *Lambdas1) GetSeatBlock() *GetDeploymentSeatBlock {
	if o == nil {
		return nil
	}
	return o.SeatBlock
}

type GetDeploymentResponseBodyType string

const (
	GetDeploymentResponseBodyTypeLambdas1 GetDeploymentResponseBodyType = "Lambdas_1"
	GetDeploymentResponseBodyTypeLambdas2 GetDeploymentResponseBodyType = "Lambdas_2"
)

// GetDeploymentResponseBody - The deployment including only public information
// The deployment including both public and private information
type GetDeploymentResponseBody struct {
	Lambdas1 *Lambdas1 `queryParam:"inline"`
	Lambdas2 *Lambdas2 `queryParam:"inline"`

	Type GetDeploymentResponseBodyType
}

func CreateGetDeploymentResponseBodyLambdas1(lambdas1 Lambdas1) GetDeploymentResponseBody {
	typ := GetDeploymentResponseBodyTypeLambdas1

	return GetDeploymentResponseBody{
		Lambdas1: &lambdas1,
		Type:     typ,
	}
}

func CreateGetDeploymentResponseBodyLambdas2(lambdas2 Lambdas2) GetDeploymentResponseBody {
	typ := GetDeploymentResponseBodyTypeLambdas2

	return GetDeploymentResponseBody{
		Lambdas2: &lambdas2,
		Type:     typ,
	}
}

func (u *GetDeploymentResponseBody) UnmarshalJSON(data []byte) error {

	var lambdas1 Lambdas1 = Lambdas1{}
	if err := utils.UnmarshalJSON(data, &lambdas1, "", true, nil); err == nil {
		u.Lambdas1 = &lambdas1
		u.Type = GetDeploymentResponseBodyTypeLambdas1
		return nil
	}

	var lambdas2 Lambdas2 = Lambdas2{}
	if err := utils.UnmarshalJSON(data, &lambdas2, "", true, nil); err == nil {
		u.Lambdas2 = &lambdas2
		u.Type = GetDeploymentResponseBodyTypeLambdas2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDeploymentResponseBody", string(data))
}

func (u GetDeploymentResponseBody) MarshalJSON() ([]byte, error) {
	if u.Lambdas1 != nil {
		return utils.MarshalJSON(u.Lambdas1, "", true)
	}

	if u.Lambdas2 != nil {
		return utils.MarshalJSON(u.Lambdas2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDeploymentResponseBody: all fields are null")
}

type GetDeploymentResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The deployment including only public information
	// The deployment including both public and private information
	OneOf *GetDeploymentResponseBody
}

func (o *GetDeploymentResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetDeploymentResponse) GetOneOf() *GetDeploymentResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
