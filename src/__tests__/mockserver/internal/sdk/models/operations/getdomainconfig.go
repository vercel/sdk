// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/models/components"
)

// Strict - When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
type Strict string

const (
	StrictTrue  Strict = "true"
	StrictFalse Strict = "false"
)

func (e Strict) ToPointer() *Strict {
	return &e
}
func (e *Strict) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "true":
		fallthrough
	case "false":
		*e = Strict(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Strict: %v", v)
	}
}

type GetDomainConfigRequest struct {
	// The name of the domain.
	Domain string `pathParam:"style=simple,explode=false,name=domain"`
	// The project id or name that will be associated with the domain. Use this when the domain is not yet associated with a project.
	ProjectIDOrName *string `queryParam:"style=form,explode=true,name=projectIdOrName"`
	// When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
	Strict *Strict `queryParam:"style=form,explode=true,name=strict"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *GetDomainConfigRequest) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *GetDomainConfigRequest) GetProjectIDOrName() *string {
	if o == nil {
		return nil
	}
	return o.ProjectIDOrName
}

func (o *GetDomainConfigRequest) GetStrict() *Strict {
	if o == nil {
		return nil
	}
	return o.Strict
}

func (o *GetDomainConfigRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetDomainConfigRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

// ConfiguredBy - How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
type ConfiguredBy string

const (
	ConfiguredByCname ConfiguredBy = "CNAME"
	ConfiguredByA     ConfiguredBy = "A"
	ConfiguredByHTTP  ConfiguredBy = "http"
	ConfiguredByDns01 ConfiguredBy = "dns-01"
)

func (e ConfiguredBy) ToPointer() *ConfiguredBy {
	return &e
}
func (e *ConfiguredBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CNAME":
		fallthrough
	case "A":
		fallthrough
	case "http":
		fallthrough
	case "dns-01":
		*e = ConfiguredBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConfiguredBy: %v", v)
	}
}

// AcceptedChallenge - Which challenge types the domain can use for issuing certs.
type AcceptedChallenge string

const (
	AcceptedChallengeDns01  AcceptedChallenge = "dns-01"
	AcceptedChallengeHttp01 AcceptedChallenge = "http-01"
)

func (e AcceptedChallenge) ToPointer() *AcceptedChallenge {
	return &e
}
func (e *AcceptedChallenge) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "dns-01":
		fallthrough
	case "http-01":
		*e = AcceptedChallenge(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AcceptedChallenge: %v", v)
	}
}

// RecommendedIPv4 - Recommended IPv4s for the domain. rank=1 is the preferred value(s) to use. Only using 1 ip value is acceptable.
type RecommendedIPv4 struct {
	Rank  float64  `json:"rank"`
	Value []string `json:"value"`
}

func (o *RecommendedIPv4) GetRank() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rank
}

func (o *RecommendedIPv4) GetValue() []string {
	if o == nil {
		return []string{}
	}
	return o.Value
}

// RecommendedCNAME - Recommended CNAMEs for the domain. rank=1 is the preferred value to use.
type RecommendedCNAME struct {
	Rank  float64 `json:"rank"`
	Value string  `json:"value"`
}

func (o *RecommendedCNAME) GetRank() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rank
}

func (o *RecommendedCNAME) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type GetDomainConfigResponseBody struct {
	// How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
	ConfiguredBy *ConfiguredBy `json:"configuredBy"`
	// Which challenge types the domain can use for issuing certs.
	AcceptedChallenges []AcceptedChallenge `json:"acceptedChallenges"`
	// Recommended IPv4s for the domain. rank=1 is the preferred value(s) to use. Only using 1 ip value is acceptable.
	RecommendedIPv4 []RecommendedIPv4 `json:"recommendedIPv4"`
	// Recommended CNAMEs for the domain. rank=1 is the preferred value to use.
	RecommendedCNAME []RecommendedCNAME `json:"recommendedCNAME"`
	// Whether or not the domain is configured AND we can automatically generate a TLS certificate.
	Misconfigured bool `json:"misconfigured"`
}

func (o *GetDomainConfigResponseBody) GetConfiguredBy() *ConfiguredBy {
	if o == nil {
		return nil
	}
	return o.ConfiguredBy
}

func (o *GetDomainConfigResponseBody) GetAcceptedChallenges() []AcceptedChallenge {
	if o == nil {
		return []AcceptedChallenge{}
	}
	return o.AcceptedChallenges
}

func (o *GetDomainConfigResponseBody) GetRecommendedIPv4() []RecommendedIPv4 {
	if o == nil {
		return []RecommendedIPv4{}
	}
	return o.RecommendedIPv4
}

func (o *GetDomainConfigResponseBody) GetRecommendedCNAME() []RecommendedCNAME {
	if o == nil {
		return []RecommendedCNAME{}
	}
	return o.RecommendedCNAME
}

func (o *GetDomainConfigResponseBody) GetMisconfigured() bool {
	if o == nil {
		return false
	}
	return o.Misconfigured
}

type GetDomainConfigResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *GetDomainConfigResponseBody
}

func (o *GetDomainConfigResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetDomainConfigResponse) GetObject() *GetDomainConfigResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
