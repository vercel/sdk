// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"fmt"
	"mockserver/internal/sdk/models/components"
)

// Strict - When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
type Strict string

const (
	StrictTrue  Strict = "true"
	StrictFalse Strict = "false"
)

func (e Strict) ToPointer() *Strict {
	return &e
}
func (e *Strict) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "true":
		fallthrough
	case "false":
		*e = Strict(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Strict: %v", v)
	}
}

type GetDomainConfigRequest struct {
	// The name of the domain.
	Domain string `pathParam:"style=simple,explode=false,name=domain"`
	// When true, the response will only include the nameservers assigned directly to the specified domain. When false and there are no nameservers assigned directly to the specified domain, the response will include the nameservers of the domain's parent zone.
	Strict *Strict `queryParam:"style=form,explode=true,name=strict"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *GetDomainConfigRequest) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *GetDomainConfigRequest) GetStrict() *Strict {
	if o == nil {
		return nil
	}
	return o.Strict
}

func (o *GetDomainConfigRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetDomainConfigRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

// ConfiguredBy - How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
type ConfiguredBy string

const (
	ConfiguredByCname ConfiguredBy = "CNAME"
	ConfiguredByA     ConfiguredBy = "A"
	ConfiguredByHTTP  ConfiguredBy = "http"
	ConfiguredByDns01 ConfiguredBy = "dns-01"
)

func (e ConfiguredBy) ToPointer() *ConfiguredBy {
	return &e
}
func (e *ConfiguredBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "CNAME":
		fallthrough
	case "A":
		fallthrough
	case "http":
		fallthrough
	case "dns-01":
		*e = ConfiguredBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ConfiguredBy: %v", v)
	}
}

// AcceptedChallenges - Which challenge types the domain can use for issuing certs.
type AcceptedChallenges string

const (
	AcceptedChallengesDns01  AcceptedChallenges = "dns-01"
	AcceptedChallengesHttp01 AcceptedChallenges = "http-01"
)

func (e AcceptedChallenges) ToPointer() *AcceptedChallenges {
	return &e
}
func (e *AcceptedChallenges) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "dns-01":
		fallthrough
	case "http-01":
		*e = AcceptedChallenges(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AcceptedChallenges: %v", v)
	}
}

type GetDomainConfigResponseBody struct {
	// How we see the domain's configuration. - `CNAME`: Domain has a CNAME pointing to Vercel. - `A`: Domain's A record is resolving to Vercel. - `http`: Domain is resolving to Vercel but may be behind a Proxy. - `dns-01`: Domain is not resolving to Vercel but dns-01 challenge is enabled. - `null`: Domain is not resolving to Vercel.
	ConfiguredBy *ConfiguredBy `json:"configuredBy,omitempty"`
	// Which challenge types the domain can use for issuing certs.
	AcceptedChallenges []AcceptedChallenges `json:"acceptedChallenges,omitempty"`
	// Whether or not the domain is configured AND we can automatically generate a TLS certificate.
	Misconfigured bool `json:"misconfigured"`
}

func (o *GetDomainConfigResponseBody) GetConfiguredBy() *ConfiguredBy {
	if o == nil {
		return nil
	}
	return o.ConfiguredBy
}

func (o *GetDomainConfigResponseBody) GetAcceptedChallenges() []AcceptedChallenges {
	if o == nil {
		return nil
	}
	return o.AcceptedChallenges
}

func (o *GetDomainConfigResponseBody) GetMisconfigured() bool {
	if o == nil {
		return false
	}
	return o.Misconfigured
}

type GetDomainConfigResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *GetDomainConfigResponseBody
}

func (o *GetDomainConfigResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetDomainConfigResponse) GetObject() *GetDomainConfigResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
