// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type GetDrainsRequest struct {
	ProjectID       *string `queryParam:"style=form,explode=true,name=projectId"`
	IncludeMetadata *bool   `default:"false" queryParam:"style=form,explode=true,name=includeMetadata"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (g GetDrainsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsRequest) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *GetDrainsRequest) GetIncludeMetadata() *bool {
	if o == nil {
		return nil
	}
	return o.IncludeMetadata
}

func (o *GetDrainsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetDrainsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type GetDrainsSchemasLog2 struct {
}

func (g GetDrainsSchemasLog2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSchemasLog2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsTrace2 struct {
}

func (g GetDrainsTrace2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsTrace2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsAnalytics2 struct {
}

func (g GetDrainsAnalytics2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsAnalytics2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsSpeedInsights2 struct {
}

func (g GetDrainsSpeedInsights2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSpeedInsights2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsSchemas2 struct {
	Log           *GetDrainsSchemasLog2    `json:"log,omitempty"`
	Trace         *GetDrainsTrace2         `json:"trace,omitempty"`
	Analytics     *GetDrainsAnalytics2     `json:"analytics,omitempty"`
	SpeedInsights *GetDrainsSpeedInsights2 `json:"speed_insights,omitempty"`
}

func (g GetDrainsSchemas2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSchemas2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSchemas2) GetLog() *GetDrainsSchemasLog2 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetDrainsSchemas2) GetTrace() *GetDrainsTrace2 {
	if o == nil {
		return nil
	}
	return o.Trace
}

func (o *GetDrainsSchemas2) GetAnalytics() *GetDrainsAnalytics2 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetDrainsSchemas2) GetSpeedInsights() *GetDrainsSpeedInsights2 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

type GetDrainsTypeInternal2 string

const (
	GetDrainsTypeInternal2Internal GetDrainsTypeInternal2 = "internal"
)

func (e GetDrainsTypeInternal2) ToPointer() *GetDrainsTypeInternal2 {
	return &e
}
func (e *GetDrainsTypeInternal2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internal":
		*e = GetDrainsTypeInternal2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeInternal2: %v", v)
	}
}

type GetDrainsTarget2 string

const (
	GetDrainsTarget2VercelOtelTracesDb GetDrainsTarget2 = "vercel-otel-traces-db"
)

func (e GetDrainsTarget2) ToPointer() *GetDrainsTarget2 {
	return &e
}
func (e *GetDrainsTarget2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "vercel-otel-traces-db":
		*e = GetDrainsTarget2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTarget2: %v", v)
	}
}

type GetDrainsDeliveryVercelOtelTracesDb2 struct {
	Type   GetDrainsTypeInternal2 `json:"type"`
	Target GetDrainsTarget2       `json:"target"`
}

func (g GetDrainsDeliveryVercelOtelTracesDb2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryVercelOtelTracesDb2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryVercelOtelTracesDb2) GetType() GetDrainsTypeInternal2 {
	if o == nil {
		return GetDrainsTypeInternal2("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryVercelOtelTracesDb2) GetTarget() GetDrainsTarget2 {
	if o == nil {
		return GetDrainsTarget2("")
	}
	return o.Target
}

type GetDrainsTypeClickhouse2 string

const (
	GetDrainsTypeClickhouse2Clickhouse GetDrainsTypeClickhouse2 = "clickhouse"
)

func (e GetDrainsTypeClickhouse2) ToPointer() *GetDrainsTypeClickhouse2 {
	return &e
}
func (e *GetDrainsTypeClickhouse2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "clickhouse":
		*e = GetDrainsTypeClickhouse2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeClickhouse2: %v", v)
	}
}

type GetDrainsDeliveryClickhouse2 struct {
	Type     GetDrainsTypeClickhouse2 `json:"type"`
	Endpoint string                   `json:"endpoint"`
	Table    string                   `json:"table"`
}

func (g GetDrainsDeliveryClickhouse2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryClickhouse2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "table"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryClickhouse2) GetType() GetDrainsTypeClickhouse2 {
	if o == nil {
		return GetDrainsTypeClickhouse2("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryClickhouse2) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryClickhouse2) GetTable() string {
	if o == nil {
		return ""
	}
	return o.Table
}

type GetDrainsTypeOtlphttp2 string

const (
	GetDrainsTypeOtlphttp2Otlphttp GetDrainsTypeOtlphttp2 = "otlphttp"
)

func (e GetDrainsTypeOtlphttp2) ToPointer() *GetDrainsTypeOtlphttp2 {
	return &e
}
func (e *GetDrainsTypeOtlphttp2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "otlphttp":
		*e = GetDrainsTypeOtlphttp2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeOtlphttp2: %v", v)
	}
}

type GetDrainsEndpoint2 struct {
	Traces string `json:"traces"`
}

func (g GetDrainsEndpoint2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsEndpoint2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"traces"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsEndpoint2) GetTraces() string {
	if o == nil {
		return ""
	}
	return o.Traces
}

type GetDrainsEncoding4 string

const (
	GetDrainsEncoding4JSON  GetDrainsEncoding4 = "json"
	GetDrainsEncoding4Proto GetDrainsEncoding4 = "proto"
)

func (e GetDrainsEncoding4) ToPointer() *GetDrainsEncoding4 {
	return &e
}
func (e *GetDrainsEncoding4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "proto":
		*e = GetDrainsEncoding4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEncoding4: %v", v)
	}
}

type GetDrainsSecretKind4 string

const (
	GetDrainsSecretKind4IntegrationSecret GetDrainsSecretKind4 = "INTEGRATION_SECRET"
)

func (e GetDrainsSecretKind4) ToPointer() *GetDrainsSecretKind4 {
	return &e
}
func (e *GetDrainsSecretKind4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetDrainsSecretKind4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsSecretKind4: %v", v)
	}
}

type GetDrainsSecretIntegrationSecret4 struct {
	Kind GetDrainsSecretKind4 `json:"kind"`
}

func (g GetDrainsSecretIntegrationSecret4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSecretIntegrationSecret4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSecretIntegrationSecret4) GetKind() GetDrainsSecretKind4 {
	if o == nil {
		return GetDrainsSecretKind4("")
	}
	return o.Kind
}

type GetDrainsSecretUnion4Type string

const (
	GetDrainsSecretUnion4TypeStr                               GetDrainsSecretUnion4Type = "str"
	GetDrainsSecretUnion4TypeGetDrainsSecretIntegrationSecret4 GetDrainsSecretUnion4Type = "getDrains_secret_IntegrationSecret_4"
)

type GetDrainsSecretUnion4 struct {
	Str                               *string                            `queryParam:"inline"`
	GetDrainsSecretIntegrationSecret4 *GetDrainsSecretIntegrationSecret4 `queryParam:"inline"`

	Type GetDrainsSecretUnion4Type
}

func CreateGetDrainsSecretUnion4Str(str string) GetDrainsSecretUnion4 {
	typ := GetDrainsSecretUnion4TypeStr

	return GetDrainsSecretUnion4{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDrainsSecretUnion4GetDrainsSecretIntegrationSecret4(getDrainsSecretIntegrationSecret4 GetDrainsSecretIntegrationSecret4) GetDrainsSecretUnion4 {
	typ := GetDrainsSecretUnion4TypeGetDrainsSecretIntegrationSecret4

	return GetDrainsSecretUnion4{
		GetDrainsSecretIntegrationSecret4: &getDrainsSecretIntegrationSecret4,
		Type:                              typ,
	}
}

func (u *GetDrainsSecretUnion4) UnmarshalJSON(data []byte) error {

	var getDrainsSecretIntegrationSecret4 GetDrainsSecretIntegrationSecret4 = GetDrainsSecretIntegrationSecret4{}
	if err := utils.UnmarshalJSON(data, &getDrainsSecretIntegrationSecret4, "", true, nil); err == nil {
		u.GetDrainsSecretIntegrationSecret4 = &getDrainsSecretIntegrationSecret4
		u.Type = GetDrainsSecretUnion4TypeGetDrainsSecretIntegrationSecret4
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDrainsSecretUnion4TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSecretUnion4", string(data))
}

func (u GetDrainsSecretUnion4) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDrainsSecretIntegrationSecret4 != nil {
		return utils.MarshalJSON(u.GetDrainsSecretIntegrationSecret4, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSecretUnion4: all fields are null")
}

type GetDrainsDeliveryOtlphttp2 struct {
	Type     GetDrainsTypeOtlphttp2 `json:"type"`
	Endpoint GetDrainsEndpoint2     `json:"endpoint"`
	Encoding GetDrainsEncoding4     `json:"encoding"`
	Headers  map[string]string      `json:"headers"`
	Secret   *GetDrainsSecretUnion4 `json:"secret,omitempty"`
}

func (g GetDrainsDeliveryOtlphttp2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryOtlphttp2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryOtlphttp2) GetType() GetDrainsTypeOtlphttp2 {
	if o == nil {
		return GetDrainsTypeOtlphttp2("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryOtlphttp2) GetEndpoint() GetDrainsEndpoint2 {
	if o == nil {
		return GetDrainsEndpoint2{}
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryOtlphttp2) GetEncoding() GetDrainsEncoding4 {
	if o == nil {
		return GetDrainsEncoding4("")
	}
	return o.Encoding
}

func (o *GetDrainsDeliveryOtlphttp2) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetDrainsDeliveryOtlphttp2) GetSecret() *GetDrainsSecretUnion4 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetDrainsTypeHTTP2 string

const (
	GetDrainsTypeHTTP2HTTP GetDrainsTypeHTTP2 = "http"
)

func (e GetDrainsTypeHTTP2) ToPointer() *GetDrainsTypeHTTP2 {
	return &e
}
func (e *GetDrainsTypeHTTP2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = GetDrainsTypeHTTP2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeHTTP2: %v", v)
	}
}

type GetDrainsEncoding3 string

const (
	GetDrainsEncoding3JSON   GetDrainsEncoding3 = "json"
	GetDrainsEncoding3Ndjson GetDrainsEncoding3 = "ndjson"
)

func (e GetDrainsEncoding3) ToPointer() *GetDrainsEncoding3 {
	return &e
}
func (e *GetDrainsEncoding3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "ndjson":
		*e = GetDrainsEncoding3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEncoding3: %v", v)
	}
}

type GetDrainsCompression2 string

const (
	GetDrainsCompression2Gzip GetDrainsCompression2 = "gzip"
	GetDrainsCompression2None GetDrainsCompression2 = "none"
)

func (e GetDrainsCompression2) ToPointer() *GetDrainsCompression2 {
	return &e
}
func (e *GetDrainsCompression2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = GetDrainsCompression2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsCompression2: %v", v)
	}
}

type GetDrainsSecretKind3 string

const (
	GetDrainsSecretKind3IntegrationSecret GetDrainsSecretKind3 = "INTEGRATION_SECRET"
)

func (e GetDrainsSecretKind3) ToPointer() *GetDrainsSecretKind3 {
	return &e
}
func (e *GetDrainsSecretKind3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetDrainsSecretKind3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsSecretKind3: %v", v)
	}
}

type GetDrainsSecretIntegrationSecret3 struct {
	Kind GetDrainsSecretKind3 `json:"kind"`
}

func (g GetDrainsSecretIntegrationSecret3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSecretIntegrationSecret3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSecretIntegrationSecret3) GetKind() GetDrainsSecretKind3 {
	if o == nil {
		return GetDrainsSecretKind3("")
	}
	return o.Kind
}

type GetDrainsSecretUnion3Type string

const (
	GetDrainsSecretUnion3TypeStr                               GetDrainsSecretUnion3Type = "str"
	GetDrainsSecretUnion3TypeGetDrainsSecretIntegrationSecret3 GetDrainsSecretUnion3Type = "getDrains_secret_IntegrationSecret_3"
)

type GetDrainsSecretUnion3 struct {
	Str                               *string                            `queryParam:"inline"`
	GetDrainsSecretIntegrationSecret3 *GetDrainsSecretIntegrationSecret3 `queryParam:"inline"`

	Type GetDrainsSecretUnion3Type
}

func CreateGetDrainsSecretUnion3Str(str string) GetDrainsSecretUnion3 {
	typ := GetDrainsSecretUnion3TypeStr

	return GetDrainsSecretUnion3{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDrainsSecretUnion3GetDrainsSecretIntegrationSecret3(getDrainsSecretIntegrationSecret3 GetDrainsSecretIntegrationSecret3) GetDrainsSecretUnion3 {
	typ := GetDrainsSecretUnion3TypeGetDrainsSecretIntegrationSecret3

	return GetDrainsSecretUnion3{
		GetDrainsSecretIntegrationSecret3: &getDrainsSecretIntegrationSecret3,
		Type:                              typ,
	}
}

func (u *GetDrainsSecretUnion3) UnmarshalJSON(data []byte) error {

	var getDrainsSecretIntegrationSecret3 GetDrainsSecretIntegrationSecret3 = GetDrainsSecretIntegrationSecret3{}
	if err := utils.UnmarshalJSON(data, &getDrainsSecretIntegrationSecret3, "", true, nil); err == nil {
		u.GetDrainsSecretIntegrationSecret3 = &getDrainsSecretIntegrationSecret3
		u.Type = GetDrainsSecretUnion3TypeGetDrainsSecretIntegrationSecret3
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDrainsSecretUnion3TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSecretUnion3", string(data))
}

func (u GetDrainsSecretUnion3) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDrainsSecretIntegrationSecret3 != nil {
		return utils.MarshalJSON(u.GetDrainsSecretIntegrationSecret3, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSecretUnion3: all fields are null")
}

type GetDrainsDeliveryHTTP2 struct {
	Type        GetDrainsTypeHTTP2     `json:"type"`
	Endpoint    string                 `json:"endpoint"`
	Encoding    GetDrainsEncoding3     `json:"encoding"`
	Compression *GetDrainsCompression2 `json:"compression,omitempty"`
	Headers     map[string]string      `json:"headers"`
	Secret      *GetDrainsSecretUnion3 `json:"secret,omitempty"`
}

func (g GetDrainsDeliveryHTTP2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryHTTP2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryHTTP2) GetType() GetDrainsTypeHTTP2 {
	if o == nil {
		return GetDrainsTypeHTTP2("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryHTTP2) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryHTTP2) GetEncoding() GetDrainsEncoding3 {
	if o == nil {
		return GetDrainsEncoding3("")
	}
	return o.Encoding
}

func (o *GetDrainsDeliveryHTTP2) GetCompression() *GetDrainsCompression2 {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *GetDrainsDeliveryHTTP2) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetDrainsDeliveryHTTP2) GetSecret() *GetDrainsSecretUnion3 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetDrainsDeliveryUnion2Type string

const (
	GetDrainsDeliveryUnion2TypeHTTP       GetDrainsDeliveryUnion2Type = "http"
	GetDrainsDeliveryUnion2TypeOtlphttp   GetDrainsDeliveryUnion2Type = "otlphttp"
	GetDrainsDeliveryUnion2TypeClickhouse GetDrainsDeliveryUnion2Type = "clickhouse"
	GetDrainsDeliveryUnion2TypeInternal   GetDrainsDeliveryUnion2Type = "internal"
)

type GetDrainsDeliveryUnion2 struct {
	GetDrainsDeliveryHTTP2               *GetDrainsDeliveryHTTP2               `queryParam:"inline"`
	GetDrainsDeliveryOtlphttp2           *GetDrainsDeliveryOtlphttp2           `queryParam:"inline"`
	GetDrainsDeliveryClickhouse2         *GetDrainsDeliveryClickhouse2         `queryParam:"inline"`
	GetDrainsDeliveryVercelOtelTracesDb2 *GetDrainsDeliveryVercelOtelTracesDb2 `queryParam:"inline"`

	Type GetDrainsDeliveryUnion2Type
}

func CreateGetDrainsDeliveryUnion2HTTP(http GetDrainsDeliveryHTTP2) GetDrainsDeliveryUnion2 {
	typ := GetDrainsDeliveryUnion2TypeHTTP

	typStr := GetDrainsTypeHTTP2(typ)
	http.Type = typStr

	return GetDrainsDeliveryUnion2{
		GetDrainsDeliveryHTTP2: &http,
		Type:                   typ,
	}
}

func CreateGetDrainsDeliveryUnion2Otlphttp(otlphttp GetDrainsDeliveryOtlphttp2) GetDrainsDeliveryUnion2 {
	typ := GetDrainsDeliveryUnion2TypeOtlphttp

	typStr := GetDrainsTypeOtlphttp2(typ)
	otlphttp.Type = typStr

	return GetDrainsDeliveryUnion2{
		GetDrainsDeliveryOtlphttp2: &otlphttp,
		Type:                       typ,
	}
}

func CreateGetDrainsDeliveryUnion2Clickhouse(clickhouse GetDrainsDeliveryClickhouse2) GetDrainsDeliveryUnion2 {
	typ := GetDrainsDeliveryUnion2TypeClickhouse

	typStr := GetDrainsTypeClickhouse2(typ)
	clickhouse.Type = typStr

	return GetDrainsDeliveryUnion2{
		GetDrainsDeliveryClickhouse2: &clickhouse,
		Type:                         typ,
	}
}

func CreateGetDrainsDeliveryUnion2Internal(internal GetDrainsDeliveryVercelOtelTracesDb2) GetDrainsDeliveryUnion2 {
	typ := GetDrainsDeliveryUnion2TypeInternal

	typStr := GetDrainsTypeInternal2(typ)
	internal.Type = typStr

	return GetDrainsDeliveryUnion2{
		GetDrainsDeliveryVercelOtelTracesDb2: &internal,
		Type:                                 typ,
	}
}

func (u *GetDrainsDeliveryUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "http":
		getDrainsDeliveryHTTP2 := new(GetDrainsDeliveryHTTP2)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryHTTP2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type GetDrainsDeliveryHTTP2 within GetDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetDrainsDeliveryHTTP2 = getDrainsDeliveryHTTP2
		u.Type = GetDrainsDeliveryUnion2TypeHTTP
		return nil
	case "otlphttp":
		getDrainsDeliveryOtlphttp2 := new(GetDrainsDeliveryOtlphttp2)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryOtlphttp2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == otlphttp) type GetDrainsDeliveryOtlphttp2 within GetDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetDrainsDeliveryOtlphttp2 = getDrainsDeliveryOtlphttp2
		u.Type = GetDrainsDeliveryUnion2TypeOtlphttp
		return nil
	case "clickhouse":
		getDrainsDeliveryClickhouse2 := new(GetDrainsDeliveryClickhouse2)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryClickhouse2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == clickhouse) type GetDrainsDeliveryClickhouse2 within GetDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetDrainsDeliveryClickhouse2 = getDrainsDeliveryClickhouse2
		u.Type = GetDrainsDeliveryUnion2TypeClickhouse
		return nil
	case "internal":
		getDrainsDeliveryVercelOtelTracesDb2 := new(GetDrainsDeliveryVercelOtelTracesDb2)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryVercelOtelTracesDb2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == internal) type GetDrainsDeliveryVercelOtelTracesDb2 within GetDrainsDeliveryUnion2: %w", string(data), err)
		}

		u.GetDrainsDeliveryVercelOtelTracesDb2 = getDrainsDeliveryVercelOtelTracesDb2
		u.Type = GetDrainsDeliveryUnion2TypeInternal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsDeliveryUnion2", string(data))
}

func (u GetDrainsDeliveryUnion2) MarshalJSON() ([]byte, error) {
	if u.GetDrainsDeliveryHTTP2 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryHTTP2, "", true)
	}

	if u.GetDrainsDeliveryOtlphttp2 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryOtlphttp2, "", true)
	}

	if u.GetDrainsDeliveryClickhouse2 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryClickhouse2, "", true)
	}

	if u.GetDrainsDeliveryVercelOtelTracesDb2 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryVercelOtelTracesDb2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsDeliveryUnion2: all fields are null")
}

type GetDrainsTypeHeadSampling2 string

const (
	GetDrainsTypeHeadSampling2HeadSampling GetDrainsTypeHeadSampling2 = "head_sampling"
)

func (e GetDrainsTypeHeadSampling2) ToPointer() *GetDrainsTypeHeadSampling2 {
	return &e
}
func (e *GetDrainsTypeHeadSampling2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "head_sampling":
		*e = GetDrainsTypeHeadSampling2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeHeadSampling2: %v", v)
	}
}

type GetDrainsEnv2 string

const (
	GetDrainsEnv2Production GetDrainsEnv2 = "production"
	GetDrainsEnv2Preview    GetDrainsEnv2 = "preview"
)

func (e GetDrainsEnv2) ToPointer() *GetDrainsEnv2 {
	return &e
}
func (e *GetDrainsEnv2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetDrainsEnv2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEnv2: %v", v)
	}
}

type GetDrainsSampling2 struct {
	Type        GetDrainsTypeHeadSampling2 `json:"type"`
	Rate        float64                    `json:"rate"`
	Env         *GetDrainsEnv2             `json:"env,omitempty"`
	RequestPath *string                    `json:"requestPath,omitempty"`
}

func (g GetDrainsSampling2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSampling2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "rate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSampling2) GetType() GetDrainsTypeHeadSampling2 {
	if o == nil {
		return GetDrainsTypeHeadSampling2("")
	}
	return o.Type
}

func (o *GetDrainsSampling2) GetRate() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rate
}

func (o *GetDrainsSampling2) GetEnv() *GetDrainsEnv2 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetDrainsSampling2) GetRequestPath() *string {
	if o == nil {
		return nil
	}
	return o.RequestPath
}

type GetDrainsStatus2 string

const (
	GetDrainsStatus2Enabled  GetDrainsStatus2 = "enabled"
	GetDrainsStatus2Disabled GetDrainsStatus2 = "disabled"
	GetDrainsStatus2Errored  GetDrainsStatus2 = "errored"
)

func (e GetDrainsStatus2) ToPointer() *GetDrainsStatus2 {
	return &e
}
func (e *GetDrainsStatus2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		fallthrough
	case "errored":
		*e = GetDrainsStatus2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsStatus2: %v", v)
	}
}

type GetDrainsDisabledReason2 string

const (
	GetDrainsDisabledReason2DisabledByOwner      GetDrainsDisabledReason2 = "disabled-by-owner"
	GetDrainsDisabledReason2FeatureNotAvailable  GetDrainsDisabledReason2 = "feature-not-available"
	GetDrainsDisabledReason2AccountPlanDowngrade GetDrainsDisabledReason2 = "account-plan-downgrade"
	GetDrainsDisabledReason2DisabledByAdmin      GetDrainsDisabledReason2 = "disabled-by-admin"
)

func (e GetDrainsDisabledReason2) ToPointer() *GetDrainsDisabledReason2 {
	return &e
}
func (e *GetDrainsDisabledReason2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "account-plan-downgrade":
		fallthrough
	case "disabled-by-admin":
		*e = GetDrainsDisabledReason2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsDisabledReason2: %v", v)
	}
}

type GetDrainsKindIntegration2 string

const (
	GetDrainsKindIntegration2Integration GetDrainsKindIntegration2 = "integration"
)

func (e GetDrainsKindIntegration2) ToPointer() *GetDrainsKindIntegration2 {
	return &e
}
func (e *GetDrainsKindIntegration2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		*e = GetDrainsKindIntegration2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsKindIntegration2: %v", v)
	}
}

type GetDrainsSourceIntegration2 struct {
	Kind                       GetDrainsKindIntegration2 `json:"kind"`
	ResourceID                 *string                   `json:"resourceId,omitempty"`
	ExternalResourceID         *string                   `json:"externalResourceId,omitempty"`
	IntegrationID              string                    `json:"integrationId"`
	IntegrationConfigurationID string                    `json:"integrationConfigurationId"`
}

func (g GetDrainsSourceIntegration2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSourceIntegration2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind", "integrationId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSourceIntegration2) GetKind() GetDrainsKindIntegration2 {
	if o == nil {
		return GetDrainsKindIntegration2("")
	}
	return o.Kind
}

func (o *GetDrainsSourceIntegration2) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *GetDrainsSourceIntegration2) GetExternalResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalResourceID
}

func (o *GetDrainsSourceIntegration2) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetDrainsSourceIntegration2) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type GetDrainsKindSelfServed2 string

const (
	GetDrainsKindSelfServed2SelfServed GetDrainsKindSelfServed2 = "self-served"
)

func (e GetDrainsKindSelfServed2) ToPointer() *GetDrainsKindSelfServed2 {
	return &e
}
func (e *GetDrainsKindSelfServed2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "self-served":
		*e = GetDrainsKindSelfServed2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsKindSelfServed2: %v", v)
	}
}

type GetDrainsSourceSelfServed2 struct {
	Kind GetDrainsKindSelfServed2 `json:"kind"`
}

func (g GetDrainsSourceSelfServed2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSourceSelfServed2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSourceSelfServed2) GetKind() GetDrainsKindSelfServed2 {
	if o == nil {
		return GetDrainsKindSelfServed2("")
	}
	return o.Kind
}

type GetDrainsSourceUnion2Type string

const (
	GetDrainsSourceUnion2TypeSelfServed  GetDrainsSourceUnion2Type = "self-served"
	GetDrainsSourceUnion2TypeIntegration GetDrainsSourceUnion2Type = "integration"
)

type GetDrainsSourceUnion2 struct {
	GetDrainsSourceSelfServed2  *GetDrainsSourceSelfServed2  `queryParam:"inline"`
	GetDrainsSourceIntegration2 *GetDrainsSourceIntegration2 `queryParam:"inline"`

	Type GetDrainsSourceUnion2Type
}

func CreateGetDrainsSourceUnion2SelfServed(selfServed GetDrainsSourceSelfServed2) GetDrainsSourceUnion2 {
	typ := GetDrainsSourceUnion2TypeSelfServed

	typStr := GetDrainsKindSelfServed2(typ)
	selfServed.Kind = typStr

	return GetDrainsSourceUnion2{
		GetDrainsSourceSelfServed2: &selfServed,
		Type:                       typ,
	}
}

func CreateGetDrainsSourceUnion2Integration(integration GetDrainsSourceIntegration2) GetDrainsSourceUnion2 {
	typ := GetDrainsSourceUnion2TypeIntegration

	typStr := GetDrainsKindIntegration2(typ)
	integration.Kind = typStr

	return GetDrainsSourceUnion2{
		GetDrainsSourceIntegration2: &integration,
		Type:                        typ,
	}
}

func (u *GetDrainsSourceUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Kind string `json:"kind"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Kind {
	case "self-served":
		getDrainsSourceSelfServed2 := new(GetDrainsSourceSelfServed2)
		if err := utils.UnmarshalJSON(data, &getDrainsSourceSelfServed2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == self-served) type GetDrainsSourceSelfServed2 within GetDrainsSourceUnion2: %w", string(data), err)
		}

		u.GetDrainsSourceSelfServed2 = getDrainsSourceSelfServed2
		u.Type = GetDrainsSourceUnion2TypeSelfServed
		return nil
	case "integration":
		getDrainsSourceIntegration2 := new(GetDrainsSourceIntegration2)
		if err := utils.UnmarshalJSON(data, &getDrainsSourceIntegration2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == integration) type GetDrainsSourceIntegration2 within GetDrainsSourceUnion2: %w", string(data), err)
		}

		u.GetDrainsSourceIntegration2 = getDrainsSourceIntegration2
		u.Type = GetDrainsSourceUnion2TypeIntegration
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSourceUnion2", string(data))
}

func (u GetDrainsSourceUnion2) MarshalJSON() ([]byte, error) {
	if u.GetDrainsSourceSelfServed2 != nil {
		return utils.MarshalJSON(u.GetDrainsSourceSelfServed2, "", true)
	}

	if u.GetDrainsSourceIntegration2 != nil {
		return utils.MarshalJSON(u.GetDrainsSourceIntegration2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSourceUnion2: all fields are null")
}

type GetDrainsVersionV22 string

const (
	GetDrainsVersionV22V2 GetDrainsVersionV22 = "v2"
)

func (e GetDrainsVersionV22) ToPointer() *GetDrainsVersionV22 {
	return &e
}
func (e *GetDrainsVersionV22) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		*e = GetDrainsVersionV22(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsVersionV22: %v", v)
	}
}

type GetDrainsTypeOdata2 string

const (
	GetDrainsTypeOdata2Odata GetDrainsTypeOdata2 = "odata"
)

func (e GetDrainsTypeOdata2) ToPointer() *GetDrainsTypeOdata2 {
	return &e
}
func (e *GetDrainsTypeOdata2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "odata":
		*e = GetDrainsTypeOdata2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeOdata2: %v", v)
	}
}

type GetDrainsFilterOdata2 struct {
	Type GetDrainsTypeOdata2 `json:"type"`
	Text string              `json:"text"`
}

func (g GetDrainsFilterOdata2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterOdata2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "text"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterOdata2) GetType() GetDrainsTypeOdata2 {
	if o == nil {
		return GetDrainsTypeOdata2("")
	}
	return o.Type
}

func (o *GetDrainsFilterOdata2) GetText() string {
	if o == nil {
		return ""
	}
	return o.Text
}

type GetDrainsTypeBasic2 string

const (
	GetDrainsTypeBasic2Basic GetDrainsTypeBasic2 = "basic"
)

func (e GetDrainsTypeBasic2) ToPointer() *GetDrainsTypeBasic2 {
	return &e
}
func (e *GetDrainsTypeBasic2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = GetDrainsTypeBasic2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeBasic2: %v", v)
	}
}

type GetDrainsProject2 struct {
	Ids []string `json:"ids,omitempty"`
}

func (g GetDrainsProject2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsProject2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsProject2) GetIds() []string {
	if o == nil {
		return nil
	}
	return o.Ids
}

type GetDrainsFilterV2Source2 string

const (
	GetDrainsFilterV2Source2Build    GetDrainsFilterV2Source2 = "build"
	GetDrainsFilterV2Source2Edge     GetDrainsFilterV2Source2 = "edge"
	GetDrainsFilterV2Source2Lambda   GetDrainsFilterV2Source2 = "lambda"
	GetDrainsFilterV2Source2Static   GetDrainsFilterV2Source2 = "static"
	GetDrainsFilterV2Source2External GetDrainsFilterV2Source2 = "external"
	GetDrainsFilterV2Source2Firewall GetDrainsFilterV2Source2 = "firewall"
	GetDrainsFilterV2Source2Redirect GetDrainsFilterV2Source2 = "redirect"
)

func (e GetDrainsFilterV2Source2) ToPointer() *GetDrainsFilterV2Source2 {
	return &e
}
func (e *GetDrainsFilterV2Source2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "build":
		fallthrough
	case "edge":
		fallthrough
	case "lambda":
		fallthrough
	case "static":
		fallthrough
	case "external":
		fallthrough
	case "firewall":
		fallthrough
	case "redirect":
		*e = GetDrainsFilterV2Source2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsFilterV2Source2: %v", v)
	}
}

type GetDrainsFilterV2Log2 struct {
	Sources                            []GetDrainsFilterV2Source2 `json:"sources,omitempty"`
	LegacyExcludeCachedStaticAssetLogs *bool                      `json:"legacy_excludeCachedStaticAssetLogs,omitempty"`
}

func (g GetDrainsFilterV2Log2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2Log2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2Log2) GetSources() []GetDrainsFilterV2Source2 {
	if o == nil {
		return nil
	}
	return o.Sources
}

func (o *GetDrainsFilterV2Log2) GetLegacyExcludeCachedStaticAssetLogs() *bool {
	if o == nil {
		return nil
	}
	return o.LegacyExcludeCachedStaticAssetLogs
}

type GetDrainsEnvironment2 string

const (
	GetDrainsEnvironment2Production GetDrainsEnvironment2 = "production"
	GetDrainsEnvironment2Preview    GetDrainsEnvironment2 = "preview"
)

func (e GetDrainsEnvironment2) ToPointer() *GetDrainsEnvironment2 {
	return &e
}
func (e *GetDrainsEnvironment2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetDrainsEnvironment2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEnvironment2: %v", v)
	}
}

type GetDrainsDeployment2 struct {
	Environments []GetDrainsEnvironment2 `json:"environments,omitempty"`
}

func (g GetDrainsDeployment2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeployment2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeployment2) GetEnvironments() []GetDrainsEnvironment2 {
	if o == nil {
		return nil
	}
	return o.Environments
}

type GetDrainsFilterBasic2 struct {
	Type       GetDrainsTypeBasic2    `json:"type"`
	Project    *GetDrainsProject2     `json:"project,omitempty"`
	Log        *GetDrainsFilterV2Log2 `json:"log,omitempty"`
	Deployment *GetDrainsDeployment2  `json:"deployment,omitempty"`
}

func (g GetDrainsFilterBasic2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterBasic2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterBasic2) GetType() GetDrainsTypeBasic2 {
	if o == nil {
		return GetDrainsTypeBasic2("")
	}
	return o.Type
}

func (o *GetDrainsFilterBasic2) GetProject() *GetDrainsProject2 {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *GetDrainsFilterBasic2) GetLog() *GetDrainsFilterV2Log2 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetDrainsFilterBasic2) GetDeployment() *GetDrainsDeployment2 {
	if o == nil {
		return nil
	}
	return o.Deployment
}

type GetDrainsFilterUnion2Type string

const (
	GetDrainsFilterUnion2TypeBasic GetDrainsFilterUnion2Type = "basic"
	GetDrainsFilterUnion2TypeOdata GetDrainsFilterUnion2Type = "odata"
)

type GetDrainsFilterUnion2 struct {
	GetDrainsFilterBasic2 *GetDrainsFilterBasic2 `queryParam:"inline"`
	GetDrainsFilterOdata2 *GetDrainsFilterOdata2 `queryParam:"inline"`

	Type GetDrainsFilterUnion2Type
}

func CreateGetDrainsFilterUnion2Basic(basic GetDrainsFilterBasic2) GetDrainsFilterUnion2 {
	typ := GetDrainsFilterUnion2TypeBasic

	typStr := GetDrainsTypeBasic2(typ)
	basic.Type = typStr

	return GetDrainsFilterUnion2{
		GetDrainsFilterBasic2: &basic,
		Type:                  typ,
	}
}

func CreateGetDrainsFilterUnion2Odata(odata GetDrainsFilterOdata2) GetDrainsFilterUnion2 {
	typ := GetDrainsFilterUnion2TypeOdata

	typStr := GetDrainsTypeOdata2(typ)
	odata.Type = typStr

	return GetDrainsFilterUnion2{
		GetDrainsFilterOdata2: &odata,
		Type:                  typ,
	}
}

func (u *GetDrainsFilterUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "basic":
		getDrainsFilterBasic2 := new(GetDrainsFilterBasic2)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterBasic2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == basic) type GetDrainsFilterBasic2 within GetDrainsFilterUnion2: %w", string(data), err)
		}

		u.GetDrainsFilterBasic2 = getDrainsFilterBasic2
		u.Type = GetDrainsFilterUnion2TypeBasic
		return nil
	case "odata":
		getDrainsFilterOdata2 := new(GetDrainsFilterOdata2)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterOdata2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == odata) type GetDrainsFilterOdata2 within GetDrainsFilterUnion2: %w", string(data), err)
		}

		u.GetDrainsFilterOdata2 = getDrainsFilterOdata2
		u.Type = GetDrainsFilterUnion2TypeOdata
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsFilterUnion2", string(data))
}

func (u GetDrainsFilterUnion2) MarshalJSON() ([]byte, error) {
	if u.GetDrainsFilterBasic2 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterBasic2, "", true)
	}

	if u.GetDrainsFilterOdata2 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterOdata2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsFilterUnion2: all fields are null")
}

type GetDrainsFilterV2V22 struct {
	Version GetDrainsVersionV22   `json:"version"`
	Filter  GetDrainsFilterUnion2 `json:"filter"`
}

func (g GetDrainsFilterV2V22) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2V22) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version", "filter"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2V22) GetVersion() GetDrainsVersionV22 {
	if o == nil {
		return GetDrainsVersionV22("")
	}
	return o.Version
}

func (o *GetDrainsFilterV2V22) GetFilter() GetDrainsFilterUnion2 {
	if o == nil {
		return GetDrainsFilterUnion2{}
	}
	return o.Filter
}

func (o *GetDrainsFilterV2V22) GetFilterBasic() *GetDrainsFilterBasic2 {
	return o.GetFilter().GetDrainsFilterBasic2
}

func (o *GetDrainsFilterV2V22) GetFilterOdata() *GetDrainsFilterOdata2 {
	return o.GetFilter().GetDrainsFilterOdata2
}

type GetDrainsVersionV12 string

const (
	GetDrainsVersionV12V1 GetDrainsVersionV12 = "v1"
)

func (e GetDrainsVersionV12) ToPointer() *GetDrainsVersionV12 {
	return &e
}
func (e *GetDrainsVersionV12) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		*e = GetDrainsVersionV12(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsVersionV12: %v", v)
	}
}

type GetDrainsFilterV2V12 struct {
	Version GetDrainsVersionV12 `json:"version"`
}

func (g GetDrainsFilterV2V12) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2V12) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2V12) GetVersion() GetDrainsVersionV12 {
	if o == nil {
		return GetDrainsVersionV12("")
	}
	return o.Version
}

type GetDrainsFilterV2Union2Type string

const (
	GetDrainsFilterV2Union2TypeV1 GetDrainsFilterV2Union2Type = "v1"
	GetDrainsFilterV2Union2TypeV2 GetDrainsFilterV2Union2Type = "v2"
)

type GetDrainsFilterV2Union2 struct {
	GetDrainsFilterV2V12 *GetDrainsFilterV2V12 `queryParam:"inline"`
	GetDrainsFilterV2V22 *GetDrainsFilterV2V22 `queryParam:"inline"`

	Type GetDrainsFilterV2Union2Type
}

func CreateGetDrainsFilterV2Union2V1(v1 GetDrainsFilterV2V12) GetDrainsFilterV2Union2 {
	typ := GetDrainsFilterV2Union2TypeV1

	typStr := GetDrainsVersionV12(typ)
	v1.Version = typStr

	return GetDrainsFilterV2Union2{
		GetDrainsFilterV2V12: &v1,
		Type:                 typ,
	}
}

func CreateGetDrainsFilterV2Union2V2(v2 GetDrainsFilterV2V22) GetDrainsFilterV2Union2 {
	typ := GetDrainsFilterV2Union2TypeV2

	typStr := GetDrainsVersionV22(typ)
	v2.Version = typStr

	return GetDrainsFilterV2Union2{
		GetDrainsFilterV2V22: &v2,
		Type:                 typ,
	}
}

func (u *GetDrainsFilterV2Union2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Version string `json:"version"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Version {
	case "v1":
		getDrainsFilterV2V12 := new(GetDrainsFilterV2V12)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterV2V12, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v1) type GetDrainsFilterV2V12 within GetDrainsFilterV2Union2: %w", string(data), err)
		}

		u.GetDrainsFilterV2V12 = getDrainsFilterV2V12
		u.Type = GetDrainsFilterV2Union2TypeV1
		return nil
	case "v2":
		getDrainsFilterV2V22 := new(GetDrainsFilterV2V22)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterV2V22, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v2) type GetDrainsFilterV2V22 within GetDrainsFilterV2Union2: %w", string(data), err)
		}

		u.GetDrainsFilterV2V22 = getDrainsFilterV2V22
		u.Type = GetDrainsFilterV2Union2TypeV2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsFilterV2Union2", string(data))
}

func (u GetDrainsFilterV2Union2) MarshalJSON() ([]byte, error) {
	if u.GetDrainsFilterV2V12 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterV2V12, "", true)
	}

	if u.GetDrainsFilterV2V22 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterV2V22, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsFilterV2Union2: all fields are null")
}

type GetDrainsAccessSome string

const (
	GetDrainsAccessSomeSome GetDrainsAccessSome = "some"
)

func (e GetDrainsAccessSome) ToPointer() *GetDrainsAccessSome {
	return &e
}
func (e *GetDrainsAccessSome) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "some":
		*e = GetDrainsAccessSome(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsAccessSome: %v", v)
	}
}

type GetDrainsProjectAccessSome struct {
	Access     GetDrainsAccessSome `json:"access"`
	ProjectIds []string            `json:"projectIds"`
}

func (g GetDrainsProjectAccessSome) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsProjectAccessSome) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"access", "projectIds"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsProjectAccessSome) GetAccess() GetDrainsAccessSome {
	if o == nil {
		return GetDrainsAccessSome("")
	}
	return o.Access
}

func (o *GetDrainsProjectAccessSome) GetProjectIds() []string {
	if o == nil {
		return []string{}
	}
	return o.ProjectIds
}

type GetDrainsAccessAll string

const (
	GetDrainsAccessAllAll GetDrainsAccessAll = "all"
)

func (e GetDrainsAccessAll) ToPointer() *GetDrainsAccessAll {
	return &e
}
func (e *GetDrainsAccessAll) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "all":
		*e = GetDrainsAccessAll(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsAccessAll: %v", v)
	}
}

type GetDrainsProjectAccessAll struct {
	Access GetDrainsAccessAll `json:"access"`
}

func (g GetDrainsProjectAccessAll) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsProjectAccessAll) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"access"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsProjectAccessAll) GetAccess() GetDrainsAccessAll {
	if o == nil {
		return GetDrainsAccessAll("")
	}
	return o.Access
}

type GetDrainsProjectAccessUnionType string

const (
	GetDrainsProjectAccessUnionTypeAll  GetDrainsProjectAccessUnionType = "all"
	GetDrainsProjectAccessUnionTypeSome GetDrainsProjectAccessUnionType = "some"
)

type GetDrainsProjectAccessUnion struct {
	GetDrainsProjectAccessAll  *GetDrainsProjectAccessAll  `queryParam:"inline"`
	GetDrainsProjectAccessSome *GetDrainsProjectAccessSome `queryParam:"inline"`

	Type GetDrainsProjectAccessUnionType
}

func CreateGetDrainsProjectAccessUnionAll(all GetDrainsProjectAccessAll) GetDrainsProjectAccessUnion {
	typ := GetDrainsProjectAccessUnionTypeAll

	typStr := GetDrainsAccessAll(typ)
	all.Access = typStr

	return GetDrainsProjectAccessUnion{
		GetDrainsProjectAccessAll: &all,
		Type:                      typ,
	}
}

func CreateGetDrainsProjectAccessUnionSome(some GetDrainsProjectAccessSome) GetDrainsProjectAccessUnion {
	typ := GetDrainsProjectAccessUnionTypeSome

	typStr := GetDrainsAccessSome(typ)
	some.Access = typStr

	return GetDrainsProjectAccessUnion{
		GetDrainsProjectAccessSome: &some,
		Type:                       typ,
	}
}

func (u *GetDrainsProjectAccessUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Access string `json:"access"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Access {
	case "all":
		getDrainsProjectAccessAll := new(GetDrainsProjectAccessAll)
		if err := utils.UnmarshalJSON(data, &getDrainsProjectAccessAll, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Access == all) type GetDrainsProjectAccessAll within GetDrainsProjectAccessUnion: %w", string(data), err)
		}

		u.GetDrainsProjectAccessAll = getDrainsProjectAccessAll
		u.Type = GetDrainsProjectAccessUnionTypeAll
		return nil
	case "some":
		getDrainsProjectAccessSome := new(GetDrainsProjectAccessSome)
		if err := utils.UnmarshalJSON(data, &getDrainsProjectAccessSome, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Access == some) type GetDrainsProjectAccessSome within GetDrainsProjectAccessUnion: %w", string(data), err)
		}

		u.GetDrainsProjectAccessSome = getDrainsProjectAccessSome
		u.Type = GetDrainsProjectAccessUnionTypeSome
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsProjectAccessUnion", string(data))
}

func (u GetDrainsProjectAccessUnion) MarshalJSON() ([]byte, error) {
	if u.GetDrainsProjectAccessAll != nil {
		return utils.MarshalJSON(u.GetDrainsProjectAccessAll, "", true)
	}

	if u.GetDrainsProjectAccessSome != nil {
		return utils.MarshalJSON(u.GetDrainsProjectAccessSome, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsProjectAccessUnion: all fields are null")
}

type DrainsGetDrains2 struct {
	ID                          string                       `json:"id"`
	OwnerID                     string                       `json:"ownerId"`
	Name                        string                       `json:"name"`
	CreatedAt                   float64                      `json:"createdAt"`
	UpdatedAt                   float64                      `json:"updatedAt"`
	ProjectIds                  []string                     `json:"projectIds,omitempty"`
	Schemas                     GetDrainsSchemas2            `json:"schemas"`
	Delivery                    GetDrainsDeliveryUnion2      `json:"delivery"`
	Sampling                    []GetDrainsSampling2         `json:"sampling,omitempty"`
	TeamID                      *string                      `json:"teamId,omitempty"`
	Status                      *GetDrainsStatus2            `json:"status,omitempty"`
	DisabledAt                  *float64                     `json:"disabledAt,omitempty"`
	DisabledReason              *GetDrainsDisabledReason2    `json:"disabledReason,omitempty"`
	DisabledBy                  *string                      `json:"disabledBy,omitempty"`
	FirstErrorTimestamp         *float64                     `json:"firstErrorTimestamp,omitempty"`
	Source                      GetDrainsSourceUnion2        `json:"source"`
	Filter                      *string                      `json:"filter,omitempty"`
	FilterV2                    *GetDrainsFilterV2Union2     `json:"filterV2,omitempty"`
	IntegrationIcon             *string                      `json:"integrationIcon,omitempty"`
	IntegrationConfigurationURI *string                      `json:"integrationConfigurationUri,omitempty"`
	IntegrationWebsite          *string                      `json:"integrationWebsite,omitempty"`
	ProjectAccess               *GetDrainsProjectAccessUnion `json:"projectAccess,omitempty"`
}

func (d DrainsGetDrains2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DrainsGetDrains2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"id", "ownerId", "name", "createdAt", "updatedAt", "schemas", "delivery", "source"}); err != nil {
		return err
	}
	return nil
}

func (o *DrainsGetDrains2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *DrainsGetDrains2) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *DrainsGetDrains2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DrainsGetDrains2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *DrainsGetDrains2) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *DrainsGetDrains2) GetProjectIds() []string {
	if o == nil {
		return nil
	}
	return o.ProjectIds
}

func (o *DrainsGetDrains2) GetSchemas() GetDrainsSchemas2 {
	if o == nil {
		return GetDrainsSchemas2{}
	}
	return o.Schemas
}

func (o *DrainsGetDrains2) GetDelivery() GetDrainsDeliveryUnion2 {
	if o == nil {
		return GetDrainsDeliveryUnion2{}
	}
	return o.Delivery
}

func (o *DrainsGetDrains2) GetDeliveryHTTP() *GetDrainsDeliveryHTTP2 {
	return o.GetDelivery().GetDrainsDeliveryHTTP2
}

func (o *DrainsGetDrains2) GetDeliveryOtlphttp() *GetDrainsDeliveryOtlphttp2 {
	return o.GetDelivery().GetDrainsDeliveryOtlphttp2
}

func (o *DrainsGetDrains2) GetDeliveryClickhouse() *GetDrainsDeliveryClickhouse2 {
	return o.GetDelivery().GetDrainsDeliveryClickhouse2
}

func (o *DrainsGetDrains2) GetDeliveryInternal() *GetDrainsDeliveryVercelOtelTracesDb2 {
	return o.GetDelivery().GetDrainsDeliveryVercelOtelTracesDb2
}

func (o *DrainsGetDrains2) GetSampling() []GetDrainsSampling2 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *DrainsGetDrains2) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *DrainsGetDrains2) GetStatus() *GetDrainsStatus2 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *DrainsGetDrains2) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *DrainsGetDrains2) GetDisabledReason() *GetDrainsDisabledReason2 {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *DrainsGetDrains2) GetDisabledBy() *string {
	if o == nil {
		return nil
	}
	return o.DisabledBy
}

func (o *DrainsGetDrains2) GetFirstErrorTimestamp() *float64 {
	if o == nil {
		return nil
	}
	return o.FirstErrorTimestamp
}

func (o *DrainsGetDrains2) GetSource() GetDrainsSourceUnion2 {
	if o == nil {
		return GetDrainsSourceUnion2{}
	}
	return o.Source
}

func (o *DrainsGetDrains2) GetSourceSelfServed() *GetDrainsSourceSelfServed2 {
	return o.GetSource().GetDrainsSourceSelfServed2
}

func (o *DrainsGetDrains2) GetSourceIntegration() *GetDrainsSourceIntegration2 {
	return o.GetSource().GetDrainsSourceIntegration2
}

func (o *DrainsGetDrains2) GetFilter() *string {
	if o == nil {
		return nil
	}
	return o.Filter
}

func (o *DrainsGetDrains2) GetFilterV2() *GetDrainsFilterV2Union2 {
	if o == nil {
		return nil
	}
	return o.FilterV2
}

func (o *DrainsGetDrains2) GetFilterV2V1() *GetDrainsFilterV2V12 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetDrainsFilterV2V12
	}
	return nil
}

func (o *DrainsGetDrains2) GetFilterV2V2() *GetDrainsFilterV2V22 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetDrainsFilterV2V22
	}
	return nil
}

func (o *DrainsGetDrains2) GetIntegrationIcon() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationIcon
}

func (o *DrainsGetDrains2) GetIntegrationConfigurationURI() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationConfigurationURI
}

func (o *DrainsGetDrains2) GetIntegrationWebsite() *string {
	if o == nil {
		return nil
	}
	return o.IntegrationWebsite
}

func (o *DrainsGetDrains2) GetProjectAccess() *GetDrainsProjectAccessUnion {
	if o == nil {
		return nil
	}
	return o.ProjectAccess
}

func (o *DrainsGetDrains2) GetProjectAccessAll() *GetDrainsProjectAccessAll {
	if v := o.GetProjectAccess(); v != nil {
		return v.GetDrainsProjectAccessAll
	}
	return nil
}

func (o *DrainsGetDrains2) GetProjectAccessSome() *GetDrainsProjectAccessSome {
	if v := o.GetProjectAccess(); v != nil {
		return v.GetDrainsProjectAccessSome
	}
	return nil
}

type GetDrainsSchemasLog1 struct {
}

func (g GetDrainsSchemasLog1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSchemasLog1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsTrace1 struct {
}

func (g GetDrainsTrace1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsTrace1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsAnalytics1 struct {
}

func (g GetDrainsAnalytics1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsAnalytics1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsSpeedInsights1 struct {
}

func (g GetDrainsSpeedInsights1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSpeedInsights1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetDrainsSchemas1 struct {
	Log           *GetDrainsSchemasLog1    `json:"log,omitempty"`
	Trace         *GetDrainsTrace1         `json:"trace,omitempty"`
	Analytics     *GetDrainsAnalytics1     `json:"analytics,omitempty"`
	SpeedInsights *GetDrainsSpeedInsights1 `json:"speed_insights,omitempty"`
}

func (g GetDrainsSchemas1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSchemas1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSchemas1) GetLog() *GetDrainsSchemasLog1 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetDrainsSchemas1) GetTrace() *GetDrainsTrace1 {
	if o == nil {
		return nil
	}
	return o.Trace
}

func (o *GetDrainsSchemas1) GetAnalytics() *GetDrainsAnalytics1 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetDrainsSchemas1) GetSpeedInsights() *GetDrainsSpeedInsights1 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

type GetDrainsTypeInternal1 string

const (
	GetDrainsTypeInternal1Internal GetDrainsTypeInternal1 = "internal"
)

func (e GetDrainsTypeInternal1) ToPointer() *GetDrainsTypeInternal1 {
	return &e
}
func (e *GetDrainsTypeInternal1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "internal":
		*e = GetDrainsTypeInternal1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeInternal1: %v", v)
	}
}

type GetDrainsTarget1 string

const (
	GetDrainsTarget1VercelOtelTracesDb GetDrainsTarget1 = "vercel-otel-traces-db"
)

func (e GetDrainsTarget1) ToPointer() *GetDrainsTarget1 {
	return &e
}
func (e *GetDrainsTarget1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "vercel-otel-traces-db":
		*e = GetDrainsTarget1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTarget1: %v", v)
	}
}

type GetDrainsDeliveryVercelOtelTracesDb1 struct {
	Type   GetDrainsTypeInternal1 `json:"type"`
	Target GetDrainsTarget1       `json:"target"`
}

func (g GetDrainsDeliveryVercelOtelTracesDb1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryVercelOtelTracesDb1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryVercelOtelTracesDb1) GetType() GetDrainsTypeInternal1 {
	if o == nil {
		return GetDrainsTypeInternal1("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryVercelOtelTracesDb1) GetTarget() GetDrainsTarget1 {
	if o == nil {
		return GetDrainsTarget1("")
	}
	return o.Target
}

type GetDrainsTypeClickhouse1 string

const (
	GetDrainsTypeClickhouse1Clickhouse GetDrainsTypeClickhouse1 = "clickhouse"
)

func (e GetDrainsTypeClickhouse1) ToPointer() *GetDrainsTypeClickhouse1 {
	return &e
}
func (e *GetDrainsTypeClickhouse1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "clickhouse":
		*e = GetDrainsTypeClickhouse1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeClickhouse1: %v", v)
	}
}

type GetDrainsDeliveryClickhouse1 struct {
	Type     GetDrainsTypeClickhouse1 `json:"type"`
	Endpoint string                   `json:"endpoint"`
	Table    string                   `json:"table"`
}

func (g GetDrainsDeliveryClickhouse1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryClickhouse1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "table"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryClickhouse1) GetType() GetDrainsTypeClickhouse1 {
	if o == nil {
		return GetDrainsTypeClickhouse1("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryClickhouse1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryClickhouse1) GetTable() string {
	if o == nil {
		return ""
	}
	return o.Table
}

type GetDrainsTypeOtlphttp1 string

const (
	GetDrainsTypeOtlphttp1Otlphttp GetDrainsTypeOtlphttp1 = "otlphttp"
)

func (e GetDrainsTypeOtlphttp1) ToPointer() *GetDrainsTypeOtlphttp1 {
	return &e
}
func (e *GetDrainsTypeOtlphttp1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "otlphttp":
		*e = GetDrainsTypeOtlphttp1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeOtlphttp1: %v", v)
	}
}

type GetDrainsEndpoint1 struct {
	Traces string `json:"traces"`
}

func (g GetDrainsEndpoint1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsEndpoint1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"traces"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsEndpoint1) GetTraces() string {
	if o == nil {
		return ""
	}
	return o.Traces
}

type GetDrainsEncoding2 string

const (
	GetDrainsEncoding2JSON  GetDrainsEncoding2 = "json"
	GetDrainsEncoding2Proto GetDrainsEncoding2 = "proto"
)

func (e GetDrainsEncoding2) ToPointer() *GetDrainsEncoding2 {
	return &e
}
func (e *GetDrainsEncoding2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "proto":
		*e = GetDrainsEncoding2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEncoding2: %v", v)
	}
}

type GetDrainsSecretKind2 string

const (
	GetDrainsSecretKind2IntegrationSecret GetDrainsSecretKind2 = "INTEGRATION_SECRET"
)

func (e GetDrainsSecretKind2) ToPointer() *GetDrainsSecretKind2 {
	return &e
}
func (e *GetDrainsSecretKind2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetDrainsSecretKind2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsSecretKind2: %v", v)
	}
}

type GetDrainsSecretIntegrationSecret2 struct {
	Kind GetDrainsSecretKind2 `json:"kind"`
}

func (g GetDrainsSecretIntegrationSecret2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSecretIntegrationSecret2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSecretIntegrationSecret2) GetKind() GetDrainsSecretKind2 {
	if o == nil {
		return GetDrainsSecretKind2("")
	}
	return o.Kind
}

type GetDrainsSecretUnion2Type string

const (
	GetDrainsSecretUnion2TypeStr                               GetDrainsSecretUnion2Type = "str"
	GetDrainsSecretUnion2TypeGetDrainsSecretIntegrationSecret2 GetDrainsSecretUnion2Type = "getDrains_secret_IntegrationSecret_2"
)

type GetDrainsSecretUnion2 struct {
	Str                               *string                            `queryParam:"inline"`
	GetDrainsSecretIntegrationSecret2 *GetDrainsSecretIntegrationSecret2 `queryParam:"inline"`

	Type GetDrainsSecretUnion2Type
}

func CreateGetDrainsSecretUnion2Str(str string) GetDrainsSecretUnion2 {
	typ := GetDrainsSecretUnion2TypeStr

	return GetDrainsSecretUnion2{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDrainsSecretUnion2GetDrainsSecretIntegrationSecret2(getDrainsSecretIntegrationSecret2 GetDrainsSecretIntegrationSecret2) GetDrainsSecretUnion2 {
	typ := GetDrainsSecretUnion2TypeGetDrainsSecretIntegrationSecret2

	return GetDrainsSecretUnion2{
		GetDrainsSecretIntegrationSecret2: &getDrainsSecretIntegrationSecret2,
		Type:                              typ,
	}
}

func (u *GetDrainsSecretUnion2) UnmarshalJSON(data []byte) error {

	var getDrainsSecretIntegrationSecret2 GetDrainsSecretIntegrationSecret2 = GetDrainsSecretIntegrationSecret2{}
	if err := utils.UnmarshalJSON(data, &getDrainsSecretIntegrationSecret2, "", true, nil); err == nil {
		u.GetDrainsSecretIntegrationSecret2 = &getDrainsSecretIntegrationSecret2
		u.Type = GetDrainsSecretUnion2TypeGetDrainsSecretIntegrationSecret2
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDrainsSecretUnion2TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSecretUnion2", string(data))
}

func (u GetDrainsSecretUnion2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDrainsSecretIntegrationSecret2 != nil {
		return utils.MarshalJSON(u.GetDrainsSecretIntegrationSecret2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSecretUnion2: all fields are null")
}

type GetDrainsDeliveryOtlphttp1 struct {
	Type     GetDrainsTypeOtlphttp1 `json:"type"`
	Endpoint GetDrainsEndpoint1     `json:"endpoint"`
	Encoding GetDrainsEncoding2     `json:"encoding"`
	Headers  map[string]string      `json:"headers"`
	Secret   *GetDrainsSecretUnion2 `json:"secret,omitempty"`
}

func (g GetDrainsDeliveryOtlphttp1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryOtlphttp1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryOtlphttp1) GetType() GetDrainsTypeOtlphttp1 {
	if o == nil {
		return GetDrainsTypeOtlphttp1("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryOtlphttp1) GetEndpoint() GetDrainsEndpoint1 {
	if o == nil {
		return GetDrainsEndpoint1{}
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryOtlphttp1) GetEncoding() GetDrainsEncoding2 {
	if o == nil {
		return GetDrainsEncoding2("")
	}
	return o.Encoding
}

func (o *GetDrainsDeliveryOtlphttp1) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetDrainsDeliveryOtlphttp1) GetSecret() *GetDrainsSecretUnion2 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetDrainsTypeHTTP1 string

const (
	GetDrainsTypeHTTP1HTTP GetDrainsTypeHTTP1 = "http"
)

func (e GetDrainsTypeHTTP1) ToPointer() *GetDrainsTypeHTTP1 {
	return &e
}
func (e *GetDrainsTypeHTTP1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "http":
		*e = GetDrainsTypeHTTP1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeHTTP1: %v", v)
	}
}

type GetDrainsEncoding1 string

const (
	GetDrainsEncoding1JSON   GetDrainsEncoding1 = "json"
	GetDrainsEncoding1Ndjson GetDrainsEncoding1 = "ndjson"
)

func (e GetDrainsEncoding1) ToPointer() *GetDrainsEncoding1 {
	return &e
}
func (e *GetDrainsEncoding1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "ndjson":
		*e = GetDrainsEncoding1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEncoding1: %v", v)
	}
}

type GetDrainsCompression1 string

const (
	GetDrainsCompression1Gzip GetDrainsCompression1 = "gzip"
	GetDrainsCompression1None GetDrainsCompression1 = "none"
)

func (e GetDrainsCompression1) ToPointer() *GetDrainsCompression1 {
	return &e
}
func (e *GetDrainsCompression1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = GetDrainsCompression1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsCompression1: %v", v)
	}
}

type GetDrainsSecretKind1 string

const (
	GetDrainsSecretKind1IntegrationSecret GetDrainsSecretKind1 = "INTEGRATION_SECRET"
)

func (e GetDrainsSecretKind1) ToPointer() *GetDrainsSecretKind1 {
	return &e
}
func (e *GetDrainsSecretKind1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "INTEGRATION_SECRET":
		*e = GetDrainsSecretKind1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsSecretKind1: %v", v)
	}
}

type GetDrainsSecretIntegrationSecret1 struct {
	Kind GetDrainsSecretKind1 `json:"kind"`
}

func (g GetDrainsSecretIntegrationSecret1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSecretIntegrationSecret1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSecretIntegrationSecret1) GetKind() GetDrainsSecretKind1 {
	if o == nil {
		return GetDrainsSecretKind1("")
	}
	return o.Kind
}

type GetDrainsSecretUnion1Type string

const (
	GetDrainsSecretUnion1TypeStr                               GetDrainsSecretUnion1Type = "str"
	GetDrainsSecretUnion1TypeGetDrainsSecretIntegrationSecret1 GetDrainsSecretUnion1Type = "getDrains_secret_IntegrationSecret_1"
)

type GetDrainsSecretUnion1 struct {
	Str                               *string                            `queryParam:"inline"`
	GetDrainsSecretIntegrationSecret1 *GetDrainsSecretIntegrationSecret1 `queryParam:"inline"`

	Type GetDrainsSecretUnion1Type
}

func CreateGetDrainsSecretUnion1Str(str string) GetDrainsSecretUnion1 {
	typ := GetDrainsSecretUnion1TypeStr

	return GetDrainsSecretUnion1{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetDrainsSecretUnion1GetDrainsSecretIntegrationSecret1(getDrainsSecretIntegrationSecret1 GetDrainsSecretIntegrationSecret1) GetDrainsSecretUnion1 {
	typ := GetDrainsSecretUnion1TypeGetDrainsSecretIntegrationSecret1

	return GetDrainsSecretUnion1{
		GetDrainsSecretIntegrationSecret1: &getDrainsSecretIntegrationSecret1,
		Type:                              typ,
	}
}

func (u *GetDrainsSecretUnion1) UnmarshalJSON(data []byte) error {

	var getDrainsSecretIntegrationSecret1 GetDrainsSecretIntegrationSecret1 = GetDrainsSecretIntegrationSecret1{}
	if err := utils.UnmarshalJSON(data, &getDrainsSecretIntegrationSecret1, "", true, nil); err == nil {
		u.GetDrainsSecretIntegrationSecret1 = &getDrainsSecretIntegrationSecret1
		u.Type = GetDrainsSecretUnion1TypeGetDrainsSecretIntegrationSecret1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetDrainsSecretUnion1TypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSecretUnion1", string(data))
}

func (u GetDrainsSecretUnion1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.GetDrainsSecretIntegrationSecret1 != nil {
		return utils.MarshalJSON(u.GetDrainsSecretIntegrationSecret1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSecretUnion1: all fields are null")
}

type GetDrainsDeliveryHTTP1 struct {
	Type        GetDrainsTypeHTTP1     `json:"type"`
	Endpoint    string                 `json:"endpoint"`
	Encoding    GetDrainsEncoding1     `json:"encoding"`
	Compression *GetDrainsCompression1 `json:"compression,omitempty"`
	Headers     map[string]string      `json:"headers"`
	Secret      *GetDrainsSecretUnion1 `json:"secret,omitempty"`
}

func (g GetDrainsDeliveryHTTP1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeliveryHTTP1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeliveryHTTP1) GetType() GetDrainsTypeHTTP1 {
	if o == nil {
		return GetDrainsTypeHTTP1("")
	}
	return o.Type
}

func (o *GetDrainsDeliveryHTTP1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *GetDrainsDeliveryHTTP1) GetEncoding() GetDrainsEncoding1 {
	if o == nil {
		return GetDrainsEncoding1("")
	}
	return o.Encoding
}

func (o *GetDrainsDeliveryHTTP1) GetCompression() *GetDrainsCompression1 {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *GetDrainsDeliveryHTTP1) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *GetDrainsDeliveryHTTP1) GetSecret() *GetDrainsSecretUnion1 {
	if o == nil {
		return nil
	}
	return o.Secret
}

type GetDrainsDeliveryUnion1Type string

const (
	GetDrainsDeliveryUnion1TypeHTTP       GetDrainsDeliveryUnion1Type = "http"
	GetDrainsDeliveryUnion1TypeOtlphttp   GetDrainsDeliveryUnion1Type = "otlphttp"
	GetDrainsDeliveryUnion1TypeClickhouse GetDrainsDeliveryUnion1Type = "clickhouse"
	GetDrainsDeliveryUnion1TypeInternal   GetDrainsDeliveryUnion1Type = "internal"
)

type GetDrainsDeliveryUnion1 struct {
	GetDrainsDeliveryHTTP1               *GetDrainsDeliveryHTTP1               `queryParam:"inline"`
	GetDrainsDeliveryOtlphttp1           *GetDrainsDeliveryOtlphttp1           `queryParam:"inline"`
	GetDrainsDeliveryClickhouse1         *GetDrainsDeliveryClickhouse1         `queryParam:"inline"`
	GetDrainsDeliveryVercelOtelTracesDb1 *GetDrainsDeliveryVercelOtelTracesDb1 `queryParam:"inline"`

	Type GetDrainsDeliveryUnion1Type
}

func CreateGetDrainsDeliveryUnion1HTTP(http GetDrainsDeliveryHTTP1) GetDrainsDeliveryUnion1 {
	typ := GetDrainsDeliveryUnion1TypeHTTP

	typStr := GetDrainsTypeHTTP1(typ)
	http.Type = typStr

	return GetDrainsDeliveryUnion1{
		GetDrainsDeliveryHTTP1: &http,
		Type:                   typ,
	}
}

func CreateGetDrainsDeliveryUnion1Otlphttp(otlphttp GetDrainsDeliveryOtlphttp1) GetDrainsDeliveryUnion1 {
	typ := GetDrainsDeliveryUnion1TypeOtlphttp

	typStr := GetDrainsTypeOtlphttp1(typ)
	otlphttp.Type = typStr

	return GetDrainsDeliveryUnion1{
		GetDrainsDeliveryOtlphttp1: &otlphttp,
		Type:                       typ,
	}
}

func CreateGetDrainsDeliveryUnion1Clickhouse(clickhouse GetDrainsDeliveryClickhouse1) GetDrainsDeliveryUnion1 {
	typ := GetDrainsDeliveryUnion1TypeClickhouse

	typStr := GetDrainsTypeClickhouse1(typ)
	clickhouse.Type = typStr

	return GetDrainsDeliveryUnion1{
		GetDrainsDeliveryClickhouse1: &clickhouse,
		Type:                         typ,
	}
}

func CreateGetDrainsDeliveryUnion1Internal(internal GetDrainsDeliveryVercelOtelTracesDb1) GetDrainsDeliveryUnion1 {
	typ := GetDrainsDeliveryUnion1TypeInternal

	typStr := GetDrainsTypeInternal1(typ)
	internal.Type = typStr

	return GetDrainsDeliveryUnion1{
		GetDrainsDeliveryVercelOtelTracesDb1: &internal,
		Type:                                 typ,
	}
}

func (u *GetDrainsDeliveryUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "http":
		getDrainsDeliveryHTTP1 := new(GetDrainsDeliveryHTTP1)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryHTTP1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == http) type GetDrainsDeliveryHTTP1 within GetDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetDrainsDeliveryHTTP1 = getDrainsDeliveryHTTP1
		u.Type = GetDrainsDeliveryUnion1TypeHTTP
		return nil
	case "otlphttp":
		getDrainsDeliveryOtlphttp1 := new(GetDrainsDeliveryOtlphttp1)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryOtlphttp1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == otlphttp) type GetDrainsDeliveryOtlphttp1 within GetDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetDrainsDeliveryOtlphttp1 = getDrainsDeliveryOtlphttp1
		u.Type = GetDrainsDeliveryUnion1TypeOtlphttp
		return nil
	case "clickhouse":
		getDrainsDeliveryClickhouse1 := new(GetDrainsDeliveryClickhouse1)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryClickhouse1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == clickhouse) type GetDrainsDeliveryClickhouse1 within GetDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetDrainsDeliveryClickhouse1 = getDrainsDeliveryClickhouse1
		u.Type = GetDrainsDeliveryUnion1TypeClickhouse
		return nil
	case "internal":
		getDrainsDeliveryVercelOtelTracesDb1 := new(GetDrainsDeliveryVercelOtelTracesDb1)
		if err := utils.UnmarshalJSON(data, &getDrainsDeliveryVercelOtelTracesDb1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == internal) type GetDrainsDeliveryVercelOtelTracesDb1 within GetDrainsDeliveryUnion1: %w", string(data), err)
		}

		u.GetDrainsDeliveryVercelOtelTracesDb1 = getDrainsDeliveryVercelOtelTracesDb1
		u.Type = GetDrainsDeliveryUnion1TypeInternal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsDeliveryUnion1", string(data))
}

func (u GetDrainsDeliveryUnion1) MarshalJSON() ([]byte, error) {
	if u.GetDrainsDeliveryHTTP1 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryHTTP1, "", true)
	}

	if u.GetDrainsDeliveryOtlphttp1 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryOtlphttp1, "", true)
	}

	if u.GetDrainsDeliveryClickhouse1 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryClickhouse1, "", true)
	}

	if u.GetDrainsDeliveryVercelOtelTracesDb1 != nil {
		return utils.MarshalJSON(u.GetDrainsDeliveryVercelOtelTracesDb1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsDeliveryUnion1: all fields are null")
}

type GetDrainsTypeHeadSampling1 string

const (
	GetDrainsTypeHeadSampling1HeadSampling GetDrainsTypeHeadSampling1 = "head_sampling"
)

func (e GetDrainsTypeHeadSampling1) ToPointer() *GetDrainsTypeHeadSampling1 {
	return &e
}
func (e *GetDrainsTypeHeadSampling1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "head_sampling":
		*e = GetDrainsTypeHeadSampling1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeHeadSampling1: %v", v)
	}
}

type GetDrainsEnv1 string

const (
	GetDrainsEnv1Production GetDrainsEnv1 = "production"
	GetDrainsEnv1Preview    GetDrainsEnv1 = "preview"
)

func (e GetDrainsEnv1) ToPointer() *GetDrainsEnv1 {
	return &e
}
func (e *GetDrainsEnv1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetDrainsEnv1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEnv1: %v", v)
	}
}

type GetDrainsSampling1 struct {
	Type        GetDrainsTypeHeadSampling1 `json:"type"`
	Rate        float64                    `json:"rate"`
	Env         *GetDrainsEnv1             `json:"env,omitempty"`
	RequestPath *string                    `json:"requestPath,omitempty"`
}

func (g GetDrainsSampling1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSampling1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "rate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSampling1) GetType() GetDrainsTypeHeadSampling1 {
	if o == nil {
		return GetDrainsTypeHeadSampling1("")
	}
	return o.Type
}

func (o *GetDrainsSampling1) GetRate() float64 {
	if o == nil {
		return 0.0
	}
	return o.Rate
}

func (o *GetDrainsSampling1) GetEnv() *GetDrainsEnv1 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetDrainsSampling1) GetRequestPath() *string {
	if o == nil {
		return nil
	}
	return o.RequestPath
}

type GetDrainsStatus1 string

const (
	GetDrainsStatus1Enabled  GetDrainsStatus1 = "enabled"
	GetDrainsStatus1Disabled GetDrainsStatus1 = "disabled"
	GetDrainsStatus1Errored  GetDrainsStatus1 = "errored"
)

func (e GetDrainsStatus1) ToPointer() *GetDrainsStatus1 {
	return &e
}
func (e *GetDrainsStatus1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		fallthrough
	case "errored":
		*e = GetDrainsStatus1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsStatus1: %v", v)
	}
}

type GetDrainsDisabledReason1 string

const (
	GetDrainsDisabledReason1DisabledByOwner      GetDrainsDisabledReason1 = "disabled-by-owner"
	GetDrainsDisabledReason1FeatureNotAvailable  GetDrainsDisabledReason1 = "feature-not-available"
	GetDrainsDisabledReason1AccountPlanDowngrade GetDrainsDisabledReason1 = "account-plan-downgrade"
	GetDrainsDisabledReason1DisabledByAdmin      GetDrainsDisabledReason1 = "disabled-by-admin"
)

func (e GetDrainsDisabledReason1) ToPointer() *GetDrainsDisabledReason1 {
	return &e
}
func (e *GetDrainsDisabledReason1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "disabled-by-owner":
		fallthrough
	case "feature-not-available":
		fallthrough
	case "account-plan-downgrade":
		fallthrough
	case "disabled-by-admin":
		*e = GetDrainsDisabledReason1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsDisabledReason1: %v", v)
	}
}

type GetDrainsKindIntegration1 string

const (
	GetDrainsKindIntegration1Integration GetDrainsKindIntegration1 = "integration"
)

func (e GetDrainsKindIntegration1) ToPointer() *GetDrainsKindIntegration1 {
	return &e
}
func (e *GetDrainsKindIntegration1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		*e = GetDrainsKindIntegration1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsKindIntegration1: %v", v)
	}
}

type GetDrainsSourceIntegration1 struct {
	Kind                       GetDrainsKindIntegration1 `json:"kind"`
	ResourceID                 *string                   `json:"resourceId,omitempty"`
	ExternalResourceID         *string                   `json:"externalResourceId,omitempty"`
	IntegrationID              string                    `json:"integrationId"`
	IntegrationConfigurationID string                    `json:"integrationConfigurationId"`
}

func (g GetDrainsSourceIntegration1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSourceIntegration1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind", "integrationId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSourceIntegration1) GetKind() GetDrainsKindIntegration1 {
	if o == nil {
		return GetDrainsKindIntegration1("")
	}
	return o.Kind
}

func (o *GetDrainsSourceIntegration1) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *GetDrainsSourceIntegration1) GetExternalResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalResourceID
}

func (o *GetDrainsSourceIntegration1) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetDrainsSourceIntegration1) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type GetDrainsKindSelfServed1 string

const (
	GetDrainsKindSelfServed1SelfServed GetDrainsKindSelfServed1 = "self-served"
)

func (e GetDrainsKindSelfServed1) ToPointer() *GetDrainsKindSelfServed1 {
	return &e
}
func (e *GetDrainsKindSelfServed1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "self-served":
		*e = GetDrainsKindSelfServed1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsKindSelfServed1: %v", v)
	}
}

type GetDrainsSourceSelfServed1 struct {
	Kind GetDrainsKindSelfServed1 `json:"kind"`
}

func (g GetDrainsSourceSelfServed1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsSourceSelfServed1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsSourceSelfServed1) GetKind() GetDrainsKindSelfServed1 {
	if o == nil {
		return GetDrainsKindSelfServed1("")
	}
	return o.Kind
}

type GetDrainsSourceUnion1Type string

const (
	GetDrainsSourceUnion1TypeSelfServed  GetDrainsSourceUnion1Type = "self-served"
	GetDrainsSourceUnion1TypeIntegration GetDrainsSourceUnion1Type = "integration"
)

type GetDrainsSourceUnion1 struct {
	GetDrainsSourceSelfServed1  *GetDrainsSourceSelfServed1  `queryParam:"inline"`
	GetDrainsSourceIntegration1 *GetDrainsSourceIntegration1 `queryParam:"inline"`

	Type GetDrainsSourceUnion1Type
}

func CreateGetDrainsSourceUnion1SelfServed(selfServed GetDrainsSourceSelfServed1) GetDrainsSourceUnion1 {
	typ := GetDrainsSourceUnion1TypeSelfServed

	typStr := GetDrainsKindSelfServed1(typ)
	selfServed.Kind = typStr

	return GetDrainsSourceUnion1{
		GetDrainsSourceSelfServed1: &selfServed,
		Type:                       typ,
	}
}

func CreateGetDrainsSourceUnion1Integration(integration GetDrainsSourceIntegration1) GetDrainsSourceUnion1 {
	typ := GetDrainsSourceUnion1TypeIntegration

	typStr := GetDrainsKindIntegration1(typ)
	integration.Kind = typStr

	return GetDrainsSourceUnion1{
		GetDrainsSourceIntegration1: &integration,
		Type:                        typ,
	}
}

func (u *GetDrainsSourceUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Kind string `json:"kind"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Kind {
	case "self-served":
		getDrainsSourceSelfServed1 := new(GetDrainsSourceSelfServed1)
		if err := utils.UnmarshalJSON(data, &getDrainsSourceSelfServed1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == self-served) type GetDrainsSourceSelfServed1 within GetDrainsSourceUnion1: %w", string(data), err)
		}

		u.GetDrainsSourceSelfServed1 = getDrainsSourceSelfServed1
		u.Type = GetDrainsSourceUnion1TypeSelfServed
		return nil
	case "integration":
		getDrainsSourceIntegration1 := new(GetDrainsSourceIntegration1)
		if err := utils.UnmarshalJSON(data, &getDrainsSourceIntegration1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == integration) type GetDrainsSourceIntegration1 within GetDrainsSourceUnion1: %w", string(data), err)
		}

		u.GetDrainsSourceIntegration1 = getDrainsSourceIntegration1
		u.Type = GetDrainsSourceUnion1TypeIntegration
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsSourceUnion1", string(data))
}

func (u GetDrainsSourceUnion1) MarshalJSON() ([]byte, error) {
	if u.GetDrainsSourceSelfServed1 != nil {
		return utils.MarshalJSON(u.GetDrainsSourceSelfServed1, "", true)
	}

	if u.GetDrainsSourceIntegration1 != nil {
		return utils.MarshalJSON(u.GetDrainsSourceIntegration1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsSourceUnion1: all fields are null")
}

type GetDrainsVersionV21 string

const (
	GetDrainsVersionV21V2 GetDrainsVersionV21 = "v2"
)

func (e GetDrainsVersionV21) ToPointer() *GetDrainsVersionV21 {
	return &e
}
func (e *GetDrainsVersionV21) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v2":
		*e = GetDrainsVersionV21(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsVersionV21: %v", v)
	}
}

type GetDrainsTypeOdata1 string

const (
	GetDrainsTypeOdata1Odata GetDrainsTypeOdata1 = "odata"
)

func (e GetDrainsTypeOdata1) ToPointer() *GetDrainsTypeOdata1 {
	return &e
}
func (e *GetDrainsTypeOdata1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "odata":
		*e = GetDrainsTypeOdata1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeOdata1: %v", v)
	}
}

type GetDrainsFilterOdata1 struct {
	Type GetDrainsTypeOdata1 `json:"type"`
	Text string              `json:"text"`
}

func (g GetDrainsFilterOdata1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterOdata1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "text"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterOdata1) GetType() GetDrainsTypeOdata1 {
	if o == nil {
		return GetDrainsTypeOdata1("")
	}
	return o.Type
}

func (o *GetDrainsFilterOdata1) GetText() string {
	if o == nil {
		return ""
	}
	return o.Text
}

type GetDrainsTypeBasic1 string

const (
	GetDrainsTypeBasic1Basic GetDrainsTypeBasic1 = "basic"
)

func (e GetDrainsTypeBasic1) ToPointer() *GetDrainsTypeBasic1 {
	return &e
}
func (e *GetDrainsTypeBasic1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "basic":
		*e = GetDrainsTypeBasic1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsTypeBasic1: %v", v)
	}
}

type GetDrainsProject1 struct {
	Ids []string `json:"ids,omitempty"`
}

func (g GetDrainsProject1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsProject1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsProject1) GetIds() []string {
	if o == nil {
		return nil
	}
	return o.Ids
}

type GetDrainsFilterV2Source1 string

const (
	GetDrainsFilterV2Source1Build    GetDrainsFilterV2Source1 = "build"
	GetDrainsFilterV2Source1Edge     GetDrainsFilterV2Source1 = "edge"
	GetDrainsFilterV2Source1Lambda   GetDrainsFilterV2Source1 = "lambda"
	GetDrainsFilterV2Source1Static   GetDrainsFilterV2Source1 = "static"
	GetDrainsFilterV2Source1External GetDrainsFilterV2Source1 = "external"
	GetDrainsFilterV2Source1Firewall GetDrainsFilterV2Source1 = "firewall"
	GetDrainsFilterV2Source1Redirect GetDrainsFilterV2Source1 = "redirect"
)

func (e GetDrainsFilterV2Source1) ToPointer() *GetDrainsFilterV2Source1 {
	return &e
}
func (e *GetDrainsFilterV2Source1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "build":
		fallthrough
	case "edge":
		fallthrough
	case "lambda":
		fallthrough
	case "static":
		fallthrough
	case "external":
		fallthrough
	case "firewall":
		fallthrough
	case "redirect":
		*e = GetDrainsFilterV2Source1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsFilterV2Source1: %v", v)
	}
}

type GetDrainsFilterV2Log1 struct {
	Sources                            []GetDrainsFilterV2Source1 `json:"sources,omitempty"`
	LegacyExcludeCachedStaticAssetLogs *bool                      `json:"legacy_excludeCachedStaticAssetLogs,omitempty"`
}

func (g GetDrainsFilterV2Log1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2Log1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2Log1) GetSources() []GetDrainsFilterV2Source1 {
	if o == nil {
		return nil
	}
	return o.Sources
}

func (o *GetDrainsFilterV2Log1) GetLegacyExcludeCachedStaticAssetLogs() *bool {
	if o == nil {
		return nil
	}
	return o.LegacyExcludeCachedStaticAssetLogs
}

type GetDrainsEnvironment1 string

const (
	GetDrainsEnvironment1Production GetDrainsEnvironment1 = "production"
	GetDrainsEnvironment1Preview    GetDrainsEnvironment1 = "preview"
)

func (e GetDrainsEnvironment1) ToPointer() *GetDrainsEnvironment1 {
	return &e
}
func (e *GetDrainsEnvironment1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetDrainsEnvironment1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsEnvironment1: %v", v)
	}
}

type GetDrainsDeployment1 struct {
	Environments []GetDrainsEnvironment1 `json:"environments,omitempty"`
}

func (g GetDrainsDeployment1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsDeployment1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsDeployment1) GetEnvironments() []GetDrainsEnvironment1 {
	if o == nil {
		return nil
	}
	return o.Environments
}

type GetDrainsFilterBasic1 struct {
	Type       GetDrainsTypeBasic1    `json:"type"`
	Project    *GetDrainsProject1     `json:"project,omitempty"`
	Log        *GetDrainsFilterV2Log1 `json:"log,omitempty"`
	Deployment *GetDrainsDeployment1  `json:"deployment,omitempty"`
}

func (g GetDrainsFilterBasic1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterBasic1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterBasic1) GetType() GetDrainsTypeBasic1 {
	if o == nil {
		return GetDrainsTypeBasic1("")
	}
	return o.Type
}

func (o *GetDrainsFilterBasic1) GetProject() *GetDrainsProject1 {
	if o == nil {
		return nil
	}
	return o.Project
}

func (o *GetDrainsFilterBasic1) GetLog() *GetDrainsFilterV2Log1 {
	if o == nil {
		return nil
	}
	return o.Log
}

func (o *GetDrainsFilterBasic1) GetDeployment() *GetDrainsDeployment1 {
	if o == nil {
		return nil
	}
	return o.Deployment
}

type GetDrainsFilterUnion1Type string

const (
	GetDrainsFilterUnion1TypeBasic GetDrainsFilterUnion1Type = "basic"
	GetDrainsFilterUnion1TypeOdata GetDrainsFilterUnion1Type = "odata"
)

type GetDrainsFilterUnion1 struct {
	GetDrainsFilterBasic1 *GetDrainsFilterBasic1 `queryParam:"inline"`
	GetDrainsFilterOdata1 *GetDrainsFilterOdata1 `queryParam:"inline"`

	Type GetDrainsFilterUnion1Type
}

func CreateGetDrainsFilterUnion1Basic(basic GetDrainsFilterBasic1) GetDrainsFilterUnion1 {
	typ := GetDrainsFilterUnion1TypeBasic

	typStr := GetDrainsTypeBasic1(typ)
	basic.Type = typStr

	return GetDrainsFilterUnion1{
		GetDrainsFilterBasic1: &basic,
		Type:                  typ,
	}
}

func CreateGetDrainsFilterUnion1Odata(odata GetDrainsFilterOdata1) GetDrainsFilterUnion1 {
	typ := GetDrainsFilterUnion1TypeOdata

	typStr := GetDrainsTypeOdata1(typ)
	odata.Type = typStr

	return GetDrainsFilterUnion1{
		GetDrainsFilterOdata1: &odata,
		Type:                  typ,
	}
}

func (u *GetDrainsFilterUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "basic":
		getDrainsFilterBasic1 := new(GetDrainsFilterBasic1)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterBasic1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == basic) type GetDrainsFilterBasic1 within GetDrainsFilterUnion1: %w", string(data), err)
		}

		u.GetDrainsFilterBasic1 = getDrainsFilterBasic1
		u.Type = GetDrainsFilterUnion1TypeBasic
		return nil
	case "odata":
		getDrainsFilterOdata1 := new(GetDrainsFilterOdata1)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterOdata1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == odata) type GetDrainsFilterOdata1 within GetDrainsFilterUnion1: %w", string(data), err)
		}

		u.GetDrainsFilterOdata1 = getDrainsFilterOdata1
		u.Type = GetDrainsFilterUnion1TypeOdata
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsFilterUnion1", string(data))
}

func (u GetDrainsFilterUnion1) MarshalJSON() ([]byte, error) {
	if u.GetDrainsFilterBasic1 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterBasic1, "", true)
	}

	if u.GetDrainsFilterOdata1 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterOdata1, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsFilterUnion1: all fields are null")
}

type GetDrainsFilterV2V21 struct {
	Version GetDrainsVersionV21   `json:"version"`
	Filter  GetDrainsFilterUnion1 `json:"filter"`
}

func (g GetDrainsFilterV2V21) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2V21) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version", "filter"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2V21) GetVersion() GetDrainsVersionV21 {
	if o == nil {
		return GetDrainsVersionV21("")
	}
	return o.Version
}

func (o *GetDrainsFilterV2V21) GetFilter() GetDrainsFilterUnion1 {
	if o == nil {
		return GetDrainsFilterUnion1{}
	}
	return o.Filter
}

func (o *GetDrainsFilterV2V21) GetFilterBasic() *GetDrainsFilterBasic1 {
	return o.GetFilter().GetDrainsFilterBasic1
}

func (o *GetDrainsFilterV2V21) GetFilterOdata() *GetDrainsFilterOdata1 {
	return o.GetFilter().GetDrainsFilterOdata1
}

type GetDrainsVersionV11 string

const (
	GetDrainsVersionV11V1 GetDrainsVersionV11 = "v1"
)

func (e GetDrainsVersionV11) ToPointer() *GetDrainsVersionV11 {
	return &e
}
func (e *GetDrainsVersionV11) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "v1":
		*e = GetDrainsVersionV11(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetDrainsVersionV11: %v", v)
	}
}

type GetDrainsFilterV2V11 struct {
	Version GetDrainsVersionV11 `json:"version"`
}

func (g GetDrainsFilterV2V11) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetDrainsFilterV2V11) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"version"}); err != nil {
		return err
	}
	return nil
}

func (o *GetDrainsFilterV2V11) GetVersion() GetDrainsVersionV11 {
	if o == nil {
		return GetDrainsVersionV11("")
	}
	return o.Version
}

type GetDrainsFilterV2Union1Type string

const (
	GetDrainsFilterV2Union1TypeV1 GetDrainsFilterV2Union1Type = "v1"
	GetDrainsFilterV2Union1TypeV2 GetDrainsFilterV2Union1Type = "v2"
)

type GetDrainsFilterV2Union1 struct {
	GetDrainsFilterV2V11 *GetDrainsFilterV2V11 `queryParam:"inline"`
	GetDrainsFilterV2V21 *GetDrainsFilterV2V21 `queryParam:"inline"`

	Type GetDrainsFilterV2Union1Type
}

func CreateGetDrainsFilterV2Union1V1(v1 GetDrainsFilterV2V11) GetDrainsFilterV2Union1 {
	typ := GetDrainsFilterV2Union1TypeV1

	typStr := GetDrainsVersionV11(typ)
	v1.Version = typStr

	return GetDrainsFilterV2Union1{
		GetDrainsFilterV2V11: &v1,
		Type:                 typ,
	}
}

func CreateGetDrainsFilterV2Union1V2(v2 GetDrainsFilterV2V21) GetDrainsFilterV2Union1 {
	typ := GetDrainsFilterV2Union1TypeV2

	typStr := GetDrainsVersionV21(typ)
	v2.Version = typStr

	return GetDrainsFilterV2Union1{
		GetDrainsFilterV2V21: &v2,
		Type:                 typ,
	}
}

func (u *GetDrainsFilterV2Union1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Version string `json:"version"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Version {
	case "v1":
		getDrainsFilterV2V11 := new(GetDrainsFilterV2V11)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterV2V11, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v1) type GetDrainsFilterV2V11 within GetDrainsFilterV2Union1: %w", string(data), err)
		}

		u.GetDrainsFilterV2V11 = getDrainsFilterV2V11
		u.Type = GetDrainsFilterV2Union1TypeV1
		return nil
	case "v2":
		getDrainsFilterV2V21 := new(GetDrainsFilterV2V21)
		if err := utils.UnmarshalJSON(data, &getDrainsFilterV2V21, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Version == v2) type GetDrainsFilterV2V21 within GetDrainsFilterV2Union1: %w", string(data), err)
		}

		u.GetDrainsFilterV2V21 = getDrainsFilterV2V21
		u.Type = GetDrainsFilterV2Union1TypeV2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsFilterV2Union1", string(data))
}

func (u GetDrainsFilterV2Union1) MarshalJSON() ([]byte, error) {
	if u.GetDrainsFilterV2V11 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterV2V11, "", true)
	}

	if u.GetDrainsFilterV2V21 != nil {
		return utils.MarshalJSON(u.GetDrainsFilterV2V21, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsFilterV2Union1: all fields are null")
}

type DrainsGetDrains1 struct {
	ID                  string                    `json:"id"`
	OwnerID             string                    `json:"ownerId"`
	Name                string                    `json:"name"`
	CreatedAt           float64                   `json:"createdAt"`
	UpdatedAt           float64                   `json:"updatedAt"`
	ProjectIds          []string                  `json:"projectIds,omitempty"`
	Schemas             GetDrainsSchemas1         `json:"schemas"`
	Delivery            GetDrainsDeliveryUnion1   `json:"delivery"`
	Sampling            []GetDrainsSampling1      `json:"sampling,omitempty"`
	TeamID              *string                   `json:"teamId,omitempty"`
	Status              *GetDrainsStatus1         `json:"status,omitempty"`
	DisabledAt          *float64                  `json:"disabledAt,omitempty"`
	DisabledReason      *GetDrainsDisabledReason1 `json:"disabledReason,omitempty"`
	DisabledBy          *string                   `json:"disabledBy,omitempty"`
	FirstErrorTimestamp *float64                  `json:"firstErrorTimestamp,omitempty"`
	Source              GetDrainsSourceUnion1     `json:"source"`
	Filter              *string                   `json:"filter,omitempty"`
	FilterV2            *GetDrainsFilterV2Union1  `json:"filterV2,omitempty"`
}

func (d DrainsGetDrains1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DrainsGetDrains1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"id", "ownerId", "name", "createdAt", "updatedAt", "schemas", "delivery", "source"}); err != nil {
		return err
	}
	return nil
}

func (o *DrainsGetDrains1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *DrainsGetDrains1) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *DrainsGetDrains1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *DrainsGetDrains1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *DrainsGetDrains1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *DrainsGetDrains1) GetProjectIds() []string {
	if o == nil {
		return nil
	}
	return o.ProjectIds
}

func (o *DrainsGetDrains1) GetSchemas() GetDrainsSchemas1 {
	if o == nil {
		return GetDrainsSchemas1{}
	}
	return o.Schemas
}

func (o *DrainsGetDrains1) GetDelivery() GetDrainsDeliveryUnion1 {
	if o == nil {
		return GetDrainsDeliveryUnion1{}
	}
	return o.Delivery
}

func (o *DrainsGetDrains1) GetDeliveryHTTP() *GetDrainsDeliveryHTTP1 {
	return o.GetDelivery().GetDrainsDeliveryHTTP1
}

func (o *DrainsGetDrains1) GetDeliveryOtlphttp() *GetDrainsDeliveryOtlphttp1 {
	return o.GetDelivery().GetDrainsDeliveryOtlphttp1
}

func (o *DrainsGetDrains1) GetDeliveryClickhouse() *GetDrainsDeliveryClickhouse1 {
	return o.GetDelivery().GetDrainsDeliveryClickhouse1
}

func (o *DrainsGetDrains1) GetDeliveryInternal() *GetDrainsDeliveryVercelOtelTracesDb1 {
	return o.GetDelivery().GetDrainsDeliveryVercelOtelTracesDb1
}

func (o *DrainsGetDrains1) GetSampling() []GetDrainsSampling1 {
	if o == nil {
		return nil
	}
	return o.Sampling
}

func (o *DrainsGetDrains1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *DrainsGetDrains1) GetStatus() *GetDrainsStatus1 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *DrainsGetDrains1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *DrainsGetDrains1) GetDisabledReason() *GetDrainsDisabledReason1 {
	if o == nil {
		return nil
	}
	return o.DisabledReason
}

func (o *DrainsGetDrains1) GetDisabledBy() *string {
	if o == nil {
		return nil
	}
	return o.DisabledBy
}

func (o *DrainsGetDrains1) GetFirstErrorTimestamp() *float64 {
	if o == nil {
		return nil
	}
	return o.FirstErrorTimestamp
}

func (o *DrainsGetDrains1) GetSource() GetDrainsSourceUnion1 {
	if o == nil {
		return GetDrainsSourceUnion1{}
	}
	return o.Source
}

func (o *DrainsGetDrains1) GetSourceSelfServed() *GetDrainsSourceSelfServed1 {
	return o.GetSource().GetDrainsSourceSelfServed1
}

func (o *DrainsGetDrains1) GetSourceIntegration() *GetDrainsSourceIntegration1 {
	return o.GetSource().GetDrainsSourceIntegration1
}

func (o *DrainsGetDrains1) GetFilter() *string {
	if o == nil {
		return nil
	}
	return o.Filter
}

func (o *DrainsGetDrains1) GetFilterV2() *GetDrainsFilterV2Union1 {
	if o == nil {
		return nil
	}
	return o.FilterV2
}

func (o *DrainsGetDrains1) GetFilterV2V1() *GetDrainsFilterV2V11 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetDrainsFilterV2V11
	}
	return nil
}

func (o *DrainsGetDrains1) GetFilterV2V2() *GetDrainsFilterV2V21 {
	if v := o.GetFilterV2(); v != nil {
		return v.GetDrainsFilterV2V21
	}
	return nil
}

type GetDrainsDrainsUnionType string

const (
	GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains1 GetDrainsDrainsUnionType = "arrayOfDrainsGetDrains1"
	GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains2 GetDrainsDrainsUnionType = "arrayOfDrainsGetDrains2"
)

type GetDrainsDrainsUnion struct {
	ArrayOfDrainsGetDrains1 []DrainsGetDrains1 `queryParam:"inline"`
	ArrayOfDrainsGetDrains2 []DrainsGetDrains2 `queryParam:"inline"`

	Type GetDrainsDrainsUnionType
}

func CreateGetDrainsDrainsUnionArrayOfDrainsGetDrains1(arrayOfDrainsGetDrains1 []DrainsGetDrains1) GetDrainsDrainsUnion {
	typ := GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains1

	return GetDrainsDrainsUnion{
		ArrayOfDrainsGetDrains1: arrayOfDrainsGetDrains1,
		Type:                    typ,
	}
}

func CreateGetDrainsDrainsUnionArrayOfDrainsGetDrains2(arrayOfDrainsGetDrains2 []DrainsGetDrains2) GetDrainsDrainsUnion {
	typ := GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains2

	return GetDrainsDrainsUnion{
		ArrayOfDrainsGetDrains2: arrayOfDrainsGetDrains2,
		Type:                    typ,
	}
}

func (u *GetDrainsDrainsUnion) UnmarshalJSON(data []byte) error {

	var arrayOfDrainsGetDrains1 []DrainsGetDrains1 = []DrainsGetDrains1{}
	if err := utils.UnmarshalJSON(data, &arrayOfDrainsGetDrains1, "", true, nil); err == nil {
		u.ArrayOfDrainsGetDrains1 = arrayOfDrainsGetDrains1
		u.Type = GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains1
		return nil
	}

	var arrayOfDrainsGetDrains2 []DrainsGetDrains2 = []DrainsGetDrains2{}
	if err := utils.UnmarshalJSON(data, &arrayOfDrainsGetDrains2, "", true, nil); err == nil {
		u.ArrayOfDrainsGetDrains2 = arrayOfDrainsGetDrains2
		u.Type = GetDrainsDrainsUnionTypeArrayOfDrainsGetDrains2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetDrainsDrainsUnion", string(data))
}

func (u GetDrainsDrainsUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfDrainsGetDrains1 != nil {
		return utils.MarshalJSON(u.ArrayOfDrainsGetDrains1, "", true)
	}

	if u.ArrayOfDrainsGetDrains2 != nil {
		return utils.MarshalJSON(u.ArrayOfDrainsGetDrains2, "", true)
	}

	return nil, errors.New("could not marshal union type GetDrainsDrainsUnion: all fields are null")
}

type GetDrainsResponseBody struct {
	Drains GetDrainsDrainsUnion `json:"drains"`
}

func (o *GetDrainsResponseBody) GetDrains() GetDrainsDrainsUnion {
	if o == nil {
		return GetDrainsDrainsUnion{}
	}
	return o.Drains
}

type GetDrainsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *GetDrainsResponseBody
}

func (o *GetDrainsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetDrainsResponse) GetObject() *GetDrainsResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
