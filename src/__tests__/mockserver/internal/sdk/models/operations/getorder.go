// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type GetOrderRequest struct {
	OrderID string  `pathParam:"style=simple,explode=false,name=orderId"`
	TeamID  *string `queryParam:"style=form,explode=true,name=teamId"`
}

func (o *GetOrderRequest) GetOrderID() string {
	if o == nil {
		return ""
	}
	return o.OrderID
}

func (o *GetOrderRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

type PurchaseTypeTransfer string

const (
	PurchaseTypeTransferTransfer PurchaseTypeTransfer = "transfer"
)

func (e PurchaseTypeTransfer) ToPointer() *PurchaseTypeTransfer {
	return &e
}
func (e *PurchaseTypeTransfer) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "transfer":
		*e = PurchaseTypeTransfer(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PurchaseTypeTransfer: %v", v)
	}
}

type DomainStatus3 string

const (
	DomainStatus3Pending      DomainStatus3 = "pending"
	DomainStatus3Completed    DomainStatus3 = "completed"
	DomainStatus3Failed       DomainStatus3 = "failed"
	DomainStatus3Refunded     DomainStatus3 = "refunded"
	DomainStatus3RefundFailed DomainStatus3 = "refund-failed"
)

func (e DomainStatus3) ToPointer() *DomainStatus3 {
	return &e
}
func (e *DomainStatus3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "completed":
		fallthrough
	case "failed":
		fallthrough
	case "refunded":
		fallthrough
	case "refund-failed":
		*e = DomainStatus3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DomainStatus3: %v", v)
	}
}

type DomainError3 struct {
	Code    string `json:"code"`
	Details any    `json:"details,omitempty"`
}

func (d DomainError3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainError3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainError3) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *DomainError3) GetDetails() any {
	if o == nil {
		return nil
	}
	return o.Details
}

type CodeUnavailableLegal3 string

const (
	CodeUnavailableLegal3UnavailableLegal CodeUnavailableLegal3 = "unavailable-legal"
)

func (e CodeUnavailableLegal3) ToPointer() *CodeUnavailableLegal3 {
	return &e
}
func (e *CodeUnavailableLegal3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unavailable-legal":
		*e = CodeUnavailableLegal3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnavailableLegal3: %v", v)
	}
}

type ErrorUnavailableLegal3 struct {
	Code CodeUnavailableLegal3 `json:"code"`
}

func (e ErrorUnavailableLegal3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnavailableLegal3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnavailableLegal3) GetCode() CodeUnavailableLegal3 {
	if o == nil {
		return CodeUnavailableLegal3("")
	}
	return o.Code
}

type CodePriceChange3 string

const (
	CodePriceChange3PriceChange CodePriceChange3 = "price-change"
)

func (e CodePriceChange3) ToPointer() *CodePriceChange3 {
	return &e
}
func (e *CodePriceChange3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "price-change":
		*e = CodePriceChange3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodePriceChange3: %v", v)
	}
}

type ErrorPriceChange3 struct {
	Code CodePriceChange3 `json:"code"`
}

func (e ErrorPriceChange3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorPriceChange3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorPriceChange3) GetCode() CodePriceChange3 {
	if o == nil {
		return CodePriceChange3("")
	}
	return o.Code
}

type CodeCannotTransferInUntil3 string

const (
	CodeCannotTransferInUntil3CannotTransferInUntil CodeCannotTransferInUntil3 = "cannot-transfer-in-until"
)

func (e CodeCannotTransferInUntil3) ToPointer() *CodeCannotTransferInUntil3 {
	return &e
}
func (e *CodeCannotTransferInUntil3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cannot-transfer-in-until":
		*e = CodeCannotTransferInUntil3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeCannotTransferInUntil3: %v", v)
	}
}

type DomainDetails9 struct {
	NumDaysUntilTransferrable float64 `json:"numDaysUntilTransferrable"`
}

func (d DomainDetails9) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails9) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"numDaysUntilTransferrable"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails9) GetNumDaysUntilTransferrable() float64 {
	if o == nil {
		return 0.0
	}
	return o.NumDaysUntilTransferrable
}

type ErrorCannotTransferInUntil3 struct {
	Code    CodeCannotTransferInUntil3 `json:"code"`
	Details DomainDetails9             `json:"details"`
}

func (e ErrorCannotTransferInUntil3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorCannotTransferInUntil3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorCannotTransferInUntil3) GetCode() CodeCannotTransferInUntil3 {
	if o == nil {
		return CodeCannotTransferInUntil3("")
	}
	return o.Code
}

func (o *ErrorCannotTransferInUntil3) GetDetails() DomainDetails9 {
	if o == nil {
		return DomainDetails9{}
	}
	return o.Details
}

type CodeClaimsNoticeRequired3 string

const (
	CodeClaimsNoticeRequired3ClaimsNoticeRequired CodeClaimsNoticeRequired3 = "claims-notice-required"
)

func (e CodeClaimsNoticeRequired3) ToPointer() *CodeClaimsNoticeRequired3 {
	return &e
}
func (e *CodeClaimsNoticeRequired3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "claims-notice-required":
		*e = CodeClaimsNoticeRequired3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClaimsNoticeRequired3: %v", v)
	}
}

type ErrorClaimsNoticeRequired3 struct {
	Code CodeClaimsNoticeRequired3 `json:"code"`
}

func (e ErrorClaimsNoticeRequired3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClaimsNoticeRequired3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClaimsNoticeRequired3) GetCode() CodeClaimsNoticeRequired3 {
	if o == nil {
		return CodeClaimsNoticeRequired3("")
	}
	return o.Code
}

type CodeIncorrectAuthCode3 string

const (
	CodeIncorrectAuthCode3IncorrectAuthCode CodeIncorrectAuthCode3 = "incorrect-auth-code"
)

func (e CodeIncorrectAuthCode3) ToPointer() *CodeIncorrectAuthCode3 {
	return &e
}
func (e *CodeIncorrectAuthCode3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-auth-code":
		*e = CodeIncorrectAuthCode3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectAuthCode3: %v", v)
	}
}

type ErrorIncorrectAuthCode3 struct {
	Code CodeIncorrectAuthCode3 `json:"code"`
}

func (e ErrorIncorrectAuthCode3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectAuthCode3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectAuthCode3) GetCode() CodeIncorrectAuthCode3 {
	if o == nil {
		return CodeIncorrectAuthCode3("")
	}
	return o.Code
}

type CodeClientTransferProhibited3 string

const (
	CodeClientTransferProhibited3ClientTransferProhibited CodeClientTransferProhibited3 = "client-transfer-prohibited"
)

func (e CodeClientTransferProhibited3) ToPointer() *CodeClientTransferProhibited3 {
	return &e
}
func (e *CodeClientTransferProhibited3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client-transfer-prohibited":
		*e = CodeClientTransferProhibited3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClientTransferProhibited3: %v", v)
	}
}

type ErrorClientTransferProhibited3 struct {
	Code CodeClientTransferProhibited3 `json:"code"`
}

func (e ErrorClientTransferProhibited3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClientTransferProhibited3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClientTransferProhibited3) GetCode() CodeClientTransferProhibited3 {
	if o == nil {
		return CodeClientTransferProhibited3("")
	}
	return o.Code
}

type CodeIncorrectLanguageCode3 string

const (
	CodeIncorrectLanguageCode3IncorrectLanguageCode CodeIncorrectLanguageCode3 = "incorrect-language-code"
)

func (e CodeIncorrectLanguageCode3) ToPointer() *CodeIncorrectLanguageCode3 {
	return &e
}
func (e *CodeIncorrectLanguageCode3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-language-code":
		*e = CodeIncorrectLanguageCode3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectLanguageCode3: %v", v)
	}
}

type DomainDetails8 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails8) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails8) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails8) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorIncorrectLanguageCode3 struct {
	Code    CodeIncorrectLanguageCode3 `json:"code"`
	Details DomainDetails8             `json:"details"`
}

func (e ErrorIncorrectLanguageCode3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectLanguageCode3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectLanguageCode3) GetCode() CodeIncorrectLanguageCode3 {
	if o == nil {
		return CodeIncorrectLanguageCode3("")
	}
	return o.Code
}

func (o *ErrorIncorrectLanguageCode3) GetDetails() DomainDetails8 {
	if o == nil {
		return DomainDetails8{}
	}
	return o.Details
}

type CodeUnsupportedLanguageCode3 string

const (
	CodeUnsupportedLanguageCode3UnsupportedLanguageCode CodeUnsupportedLanguageCode3 = "unsupported-language-code"
)

func (e CodeUnsupportedLanguageCode3) ToPointer() *CodeUnsupportedLanguageCode3 {
	return &e
}
func (e *CodeUnsupportedLanguageCode3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unsupported-language-code":
		*e = CodeUnsupportedLanguageCode3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnsupportedLanguageCode3: %v", v)
	}
}

type DomainDetails7 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails7) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails7) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails7) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorUnsupportedLanguageCode3 struct {
	Code    CodeUnsupportedLanguageCode3 `json:"code"`
	Details DomainDetails7               `json:"details"`
}

func (e ErrorUnsupportedLanguageCode3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnsupportedLanguageCode3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnsupportedLanguageCode3) GetCode() CodeUnsupportedLanguageCode3 {
	if o == nil {
		return CodeUnsupportedLanguageCode3("")
	}
	return o.Code
}

func (o *ErrorUnsupportedLanguageCode3) GetDetails() DomainDetails7 {
	if o == nil {
		return DomainDetails7{}
	}
	return o.Details
}

type DomainErrorUnion5Type string

const (
	DomainErrorUnion5TypeUnsupportedLanguageCode  DomainErrorUnion5Type = "unsupported-language-code"
	DomainErrorUnion5TypeIncorrectLanguageCode    DomainErrorUnion5Type = "incorrect-language-code"
	DomainErrorUnion5TypeClientTransferProhibited DomainErrorUnion5Type = "client-transfer-prohibited"
	DomainErrorUnion5TypeIncorrectAuthCode        DomainErrorUnion5Type = "incorrect-auth-code"
	DomainErrorUnion5TypeClaimsNoticeRequired     DomainErrorUnion5Type = "claims-notice-required"
	DomainErrorUnion5TypeCannotTransferInUntil    DomainErrorUnion5Type = "cannot-transfer-in-until"
	DomainErrorUnion5TypePriceChange              DomainErrorUnion5Type = "price-change"
	DomainErrorUnion5TypeUnavailableLegal         DomainErrorUnion5Type = "unavailable-legal"
)

type DomainErrorUnion5 struct {
	ErrorUnsupportedLanguageCode3  *ErrorUnsupportedLanguageCode3  `queryParam:"inline"`
	ErrorIncorrectLanguageCode3    *ErrorIncorrectLanguageCode3    `queryParam:"inline"`
	ErrorClientTransferProhibited3 *ErrorClientTransferProhibited3 `queryParam:"inline"`
	ErrorIncorrectAuthCode3        *ErrorIncorrectAuthCode3        `queryParam:"inline"`
	ErrorClaimsNoticeRequired3     *ErrorClaimsNoticeRequired3     `queryParam:"inline"`
	ErrorCannotTransferInUntil3    *ErrorCannotTransferInUntil3    `queryParam:"inline"`
	ErrorPriceChange3              *ErrorPriceChange3              `queryParam:"inline"`
	ErrorUnavailableLegal3         *ErrorUnavailableLegal3         `queryParam:"inline"`

	Type DomainErrorUnion5Type
}

func CreateDomainErrorUnion5UnsupportedLanguageCode(unsupportedLanguageCode ErrorUnsupportedLanguageCode3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeUnsupportedLanguageCode

	typStr := CodeUnsupportedLanguageCode3(typ)
	unsupportedLanguageCode.Code = typStr

	return DomainErrorUnion5{
		ErrorUnsupportedLanguageCode3: &unsupportedLanguageCode,
		Type:                          typ,
	}
}

func CreateDomainErrorUnion5IncorrectLanguageCode(incorrectLanguageCode ErrorIncorrectLanguageCode3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeIncorrectLanguageCode

	typStr := CodeIncorrectLanguageCode3(typ)
	incorrectLanguageCode.Code = typStr

	return DomainErrorUnion5{
		ErrorIncorrectLanguageCode3: &incorrectLanguageCode,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion5ClientTransferProhibited(clientTransferProhibited ErrorClientTransferProhibited3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeClientTransferProhibited

	typStr := CodeClientTransferProhibited3(typ)
	clientTransferProhibited.Code = typStr

	return DomainErrorUnion5{
		ErrorClientTransferProhibited3: &clientTransferProhibited,
		Type:                           typ,
	}
}

func CreateDomainErrorUnion5IncorrectAuthCode(incorrectAuthCode ErrorIncorrectAuthCode3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeIncorrectAuthCode

	typStr := CodeIncorrectAuthCode3(typ)
	incorrectAuthCode.Code = typStr

	return DomainErrorUnion5{
		ErrorIncorrectAuthCode3: &incorrectAuthCode,
		Type:                    typ,
	}
}

func CreateDomainErrorUnion5ClaimsNoticeRequired(claimsNoticeRequired ErrorClaimsNoticeRequired3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeClaimsNoticeRequired

	typStr := CodeClaimsNoticeRequired3(typ)
	claimsNoticeRequired.Code = typStr

	return DomainErrorUnion5{
		ErrorClaimsNoticeRequired3: &claimsNoticeRequired,
		Type:                       typ,
	}
}

func CreateDomainErrorUnion5CannotTransferInUntil(cannotTransferInUntil ErrorCannotTransferInUntil3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeCannotTransferInUntil

	typStr := CodeCannotTransferInUntil3(typ)
	cannotTransferInUntil.Code = typStr

	return DomainErrorUnion5{
		ErrorCannotTransferInUntil3: &cannotTransferInUntil,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion5PriceChange(priceChange ErrorPriceChange3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypePriceChange

	typStr := CodePriceChange3(typ)
	priceChange.Code = typStr

	return DomainErrorUnion5{
		ErrorPriceChange3: &priceChange,
		Type:              typ,
	}
}

func CreateDomainErrorUnion5UnavailableLegal(unavailableLegal ErrorUnavailableLegal3) DomainErrorUnion5 {
	typ := DomainErrorUnion5TypeUnavailableLegal

	typStr := CodeUnavailableLegal3(typ)
	unavailableLegal.Code = typStr

	return DomainErrorUnion5{
		ErrorUnavailableLegal3: &unavailableLegal,
		Type:                   typ,
	}
}

func (u *DomainErrorUnion5) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Code string `json:"code"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Code {
	case "unsupported-language-code":
		errorUnsupportedLanguageCode3 := new(ErrorUnsupportedLanguageCode3)
		if err := utils.UnmarshalJSON(data, &errorUnsupportedLanguageCode3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unsupported-language-code) type ErrorUnsupportedLanguageCode3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorUnsupportedLanguageCode3 = errorUnsupportedLanguageCode3
		u.Type = DomainErrorUnion5TypeUnsupportedLanguageCode
		return nil
	case "incorrect-language-code":
		errorIncorrectLanguageCode3 := new(ErrorIncorrectLanguageCode3)
		if err := utils.UnmarshalJSON(data, &errorIncorrectLanguageCode3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-language-code) type ErrorIncorrectLanguageCode3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorIncorrectLanguageCode3 = errorIncorrectLanguageCode3
		u.Type = DomainErrorUnion5TypeIncorrectLanguageCode
		return nil
	case "client-transfer-prohibited":
		errorClientTransferProhibited3 := new(ErrorClientTransferProhibited3)
		if err := utils.UnmarshalJSON(data, &errorClientTransferProhibited3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == client-transfer-prohibited) type ErrorClientTransferProhibited3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorClientTransferProhibited3 = errorClientTransferProhibited3
		u.Type = DomainErrorUnion5TypeClientTransferProhibited
		return nil
	case "incorrect-auth-code":
		errorIncorrectAuthCode3 := new(ErrorIncorrectAuthCode3)
		if err := utils.UnmarshalJSON(data, &errorIncorrectAuthCode3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-auth-code) type ErrorIncorrectAuthCode3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorIncorrectAuthCode3 = errorIncorrectAuthCode3
		u.Type = DomainErrorUnion5TypeIncorrectAuthCode
		return nil
	case "claims-notice-required":
		errorClaimsNoticeRequired3 := new(ErrorClaimsNoticeRequired3)
		if err := utils.UnmarshalJSON(data, &errorClaimsNoticeRequired3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == claims-notice-required) type ErrorClaimsNoticeRequired3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorClaimsNoticeRequired3 = errorClaimsNoticeRequired3
		u.Type = DomainErrorUnion5TypeClaimsNoticeRequired
		return nil
	case "cannot-transfer-in-until":
		errorCannotTransferInUntil3 := new(ErrorCannotTransferInUntil3)
		if err := utils.UnmarshalJSON(data, &errorCannotTransferInUntil3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == cannot-transfer-in-until) type ErrorCannotTransferInUntil3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorCannotTransferInUntil3 = errorCannotTransferInUntil3
		u.Type = DomainErrorUnion5TypeCannotTransferInUntil
		return nil
	case "price-change":
		errorPriceChange3 := new(ErrorPriceChange3)
		if err := utils.UnmarshalJSON(data, &errorPriceChange3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == price-change) type ErrorPriceChange3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorPriceChange3 = errorPriceChange3
		u.Type = DomainErrorUnion5TypePriceChange
		return nil
	case "unavailable-legal":
		errorUnavailableLegal3 := new(ErrorUnavailableLegal3)
		if err := utils.UnmarshalJSON(data, &errorUnavailableLegal3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unavailable-legal) type ErrorUnavailableLegal3 within DomainErrorUnion5: %w", string(data), err)
		}

		u.ErrorUnavailableLegal3 = errorUnavailableLegal3
		u.Type = DomainErrorUnion5TypeUnavailableLegal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion5", string(data))
}

func (u DomainErrorUnion5) MarshalJSON() ([]byte, error) {
	if u.ErrorUnsupportedLanguageCode3 != nil {
		return utils.MarshalJSON(u.ErrorUnsupportedLanguageCode3, "", true)
	}

	if u.ErrorIncorrectLanguageCode3 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectLanguageCode3, "", true)
	}

	if u.ErrorClientTransferProhibited3 != nil {
		return utils.MarshalJSON(u.ErrorClientTransferProhibited3, "", true)
	}

	if u.ErrorIncorrectAuthCode3 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectAuthCode3, "", true)
	}

	if u.ErrorClaimsNoticeRequired3 != nil {
		return utils.MarshalJSON(u.ErrorClaimsNoticeRequired3, "", true)
	}

	if u.ErrorCannotTransferInUntil3 != nil {
		return utils.MarshalJSON(u.ErrorCannotTransferInUntil3, "", true)
	}

	if u.ErrorPriceChange3 != nil {
		return utils.MarshalJSON(u.ErrorPriceChange3, "", true)
	}

	if u.ErrorUnavailableLegal3 != nil {
		return utils.MarshalJSON(u.ErrorUnavailableLegal3, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion5: all fields are null")
}

type DomainErrorUnion6Type string

const (
	DomainErrorUnion6TypeDomainErrorUnion5 DomainErrorUnion6Type = "domain_error_union_5"
	DomainErrorUnion6TypeDomainError3      DomainErrorUnion6Type = "domain_error_3"
)

type DomainErrorUnion6 struct {
	DomainErrorUnion5 *DomainErrorUnion5 `queryParam:"inline"`
	DomainError3      *DomainError3      `queryParam:"inline"`

	Type DomainErrorUnion6Type
}

func CreateDomainErrorUnion6DomainErrorUnion5(domainErrorUnion5 DomainErrorUnion5) DomainErrorUnion6 {
	typ := DomainErrorUnion6TypeDomainErrorUnion5

	return DomainErrorUnion6{
		DomainErrorUnion5: &domainErrorUnion5,
		Type:              typ,
	}
}

func CreateDomainErrorUnion6DomainError3(domainError3 DomainError3) DomainErrorUnion6 {
	typ := DomainErrorUnion6TypeDomainError3

	return DomainErrorUnion6{
		DomainError3: &domainError3,
		Type:         typ,
	}
}

func (u *DomainErrorUnion6) UnmarshalJSON(data []byte) error {

	var domainError3 DomainError3 = DomainError3{}
	if err := utils.UnmarshalJSON(data, &domainError3, "", true, nil); err == nil {
		u.DomainError3 = &domainError3
		u.Type = DomainErrorUnion6TypeDomainError3
		return nil
	}

	var domainErrorUnion5 DomainErrorUnion5 = DomainErrorUnion5{}
	if err := utils.UnmarshalJSON(data, &domainErrorUnion5, "", true, nil); err == nil {
		u.DomainErrorUnion5 = &domainErrorUnion5
		u.Type = DomainErrorUnion6TypeDomainErrorUnion5
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion6", string(data))
}

func (u DomainErrorUnion6) MarshalJSON() ([]byte, error) {
	if u.DomainErrorUnion5 != nil {
		return utils.MarshalJSON(u.DomainErrorUnion5, "", true)
	}

	if u.DomainError3 != nil {
		return utils.MarshalJSON(u.DomainError3, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion6: all fields are null")
}

type DomainTransfer struct {
	PurchaseType PurchaseTypeTransfer `json:"purchaseType"`
	AutoRenew    bool                 `json:"autoRenew"`
	// The number of years the domain is being transferred for.
	Years float64 `json:"years"`
	// A valid domain name
	DomainName string             `json:"domainName"`
	Status     DomainStatus3      `json:"status"`
	Price      float64            `json:"price"`
	Error      *DomainErrorUnion6 `json:"error,omitempty"`
}

func (d DomainTransfer) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainTransfer) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"purchaseType", "autoRenew", "years", "domainName", "status", "price"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainTransfer) GetPurchaseType() PurchaseTypeTransfer {
	if o == nil {
		return PurchaseTypeTransfer("")
	}
	return o.PurchaseType
}

func (o *DomainTransfer) GetAutoRenew() bool {
	if o == nil {
		return false
	}
	return o.AutoRenew
}

func (o *DomainTransfer) GetYears() float64 {
	if o == nil {
		return 0.0
	}
	return o.Years
}

func (o *DomainTransfer) GetDomainName() string {
	if o == nil {
		return ""
	}
	return o.DomainName
}

func (o *DomainTransfer) GetStatus() DomainStatus3 {
	if o == nil {
		return DomainStatus3("")
	}
	return o.Status
}

func (o *DomainTransfer) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

func (o *DomainTransfer) GetError() *DomainErrorUnion6 {
	if o == nil {
		return nil
	}
	return o.Error
}

type PurchaseTypeRenewal string

const (
	PurchaseTypeRenewalRenewal PurchaseTypeRenewal = "renewal"
)

func (e PurchaseTypeRenewal) ToPointer() *PurchaseTypeRenewal {
	return &e
}
func (e *PurchaseTypeRenewal) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "renewal":
		*e = PurchaseTypeRenewal(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PurchaseTypeRenewal: %v", v)
	}
}

type DomainStatus2 string

const (
	DomainStatus2Pending      DomainStatus2 = "pending"
	DomainStatus2Completed    DomainStatus2 = "completed"
	DomainStatus2Failed       DomainStatus2 = "failed"
	DomainStatus2Refunded     DomainStatus2 = "refunded"
	DomainStatus2RefundFailed DomainStatus2 = "refund-failed"
)

func (e DomainStatus2) ToPointer() *DomainStatus2 {
	return &e
}
func (e *DomainStatus2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "completed":
		fallthrough
	case "failed":
		fallthrough
	case "refunded":
		fallthrough
	case "refund-failed":
		*e = DomainStatus2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DomainStatus2: %v", v)
	}
}

type DomainError2 struct {
	Code    string `json:"code"`
	Details any    `json:"details,omitempty"`
}

func (d DomainError2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainError2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainError2) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *DomainError2) GetDetails() any {
	if o == nil {
		return nil
	}
	return o.Details
}

type CodeUnavailableLegal2 string

const (
	CodeUnavailableLegal2UnavailableLegal CodeUnavailableLegal2 = "unavailable-legal"
)

func (e CodeUnavailableLegal2) ToPointer() *CodeUnavailableLegal2 {
	return &e
}
func (e *CodeUnavailableLegal2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unavailable-legal":
		*e = CodeUnavailableLegal2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnavailableLegal2: %v", v)
	}
}

type ErrorUnavailableLegal2 struct {
	Code CodeUnavailableLegal2 `json:"code"`
}

func (e ErrorUnavailableLegal2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnavailableLegal2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnavailableLegal2) GetCode() CodeUnavailableLegal2 {
	if o == nil {
		return CodeUnavailableLegal2("")
	}
	return o.Code
}

type CodePriceChange2 string

const (
	CodePriceChange2PriceChange CodePriceChange2 = "price-change"
)

func (e CodePriceChange2) ToPointer() *CodePriceChange2 {
	return &e
}
func (e *CodePriceChange2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "price-change":
		*e = CodePriceChange2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodePriceChange2: %v", v)
	}
}

type ErrorPriceChange2 struct {
	Code CodePriceChange2 `json:"code"`
}

func (e ErrorPriceChange2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorPriceChange2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorPriceChange2) GetCode() CodePriceChange2 {
	if o == nil {
		return CodePriceChange2("")
	}
	return o.Code
}

type CodeCannotTransferInUntil2 string

const (
	CodeCannotTransferInUntil2CannotTransferInUntil CodeCannotTransferInUntil2 = "cannot-transfer-in-until"
)

func (e CodeCannotTransferInUntil2) ToPointer() *CodeCannotTransferInUntil2 {
	return &e
}
func (e *CodeCannotTransferInUntil2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cannot-transfer-in-until":
		*e = CodeCannotTransferInUntil2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeCannotTransferInUntil2: %v", v)
	}
}

type DomainDetails6 struct {
	NumDaysUntilTransferrable float64 `json:"numDaysUntilTransferrable"`
}

func (d DomainDetails6) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails6) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"numDaysUntilTransferrable"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails6) GetNumDaysUntilTransferrable() float64 {
	if o == nil {
		return 0.0
	}
	return o.NumDaysUntilTransferrable
}

type ErrorCannotTransferInUntil2 struct {
	Code    CodeCannotTransferInUntil2 `json:"code"`
	Details DomainDetails6             `json:"details"`
}

func (e ErrorCannotTransferInUntil2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorCannotTransferInUntil2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorCannotTransferInUntil2) GetCode() CodeCannotTransferInUntil2 {
	if o == nil {
		return CodeCannotTransferInUntil2("")
	}
	return o.Code
}

func (o *ErrorCannotTransferInUntil2) GetDetails() DomainDetails6 {
	if o == nil {
		return DomainDetails6{}
	}
	return o.Details
}

type CodeClaimsNoticeRequired2 string

const (
	CodeClaimsNoticeRequired2ClaimsNoticeRequired CodeClaimsNoticeRequired2 = "claims-notice-required"
)

func (e CodeClaimsNoticeRequired2) ToPointer() *CodeClaimsNoticeRequired2 {
	return &e
}
func (e *CodeClaimsNoticeRequired2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "claims-notice-required":
		*e = CodeClaimsNoticeRequired2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClaimsNoticeRequired2: %v", v)
	}
}

type ErrorClaimsNoticeRequired2 struct {
	Code CodeClaimsNoticeRequired2 `json:"code"`
}

func (e ErrorClaimsNoticeRequired2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClaimsNoticeRequired2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClaimsNoticeRequired2) GetCode() CodeClaimsNoticeRequired2 {
	if o == nil {
		return CodeClaimsNoticeRequired2("")
	}
	return o.Code
}

type CodeIncorrectAuthCode2 string

const (
	CodeIncorrectAuthCode2IncorrectAuthCode CodeIncorrectAuthCode2 = "incorrect-auth-code"
)

func (e CodeIncorrectAuthCode2) ToPointer() *CodeIncorrectAuthCode2 {
	return &e
}
func (e *CodeIncorrectAuthCode2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-auth-code":
		*e = CodeIncorrectAuthCode2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectAuthCode2: %v", v)
	}
}

type ErrorIncorrectAuthCode2 struct {
	Code CodeIncorrectAuthCode2 `json:"code"`
}

func (e ErrorIncorrectAuthCode2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectAuthCode2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectAuthCode2) GetCode() CodeIncorrectAuthCode2 {
	if o == nil {
		return CodeIncorrectAuthCode2("")
	}
	return o.Code
}

type CodeClientTransferProhibited2 string

const (
	CodeClientTransferProhibited2ClientTransferProhibited CodeClientTransferProhibited2 = "client-transfer-prohibited"
)

func (e CodeClientTransferProhibited2) ToPointer() *CodeClientTransferProhibited2 {
	return &e
}
func (e *CodeClientTransferProhibited2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client-transfer-prohibited":
		*e = CodeClientTransferProhibited2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClientTransferProhibited2: %v", v)
	}
}

type ErrorClientTransferProhibited2 struct {
	Code CodeClientTransferProhibited2 `json:"code"`
}

func (e ErrorClientTransferProhibited2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClientTransferProhibited2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClientTransferProhibited2) GetCode() CodeClientTransferProhibited2 {
	if o == nil {
		return CodeClientTransferProhibited2("")
	}
	return o.Code
}

type CodeIncorrectLanguageCode2 string

const (
	CodeIncorrectLanguageCode2IncorrectLanguageCode CodeIncorrectLanguageCode2 = "incorrect-language-code"
)

func (e CodeIncorrectLanguageCode2) ToPointer() *CodeIncorrectLanguageCode2 {
	return &e
}
func (e *CodeIncorrectLanguageCode2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-language-code":
		*e = CodeIncorrectLanguageCode2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectLanguageCode2: %v", v)
	}
}

type DomainDetails5 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails5) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorIncorrectLanguageCode2 struct {
	Code    CodeIncorrectLanguageCode2 `json:"code"`
	Details DomainDetails5             `json:"details"`
}

func (e ErrorIncorrectLanguageCode2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectLanguageCode2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectLanguageCode2) GetCode() CodeIncorrectLanguageCode2 {
	if o == nil {
		return CodeIncorrectLanguageCode2("")
	}
	return o.Code
}

func (o *ErrorIncorrectLanguageCode2) GetDetails() DomainDetails5 {
	if o == nil {
		return DomainDetails5{}
	}
	return o.Details
}

type CodeUnsupportedLanguageCode2 string

const (
	CodeUnsupportedLanguageCode2UnsupportedLanguageCode CodeUnsupportedLanguageCode2 = "unsupported-language-code"
)

func (e CodeUnsupportedLanguageCode2) ToPointer() *CodeUnsupportedLanguageCode2 {
	return &e
}
func (e *CodeUnsupportedLanguageCode2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unsupported-language-code":
		*e = CodeUnsupportedLanguageCode2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnsupportedLanguageCode2: %v", v)
	}
}

type DomainDetails4 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails4) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorUnsupportedLanguageCode2 struct {
	Code    CodeUnsupportedLanguageCode2 `json:"code"`
	Details DomainDetails4               `json:"details"`
}

func (e ErrorUnsupportedLanguageCode2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnsupportedLanguageCode2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnsupportedLanguageCode2) GetCode() CodeUnsupportedLanguageCode2 {
	if o == nil {
		return CodeUnsupportedLanguageCode2("")
	}
	return o.Code
}

func (o *ErrorUnsupportedLanguageCode2) GetDetails() DomainDetails4 {
	if o == nil {
		return DomainDetails4{}
	}
	return o.Details
}

type DomainErrorUnion3Type string

const (
	DomainErrorUnion3TypeUnsupportedLanguageCode  DomainErrorUnion3Type = "unsupported-language-code"
	DomainErrorUnion3TypeIncorrectLanguageCode    DomainErrorUnion3Type = "incorrect-language-code"
	DomainErrorUnion3TypeClientTransferProhibited DomainErrorUnion3Type = "client-transfer-prohibited"
	DomainErrorUnion3TypeIncorrectAuthCode        DomainErrorUnion3Type = "incorrect-auth-code"
	DomainErrorUnion3TypeClaimsNoticeRequired     DomainErrorUnion3Type = "claims-notice-required"
	DomainErrorUnion3TypeCannotTransferInUntil    DomainErrorUnion3Type = "cannot-transfer-in-until"
	DomainErrorUnion3TypePriceChange              DomainErrorUnion3Type = "price-change"
	DomainErrorUnion3TypeUnavailableLegal         DomainErrorUnion3Type = "unavailable-legal"
)

type DomainErrorUnion3 struct {
	ErrorUnsupportedLanguageCode2  *ErrorUnsupportedLanguageCode2  `queryParam:"inline"`
	ErrorIncorrectLanguageCode2    *ErrorIncorrectLanguageCode2    `queryParam:"inline"`
	ErrorClientTransferProhibited2 *ErrorClientTransferProhibited2 `queryParam:"inline"`
	ErrorIncorrectAuthCode2        *ErrorIncorrectAuthCode2        `queryParam:"inline"`
	ErrorClaimsNoticeRequired2     *ErrorClaimsNoticeRequired2     `queryParam:"inline"`
	ErrorCannotTransferInUntil2    *ErrorCannotTransferInUntil2    `queryParam:"inline"`
	ErrorPriceChange2              *ErrorPriceChange2              `queryParam:"inline"`
	ErrorUnavailableLegal2         *ErrorUnavailableLegal2         `queryParam:"inline"`

	Type DomainErrorUnion3Type
}

func CreateDomainErrorUnion3UnsupportedLanguageCode(unsupportedLanguageCode ErrorUnsupportedLanguageCode2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeUnsupportedLanguageCode

	typStr := CodeUnsupportedLanguageCode2(typ)
	unsupportedLanguageCode.Code = typStr

	return DomainErrorUnion3{
		ErrorUnsupportedLanguageCode2: &unsupportedLanguageCode,
		Type:                          typ,
	}
}

func CreateDomainErrorUnion3IncorrectLanguageCode(incorrectLanguageCode ErrorIncorrectLanguageCode2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeIncorrectLanguageCode

	typStr := CodeIncorrectLanguageCode2(typ)
	incorrectLanguageCode.Code = typStr

	return DomainErrorUnion3{
		ErrorIncorrectLanguageCode2: &incorrectLanguageCode,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion3ClientTransferProhibited(clientTransferProhibited ErrorClientTransferProhibited2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeClientTransferProhibited

	typStr := CodeClientTransferProhibited2(typ)
	clientTransferProhibited.Code = typStr

	return DomainErrorUnion3{
		ErrorClientTransferProhibited2: &clientTransferProhibited,
		Type:                           typ,
	}
}

func CreateDomainErrorUnion3IncorrectAuthCode(incorrectAuthCode ErrorIncorrectAuthCode2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeIncorrectAuthCode

	typStr := CodeIncorrectAuthCode2(typ)
	incorrectAuthCode.Code = typStr

	return DomainErrorUnion3{
		ErrorIncorrectAuthCode2: &incorrectAuthCode,
		Type:                    typ,
	}
}

func CreateDomainErrorUnion3ClaimsNoticeRequired(claimsNoticeRequired ErrorClaimsNoticeRequired2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeClaimsNoticeRequired

	typStr := CodeClaimsNoticeRequired2(typ)
	claimsNoticeRequired.Code = typStr

	return DomainErrorUnion3{
		ErrorClaimsNoticeRequired2: &claimsNoticeRequired,
		Type:                       typ,
	}
}

func CreateDomainErrorUnion3CannotTransferInUntil(cannotTransferInUntil ErrorCannotTransferInUntil2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeCannotTransferInUntil

	typStr := CodeCannotTransferInUntil2(typ)
	cannotTransferInUntil.Code = typStr

	return DomainErrorUnion3{
		ErrorCannotTransferInUntil2: &cannotTransferInUntil,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion3PriceChange(priceChange ErrorPriceChange2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypePriceChange

	typStr := CodePriceChange2(typ)
	priceChange.Code = typStr

	return DomainErrorUnion3{
		ErrorPriceChange2: &priceChange,
		Type:              typ,
	}
}

func CreateDomainErrorUnion3UnavailableLegal(unavailableLegal ErrorUnavailableLegal2) DomainErrorUnion3 {
	typ := DomainErrorUnion3TypeUnavailableLegal

	typStr := CodeUnavailableLegal2(typ)
	unavailableLegal.Code = typStr

	return DomainErrorUnion3{
		ErrorUnavailableLegal2: &unavailableLegal,
		Type:                   typ,
	}
}

func (u *DomainErrorUnion3) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Code string `json:"code"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Code {
	case "unsupported-language-code":
		errorUnsupportedLanguageCode2 := new(ErrorUnsupportedLanguageCode2)
		if err := utils.UnmarshalJSON(data, &errorUnsupportedLanguageCode2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unsupported-language-code) type ErrorUnsupportedLanguageCode2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorUnsupportedLanguageCode2 = errorUnsupportedLanguageCode2
		u.Type = DomainErrorUnion3TypeUnsupportedLanguageCode
		return nil
	case "incorrect-language-code":
		errorIncorrectLanguageCode2 := new(ErrorIncorrectLanguageCode2)
		if err := utils.UnmarshalJSON(data, &errorIncorrectLanguageCode2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-language-code) type ErrorIncorrectLanguageCode2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorIncorrectLanguageCode2 = errorIncorrectLanguageCode2
		u.Type = DomainErrorUnion3TypeIncorrectLanguageCode
		return nil
	case "client-transfer-prohibited":
		errorClientTransferProhibited2 := new(ErrorClientTransferProhibited2)
		if err := utils.UnmarshalJSON(data, &errorClientTransferProhibited2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == client-transfer-prohibited) type ErrorClientTransferProhibited2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorClientTransferProhibited2 = errorClientTransferProhibited2
		u.Type = DomainErrorUnion3TypeClientTransferProhibited
		return nil
	case "incorrect-auth-code":
		errorIncorrectAuthCode2 := new(ErrorIncorrectAuthCode2)
		if err := utils.UnmarshalJSON(data, &errorIncorrectAuthCode2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-auth-code) type ErrorIncorrectAuthCode2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorIncorrectAuthCode2 = errorIncorrectAuthCode2
		u.Type = DomainErrorUnion3TypeIncorrectAuthCode
		return nil
	case "claims-notice-required":
		errorClaimsNoticeRequired2 := new(ErrorClaimsNoticeRequired2)
		if err := utils.UnmarshalJSON(data, &errorClaimsNoticeRequired2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == claims-notice-required) type ErrorClaimsNoticeRequired2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorClaimsNoticeRequired2 = errorClaimsNoticeRequired2
		u.Type = DomainErrorUnion3TypeClaimsNoticeRequired
		return nil
	case "cannot-transfer-in-until":
		errorCannotTransferInUntil2 := new(ErrorCannotTransferInUntil2)
		if err := utils.UnmarshalJSON(data, &errorCannotTransferInUntil2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == cannot-transfer-in-until) type ErrorCannotTransferInUntil2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorCannotTransferInUntil2 = errorCannotTransferInUntil2
		u.Type = DomainErrorUnion3TypeCannotTransferInUntil
		return nil
	case "price-change":
		errorPriceChange2 := new(ErrorPriceChange2)
		if err := utils.UnmarshalJSON(data, &errorPriceChange2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == price-change) type ErrorPriceChange2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorPriceChange2 = errorPriceChange2
		u.Type = DomainErrorUnion3TypePriceChange
		return nil
	case "unavailable-legal":
		errorUnavailableLegal2 := new(ErrorUnavailableLegal2)
		if err := utils.UnmarshalJSON(data, &errorUnavailableLegal2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unavailable-legal) type ErrorUnavailableLegal2 within DomainErrorUnion3: %w", string(data), err)
		}

		u.ErrorUnavailableLegal2 = errorUnavailableLegal2
		u.Type = DomainErrorUnion3TypeUnavailableLegal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion3", string(data))
}

func (u DomainErrorUnion3) MarshalJSON() ([]byte, error) {
	if u.ErrorUnsupportedLanguageCode2 != nil {
		return utils.MarshalJSON(u.ErrorUnsupportedLanguageCode2, "", true)
	}

	if u.ErrorIncorrectLanguageCode2 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectLanguageCode2, "", true)
	}

	if u.ErrorClientTransferProhibited2 != nil {
		return utils.MarshalJSON(u.ErrorClientTransferProhibited2, "", true)
	}

	if u.ErrorIncorrectAuthCode2 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectAuthCode2, "", true)
	}

	if u.ErrorClaimsNoticeRequired2 != nil {
		return utils.MarshalJSON(u.ErrorClaimsNoticeRequired2, "", true)
	}

	if u.ErrorCannotTransferInUntil2 != nil {
		return utils.MarshalJSON(u.ErrorCannotTransferInUntil2, "", true)
	}

	if u.ErrorPriceChange2 != nil {
		return utils.MarshalJSON(u.ErrorPriceChange2, "", true)
	}

	if u.ErrorUnavailableLegal2 != nil {
		return utils.MarshalJSON(u.ErrorUnavailableLegal2, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion3: all fields are null")
}

type DomainErrorUnion4Type string

const (
	DomainErrorUnion4TypeDomainErrorUnion3 DomainErrorUnion4Type = "domain_error_union_3"
	DomainErrorUnion4TypeDomainError2      DomainErrorUnion4Type = "domain_error_2"
)

type DomainErrorUnion4 struct {
	DomainErrorUnion3 *DomainErrorUnion3 `queryParam:"inline"`
	DomainError2      *DomainError2      `queryParam:"inline"`

	Type DomainErrorUnion4Type
}

func CreateDomainErrorUnion4DomainErrorUnion3(domainErrorUnion3 DomainErrorUnion3) DomainErrorUnion4 {
	typ := DomainErrorUnion4TypeDomainErrorUnion3

	return DomainErrorUnion4{
		DomainErrorUnion3: &domainErrorUnion3,
		Type:              typ,
	}
}

func CreateDomainErrorUnion4DomainError2(domainError2 DomainError2) DomainErrorUnion4 {
	typ := DomainErrorUnion4TypeDomainError2

	return DomainErrorUnion4{
		DomainError2: &domainError2,
		Type:         typ,
	}
}

func (u *DomainErrorUnion4) UnmarshalJSON(data []byte) error {

	var domainError2 DomainError2 = DomainError2{}
	if err := utils.UnmarshalJSON(data, &domainError2, "", true, nil); err == nil {
		u.DomainError2 = &domainError2
		u.Type = DomainErrorUnion4TypeDomainError2
		return nil
	}

	var domainErrorUnion3 DomainErrorUnion3 = DomainErrorUnion3{}
	if err := utils.UnmarshalJSON(data, &domainErrorUnion3, "", true, nil); err == nil {
		u.DomainErrorUnion3 = &domainErrorUnion3
		u.Type = DomainErrorUnion4TypeDomainErrorUnion3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion4", string(data))
}

func (u DomainErrorUnion4) MarshalJSON() ([]byte, error) {
	if u.DomainErrorUnion3 != nil {
		return utils.MarshalJSON(u.DomainErrorUnion3, "", true)
	}

	if u.DomainError2 != nil {
		return utils.MarshalJSON(u.DomainError2, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion4: all fields are null")
}

type DomainRenewal struct {
	PurchaseType PurchaseTypeRenewal `json:"purchaseType"`
	// The number of years the domain is being renewed for.
	Years float64 `json:"years"`
	// A valid domain name
	DomainName string             `json:"domainName"`
	Status     DomainStatus2      `json:"status"`
	Price      float64            `json:"price"`
	Error      *DomainErrorUnion4 `json:"error,omitempty"`
}

func (d DomainRenewal) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainRenewal) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"purchaseType", "years", "domainName", "status", "price"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainRenewal) GetPurchaseType() PurchaseTypeRenewal {
	if o == nil {
		return PurchaseTypeRenewal("")
	}
	return o.PurchaseType
}

func (o *DomainRenewal) GetYears() float64 {
	if o == nil {
		return 0.0
	}
	return o.Years
}

func (o *DomainRenewal) GetDomainName() string {
	if o == nil {
		return ""
	}
	return o.DomainName
}

func (o *DomainRenewal) GetStatus() DomainStatus2 {
	if o == nil {
		return DomainStatus2("")
	}
	return o.Status
}

func (o *DomainRenewal) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

func (o *DomainRenewal) GetError() *DomainErrorUnion4 {
	if o == nil {
		return nil
	}
	return o.Error
}

type PurchaseTypePurchase string

const (
	PurchaseTypePurchasePurchase PurchaseTypePurchase = "purchase"
)

func (e PurchaseTypePurchase) ToPointer() *PurchaseTypePurchase {
	return &e
}
func (e *PurchaseTypePurchase) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "purchase":
		*e = PurchaseTypePurchase(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PurchaseTypePurchase: %v", v)
	}
}

type DomainStatus1 string

const (
	DomainStatus1Pending      DomainStatus1 = "pending"
	DomainStatus1Completed    DomainStatus1 = "completed"
	DomainStatus1Failed       DomainStatus1 = "failed"
	DomainStatus1Refunded     DomainStatus1 = "refunded"
	DomainStatus1RefundFailed DomainStatus1 = "refund-failed"
)

func (e DomainStatus1) ToPointer() *DomainStatus1 {
	return &e
}
func (e *DomainStatus1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "pending":
		fallthrough
	case "completed":
		fallthrough
	case "failed":
		fallthrough
	case "refunded":
		fallthrough
	case "refund-failed":
		*e = DomainStatus1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for DomainStatus1: %v", v)
	}
}

type DomainError1 struct {
	Code    string `json:"code"`
	Details any    `json:"details,omitempty"`
}

func (d DomainError1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainError1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainError1) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *DomainError1) GetDetails() any {
	if o == nil {
		return nil
	}
	return o.Details
}

type CodeUnavailableLegal1 string

const (
	CodeUnavailableLegal1UnavailableLegal CodeUnavailableLegal1 = "unavailable-legal"
)

func (e CodeUnavailableLegal1) ToPointer() *CodeUnavailableLegal1 {
	return &e
}
func (e *CodeUnavailableLegal1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unavailable-legal":
		*e = CodeUnavailableLegal1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnavailableLegal1: %v", v)
	}
}

type ErrorUnavailableLegal1 struct {
	Code CodeUnavailableLegal1 `json:"code"`
}

func (e ErrorUnavailableLegal1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnavailableLegal1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnavailableLegal1) GetCode() CodeUnavailableLegal1 {
	if o == nil {
		return CodeUnavailableLegal1("")
	}
	return o.Code
}

type CodePriceChange1 string

const (
	CodePriceChange1PriceChange CodePriceChange1 = "price-change"
)

func (e CodePriceChange1) ToPointer() *CodePriceChange1 {
	return &e
}
func (e *CodePriceChange1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "price-change":
		*e = CodePriceChange1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodePriceChange1: %v", v)
	}
}

type ErrorPriceChange1 struct {
	Code CodePriceChange1 `json:"code"`
}

func (e ErrorPriceChange1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorPriceChange1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorPriceChange1) GetCode() CodePriceChange1 {
	if o == nil {
		return CodePriceChange1("")
	}
	return o.Code
}

type CodeCannotTransferInUntil1 string

const (
	CodeCannotTransferInUntil1CannotTransferInUntil CodeCannotTransferInUntil1 = "cannot-transfer-in-until"
)

func (e CodeCannotTransferInUntil1) ToPointer() *CodeCannotTransferInUntil1 {
	return &e
}
func (e *CodeCannotTransferInUntil1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "cannot-transfer-in-until":
		*e = CodeCannotTransferInUntil1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeCannotTransferInUntil1: %v", v)
	}
}

type DomainDetails3 struct {
	NumDaysUntilTransferrable float64 `json:"numDaysUntilTransferrable"`
}

func (d DomainDetails3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"numDaysUntilTransferrable"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails3) GetNumDaysUntilTransferrable() float64 {
	if o == nil {
		return 0.0
	}
	return o.NumDaysUntilTransferrable
}

type ErrorCannotTransferInUntil1 struct {
	Code    CodeCannotTransferInUntil1 `json:"code"`
	Details DomainDetails3             `json:"details"`
}

func (e ErrorCannotTransferInUntil1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorCannotTransferInUntil1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorCannotTransferInUntil1) GetCode() CodeCannotTransferInUntil1 {
	if o == nil {
		return CodeCannotTransferInUntil1("")
	}
	return o.Code
}

func (o *ErrorCannotTransferInUntil1) GetDetails() DomainDetails3 {
	if o == nil {
		return DomainDetails3{}
	}
	return o.Details
}

type CodeClaimsNoticeRequired1 string

const (
	CodeClaimsNoticeRequired1ClaimsNoticeRequired CodeClaimsNoticeRequired1 = "claims-notice-required"
)

func (e CodeClaimsNoticeRequired1) ToPointer() *CodeClaimsNoticeRequired1 {
	return &e
}
func (e *CodeClaimsNoticeRequired1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "claims-notice-required":
		*e = CodeClaimsNoticeRequired1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClaimsNoticeRequired1: %v", v)
	}
}

type ErrorClaimsNoticeRequired1 struct {
	Code CodeClaimsNoticeRequired1 `json:"code"`
}

func (e ErrorClaimsNoticeRequired1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClaimsNoticeRequired1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClaimsNoticeRequired1) GetCode() CodeClaimsNoticeRequired1 {
	if o == nil {
		return CodeClaimsNoticeRequired1("")
	}
	return o.Code
}

type CodeIncorrectAuthCode1 string

const (
	CodeIncorrectAuthCode1IncorrectAuthCode CodeIncorrectAuthCode1 = "incorrect-auth-code"
)

func (e CodeIncorrectAuthCode1) ToPointer() *CodeIncorrectAuthCode1 {
	return &e
}
func (e *CodeIncorrectAuthCode1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-auth-code":
		*e = CodeIncorrectAuthCode1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectAuthCode1: %v", v)
	}
}

type ErrorIncorrectAuthCode1 struct {
	Code CodeIncorrectAuthCode1 `json:"code"`
}

func (e ErrorIncorrectAuthCode1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectAuthCode1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectAuthCode1) GetCode() CodeIncorrectAuthCode1 {
	if o == nil {
		return CodeIncorrectAuthCode1("")
	}
	return o.Code
}

type CodeClientTransferProhibited1 string

const (
	CodeClientTransferProhibited1ClientTransferProhibited CodeClientTransferProhibited1 = "client-transfer-prohibited"
)

func (e CodeClientTransferProhibited1) ToPointer() *CodeClientTransferProhibited1 {
	return &e
}
func (e *CodeClientTransferProhibited1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "client-transfer-prohibited":
		*e = CodeClientTransferProhibited1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClientTransferProhibited1: %v", v)
	}
}

type ErrorClientTransferProhibited1 struct {
	Code CodeClientTransferProhibited1 `json:"code"`
}

func (e ErrorClientTransferProhibited1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClientTransferProhibited1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClientTransferProhibited1) GetCode() CodeClientTransferProhibited1 {
	if o == nil {
		return CodeClientTransferProhibited1("")
	}
	return o.Code
}

type CodeIncorrectLanguageCode1 string

const (
	CodeIncorrectLanguageCode1IncorrectLanguageCode CodeIncorrectLanguageCode1 = "incorrect-language-code"
)

func (e CodeIncorrectLanguageCode1) ToPointer() *CodeIncorrectLanguageCode1 {
	return &e
}
func (e *CodeIncorrectLanguageCode1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "incorrect-language-code":
		*e = CodeIncorrectLanguageCode1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeIncorrectLanguageCode1: %v", v)
	}
}

type DomainDetails2 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails2) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorIncorrectLanguageCode1 struct {
	Code    CodeIncorrectLanguageCode1 `json:"code"`
	Details DomainDetails2             `json:"details"`
}

func (e ErrorIncorrectLanguageCode1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorIncorrectLanguageCode1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorIncorrectLanguageCode1) GetCode() CodeIncorrectLanguageCode1 {
	if o == nil {
		return CodeIncorrectLanguageCode1("")
	}
	return o.Code
}

func (o *ErrorIncorrectLanguageCode1) GetDetails() DomainDetails2 {
	if o == nil {
		return DomainDetails2{}
	}
	return o.Details
}

type CodeUnsupportedLanguageCode1 string

const (
	CodeUnsupportedLanguageCode1UnsupportedLanguageCode CodeUnsupportedLanguageCode1 = "unsupported-language-code"
)

func (e CodeUnsupportedLanguageCode1) ToPointer() *CodeUnsupportedLanguageCode1 {
	return &e
}
func (e *CodeUnsupportedLanguageCode1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unsupported-language-code":
		*e = CodeUnsupportedLanguageCode1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnsupportedLanguageCode1: %v", v)
	}
}

type DomainDetails1 struct {
	DetectedLanguageCode string `json:"detectedLanguageCode"`
}

func (d DomainDetails1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainDetails1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"detectedLanguageCode"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainDetails1) GetDetectedLanguageCode() string {
	if o == nil {
		return ""
	}
	return o.DetectedLanguageCode
}

type ErrorUnsupportedLanguageCode1 struct {
	Code    CodeUnsupportedLanguageCode1 `json:"code"`
	Details DomainDetails1               `json:"details"`
}

func (e ErrorUnsupportedLanguageCode1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnsupportedLanguageCode1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnsupportedLanguageCode1) GetCode() CodeUnsupportedLanguageCode1 {
	if o == nil {
		return CodeUnsupportedLanguageCode1("")
	}
	return o.Code
}

func (o *ErrorUnsupportedLanguageCode1) GetDetails() DomainDetails1 {
	if o == nil {
		return DomainDetails1{}
	}
	return o.Details
}

type DomainErrorUnion1Type string

const (
	DomainErrorUnion1TypeUnsupportedLanguageCode  DomainErrorUnion1Type = "unsupported-language-code"
	DomainErrorUnion1TypeIncorrectLanguageCode    DomainErrorUnion1Type = "incorrect-language-code"
	DomainErrorUnion1TypeClientTransferProhibited DomainErrorUnion1Type = "client-transfer-prohibited"
	DomainErrorUnion1TypeIncorrectAuthCode        DomainErrorUnion1Type = "incorrect-auth-code"
	DomainErrorUnion1TypeClaimsNoticeRequired     DomainErrorUnion1Type = "claims-notice-required"
	DomainErrorUnion1TypeCannotTransferInUntil    DomainErrorUnion1Type = "cannot-transfer-in-until"
	DomainErrorUnion1TypePriceChange              DomainErrorUnion1Type = "price-change"
	DomainErrorUnion1TypeUnavailableLegal         DomainErrorUnion1Type = "unavailable-legal"
)

type DomainErrorUnion1 struct {
	ErrorUnsupportedLanguageCode1  *ErrorUnsupportedLanguageCode1  `queryParam:"inline"`
	ErrorIncorrectLanguageCode1    *ErrorIncorrectLanguageCode1    `queryParam:"inline"`
	ErrorClientTransferProhibited1 *ErrorClientTransferProhibited1 `queryParam:"inline"`
	ErrorIncorrectAuthCode1        *ErrorIncorrectAuthCode1        `queryParam:"inline"`
	ErrorClaimsNoticeRequired1     *ErrorClaimsNoticeRequired1     `queryParam:"inline"`
	ErrorCannotTransferInUntil1    *ErrorCannotTransferInUntil1    `queryParam:"inline"`
	ErrorPriceChange1              *ErrorPriceChange1              `queryParam:"inline"`
	ErrorUnavailableLegal1         *ErrorUnavailableLegal1         `queryParam:"inline"`

	Type DomainErrorUnion1Type
}

func CreateDomainErrorUnion1UnsupportedLanguageCode(unsupportedLanguageCode ErrorUnsupportedLanguageCode1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeUnsupportedLanguageCode

	typStr := CodeUnsupportedLanguageCode1(typ)
	unsupportedLanguageCode.Code = typStr

	return DomainErrorUnion1{
		ErrorUnsupportedLanguageCode1: &unsupportedLanguageCode,
		Type:                          typ,
	}
}

func CreateDomainErrorUnion1IncorrectLanguageCode(incorrectLanguageCode ErrorIncorrectLanguageCode1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeIncorrectLanguageCode

	typStr := CodeIncorrectLanguageCode1(typ)
	incorrectLanguageCode.Code = typStr

	return DomainErrorUnion1{
		ErrorIncorrectLanguageCode1: &incorrectLanguageCode,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion1ClientTransferProhibited(clientTransferProhibited ErrorClientTransferProhibited1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeClientTransferProhibited

	typStr := CodeClientTransferProhibited1(typ)
	clientTransferProhibited.Code = typStr

	return DomainErrorUnion1{
		ErrorClientTransferProhibited1: &clientTransferProhibited,
		Type:                           typ,
	}
}

func CreateDomainErrorUnion1IncorrectAuthCode(incorrectAuthCode ErrorIncorrectAuthCode1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeIncorrectAuthCode

	typStr := CodeIncorrectAuthCode1(typ)
	incorrectAuthCode.Code = typStr

	return DomainErrorUnion1{
		ErrorIncorrectAuthCode1: &incorrectAuthCode,
		Type:                    typ,
	}
}

func CreateDomainErrorUnion1ClaimsNoticeRequired(claimsNoticeRequired ErrorClaimsNoticeRequired1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeClaimsNoticeRequired

	typStr := CodeClaimsNoticeRequired1(typ)
	claimsNoticeRequired.Code = typStr

	return DomainErrorUnion1{
		ErrorClaimsNoticeRequired1: &claimsNoticeRequired,
		Type:                       typ,
	}
}

func CreateDomainErrorUnion1CannotTransferInUntil(cannotTransferInUntil ErrorCannotTransferInUntil1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeCannotTransferInUntil

	typStr := CodeCannotTransferInUntil1(typ)
	cannotTransferInUntil.Code = typStr

	return DomainErrorUnion1{
		ErrorCannotTransferInUntil1: &cannotTransferInUntil,
		Type:                        typ,
	}
}

func CreateDomainErrorUnion1PriceChange(priceChange ErrorPriceChange1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypePriceChange

	typStr := CodePriceChange1(typ)
	priceChange.Code = typStr

	return DomainErrorUnion1{
		ErrorPriceChange1: &priceChange,
		Type:              typ,
	}
}

func CreateDomainErrorUnion1UnavailableLegal(unavailableLegal ErrorUnavailableLegal1) DomainErrorUnion1 {
	typ := DomainErrorUnion1TypeUnavailableLegal

	typStr := CodeUnavailableLegal1(typ)
	unavailableLegal.Code = typStr

	return DomainErrorUnion1{
		ErrorUnavailableLegal1: &unavailableLegal,
		Type:                   typ,
	}
}

func (u *DomainErrorUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Code string `json:"code"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Code {
	case "unsupported-language-code":
		errorUnsupportedLanguageCode1 := new(ErrorUnsupportedLanguageCode1)
		if err := utils.UnmarshalJSON(data, &errorUnsupportedLanguageCode1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unsupported-language-code) type ErrorUnsupportedLanguageCode1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorUnsupportedLanguageCode1 = errorUnsupportedLanguageCode1
		u.Type = DomainErrorUnion1TypeUnsupportedLanguageCode
		return nil
	case "incorrect-language-code":
		errorIncorrectLanguageCode1 := new(ErrorIncorrectLanguageCode1)
		if err := utils.UnmarshalJSON(data, &errorIncorrectLanguageCode1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-language-code) type ErrorIncorrectLanguageCode1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorIncorrectLanguageCode1 = errorIncorrectLanguageCode1
		u.Type = DomainErrorUnion1TypeIncorrectLanguageCode
		return nil
	case "client-transfer-prohibited":
		errorClientTransferProhibited1 := new(ErrorClientTransferProhibited1)
		if err := utils.UnmarshalJSON(data, &errorClientTransferProhibited1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == client-transfer-prohibited) type ErrorClientTransferProhibited1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorClientTransferProhibited1 = errorClientTransferProhibited1
		u.Type = DomainErrorUnion1TypeClientTransferProhibited
		return nil
	case "incorrect-auth-code":
		errorIncorrectAuthCode1 := new(ErrorIncorrectAuthCode1)
		if err := utils.UnmarshalJSON(data, &errorIncorrectAuthCode1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == incorrect-auth-code) type ErrorIncorrectAuthCode1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorIncorrectAuthCode1 = errorIncorrectAuthCode1
		u.Type = DomainErrorUnion1TypeIncorrectAuthCode
		return nil
	case "claims-notice-required":
		errorClaimsNoticeRequired1 := new(ErrorClaimsNoticeRequired1)
		if err := utils.UnmarshalJSON(data, &errorClaimsNoticeRequired1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == claims-notice-required) type ErrorClaimsNoticeRequired1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorClaimsNoticeRequired1 = errorClaimsNoticeRequired1
		u.Type = DomainErrorUnion1TypeClaimsNoticeRequired
		return nil
	case "cannot-transfer-in-until":
		errorCannotTransferInUntil1 := new(ErrorCannotTransferInUntil1)
		if err := utils.UnmarshalJSON(data, &errorCannotTransferInUntil1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == cannot-transfer-in-until) type ErrorCannotTransferInUntil1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorCannotTransferInUntil1 = errorCannotTransferInUntil1
		u.Type = DomainErrorUnion1TypeCannotTransferInUntil
		return nil
	case "price-change":
		errorPriceChange1 := new(ErrorPriceChange1)
		if err := utils.UnmarshalJSON(data, &errorPriceChange1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == price-change) type ErrorPriceChange1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorPriceChange1 = errorPriceChange1
		u.Type = DomainErrorUnion1TypePriceChange
		return nil
	case "unavailable-legal":
		errorUnavailableLegal1 := new(ErrorUnavailableLegal1)
		if err := utils.UnmarshalJSON(data, &errorUnavailableLegal1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unavailable-legal) type ErrorUnavailableLegal1 within DomainErrorUnion1: %w", string(data), err)
		}

		u.ErrorUnavailableLegal1 = errorUnavailableLegal1
		u.Type = DomainErrorUnion1TypeUnavailableLegal
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion1", string(data))
}

func (u DomainErrorUnion1) MarshalJSON() ([]byte, error) {
	if u.ErrorUnsupportedLanguageCode1 != nil {
		return utils.MarshalJSON(u.ErrorUnsupportedLanguageCode1, "", true)
	}

	if u.ErrorIncorrectLanguageCode1 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectLanguageCode1, "", true)
	}

	if u.ErrorClientTransferProhibited1 != nil {
		return utils.MarshalJSON(u.ErrorClientTransferProhibited1, "", true)
	}

	if u.ErrorIncorrectAuthCode1 != nil {
		return utils.MarshalJSON(u.ErrorIncorrectAuthCode1, "", true)
	}

	if u.ErrorClaimsNoticeRequired1 != nil {
		return utils.MarshalJSON(u.ErrorClaimsNoticeRequired1, "", true)
	}

	if u.ErrorCannotTransferInUntil1 != nil {
		return utils.MarshalJSON(u.ErrorCannotTransferInUntil1, "", true)
	}

	if u.ErrorPriceChange1 != nil {
		return utils.MarshalJSON(u.ErrorPriceChange1, "", true)
	}

	if u.ErrorUnavailableLegal1 != nil {
		return utils.MarshalJSON(u.ErrorUnavailableLegal1, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion1: all fields are null")
}

type DomainErrorUnion2Type string

const (
	DomainErrorUnion2TypeDomainErrorUnion1 DomainErrorUnion2Type = "domain_error_union_1"
	DomainErrorUnion2TypeDomainError1      DomainErrorUnion2Type = "domain_error_1"
)

type DomainErrorUnion2 struct {
	DomainErrorUnion1 *DomainErrorUnion1 `queryParam:"inline"`
	DomainError1      *DomainError1      `queryParam:"inline"`

	Type DomainErrorUnion2Type
}

func CreateDomainErrorUnion2DomainErrorUnion1(domainErrorUnion1 DomainErrorUnion1) DomainErrorUnion2 {
	typ := DomainErrorUnion2TypeDomainErrorUnion1

	return DomainErrorUnion2{
		DomainErrorUnion1: &domainErrorUnion1,
		Type:              typ,
	}
}

func CreateDomainErrorUnion2DomainError1(domainError1 DomainError1) DomainErrorUnion2 {
	typ := DomainErrorUnion2TypeDomainError1

	return DomainErrorUnion2{
		DomainError1: &domainError1,
		Type:         typ,
	}
}

func (u *DomainErrorUnion2) UnmarshalJSON(data []byte) error {

	var domainError1 DomainError1 = DomainError1{}
	if err := utils.UnmarshalJSON(data, &domainError1, "", true, nil); err == nil {
		u.DomainError1 = &domainError1
		u.Type = DomainErrorUnion2TypeDomainError1
		return nil
	}

	var domainErrorUnion1 DomainErrorUnion1 = DomainErrorUnion1{}
	if err := utils.UnmarshalJSON(data, &domainErrorUnion1, "", true, nil); err == nil {
		u.DomainErrorUnion1 = &domainErrorUnion1
		u.Type = DomainErrorUnion2TypeDomainErrorUnion1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DomainErrorUnion2", string(data))
}

func (u DomainErrorUnion2) MarshalJSON() ([]byte, error) {
	if u.DomainErrorUnion1 != nil {
		return utils.MarshalJSON(u.DomainErrorUnion1, "", true)
	}

	if u.DomainError1 != nil {
		return utils.MarshalJSON(u.DomainError1, "", true)
	}

	return nil, errors.New("could not marshal union type DomainErrorUnion2: all fields are null")
}

type DomainPurchase struct {
	PurchaseType PurchaseTypePurchase `json:"purchaseType"`
	AutoRenew    bool                 `json:"autoRenew"`
	// The number of years the domain is being purchased for.
	Years float64 `json:"years"`
	// A valid domain name
	DomainName string             `json:"domainName"`
	Status     DomainStatus1      `json:"status"`
	Price      float64            `json:"price"`
	Error      *DomainErrorUnion2 `json:"error,omitempty"`
}

func (d DomainPurchase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DomainPurchase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"purchaseType", "autoRenew", "years", "domainName", "status", "price"}); err != nil {
		return err
	}
	return nil
}

func (o *DomainPurchase) GetPurchaseType() PurchaseTypePurchase {
	if o == nil {
		return PurchaseTypePurchase("")
	}
	return o.PurchaseType
}

func (o *DomainPurchase) GetAutoRenew() bool {
	if o == nil {
		return false
	}
	return o.AutoRenew
}

func (o *DomainPurchase) GetYears() float64 {
	if o == nil {
		return 0.0
	}
	return o.Years
}

func (o *DomainPurchase) GetDomainName() string {
	if o == nil {
		return ""
	}
	return o.DomainName
}

func (o *DomainPurchase) GetStatus() DomainStatus1 {
	if o == nil {
		return DomainStatus1("")
	}
	return o.Status
}

func (o *DomainPurchase) GetPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.Price
}

func (o *DomainPurchase) GetError() *DomainErrorUnion2 {
	if o == nil {
		return nil
	}
	return o.Error
}

type GetOrderDomainUnionType string

const (
	GetOrderDomainUnionTypePurchase GetOrderDomainUnionType = "purchase"
	GetOrderDomainUnionTypeRenewal  GetOrderDomainUnionType = "renewal"
	GetOrderDomainUnionTypeTransfer GetOrderDomainUnionType = "transfer"
)

type GetOrderDomainUnion struct {
	DomainPurchase *DomainPurchase `queryParam:"inline"`
	DomainRenewal  *DomainRenewal  `queryParam:"inline"`
	DomainTransfer *DomainTransfer `queryParam:"inline"`

	Type GetOrderDomainUnionType
}

func CreateGetOrderDomainUnionPurchase(purchase DomainPurchase) GetOrderDomainUnion {
	typ := GetOrderDomainUnionTypePurchase

	typStr := PurchaseTypePurchase(typ)
	purchase.PurchaseType = typStr

	return GetOrderDomainUnion{
		DomainPurchase: &purchase,
		Type:           typ,
	}
}

func CreateGetOrderDomainUnionRenewal(renewal DomainRenewal) GetOrderDomainUnion {
	typ := GetOrderDomainUnionTypeRenewal

	typStr := PurchaseTypeRenewal(typ)
	renewal.PurchaseType = typStr

	return GetOrderDomainUnion{
		DomainRenewal: &renewal,
		Type:          typ,
	}
}

func CreateGetOrderDomainUnionTransfer(transfer DomainTransfer) GetOrderDomainUnion {
	typ := GetOrderDomainUnionTypeTransfer

	typStr := PurchaseTypeTransfer(typ)
	transfer.PurchaseType = typStr

	return GetOrderDomainUnion{
		DomainTransfer: &transfer,
		Type:           typ,
	}
}

func (u *GetOrderDomainUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		PurchaseType string `json:"purchaseType"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.PurchaseType {
	case "purchase":
		domainPurchase := new(DomainPurchase)
		if err := utils.UnmarshalJSON(data, &domainPurchase, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (PurchaseType == purchase) type DomainPurchase within GetOrderDomainUnion: %w", string(data), err)
		}

		u.DomainPurchase = domainPurchase
		u.Type = GetOrderDomainUnionTypePurchase
		return nil
	case "renewal":
		domainRenewal := new(DomainRenewal)
		if err := utils.UnmarshalJSON(data, &domainRenewal, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (PurchaseType == renewal) type DomainRenewal within GetOrderDomainUnion: %w", string(data), err)
		}

		u.DomainRenewal = domainRenewal
		u.Type = GetOrderDomainUnionTypeRenewal
		return nil
	case "transfer":
		domainTransfer := new(DomainTransfer)
		if err := utils.UnmarshalJSON(data, &domainTransfer, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (PurchaseType == transfer) type DomainTransfer within GetOrderDomainUnion: %w", string(data), err)
		}

		u.DomainTransfer = domainTransfer
		u.Type = GetOrderDomainUnionTypeTransfer
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetOrderDomainUnion", string(data))
}

func (u GetOrderDomainUnion) MarshalJSON() ([]byte, error) {
	if u.DomainPurchase != nil {
		return utils.MarshalJSON(u.DomainPurchase, "", true)
	}

	if u.DomainRenewal != nil {
		return utils.MarshalJSON(u.DomainRenewal, "", true)
	}

	if u.DomainTransfer != nil {
		return utils.MarshalJSON(u.DomainTransfer, "", true)
	}

	return nil, errors.New("could not marshal union type GetOrderDomainUnion: all fields are null")
}

type GetOrderStatus string

const (
	GetOrderStatusDraft      GetOrderStatus = "draft"
	GetOrderStatusPurchasing GetOrderStatus = "purchasing"
	GetOrderStatusCompleted  GetOrderStatus = "completed"
	GetOrderStatusFailed     GetOrderStatus = "failed"
)

func (e GetOrderStatus) ToPointer() *GetOrderStatus {
	return &e
}
func (e *GetOrderStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "draft":
		fallthrough
	case "purchasing":
		fallthrough
	case "completed":
		fallthrough
	case "failed":
		*e = GetOrderStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetOrderStatus: %v", v)
	}
}

type GetOrderError struct {
	Code    string `json:"code"`
	Details any    `json:"details,omitempty"`
}

func (g GetOrderError) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetOrderError) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *GetOrderError) GetCode() string {
	if o == nil {
		return ""
	}
	return o.Code
}

func (o *GetOrderError) GetDetails() any {
	if o == nil {
		return nil
	}
	return o.Details
}

type CodeDomainMismatch string

const (
	CodeDomainMismatchDomainMismatch CodeDomainMismatch = "domain-mismatch"
)

func (e CodeDomainMismatch) ToPointer() *CodeDomainMismatch {
	return &e
}
func (e *CodeDomainMismatch) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "domain-mismatch":
		*e = CodeDomainMismatch(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeDomainMismatch: %v", v)
	}
}

type ErrorDomainMismatch struct {
	Code CodeDomainMismatch `json:"code"`
}

func (e ErrorDomainMismatch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorDomainMismatch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorDomainMismatch) GetCode() CodeDomainMismatch {
	if o == nil {
		return CodeDomainMismatch("")
	}
	return o.Code
}

type CodeClaimsRequired string

const (
	CodeClaimsRequiredClaimsRequired CodeClaimsRequired = "claims-required"
)

func (e CodeClaimsRequired) ToPointer() *CodeClaimsRequired {
	return &e
}
func (e *CodeClaimsRequired) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "claims-required":
		*e = CodeClaimsRequired(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeClaimsRequired: %v", v)
	}
}

type Details3 struct {
	Message     string   `json:"message"`
	DomainNames []string `json:"domainNames"`
}

func (d Details3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"message", "domainNames"}); err != nil {
		return err
	}
	return nil
}

func (o *Details3) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

func (o *Details3) GetDomainNames() []string {
	if o == nil {
		return []string{}
	}
	return o.DomainNames
}

type ErrorClaimsRequired struct {
	Code    CodeClaimsRequired `json:"code"`
	Details Details3           `json:"details"`
}

func (e ErrorClaimsRequired) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorClaimsRequired) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorClaimsRequired) GetCode() CodeClaimsRequired {
	if o == nil {
		return CodeClaimsRequired("")
	}
	return o.Code
}

func (o *ErrorClaimsRequired) GetDetails() Details3 {
	if o == nil {
		return Details3{}
	}
	return o.Details
}

type CodeUnexpectedError string

const (
	CodeUnexpectedErrorUnexpectedError CodeUnexpectedError = "unexpected-error"
)

func (e CodeUnexpectedError) ToPointer() *CodeUnexpectedError {
	return &e
}
func (e *CodeUnexpectedError) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unexpected-error":
		*e = CodeUnexpectedError(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeUnexpectedError: %v", v)
	}
}

type ErrorUnexpectedError struct {
	Code CodeUnexpectedError `json:"code"`
}

func (e ErrorUnexpectedError) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorUnexpectedError) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorUnexpectedError) GetCode() CodeUnexpectedError {
	if o == nil {
		return CodeUnexpectedError("")
	}
	return o.Code
}

type CodePriceMismatch string

const (
	CodePriceMismatchPriceMismatch CodePriceMismatch = "price-mismatch"
)

func (e CodePriceMismatch) ToPointer() *CodePriceMismatch {
	return &e
}
func (e *CodePriceMismatch) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "price-mismatch":
		*e = CodePriceMismatch(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodePriceMismatch: %v", v)
	}
}

type Details2 struct {
	ExpectedPrice float64  `json:"expectedPrice"`
	ActualPrice   *float64 `json:"actualPrice,omitempty"`
}

func (d Details2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"expectedPrice"}); err != nil {
		return err
	}
	return nil
}

func (o *Details2) GetExpectedPrice() float64 {
	if o == nil {
		return 0.0
	}
	return o.ExpectedPrice
}

func (o *Details2) GetActualPrice() *float64 {
	if o == nil {
		return nil
	}
	return o.ActualPrice
}

type ErrorPriceMismatch struct {
	Code    CodePriceMismatch `json:"code"`
	Details Details2          `json:"details"`
}

func (e ErrorPriceMismatch) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorPriceMismatch) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorPriceMismatch) GetCode() CodePriceMismatch {
	if o == nil {
		return CodePriceMismatch("")
	}
	return o.Code
}

func (o *ErrorPriceMismatch) GetDetails() Details2 {
	if o == nil {
		return Details2{}
	}
	return o.Details
}

type CodeTldOutage string

const (
	CodeTldOutageTldOutage CodeTldOutage = "tld-outage"
)

func (e CodeTldOutage) ToPointer() *CodeTldOutage {
	return &e
}
func (e *CodeTldOutage) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "tld-outage":
		*e = CodeTldOutage(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodeTldOutage: %v", v)
	}
}

type Tld struct {
	TldName string `json:"tldName"`
	EndsAt  string `json:"endsAt"`
}

func (t Tld) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *Tld) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"tldName", "endsAt"}); err != nil {
		return err
	}
	return nil
}

func (o *Tld) GetTldName() string {
	if o == nil {
		return ""
	}
	return o.TldName
}

func (o *Tld) GetEndsAt() string {
	if o == nil {
		return ""
	}
	return o.EndsAt
}

type Details1 struct {
	Tlds []Tld `json:"tlds"`
}

func (d Details1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *Details1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"tlds"}); err != nil {
		return err
	}
	return nil
}

func (o *Details1) GetTlds() []Tld {
	if o == nil {
		return []Tld{}
	}
	return o.Tlds
}

type ErrorTldOutage struct {
	Code    CodeTldOutage `json:"code"`
	Details Details1      `json:"details"`
}

func (e ErrorTldOutage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorTldOutage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code", "details"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorTldOutage) GetCode() CodeTldOutage {
	if o == nil {
		return CodeTldOutage("")
	}
	return o.Code
}

func (o *ErrorTldOutage) GetDetails() Details1 {
	if o == nil {
		return Details1{}
	}
	return o.Details
}

type CodePaymentFailed string

const (
	CodePaymentFailedPaymentFailed CodePaymentFailed = "payment-failed"
)

func (e CodePaymentFailed) ToPointer() *CodePaymentFailed {
	return &e
}
func (e *CodePaymentFailed) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "payment-failed":
		*e = CodePaymentFailed(v)
		return nil
	default:
		return fmt.Errorf("invalid value for CodePaymentFailed: %v", v)
	}
}

type ErrorPaymentFailed struct {
	Code CodePaymentFailed `json:"code"`
}

func (e ErrorPaymentFailed) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *ErrorPaymentFailed) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"code"}); err != nil {
		return err
	}
	return nil
}

func (o *ErrorPaymentFailed) GetCode() CodePaymentFailed {
	if o == nil {
		return CodePaymentFailed("")
	}
	return o.Code
}

type ErrorUnion1Type string

const (
	ErrorUnion1TypePaymentFailed   ErrorUnion1Type = "payment-failed"
	ErrorUnion1TypeTldOutage       ErrorUnion1Type = "tld-outage"
	ErrorUnion1TypePriceMismatch   ErrorUnion1Type = "price-mismatch"
	ErrorUnion1TypeUnexpectedError ErrorUnion1Type = "unexpected-error"
	ErrorUnion1TypeClaimsRequired  ErrorUnion1Type = "claims-required"
	ErrorUnion1TypeDomainMismatch  ErrorUnion1Type = "domain-mismatch"
)

type ErrorUnion1 struct {
	ErrorPaymentFailed   *ErrorPaymentFailed   `queryParam:"inline"`
	ErrorTldOutage       *ErrorTldOutage       `queryParam:"inline"`
	ErrorPriceMismatch   *ErrorPriceMismatch   `queryParam:"inline"`
	ErrorUnexpectedError *ErrorUnexpectedError `queryParam:"inline"`
	ErrorClaimsRequired  *ErrorClaimsRequired  `queryParam:"inline"`
	ErrorDomainMismatch  *ErrorDomainMismatch  `queryParam:"inline"`

	Type ErrorUnion1Type
}

func CreateErrorUnion1PaymentFailed(paymentFailed ErrorPaymentFailed) ErrorUnion1 {
	typ := ErrorUnion1TypePaymentFailed

	typStr := CodePaymentFailed(typ)
	paymentFailed.Code = typStr

	return ErrorUnion1{
		ErrorPaymentFailed: &paymentFailed,
		Type:               typ,
	}
}

func CreateErrorUnion1TldOutage(tldOutage ErrorTldOutage) ErrorUnion1 {
	typ := ErrorUnion1TypeTldOutage

	typStr := CodeTldOutage(typ)
	tldOutage.Code = typStr

	return ErrorUnion1{
		ErrorTldOutage: &tldOutage,
		Type:           typ,
	}
}

func CreateErrorUnion1PriceMismatch(priceMismatch ErrorPriceMismatch) ErrorUnion1 {
	typ := ErrorUnion1TypePriceMismatch

	typStr := CodePriceMismatch(typ)
	priceMismatch.Code = typStr

	return ErrorUnion1{
		ErrorPriceMismatch: &priceMismatch,
		Type:               typ,
	}
}

func CreateErrorUnion1UnexpectedError(unexpectedError ErrorUnexpectedError) ErrorUnion1 {
	typ := ErrorUnion1TypeUnexpectedError

	typStr := CodeUnexpectedError(typ)
	unexpectedError.Code = typStr

	return ErrorUnion1{
		ErrorUnexpectedError: &unexpectedError,
		Type:                 typ,
	}
}

func CreateErrorUnion1ClaimsRequired(claimsRequired ErrorClaimsRequired) ErrorUnion1 {
	typ := ErrorUnion1TypeClaimsRequired

	typStr := CodeClaimsRequired(typ)
	claimsRequired.Code = typStr

	return ErrorUnion1{
		ErrorClaimsRequired: &claimsRequired,
		Type:                typ,
	}
}

func CreateErrorUnion1DomainMismatch(domainMismatch ErrorDomainMismatch) ErrorUnion1 {
	typ := ErrorUnion1TypeDomainMismatch

	typStr := CodeDomainMismatch(typ)
	domainMismatch.Code = typStr

	return ErrorUnion1{
		ErrorDomainMismatch: &domainMismatch,
		Type:                typ,
	}
}

func (u *ErrorUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Code string `json:"code"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Code {
	case "payment-failed":
		errorPaymentFailed := new(ErrorPaymentFailed)
		if err := utils.UnmarshalJSON(data, &errorPaymentFailed, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == payment-failed) type ErrorPaymentFailed within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorPaymentFailed = errorPaymentFailed
		u.Type = ErrorUnion1TypePaymentFailed
		return nil
	case "tld-outage":
		errorTldOutage := new(ErrorTldOutage)
		if err := utils.UnmarshalJSON(data, &errorTldOutage, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == tld-outage) type ErrorTldOutage within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorTldOutage = errorTldOutage
		u.Type = ErrorUnion1TypeTldOutage
		return nil
	case "price-mismatch":
		errorPriceMismatch := new(ErrorPriceMismatch)
		if err := utils.UnmarshalJSON(data, &errorPriceMismatch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == price-mismatch) type ErrorPriceMismatch within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorPriceMismatch = errorPriceMismatch
		u.Type = ErrorUnion1TypePriceMismatch
		return nil
	case "unexpected-error":
		errorUnexpectedError := new(ErrorUnexpectedError)
		if err := utils.UnmarshalJSON(data, &errorUnexpectedError, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == unexpected-error) type ErrorUnexpectedError within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorUnexpectedError = errorUnexpectedError
		u.Type = ErrorUnion1TypeUnexpectedError
		return nil
	case "claims-required":
		errorClaimsRequired := new(ErrorClaimsRequired)
		if err := utils.UnmarshalJSON(data, &errorClaimsRequired, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == claims-required) type ErrorClaimsRequired within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorClaimsRequired = errorClaimsRequired
		u.Type = ErrorUnion1TypeClaimsRequired
		return nil
	case "domain-mismatch":
		errorDomainMismatch := new(ErrorDomainMismatch)
		if err := utils.UnmarshalJSON(data, &errorDomainMismatch, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == domain-mismatch) type ErrorDomainMismatch within ErrorUnion1: %w", string(data), err)
		}

		u.ErrorDomainMismatch = errorDomainMismatch
		u.Type = ErrorUnion1TypeDomainMismatch
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ErrorUnion1", string(data))
}

func (u ErrorUnion1) MarshalJSON() ([]byte, error) {
	if u.ErrorPaymentFailed != nil {
		return utils.MarshalJSON(u.ErrorPaymentFailed, "", true)
	}

	if u.ErrorTldOutage != nil {
		return utils.MarshalJSON(u.ErrorTldOutage, "", true)
	}

	if u.ErrorPriceMismatch != nil {
		return utils.MarshalJSON(u.ErrorPriceMismatch, "", true)
	}

	if u.ErrorUnexpectedError != nil {
		return utils.MarshalJSON(u.ErrorUnexpectedError, "", true)
	}

	if u.ErrorClaimsRequired != nil {
		return utils.MarshalJSON(u.ErrorClaimsRequired, "", true)
	}

	if u.ErrorDomainMismatch != nil {
		return utils.MarshalJSON(u.ErrorDomainMismatch, "", true)
	}

	return nil, errors.New("could not marshal union type ErrorUnion1: all fields are null")
}

type ErrorUnion2Type string

const (
	ErrorUnion2TypeErrorUnion1   ErrorUnion2Type = "error_union_1"
	ErrorUnion2TypeGetOrderError ErrorUnion2Type = "getOrder_error"
)

type ErrorUnion2 struct {
	ErrorUnion1   *ErrorUnion1   `queryParam:"inline"`
	GetOrderError *GetOrderError `queryParam:"inline"`

	Type ErrorUnion2Type
}

func CreateErrorUnion2ErrorUnion1(errorUnion1 ErrorUnion1) ErrorUnion2 {
	typ := ErrorUnion2TypeErrorUnion1

	return ErrorUnion2{
		ErrorUnion1: &errorUnion1,
		Type:        typ,
	}
}

func CreateErrorUnion2GetOrderError(getOrderError GetOrderError) ErrorUnion2 {
	typ := ErrorUnion2TypeGetOrderError

	return ErrorUnion2{
		GetOrderError: &getOrderError,
		Type:          typ,
	}
}

func (u *ErrorUnion2) UnmarshalJSON(data []byte) error {

	var getOrderError GetOrderError = GetOrderError{}
	if err := utils.UnmarshalJSON(data, &getOrderError, "", true, nil); err == nil {
		u.GetOrderError = &getOrderError
		u.Type = ErrorUnion2TypeGetOrderError
		return nil
	}

	var errorUnion1 ErrorUnion1 = ErrorUnion1{}
	if err := utils.UnmarshalJSON(data, &errorUnion1, "", true, nil); err == nil {
		u.ErrorUnion1 = &errorUnion1
		u.Type = ErrorUnion2TypeErrorUnion1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ErrorUnion2", string(data))
}

func (u ErrorUnion2) MarshalJSON() ([]byte, error) {
	if u.ErrorUnion1 != nil {
		return utils.MarshalJSON(u.ErrorUnion1, "", true)
	}

	if u.GetOrderError != nil {
		return utils.MarshalJSON(u.GetOrderError, "", true)
	}

	return nil, errors.New("could not marshal union type ErrorUnion2: all fields are null")
}

// GetOrderResponseBody - Success
type GetOrderResponseBody struct {
	// A valid order ID
	OrderID string                `json:"orderId"`
	Domains []GetOrderDomainUnion `json:"domains"`
	Status  GetOrderStatus        `json:"status"`
	Error   *ErrorUnion2          `json:"error,omitempty"`
}

func (o *GetOrderResponseBody) GetOrderID() string {
	if o == nil {
		return ""
	}
	return o.OrderID
}

func (o *GetOrderResponseBody) GetDomains() []GetOrderDomainUnion {
	if o == nil {
		return []GetOrderDomainUnion{}
	}
	return o.Domains
}

func (o *GetOrderResponseBody) GetStatus() GetOrderStatus {
	if o == nil {
		return GetOrderStatus("")
	}
	return o.Status
}

func (o *GetOrderResponseBody) GetError() *ErrorUnion2 {
	if o == nil {
		return nil
	}
	return o.Error
}

type GetOrderResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// Success
	Object *GetOrderResponseBody
}

func (o *GetOrderResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetOrderResponse) GetObject() *GetOrderResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
