// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type ProjectFirewallRouteHasType string

const (
	ProjectFirewallRouteHasTypePath               ProjectFirewallRouteHasType = "path"
	ProjectFirewallRouteHasTypeQuery              ProjectFirewallRouteHasType = "query"
	ProjectFirewallRouteHasTypeHost               ProjectFirewallRouteHasType = "host"
	ProjectFirewallRouteHasTypeMethod             ProjectFirewallRouteHasType = "method"
	ProjectFirewallRouteHasTypeHeader             ProjectFirewallRouteHasType = "header"
	ProjectFirewallRouteHasTypeCookie             ProjectFirewallRouteHasType = "cookie"
	ProjectFirewallRouteHasTypeIPAddress          ProjectFirewallRouteHasType = "ip_address"
	ProjectFirewallRouteHasTypeProtocol           ProjectFirewallRouteHasType = "protocol"
	ProjectFirewallRouteHasTypeScheme             ProjectFirewallRouteHasType = "scheme"
	ProjectFirewallRouteHasTypeEnvironment        ProjectFirewallRouteHasType = "environment"
	ProjectFirewallRouteHasTypeRegion             ProjectFirewallRouteHasType = "region"
	ProjectFirewallRouteHasTypeInitialRequestPath ProjectFirewallRouteHasType = "initial_request_path"
)

func (e ProjectFirewallRouteHasType) ToPointer() *ProjectFirewallRouteHasType {
	return &e
}
func (e *ProjectFirewallRouteHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "path":
		fallthrough
	case "query":
		fallthrough
	case "host":
		fallthrough
	case "method":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "ip_address":
		fallthrough
	case "protocol":
		fallthrough
	case "scheme":
		fallthrough
	case "environment":
		fallthrough
	case "region":
		fallthrough
	case "initial_request_path":
		*e = ProjectFirewallRouteHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectFirewallRouteHasType: %v", v)
	}
}

type ValueProjectFirewallRouteHas struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (v ValueProjectFirewallRouteHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *ValueProjectFirewallRouteHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ValueProjectFirewallRouteHas) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *ValueProjectFirewallRouteHas) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *ValueProjectFirewallRouteHas) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *ValueProjectFirewallRouteHas) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *ValueProjectFirewallRouteHas) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *ValueProjectFirewallRouteHas) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *ValueProjectFirewallRouteHas) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *ValueProjectFirewallRouteHas) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *ValueProjectFirewallRouteHas) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *ValueProjectFirewallRouteHas) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *ValueProjectFirewallRouteHas) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type ProjectHasValueUnionType string

const (
	ProjectHasValueUnionTypeStr                          ProjectHasValueUnionType = "str"
	ProjectHasValueUnionTypeValueProjectFirewallRouteHas ProjectHasValueUnionType = "value_project_firewallRoute_has"
)

type ProjectHasValueUnion struct {
	Str                          *string                       `queryParam:"inline"`
	ValueProjectFirewallRouteHas *ValueProjectFirewallRouteHas `queryParam:"inline"`

	Type ProjectHasValueUnionType
}

func CreateProjectHasValueUnionStr(str string) ProjectHasValueUnion {
	typ := ProjectHasValueUnionTypeStr

	return ProjectHasValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateProjectHasValueUnionValueProjectFirewallRouteHas(valueProjectFirewallRouteHas ValueProjectFirewallRouteHas) ProjectHasValueUnion {
	typ := ProjectHasValueUnionTypeValueProjectFirewallRouteHas

	return ProjectHasValueUnion{
		ValueProjectFirewallRouteHas: &valueProjectFirewallRouteHas,
		Type:                         typ,
	}
}

func (u *ProjectHasValueUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ProjectHasValueUnionTypeStr
		return nil
	}

	var valueProjectFirewallRouteHas ValueProjectFirewallRouteHas = ValueProjectFirewallRouteHas{}
	if err := utils.UnmarshalJSON(data, &valueProjectFirewallRouteHas, "", true, nil); err == nil {
		u.ValueProjectFirewallRouteHas = &valueProjectFirewallRouteHas
		u.Type = ProjectHasValueUnionTypeValueProjectFirewallRouteHas
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectHasValueUnion", string(data))
}

func (u ProjectHasValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueProjectFirewallRouteHas != nil {
		return utils.MarshalJSON(u.ValueProjectFirewallRouteHas, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectHasValueUnion: all fields are null")
}

type ProjectFirewallRouteHas struct {
	Type  ProjectFirewallRouteHasType `json:"type"`
	Key   *string                     `json:"key,omitempty"`
	Value *ProjectHasValueUnion       `json:"value,omitempty"`
}

func (p ProjectFirewallRouteHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectFirewallRouteHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectFirewallRouteHas) GetType() ProjectFirewallRouteHasType {
	if o == nil {
		return ProjectFirewallRouteHasType("")
	}
	return o.Type
}

func (o *ProjectFirewallRouteHas) GetKey() *string {
	if o == nil {
		return nil
	}
	return o.Key
}

func (o *ProjectFirewallRouteHas) GetValue() *ProjectHasValueUnion {
	if o == nil {
		return nil
	}
	return o.Value
}

type ProjectMissingType string

const (
	ProjectMissingTypePath               ProjectMissingType = "path"
	ProjectMissingTypeQuery              ProjectMissingType = "query"
	ProjectMissingTypeHost               ProjectMissingType = "host"
	ProjectMissingTypeMethod             ProjectMissingType = "method"
	ProjectMissingTypeHeader             ProjectMissingType = "header"
	ProjectMissingTypeCookie             ProjectMissingType = "cookie"
	ProjectMissingTypeIPAddress          ProjectMissingType = "ip_address"
	ProjectMissingTypeProtocol           ProjectMissingType = "protocol"
	ProjectMissingTypeScheme             ProjectMissingType = "scheme"
	ProjectMissingTypeEnvironment        ProjectMissingType = "environment"
	ProjectMissingTypeRegion             ProjectMissingType = "region"
	ProjectMissingTypeInitialRequestPath ProjectMissingType = "initial_request_path"
)

func (e ProjectMissingType) ToPointer() *ProjectMissingType {
	return &e
}
func (e *ProjectMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "path":
		fallthrough
	case "query":
		fallthrough
	case "host":
		fallthrough
	case "method":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "ip_address":
		fallthrough
	case "protocol":
		fallthrough
	case "scheme":
		fallthrough
	case "environment":
		fallthrough
	case "region":
		fallthrough
	case "initial_request_path":
		*e = ProjectMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectMissingType: %v", v)
	}
}

type ValueProjectMissing struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (v ValueProjectMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *ValueProjectMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ValueProjectMissing) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *ValueProjectMissing) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *ValueProjectMissing) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *ValueProjectMissing) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *ValueProjectMissing) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *ValueProjectMissing) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *ValueProjectMissing) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *ValueProjectMissing) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *ValueProjectMissing) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *ValueProjectMissing) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *ValueProjectMissing) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type ProjectMissingValueUnionType string

const (
	ProjectMissingValueUnionTypeStr                 ProjectMissingValueUnionType = "str"
	ProjectMissingValueUnionTypeValueProjectMissing ProjectMissingValueUnionType = "value_project_missing"
)

type ProjectMissingValueUnion struct {
	Str                 *string              `queryParam:"inline"`
	ValueProjectMissing *ValueProjectMissing `queryParam:"inline"`

	Type ProjectMissingValueUnionType
}

func CreateProjectMissingValueUnionStr(str string) ProjectMissingValueUnion {
	typ := ProjectMissingValueUnionTypeStr

	return ProjectMissingValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateProjectMissingValueUnionValueProjectMissing(valueProjectMissing ValueProjectMissing) ProjectMissingValueUnion {
	typ := ProjectMissingValueUnionTypeValueProjectMissing

	return ProjectMissingValueUnion{
		ValueProjectMissing: &valueProjectMissing,
		Type:                typ,
	}
}

func (u *ProjectMissingValueUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ProjectMissingValueUnionTypeStr
		return nil
	}

	var valueProjectMissing ValueProjectMissing = ValueProjectMissing{}
	if err := utils.UnmarshalJSON(data, &valueProjectMissing, "", true, nil); err == nil {
		u.ValueProjectMissing = &valueProjectMissing
		u.Type = ProjectMissingValueUnionTypeValueProjectMissing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectMissingValueUnion", string(data))
}

func (u ProjectMissingValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueProjectMissing != nil {
		return utils.MarshalJSON(u.ValueProjectMissing, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectMissingValueUnion: all fields are null")
}

type ProjectMissing struct {
	Type  ProjectMissingType        `json:"type"`
	Key   *string                   `json:"key,omitempty"`
	Value *ProjectMissingValueUnion `json:"value,omitempty"`
}

func (p ProjectMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectMissing) GetType() ProjectMissingType {
	if o == nil {
		return ProjectMissingType("")
	}
	return o.Type
}

func (o *ProjectMissing) GetKey() *string {
	if o == nil {
		return nil
	}
	return o.Key
}

func (o *ProjectMissing) GetValue() *ProjectMissingValueUnion {
	if o == nil {
		return nil
	}
	return o.Value
}

type ProjectHandle string

const (
	ProjectHandleInit     ProjectHandle = "init"
	ProjectHandleFinalize ProjectHandle = "finalize"
)

func (e ProjectHandle) ToPointer() *ProjectHandle {
	return &e
}
func (e *ProjectHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "init":
		fallthrough
	case "finalize":
		*e = ProjectHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectHandle: %v", v)
	}
}

type ProjectFirewallRouteAction string

const (
	ProjectFirewallRouteActionLog       ProjectFirewallRouteAction = "log"
	ProjectFirewallRouteActionDeny      ProjectFirewallRouteAction = "deny"
	ProjectFirewallRouteActionChallenge ProjectFirewallRouteAction = "challenge"
	ProjectFirewallRouteActionBypass    ProjectFirewallRouteAction = "bypass"
	ProjectFirewallRouteActionRateLimit ProjectFirewallRouteAction = "rate_limit"
	ProjectFirewallRouteActionRedirect  ProjectFirewallRouteAction = "redirect"
)

func (e ProjectFirewallRouteAction) ToPointer() *ProjectFirewallRouteAction {
	return &e
}
func (e *ProjectFirewallRouteAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		fallthrough
	case "bypass":
		fallthrough
	case "rate_limit":
		fallthrough
	case "redirect":
		*e = ProjectFirewallRouteAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectFirewallRouteAction: %v", v)
	}
}

type ProjectAlgo string

const (
	ProjectAlgoFixedWindow ProjectAlgo = "fixed_window"
	ProjectAlgoTokenBucket ProjectAlgo = "token_bucket"
)

func (e ProjectAlgo) ToPointer() *ProjectAlgo {
	return &e
}
func (e *ProjectAlgo) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fixed_window":
		fallthrough
	case "token_bucket":
		*e = ProjectAlgo(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectAlgo: %v", v)
	}
}

type ProjectErl struct {
	Algo   ProjectAlgo `json:"algo"`
	Window float64     `json:"window"`
	Limit  float64     `json:"limit"`
	Keys   []string    `json:"keys"`
}

func (p ProjectErl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectErl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"algo", "window", "limit", "keys"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectErl) GetAlgo() ProjectAlgo {
	if o == nil {
		return ProjectAlgo("")
	}
	return o.Algo
}

func (o *ProjectErl) GetWindow() float64 {
	if o == nil {
		return 0.0
	}
	return o.Window
}

func (o *ProjectErl) GetLimit() float64 {
	if o == nil {
		return 0.0
	}
	return o.Limit
}

func (o *ProjectErl) GetKeys() []string {
	if o == nil {
		return []string{}
	}
	return o.Keys
}

type LogHeadersProjectEnum string

const (
	LogHeadersProjectEnumWildcard LogHeadersProjectEnum = "*"
)

func (e LogHeadersProjectEnum) ToPointer() *LogHeadersProjectEnum {
	return &e
}
func (e *LogHeadersProjectEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "*":
		*e = LogHeadersProjectEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for LogHeadersProjectEnum: %v", v)
	}
}

type ProjectLogHeadersUnionType string

const (
	ProjectLogHeadersUnionTypeArrayOfStr            ProjectLogHeadersUnionType = "arrayOfStr"
	ProjectLogHeadersUnionTypeLogHeadersProjectEnum ProjectLogHeadersUnionType = "log_headers_project_enum"
)

type ProjectLogHeadersUnion struct {
	ArrayOfStr            []string               `queryParam:"inline"`
	LogHeadersProjectEnum *LogHeadersProjectEnum `queryParam:"inline"`

	Type ProjectLogHeadersUnionType
}

func CreateProjectLogHeadersUnionArrayOfStr(arrayOfStr []string) ProjectLogHeadersUnion {
	typ := ProjectLogHeadersUnionTypeArrayOfStr

	return ProjectLogHeadersUnion{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func CreateProjectLogHeadersUnionLogHeadersProjectEnum(logHeadersProjectEnum LogHeadersProjectEnum) ProjectLogHeadersUnion {
	typ := ProjectLogHeadersUnionTypeLogHeadersProjectEnum

	return ProjectLogHeadersUnion{
		LogHeadersProjectEnum: &logHeadersProjectEnum,
		Type:                  typ,
	}
}

func (u *ProjectLogHeadersUnion) UnmarshalJSON(data []byte) error {

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = ProjectLogHeadersUnionTypeArrayOfStr
		return nil
	}

	var logHeadersProjectEnum LogHeadersProjectEnum = LogHeadersProjectEnum("")
	if err := utils.UnmarshalJSON(data, &logHeadersProjectEnum, "", true, nil); err == nil {
		u.LogHeadersProjectEnum = &logHeadersProjectEnum
		u.Type = ProjectLogHeadersUnionTypeLogHeadersProjectEnum
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectLogHeadersUnion", string(data))
}

func (u ProjectLogHeadersUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	if u.LogHeadersProjectEnum != nil {
		return utils.MarshalJSON(u.LogHeadersProjectEnum, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectLogHeadersUnion: all fields are null")
}

type ProjectFirewallRouteMitigate struct {
	Action     ProjectFirewallRouteAction `json:"action"`
	RuleID     string                     `json:"rule_id"`
	TTL        *float64                   `json:"ttl,omitempty"`
	Erl        *ProjectErl                `json:"erl,omitempty"`
	LogHeaders *ProjectLogHeadersUnion    `json:"log_headers,omitempty"`
}

func (p ProjectFirewallRouteMitigate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectFirewallRouteMitigate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"action", "rule_id"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectFirewallRouteMitigate) GetAction() ProjectFirewallRouteAction {
	if o == nil {
		return ProjectFirewallRouteAction("")
	}
	return o.Action
}

func (o *ProjectFirewallRouteMitigate) GetRuleID() string {
	if o == nil {
		return ""
	}
	return o.RuleID
}

func (o *ProjectFirewallRouteMitigate) GetTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.TTL
}

func (o *ProjectFirewallRouteMitigate) GetErl() *ProjectErl {
	if o == nil {
		return nil
	}
	return o.Erl
}

func (o *ProjectFirewallRouteMitigate) GetLogHeaders() *ProjectLogHeadersUnion {
	if o == nil {
		return nil
	}
	return o.LogHeaders
}

type ProjectFirewallRoute struct {
	Src      *ProjectSrcUnion              `json:"src,omitempty"`
	Has      []ProjectFirewallRouteHas     `json:"has,omitempty"`
	Missing  []ProjectMissing              `json:"missing,omitempty"`
	Dest     *string                       `json:"dest,omitempty"`
	Status   *float64                      `json:"status,omitempty"`
	Handle   *ProjectHandle                `json:"handle,omitempty"`
	Mitigate *ProjectFirewallRouteMitigate `json:"mitigate,omitempty"`
}

func (p ProjectFirewallRoute) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectFirewallRoute) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ProjectFirewallRoute) GetSrc() *ProjectSrcUnion {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *ProjectFirewallRoute) GetHas() []ProjectFirewallRouteHas {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *ProjectFirewallRoute) GetMissing() []ProjectMissing {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *ProjectFirewallRoute) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *ProjectFirewallRoute) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *ProjectFirewallRoute) GetHandle() *ProjectHandle {
	if o == nil {
		return nil
	}
	return o.Handle
}

func (o *ProjectFirewallRoute) GetMitigate() *ProjectFirewallRouteMitigate {
	if o == nil {
		return nil
	}
	return o.Mitigate
}

type ProjectVercelRulesetAction1 string

const (
	ProjectVercelRulesetAction1Log       ProjectVercelRulesetAction1 = "log"
	ProjectVercelRulesetAction1Deny      ProjectVercelRulesetAction1 = "deny"
	ProjectVercelRulesetAction1Challenge ProjectVercelRulesetAction1 = "challenge"
)

func (e ProjectVercelRulesetAction1) ToPointer() *ProjectVercelRulesetAction1 {
	return &e
}
func (e *ProjectVercelRulesetAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = ProjectVercelRulesetAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectVercelRulesetAction1: %v", v)
	}
}

type ProjectVercelRuleset1 struct {
	Active bool                         `json:"active"`
	Action *ProjectVercelRulesetAction1 `json:"action,omitempty"`
}

func (p ProjectVercelRuleset1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectVercelRuleset1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectVercelRuleset1) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ProjectVercelRuleset1) GetAction() *ProjectVercelRulesetAction1 {
	if o == nil {
		return nil
	}
	return o.Action
}

type ProjectBotFilterAction1 string

const (
	ProjectBotFilterAction1Log       ProjectBotFilterAction1 = "log"
	ProjectBotFilterAction1Deny      ProjectBotFilterAction1 = "deny"
	ProjectBotFilterAction1Challenge ProjectBotFilterAction1 = "challenge"
)

func (e ProjectBotFilterAction1) ToPointer() *ProjectBotFilterAction1 {
	return &e
}
func (e *ProjectBotFilterAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = ProjectBotFilterAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectBotFilterAction1: %v", v)
	}
}

type ProjectBotFilter1 struct {
	Active bool                     `json:"active"`
	Action *ProjectBotFilterAction1 `json:"action,omitempty"`
}

func (p ProjectBotFilter1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectBotFilter1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectBotFilter1) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ProjectBotFilter1) GetAction() *ProjectBotFilterAction1 {
	if o == nil {
		return nil
	}
	return o.Action
}

type ProjectAiBotsAction1 string

const (
	ProjectAiBotsAction1Log       ProjectAiBotsAction1 = "log"
	ProjectAiBotsAction1Deny      ProjectAiBotsAction1 = "deny"
	ProjectAiBotsAction1Challenge ProjectAiBotsAction1 = "challenge"
)

func (e ProjectAiBotsAction1) ToPointer() *ProjectAiBotsAction1 {
	return &e
}
func (e *ProjectAiBotsAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = ProjectAiBotsAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectAiBotsAction1: %v", v)
	}
}

type ProjectAiBots1 struct {
	Active bool                  `json:"active"`
	Action *ProjectAiBotsAction1 `json:"action,omitempty"`
}

func (p ProjectAiBots1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectAiBots1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectAiBots1) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ProjectAiBots1) GetAction() *ProjectAiBotsAction1 {
	if o == nil {
		return nil
	}
	return o.Action
}

type ProjectOwaspAction1 string

const (
	ProjectOwaspAction1Log       ProjectOwaspAction1 = "log"
	ProjectOwaspAction1Deny      ProjectOwaspAction1 = "deny"
	ProjectOwaspAction1Challenge ProjectOwaspAction1 = "challenge"
)

func (e ProjectOwaspAction1) ToPointer() *ProjectOwaspAction1 {
	return &e
}
func (e *ProjectOwaspAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = ProjectOwaspAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectOwaspAction1: %v", v)
	}
}

type ProjectOwasp1 struct {
	Active bool                 `json:"active"`
	Action *ProjectOwaspAction1 `json:"action,omitempty"`
}

func (p ProjectOwasp1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectOwasp1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectOwasp1) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ProjectOwasp1) GetAction() *ProjectOwaspAction1 {
	if o == nil {
		return nil
	}
	return o.Action
}

type ProjectManagedRules1 struct {
	VercelRuleset ProjectVercelRuleset1 `json:"vercel_ruleset"`
	BotFilter     ProjectBotFilter1     `json:"bot_filter"`
	AiBots        ProjectAiBots1        `json:"ai_bots"`
	Owasp         ProjectOwasp1         `json:"owasp"`
}

func (p ProjectManagedRules1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectManagedRules1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"vercel_ruleset", "bot_filter", "ai_bots", "owasp"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectManagedRules1) GetVercelRuleset() ProjectVercelRuleset1 {
	if o == nil {
		return ProjectVercelRuleset1{}
	}
	return o.VercelRuleset
}

func (o *ProjectManagedRules1) GetBotFilter() ProjectBotFilter1 {
	if o == nil {
		return ProjectBotFilter1{}
	}
	return o.BotFilter
}

func (o *ProjectManagedRules1) GetAiBots() ProjectAiBots1 {
	if o == nil {
		return ProjectAiBots1{}
	}
	return o.AiBots
}

func (o *ProjectManagedRules1) GetOwasp() ProjectOwasp1 {
	if o == nil {
		return ProjectOwasp1{}
	}
	return o.Owasp
}

type ProjectSecurity1 struct {
	AttackModeEnabled      *bool                  `json:"attackModeEnabled,omitempty"`
	AttackModeUpdatedAt    *float64               `json:"attackModeUpdatedAt,omitempty"`
	FirewallEnabled        *bool                  `json:"firewallEnabled,omitempty"`
	FirewallUpdatedAt      *float64               `json:"firewallUpdatedAt,omitempty"`
	AttackModeActiveUntil  *float64               `json:"attackModeActiveUntil,omitempty"`
	FirewallConfigVersion  *float64               `json:"firewallConfigVersion,omitempty"`
	FirewallRoutes         []ProjectFirewallRoute `json:"firewallRoutes,omitempty"`
	FirewallSeawallEnabled *bool                  `json:"firewallSeawallEnabled,omitempty"`
	Ja3Enabled             *bool                  `json:"ja3Enabled,omitempty"`
	Ja4Enabled             *bool                  `json:"ja4Enabled,omitempty"`
	FirewallBypassIps      []string               `json:"firewallBypassIps,omitempty"`
	ManagedRules           *ProjectManagedRules1  `json:"managedRules,omitempty"`
	BotIDEnabled           *bool                  `json:"botIdEnabled,omitempty"`
}

func (p ProjectSecurity1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectSecurity1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ProjectSecurity1) GetAttackModeEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.AttackModeEnabled
}

func (o *ProjectSecurity1) GetAttackModeUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AttackModeUpdatedAt
}

func (o *ProjectSecurity1) GetFirewallEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.FirewallEnabled
}

func (o *ProjectSecurity1) GetFirewallUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.FirewallUpdatedAt
}

func (o *ProjectSecurity1) GetAttackModeActiveUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.AttackModeActiveUntil
}

func (o *ProjectSecurity1) GetFirewallConfigVersion() *float64 {
	if o == nil {
		return nil
	}
	return o.FirewallConfigVersion
}

func (o *ProjectSecurity1) GetFirewallRoutes() []ProjectFirewallRoute {
	if o == nil {
		return nil
	}
	return o.FirewallRoutes
}

func (o *ProjectSecurity1) GetFirewallSeawallEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.FirewallSeawallEnabled
}

func (o *ProjectSecurity1) GetJa3Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.Ja3Enabled
}

func (o *ProjectSecurity1) GetJa4Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.Ja4Enabled
}

func (o *ProjectSecurity1) GetFirewallBypassIps() []string {
	if o == nil {
		return nil
	}
	return o.FirewallBypassIps
}

func (o *ProjectSecurity1) GetManagedRules() *ProjectManagedRules1 {
	if o == nil {
		return nil
	}
	return o.ManagedRules
}

func (o *ProjectSecurity1) GetBotIDEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.BotIDEnabled
}

// ProjectIssuerMode1 - - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
type ProjectIssuerMode1 string

const (
	ProjectIssuerMode1Team   ProjectIssuerMode1 = "team"
	ProjectIssuerMode1Global ProjectIssuerMode1 = "global"
)

func (e ProjectIssuerMode1) ToPointer() *ProjectIssuerMode1 {
	return &e
}
func (e *ProjectIssuerMode1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "global":
		*e = ProjectIssuerMode1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectIssuerMode1: %v", v)
	}
}

type ProjectOidcTokenConfig1 struct {
	// Whether or not to generate OpenID Connect JSON Web Tokens.
	Enabled *bool `json:"enabled,omitempty"`
	// - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
	IssuerMode *ProjectIssuerMode1 `json:"issuerMode,omitempty"`
}

func (p ProjectOidcTokenConfig1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectOidcTokenConfig1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ProjectOidcTokenConfig1) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *ProjectOidcTokenConfig1) GetIssuerMode() *ProjectIssuerMode1 {
	if o == nil {
		return nil
	}
	return o.IssuerMode
}

type ProjectTier1 string

const (
	ProjectTier1Standard ProjectTier1 = "standard"
	ProjectTier1Advanced ProjectTier1 = "advanced"
	ProjectTier1Critical ProjectTier1 = "critical"
)

func (e ProjectTier1) ToPointer() *ProjectTier1 {
	return &e
}
func (e *ProjectTier1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "advanced":
		fallthrough
	case "critical":
		*e = ProjectTier1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTier1: %v", v)
	}
}

type ProjectHistory1 struct {
	Scanner string  `json:"scanner"`
	Reason  string  `json:"reason"`
	By      string  `json:"by"`
	ByID    string  `json:"byId"`
	At      float64 `json:"at"`
}

func (p ProjectHistory1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectHistory1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"scanner", "reason", "by", "byId", "at"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectHistory1) GetScanner() string {
	if o == nil {
		return ""
	}
	return o.Scanner
}

func (o *ProjectHistory1) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *ProjectHistory1) GetBy() string {
	if o == nil {
		return ""
	}
	return o.By
}

func (o *ProjectHistory1) GetByID() string {
	if o == nil {
		return ""
	}
	return o.ByID
}

func (o *ProjectHistory1) GetAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.At
}

type ProjectActionBlocked1 string

const (
	ProjectActionBlocked1Blocked ProjectActionBlocked1 = "blocked"
)

func (e ProjectActionBlocked1) ToPointer() *ProjectActionBlocked1 {
	return &e
}
func (e *ProjectActionBlocked1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blocked":
		*e = ProjectActionBlocked1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionBlocked1: %v", v)
	}
}

type ProjectBlock1 struct {
	Action              ProjectActionBlocked1 `json:"action"`
	Reason              string                `json:"reason"`
	StatusCode          float64               `json:"statusCode"`
	CreatedAt           float64               `json:"createdAt"`
	CaseID              *string               `json:"caseId,omitempty"`
	Actor               *string               `json:"actor,omitempty"`
	Comment             *string               `json:"comment,omitempty"`
	IneligibleForAppeal *bool                 `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                 `json:"isCascading,omitempty"`
}

func (p ProjectBlock1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectBlock1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"action", "reason", "statusCode", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectBlock1) GetAction() ProjectActionBlocked1 {
	if o == nil {
		return ProjectActionBlocked1("")
	}
	return o.Action
}

func (o *ProjectBlock1) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *ProjectBlock1) GetStatusCode() float64 {
	if o == nil {
		return 0.0
	}
	return o.StatusCode
}

func (o *ProjectBlock1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ProjectBlock1) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *ProjectBlock1) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *ProjectBlock1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *ProjectBlock1) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *ProjectBlock1) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectActionRouteUnblocked1 string

const (
	ProjectActionRouteUnblocked1RouteUnblocked ProjectActionRouteUnblocked1 = "route-unblocked"
)

func (e ProjectActionRouteUnblocked1) ToPointer() *ProjectActionRouteUnblocked1 {
	return &e
}
func (e *ProjectActionRouteUnblocked1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "route-unblocked":
		*e = ProjectActionRouteUnblocked1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionRouteUnblocked1: %v", v)
	}
}

type BlockHistoryProjectTypeHost2 string

const (
	BlockHistoryProjectTypeHost2Host BlockHistoryProjectTypeHost2 = "host"
)

func (e BlockHistoryProjectTypeHost2) ToPointer() *BlockHistoryProjectTypeHost2 {
	return &e
}
func (e *BlockHistoryProjectTypeHost2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = BlockHistoryProjectTypeHost2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHost2: %v", v)
	}
}

type BlockHistoryProjectValue4 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue4) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectHost2 struct {
	Type  BlockHistoryProjectTypeHost2 `json:"type"`
	Value BlockHistoryProjectValue4    `json:"value"`
}

func (b BlockHistoryHasProjectHost2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectHost2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectHost2) GetType() BlockHistoryProjectTypeHost2 {
	if o == nil {
		return BlockHistoryProjectTypeHost2("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectHost2) GetValue() BlockHistoryProjectValue4 {
	if o == nil {
		return BlockHistoryProjectValue4{}
	}
	return o.Value
}

type BlockHistoryProjectTypeHeader2 string

const (
	BlockHistoryProjectTypeHeader2Header BlockHistoryProjectTypeHeader2 = "header"
)

func (e BlockHistoryProjectTypeHeader2) ToPointer() *BlockHistoryProjectTypeHeader2 {
	return &e
}
func (e *BlockHistoryProjectTypeHeader2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = BlockHistoryProjectTypeHeader2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHeader2: %v", v)
	}
}

type BlockHistoryProjectKey2 string

const (
	BlockHistoryProjectKey2XVercelIPCountry BlockHistoryProjectKey2 = "x-vercel-ip-country"
)

func (e BlockHistoryProjectKey2) ToPointer() *BlockHistoryProjectKey2 {
	return &e
}
func (e *BlockHistoryProjectKey2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = BlockHistoryProjectKey2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectKey2: %v", v)
	}
}

type BlockHistoryProjectValue3 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue3) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectXVercelIPCountry2 struct {
	Type  BlockHistoryProjectTypeHeader2 `json:"type"`
	Key   BlockHistoryProjectKey2        `json:"key"`
	Value BlockHistoryProjectValue3      `json:"value"`
}

func (b BlockHistoryHasProjectXVercelIPCountry2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectXVercelIPCountry2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectXVercelIPCountry2) GetType() BlockHistoryProjectTypeHeader2 {
	if o == nil {
		return BlockHistoryProjectTypeHeader2("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectXVercelIPCountry2) GetKey() BlockHistoryProjectKey2 {
	if o == nil {
		return BlockHistoryProjectKey2("")
	}
	return o.Key
}

func (o *BlockHistoryHasProjectXVercelIPCountry2) GetValue() BlockHistoryProjectValue3 {
	if o == nil {
		return BlockHistoryProjectValue3{}
	}
	return o.Value
}

type BlockHistoryProjectHasUnion2Type string

const (
	BlockHistoryProjectHasUnion2TypeHeader BlockHistoryProjectHasUnion2Type = "header"
	BlockHistoryProjectHasUnion2TypeHost   BlockHistoryProjectHasUnion2Type = "host"
)

type BlockHistoryProjectHasUnion2 struct {
	BlockHistoryHasProjectXVercelIPCountry2 *BlockHistoryHasProjectXVercelIPCountry2 `queryParam:"inline"`
	BlockHistoryHasProjectHost2             *BlockHistoryHasProjectHost2             `queryParam:"inline"`

	Type BlockHistoryProjectHasUnion2Type
}

func CreateBlockHistoryProjectHasUnion2Header(header BlockHistoryHasProjectXVercelIPCountry2) BlockHistoryProjectHasUnion2 {
	typ := BlockHistoryProjectHasUnion2TypeHeader

	typStr := BlockHistoryProjectTypeHeader2(typ)
	header.Type = typStr

	return BlockHistoryProjectHasUnion2{
		BlockHistoryHasProjectXVercelIPCountry2: &header,
		Type:                                    typ,
	}
}

func CreateBlockHistoryProjectHasUnion2Host(host BlockHistoryHasProjectHost2) BlockHistoryProjectHasUnion2 {
	typ := BlockHistoryProjectHasUnion2TypeHost

	typStr := BlockHistoryProjectTypeHost2(typ)
	host.Type = typStr

	return BlockHistoryProjectHasUnion2{
		BlockHistoryHasProjectHost2: &host,
		Type:                        typ,
	}
}

func (u *BlockHistoryProjectHasUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		blockHistoryHasProjectXVercelIPCountry2 := new(BlockHistoryHasProjectXVercelIPCountry2)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectXVercelIPCountry2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type BlockHistoryHasProjectXVercelIPCountry2 within BlockHistoryProjectHasUnion2: %w", string(data), err)
		}

		u.BlockHistoryHasProjectXVercelIPCountry2 = blockHistoryHasProjectXVercelIPCountry2
		u.Type = BlockHistoryProjectHasUnion2TypeHeader
		return nil
	case "host":
		blockHistoryHasProjectHost2 := new(BlockHistoryHasProjectHost2)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectHost2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type BlockHistoryHasProjectHost2 within BlockHistoryProjectHasUnion2: %w", string(data), err)
		}

		u.BlockHistoryHasProjectHost2 = blockHistoryHasProjectHost2
		u.Type = BlockHistoryProjectHasUnion2TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BlockHistoryProjectHasUnion2", string(data))
}

func (u BlockHistoryProjectHasUnion2) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryHasProjectXVercelIPCountry2 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectXVercelIPCountry2, "", true)
	}

	if u.BlockHistoryHasProjectHost2 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectHost2, "", true)
	}

	return nil, errors.New("could not marshal union type BlockHistoryProjectHasUnion2: all fields are null")
}

type RouteProjectAction2 string

const (
	RouteProjectAction2BlockLegalCwc RouteProjectAction2 = "block_legal_cwc"
)

func (e RouteProjectAction2) ToPointer() *RouteProjectAction2 {
	return &e
}
func (e *RouteProjectAction2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = RouteProjectAction2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteProjectAction2: %v", v)
	}
}

type BlockHistoryProjectMitigate2 struct {
	Action RouteProjectAction2 `json:"action"`
}

func (b BlockHistoryProjectMitigate2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectMitigate2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectMitigate2) GetAction() RouteProjectAction2 {
	if o == nil {
		return RouteProjectAction2("")
	}
	return o.Action
}

type RouteProject4 struct {
	Has      []BlockHistoryProjectHasUnion2 `json:"has"`
	Mitigate BlockHistoryProjectMitigate2   `json:"mitigate"`
	Src      *string                        `json:"src,omitempty"`
}

func (r RouteProject4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject4) GetHas() []BlockHistoryProjectHasUnion2 {
	if o == nil {
		return []BlockHistoryProjectHasUnion2{}
	}
	return o.Has
}

func (o *RouteProject4) GetMitigate() BlockHistoryProjectMitigate2 {
	if o == nil {
		return BlockHistoryProjectMitigate2{}
	}
	return o.Mitigate
}

func (o *RouteProject4) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type RouteProject3 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (r RouteProject3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *RouteProject3) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectRouteUnion2Type string

const (
	ProjectRouteUnion2TypeRouteProject3 ProjectRouteUnion2Type = "route_project_3"
	ProjectRouteUnion2TypeRouteProject4 ProjectRouteUnion2Type = "route_project_4"
)

type ProjectRouteUnion2 struct {
	RouteProject3 *RouteProject3 `queryParam:"inline"`
	RouteProject4 *RouteProject4 `queryParam:"inline"`

	Type ProjectRouteUnion2Type
}

func CreateProjectRouteUnion2RouteProject3(routeProject3 RouteProject3) ProjectRouteUnion2 {
	typ := ProjectRouteUnion2TypeRouteProject3

	return ProjectRouteUnion2{
		RouteProject3: &routeProject3,
		Type:          typ,
	}
}

func CreateProjectRouteUnion2RouteProject4(routeProject4 RouteProject4) ProjectRouteUnion2 {
	typ := ProjectRouteUnion2TypeRouteProject4

	return ProjectRouteUnion2{
		RouteProject4: &routeProject4,
		Type:          typ,
	}
}

func (u *ProjectRouteUnion2) UnmarshalJSON(data []byte) error {

	var routeProject3 RouteProject3 = RouteProject3{}
	if err := utils.UnmarshalJSON(data, &routeProject3, "", true, nil); err == nil {
		u.RouteProject3 = &routeProject3
		u.Type = ProjectRouteUnion2TypeRouteProject3
		return nil
	}

	var routeProject4 RouteProject4 = RouteProject4{}
	if err := utils.UnmarshalJSON(data, &routeProject4, "", true, nil); err == nil {
		u.RouteProject4 = &routeProject4
		u.Type = ProjectRouteUnion2TypeRouteProject4
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectRouteUnion2", string(data))
}

func (u ProjectRouteUnion2) MarshalJSON() ([]byte, error) {
	if u.RouteProject3 != nil {
		return utils.MarshalJSON(u.RouteProject3, "", true)
	}

	if u.RouteProject4 != nil {
		return utils.MarshalJSON(u.RouteProject4, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectRouteUnion2: all fields are null")
}

type BlockHistoryProjectRouteUnblocked1 struct {
	Action              ProjectActionRouteUnblocked1 `json:"action"`
	Route               ProjectRouteUnion2           `json:"route"`
	StatusCode          *float64                     `json:"statusCode,omitempty"`
	CreatedAt           float64                      `json:"createdAt"`
	CaseID              *string                      `json:"caseId,omitempty"`
	Actor               *string                      `json:"actor,omitempty"`
	Comment             *string                      `json:"comment,omitempty"`
	IneligibleForAppeal *bool                        `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                        `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectRouteUnblocked1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectRouteUnblocked1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "route", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectRouteUnblocked1) GetAction() ProjectActionRouteUnblocked1 {
	if o == nil {
		return ProjectActionRouteUnblocked1("")
	}
	return o.Action
}

func (o *BlockHistoryProjectRouteUnblocked1) GetRoute() ProjectRouteUnion2 {
	if o == nil {
		return ProjectRouteUnion2{}
	}
	return o.Route
}

func (o *BlockHistoryProjectRouteUnblocked1) GetStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.StatusCode
}

func (o *BlockHistoryProjectRouteUnblocked1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectRouteUnblocked1) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectRouteUnblocked1) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectRouteUnblocked1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectRouteUnblocked1) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectRouteUnblocked1) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectActionRouteBlocked1 string

const (
	ProjectActionRouteBlocked1RouteBlocked ProjectActionRouteBlocked1 = "route-blocked"
)

func (e ProjectActionRouteBlocked1) ToPointer() *ProjectActionRouteBlocked1 {
	return &e
}
func (e *ProjectActionRouteBlocked1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "route-blocked":
		*e = ProjectActionRouteBlocked1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionRouteBlocked1: %v", v)
	}
}

type BlockHistoryProjectTypeHost1 string

const (
	BlockHistoryProjectTypeHost1Host BlockHistoryProjectTypeHost1 = "host"
)

func (e BlockHistoryProjectTypeHost1) ToPointer() *BlockHistoryProjectTypeHost1 {
	return &e
}
func (e *BlockHistoryProjectTypeHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = BlockHistoryProjectTypeHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHost1: %v", v)
	}
}

type BlockHistoryProjectValue2 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue2) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectHost1 struct {
	Type  BlockHistoryProjectTypeHost1 `json:"type"`
	Value BlockHistoryProjectValue2    `json:"value"`
}

func (b BlockHistoryHasProjectHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectHost1) GetType() BlockHistoryProjectTypeHost1 {
	if o == nil {
		return BlockHistoryProjectTypeHost1("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectHost1) GetValue() BlockHistoryProjectValue2 {
	if o == nil {
		return BlockHistoryProjectValue2{}
	}
	return o.Value
}

type BlockHistoryProjectTypeHeader1 string

const (
	BlockHistoryProjectTypeHeader1Header BlockHistoryProjectTypeHeader1 = "header"
)

func (e BlockHistoryProjectTypeHeader1) ToPointer() *BlockHistoryProjectTypeHeader1 {
	return &e
}
func (e *BlockHistoryProjectTypeHeader1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = BlockHistoryProjectTypeHeader1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHeader1: %v", v)
	}
}

type BlockHistoryProjectKey1 string

const (
	BlockHistoryProjectKey1XVercelIPCountry BlockHistoryProjectKey1 = "x-vercel-ip-country"
)

func (e BlockHistoryProjectKey1) ToPointer() *BlockHistoryProjectKey1 {
	return &e
}
func (e *BlockHistoryProjectKey1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = BlockHistoryProjectKey1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectKey1: %v", v)
	}
}

type BlockHistoryProjectValue1 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue1) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectXVercelIPCountry1 struct {
	Type  BlockHistoryProjectTypeHeader1 `json:"type"`
	Key   BlockHistoryProjectKey1        `json:"key"`
	Value BlockHistoryProjectValue1      `json:"value"`
}

func (b BlockHistoryHasProjectXVercelIPCountry1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectXVercelIPCountry1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectXVercelIPCountry1) GetType() BlockHistoryProjectTypeHeader1 {
	if o == nil {
		return BlockHistoryProjectTypeHeader1("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectXVercelIPCountry1) GetKey() BlockHistoryProjectKey1 {
	if o == nil {
		return BlockHistoryProjectKey1("")
	}
	return o.Key
}

func (o *BlockHistoryHasProjectXVercelIPCountry1) GetValue() BlockHistoryProjectValue1 {
	if o == nil {
		return BlockHistoryProjectValue1{}
	}
	return o.Value
}

type BlockHistoryProjectHasUnion1Type string

const (
	BlockHistoryProjectHasUnion1TypeHeader BlockHistoryProjectHasUnion1Type = "header"
	BlockHistoryProjectHasUnion1TypeHost   BlockHistoryProjectHasUnion1Type = "host"
)

type BlockHistoryProjectHasUnion1 struct {
	BlockHistoryHasProjectXVercelIPCountry1 *BlockHistoryHasProjectXVercelIPCountry1 `queryParam:"inline"`
	BlockHistoryHasProjectHost1             *BlockHistoryHasProjectHost1             `queryParam:"inline"`

	Type BlockHistoryProjectHasUnion1Type
}

func CreateBlockHistoryProjectHasUnion1Header(header BlockHistoryHasProjectXVercelIPCountry1) BlockHistoryProjectHasUnion1 {
	typ := BlockHistoryProjectHasUnion1TypeHeader

	typStr := BlockHistoryProjectTypeHeader1(typ)
	header.Type = typStr

	return BlockHistoryProjectHasUnion1{
		BlockHistoryHasProjectXVercelIPCountry1: &header,
		Type:                                    typ,
	}
}

func CreateBlockHistoryProjectHasUnion1Host(host BlockHistoryHasProjectHost1) BlockHistoryProjectHasUnion1 {
	typ := BlockHistoryProjectHasUnion1TypeHost

	typStr := BlockHistoryProjectTypeHost1(typ)
	host.Type = typStr

	return BlockHistoryProjectHasUnion1{
		BlockHistoryHasProjectHost1: &host,
		Type:                        typ,
	}
}

func (u *BlockHistoryProjectHasUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		blockHistoryHasProjectXVercelIPCountry1 := new(BlockHistoryHasProjectXVercelIPCountry1)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectXVercelIPCountry1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type BlockHistoryHasProjectXVercelIPCountry1 within BlockHistoryProjectHasUnion1: %w", string(data), err)
		}

		u.BlockHistoryHasProjectXVercelIPCountry1 = blockHistoryHasProjectXVercelIPCountry1
		u.Type = BlockHistoryProjectHasUnion1TypeHeader
		return nil
	case "host":
		blockHistoryHasProjectHost1 := new(BlockHistoryHasProjectHost1)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectHost1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type BlockHistoryHasProjectHost1 within BlockHistoryProjectHasUnion1: %w", string(data), err)
		}

		u.BlockHistoryHasProjectHost1 = blockHistoryHasProjectHost1
		u.Type = BlockHistoryProjectHasUnion1TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BlockHistoryProjectHasUnion1", string(data))
}

func (u BlockHistoryProjectHasUnion1) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryHasProjectXVercelIPCountry1 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectXVercelIPCountry1, "", true)
	}

	if u.BlockHistoryHasProjectHost1 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectHost1, "", true)
	}

	return nil, errors.New("could not marshal union type BlockHistoryProjectHasUnion1: all fields are null")
}

type RouteProjectAction1 string

const (
	RouteProjectAction1BlockLegalCwc RouteProjectAction1 = "block_legal_cwc"
)

func (e RouteProjectAction1) ToPointer() *RouteProjectAction1 {
	return &e
}
func (e *RouteProjectAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = RouteProjectAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteProjectAction1: %v", v)
	}
}

type BlockHistoryProjectMitigate1 struct {
	Action RouteProjectAction1 `json:"action"`
}

func (b BlockHistoryProjectMitigate1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectMitigate1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectMitigate1) GetAction() RouteProjectAction1 {
	if o == nil {
		return RouteProjectAction1("")
	}
	return o.Action
}

type RouteProject2 struct {
	Has      []BlockHistoryProjectHasUnion1 `json:"has"`
	Mitigate BlockHistoryProjectMitigate1   `json:"mitigate"`
	Src      *string                        `json:"src,omitempty"`
}

func (r RouteProject2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject2) GetHas() []BlockHistoryProjectHasUnion1 {
	if o == nil {
		return []BlockHistoryProjectHasUnion1{}
	}
	return o.Has
}

func (o *RouteProject2) GetMitigate() BlockHistoryProjectMitigate1 {
	if o == nil {
		return BlockHistoryProjectMitigate1{}
	}
	return o.Mitigate
}

func (o *RouteProject2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type RouteProject1 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (r RouteProject1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *RouteProject1) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectRouteUnion1Type string

const (
	ProjectRouteUnion1TypeRouteProject1 ProjectRouteUnion1Type = "route_project_1"
	ProjectRouteUnion1TypeRouteProject2 ProjectRouteUnion1Type = "route_project_2"
)

type ProjectRouteUnion1 struct {
	RouteProject1 *RouteProject1 `queryParam:"inline"`
	RouteProject2 *RouteProject2 `queryParam:"inline"`

	Type ProjectRouteUnion1Type
}

func CreateProjectRouteUnion1RouteProject1(routeProject1 RouteProject1) ProjectRouteUnion1 {
	typ := ProjectRouteUnion1TypeRouteProject1

	return ProjectRouteUnion1{
		RouteProject1: &routeProject1,
		Type:          typ,
	}
}

func CreateProjectRouteUnion1RouteProject2(routeProject2 RouteProject2) ProjectRouteUnion1 {
	typ := ProjectRouteUnion1TypeRouteProject2

	return ProjectRouteUnion1{
		RouteProject2: &routeProject2,
		Type:          typ,
	}
}

func (u *ProjectRouteUnion1) UnmarshalJSON(data []byte) error {

	var routeProject1 RouteProject1 = RouteProject1{}
	if err := utils.UnmarshalJSON(data, &routeProject1, "", true, nil); err == nil {
		u.RouteProject1 = &routeProject1
		u.Type = ProjectRouteUnion1TypeRouteProject1
		return nil
	}

	var routeProject2 RouteProject2 = RouteProject2{}
	if err := utils.UnmarshalJSON(data, &routeProject2, "", true, nil); err == nil {
		u.RouteProject2 = &routeProject2
		u.Type = ProjectRouteUnion1TypeRouteProject2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectRouteUnion1", string(data))
}

func (u ProjectRouteUnion1) MarshalJSON() ([]byte, error) {
	if u.RouteProject1 != nil {
		return utils.MarshalJSON(u.RouteProject1, "", true)
	}

	if u.RouteProject2 != nil {
		return utils.MarshalJSON(u.RouteProject2, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectRouteUnion1: all fields are null")
}

type BlockHistoryProjectRouteBlocked1 struct {
	Action              ProjectActionRouteBlocked1 `json:"action"`
	Route               ProjectRouteUnion1         `json:"route"`
	Reason              string                     `json:"reason"`
	CreatedAt           float64                    `json:"createdAt"`
	CaseID              *string                    `json:"caseId,omitempty"`
	Actor               *string                    `json:"actor,omitempty"`
	Comment             *string                    `json:"comment,omitempty"`
	IneligibleForAppeal *bool                      `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                      `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectRouteBlocked1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectRouteBlocked1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "route", "reason", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectRouteBlocked1) GetAction() ProjectActionRouteBlocked1 {
	if o == nil {
		return ProjectActionRouteBlocked1("")
	}
	return o.Action
}

func (o *BlockHistoryProjectRouteBlocked1) GetRoute() ProjectRouteUnion1 {
	if o == nil {
		return ProjectRouteUnion1{}
	}
	return o.Route
}

func (o *BlockHistoryProjectRouteBlocked1) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *BlockHistoryProjectRouteBlocked1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectRouteBlocked1) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectRouteBlocked1) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectRouteBlocked1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectRouteBlocked1) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectRouteBlocked1) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectActionUnblocked1 string

const (
	ProjectActionUnblocked1Unblocked ProjectActionUnblocked1 = "unblocked"
)

func (e ProjectActionUnblocked1) ToPointer() *ProjectActionUnblocked1 {
	return &e
}
func (e *ProjectActionUnblocked1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unblocked":
		*e = ProjectActionUnblocked1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionUnblocked1: %v", v)
	}
}

type BlockHistoryProjectUnblocked1 struct {
	Action              ProjectActionUnblocked1 `json:"action"`
	CreatedAt           float64                 `json:"createdAt"`
	CaseID              *string                 `json:"caseId,omitempty"`
	Actor               *string                 `json:"actor,omitempty"`
	Comment             *string                 `json:"comment,omitempty"`
	IneligibleForAppeal *bool                   `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                   `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectUnblocked1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectUnblocked1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectUnblocked1) GetAction() ProjectActionUnblocked1 {
	if o == nil {
		return ProjectActionUnblocked1("")
	}
	return o.Action
}

func (o *BlockHistoryProjectUnblocked1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectUnblocked1) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectUnblocked1) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectUnblocked1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectUnblocked1) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectUnblocked1) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type BlockHistoryProjectActionBlocked1 string

const (
	BlockHistoryProjectActionBlocked1Blocked BlockHistoryProjectActionBlocked1 = "blocked"
)

func (e BlockHistoryProjectActionBlocked1) ToPointer() *BlockHistoryProjectActionBlocked1 {
	return &e
}
func (e *BlockHistoryProjectActionBlocked1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blocked":
		*e = BlockHistoryProjectActionBlocked1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectActionBlocked1: %v", v)
	}
}

type BlockHistoryProjectBlocked1 struct {
	Action              BlockHistoryProjectActionBlocked1 `json:"action"`
	Reason              string                            `json:"reason"`
	StatusCode          float64                           `json:"statusCode"`
	CreatedAt           float64                           `json:"createdAt"`
	CaseID              *string                           `json:"caseId,omitempty"`
	Actor               *string                           `json:"actor,omitempty"`
	Comment             *string                           `json:"comment,omitempty"`
	IneligibleForAppeal *bool                             `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                             `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectBlocked1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectBlocked1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "reason", "statusCode", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectBlocked1) GetAction() BlockHistoryProjectActionBlocked1 {
	if o == nil {
		return BlockHistoryProjectActionBlocked1("")
	}
	return o.Action
}

func (o *BlockHistoryProjectBlocked1) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *BlockHistoryProjectBlocked1) GetStatusCode() float64 {
	if o == nil {
		return 0.0
	}
	return o.StatusCode
}

func (o *BlockHistoryProjectBlocked1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectBlocked1) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectBlocked1) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectBlocked1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectBlocked1) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectBlocked1) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectBlockHistoryUnion1Type string

const (
	ProjectBlockHistoryUnion1TypeBlocked        ProjectBlockHistoryUnion1Type = "blocked"
	ProjectBlockHistoryUnion1TypeUnblocked      ProjectBlockHistoryUnion1Type = "unblocked"
	ProjectBlockHistoryUnion1TypeRouteBlocked   ProjectBlockHistoryUnion1Type = "route-blocked"
	ProjectBlockHistoryUnion1TypeRouteUnblocked ProjectBlockHistoryUnion1Type = "route-unblocked"
)

type ProjectBlockHistoryUnion1 struct {
	BlockHistoryProjectBlocked1        *BlockHistoryProjectBlocked1        `queryParam:"inline"`
	BlockHistoryProjectUnblocked1      *BlockHistoryProjectUnblocked1      `queryParam:"inline"`
	BlockHistoryProjectRouteBlocked1   *BlockHistoryProjectRouteBlocked1   `queryParam:"inline"`
	BlockHistoryProjectRouteUnblocked1 *BlockHistoryProjectRouteUnblocked1 `queryParam:"inline"`

	Type ProjectBlockHistoryUnion1Type
}

func CreateProjectBlockHistoryUnion1Blocked(blocked BlockHistoryProjectBlocked1) ProjectBlockHistoryUnion1 {
	typ := ProjectBlockHistoryUnion1TypeBlocked

	typStr := BlockHistoryProjectActionBlocked1(typ)
	blocked.Action = typStr

	return ProjectBlockHistoryUnion1{
		BlockHistoryProjectBlocked1: &blocked,
		Type:                        typ,
	}
}

func CreateProjectBlockHistoryUnion1Unblocked(unblocked BlockHistoryProjectUnblocked1) ProjectBlockHistoryUnion1 {
	typ := ProjectBlockHistoryUnion1TypeUnblocked

	typStr := ProjectActionUnblocked1(typ)
	unblocked.Action = typStr

	return ProjectBlockHistoryUnion1{
		BlockHistoryProjectUnblocked1: &unblocked,
		Type:                          typ,
	}
}

func CreateProjectBlockHistoryUnion1RouteBlocked(routeBlocked BlockHistoryProjectRouteBlocked1) ProjectBlockHistoryUnion1 {
	typ := ProjectBlockHistoryUnion1TypeRouteBlocked

	typStr := ProjectActionRouteBlocked1(typ)
	routeBlocked.Action = typStr

	return ProjectBlockHistoryUnion1{
		BlockHistoryProjectRouteBlocked1: &routeBlocked,
		Type:                             typ,
	}
}

func CreateProjectBlockHistoryUnion1RouteUnblocked(routeUnblocked BlockHistoryProjectRouteUnblocked1) ProjectBlockHistoryUnion1 {
	typ := ProjectBlockHistoryUnion1TypeRouteUnblocked

	typStr := ProjectActionRouteUnblocked1(typ)
	routeUnblocked.Action = typStr

	return ProjectBlockHistoryUnion1{
		BlockHistoryProjectRouteUnblocked1: &routeUnblocked,
		Type:                               typ,
	}
}

func (u *ProjectBlockHistoryUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Action string `json:"action"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Action {
	case "blocked":
		blockHistoryProjectBlocked1 := new(BlockHistoryProjectBlocked1)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectBlocked1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == blocked) type BlockHistoryProjectBlocked1 within ProjectBlockHistoryUnion1: %w", string(data), err)
		}

		u.BlockHistoryProjectBlocked1 = blockHistoryProjectBlocked1
		u.Type = ProjectBlockHistoryUnion1TypeBlocked
		return nil
	case "unblocked":
		blockHistoryProjectUnblocked1 := new(BlockHistoryProjectUnblocked1)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectUnblocked1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == unblocked) type BlockHistoryProjectUnblocked1 within ProjectBlockHistoryUnion1: %w", string(data), err)
		}

		u.BlockHistoryProjectUnblocked1 = blockHistoryProjectUnblocked1
		u.Type = ProjectBlockHistoryUnion1TypeUnblocked
		return nil
	case "route-blocked":
		blockHistoryProjectRouteBlocked1 := new(BlockHistoryProjectRouteBlocked1)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectRouteBlocked1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-blocked) type BlockHistoryProjectRouteBlocked1 within ProjectBlockHistoryUnion1: %w", string(data), err)
		}

		u.BlockHistoryProjectRouteBlocked1 = blockHistoryProjectRouteBlocked1
		u.Type = ProjectBlockHistoryUnion1TypeRouteBlocked
		return nil
	case "route-unblocked":
		blockHistoryProjectRouteUnblocked1 := new(BlockHistoryProjectRouteUnblocked1)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectRouteUnblocked1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-unblocked) type BlockHistoryProjectRouteUnblocked1 within ProjectBlockHistoryUnion1: %w", string(data), err)
		}

		u.BlockHistoryProjectRouteUnblocked1 = blockHistoryProjectRouteUnblocked1
		u.Type = ProjectBlockHistoryUnion1TypeRouteUnblocked
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectBlockHistoryUnion1", string(data))
}

func (u ProjectBlockHistoryUnion1) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryProjectBlocked1 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectBlocked1, "", true)
	}

	if u.BlockHistoryProjectUnblocked1 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectUnblocked1, "", true)
	}

	if u.BlockHistoryProjectRouteBlocked1 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectRouteBlocked1, "", true)
	}

	if u.BlockHistoryProjectRouteUnblocked1 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectRouteUnblocked1, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectBlockHistoryUnion1: all fields are null")
}

type ProjectAbuse1 struct {
	Scanner      *string                     `json:"scanner,omitempty"`
	History      []ProjectHistory1           `json:"history"`
	UpdatedAt    float64                     `json:"updatedAt"`
	Block        *ProjectBlock1              `json:"block,omitempty"`
	BlockHistory []ProjectBlockHistoryUnion1 `json:"blockHistory,omitempty"`
	Interstitial *bool                       `json:"interstitial,omitempty"`
}

func (p ProjectAbuse1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectAbuse1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"history", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectAbuse1) GetScanner() *string {
	if o == nil {
		return nil
	}
	return o.Scanner
}

func (o *ProjectAbuse1) GetHistory() []ProjectHistory1 {
	if o == nil {
		return []ProjectHistory1{}
	}
	return o.History
}

func (o *ProjectAbuse1) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *ProjectAbuse1) GetBlock() *ProjectBlock1 {
	if o == nil {
		return nil
	}
	return o.Block
}

func (o *ProjectAbuse1) GetBlockHistory() []ProjectBlockHistoryUnion1 {
	if o == nil {
		return nil
	}
	return o.BlockHistory
}

func (o *ProjectAbuse1) GetInterstitial() *bool {
	if o == nil {
		return nil
	}
	return o.Interstitial
}

type InternalRouteProjectTypeHost1 string

const (
	InternalRouteProjectTypeHost1Host InternalRouteProjectTypeHost1 = "host"
)

func (e InternalRouteProjectTypeHost1) ToPointer() *InternalRouteProjectTypeHost1 {
	return &e
}
func (e *InternalRouteProjectTypeHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = InternalRouteProjectTypeHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectTypeHost1: %v", v)
	}
}

type InternalRouteProjectValue2 struct {
	Eq string `json:"eq"`
}

func (i InternalRouteProjectValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectValue2) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type InternalRouteHasProjectHost1 struct {
	Type  InternalRouteProjectTypeHost1 `json:"type"`
	Value InternalRouteProjectValue2    `json:"value"`
}

func (i InternalRouteHasProjectHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteHasProjectHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteHasProjectHost1) GetType() InternalRouteProjectTypeHost1 {
	if o == nil {
		return InternalRouteProjectTypeHost1("")
	}
	return o.Type
}

func (o *InternalRouteHasProjectHost1) GetValue() InternalRouteProjectValue2 {
	if o == nil {
		return InternalRouteProjectValue2{}
	}
	return o.Value
}

type InternalRouteProjectTypeHeader1 string

const (
	InternalRouteProjectTypeHeader1Header InternalRouteProjectTypeHeader1 = "header"
)

func (e InternalRouteProjectTypeHeader1) ToPointer() *InternalRouteProjectTypeHeader1 {
	return &e
}
func (e *InternalRouteProjectTypeHeader1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = InternalRouteProjectTypeHeader1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectTypeHeader1: %v", v)
	}
}

type InternalRouteProjectKey1 string

const (
	InternalRouteProjectKey1XVercelIPCountry InternalRouteProjectKey1 = "x-vercel-ip-country"
)

func (e InternalRouteProjectKey1) ToPointer() *InternalRouteProjectKey1 {
	return &e
}
func (e *InternalRouteProjectKey1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = InternalRouteProjectKey1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectKey1: %v", v)
	}
}

type InternalRouteProjectValue1 struct {
	Eq string `json:"eq"`
}

func (i InternalRouteProjectValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectValue1) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type InternalRouteHasProjectXVercelIPCountry1 struct {
	Type  InternalRouteProjectTypeHeader1 `json:"type"`
	Key   InternalRouteProjectKey1        `json:"key"`
	Value InternalRouteProjectValue1      `json:"value"`
}

func (i InternalRouteHasProjectXVercelIPCountry1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteHasProjectXVercelIPCountry1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteHasProjectXVercelIPCountry1) GetType() InternalRouteProjectTypeHeader1 {
	if o == nil {
		return InternalRouteProjectTypeHeader1("")
	}
	return o.Type
}

func (o *InternalRouteHasProjectXVercelIPCountry1) GetKey() InternalRouteProjectKey1 {
	if o == nil {
		return InternalRouteProjectKey1("")
	}
	return o.Key
}

func (o *InternalRouteHasProjectXVercelIPCountry1) GetValue() InternalRouteProjectValue1 {
	if o == nil {
		return InternalRouteProjectValue1{}
	}
	return o.Value
}

type InternalRouteProjectHasUnion1Type string

const (
	InternalRouteProjectHasUnion1TypeHeader InternalRouteProjectHasUnion1Type = "header"
	InternalRouteProjectHasUnion1TypeHost   InternalRouteProjectHasUnion1Type = "host"
)

type InternalRouteProjectHasUnion1 struct {
	InternalRouteHasProjectXVercelIPCountry1 *InternalRouteHasProjectXVercelIPCountry1 `queryParam:"inline"`
	InternalRouteHasProjectHost1             *InternalRouteHasProjectHost1             `queryParam:"inline"`

	Type InternalRouteProjectHasUnion1Type
}

func CreateInternalRouteProjectHasUnion1Header(header InternalRouteHasProjectXVercelIPCountry1) InternalRouteProjectHasUnion1 {
	typ := InternalRouteProjectHasUnion1TypeHeader

	typStr := InternalRouteProjectTypeHeader1(typ)
	header.Type = typStr

	return InternalRouteProjectHasUnion1{
		InternalRouteHasProjectXVercelIPCountry1: &header,
		Type:                                     typ,
	}
}

func CreateInternalRouteProjectHasUnion1Host(host InternalRouteHasProjectHost1) InternalRouteProjectHasUnion1 {
	typ := InternalRouteProjectHasUnion1TypeHost

	typStr := InternalRouteProjectTypeHost1(typ)
	host.Type = typStr

	return InternalRouteProjectHasUnion1{
		InternalRouteHasProjectHost1: &host,
		Type:                         typ,
	}
}

func (u *InternalRouteProjectHasUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		internalRouteHasProjectXVercelIPCountry1 := new(InternalRouteHasProjectXVercelIPCountry1)
		if err := utils.UnmarshalJSON(data, &internalRouteHasProjectXVercelIPCountry1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type InternalRouteHasProjectXVercelIPCountry1 within InternalRouteProjectHasUnion1: %w", string(data), err)
		}

		u.InternalRouteHasProjectXVercelIPCountry1 = internalRouteHasProjectXVercelIPCountry1
		u.Type = InternalRouteProjectHasUnion1TypeHeader
		return nil
	case "host":
		internalRouteHasProjectHost1 := new(InternalRouteHasProjectHost1)
		if err := utils.UnmarshalJSON(data, &internalRouteHasProjectHost1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type InternalRouteHasProjectHost1 within InternalRouteProjectHasUnion1: %w", string(data), err)
		}

		u.InternalRouteHasProjectHost1 = internalRouteHasProjectHost1
		u.Type = InternalRouteProjectHasUnion1TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InternalRouteProjectHasUnion1", string(data))
}

func (u InternalRouteProjectHasUnion1) MarshalJSON() ([]byte, error) {
	if u.InternalRouteHasProjectXVercelIPCountry1 != nil {
		return utils.MarshalJSON(u.InternalRouteHasProjectXVercelIPCountry1, "", true)
	}

	if u.InternalRouteHasProjectHost1 != nil {
		return utils.MarshalJSON(u.InternalRouteHasProjectHost1, "", true)
	}

	return nil, errors.New("could not marshal union type InternalRouteProjectHasUnion1: all fields are null")
}

type InternalRouteProjectAction1 string

const (
	InternalRouteProjectAction1BlockLegalCwc InternalRouteProjectAction1 = "block_legal_cwc"
)

func (e InternalRouteProjectAction1) ToPointer() *InternalRouteProjectAction1 {
	return &e
}
func (e *InternalRouteProjectAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = InternalRouteProjectAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectAction1: %v", v)
	}
}

type InternalRouteProjectMitigate1 struct {
	Action InternalRouteProjectAction1 `json:"action"`
}

func (i InternalRouteProjectMitigate1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectMitigate1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectMitigate1) GetAction() InternalRouteProjectAction1 {
	if o == nil {
		return InternalRouteProjectAction1("")
	}
	return o.Action
}

type InternalRouteProject2 struct {
	Has      []InternalRouteProjectHasUnion1 `json:"has"`
	Mitigate InternalRouteProjectMitigate1   `json:"mitigate"`
	Src      *string                         `json:"src,omitempty"`
}

func (i InternalRouteProject2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProject2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProject2) GetHas() []InternalRouteProjectHasUnion1 {
	if o == nil {
		return []InternalRouteProjectHasUnion1{}
	}
	return o.Has
}

func (o *InternalRouteProject2) GetMitigate() InternalRouteProjectMitigate1 {
	if o == nil {
		return InternalRouteProjectMitigate1{}
	}
	return o.Mitigate
}

func (o *InternalRouteProject2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type InternalRouteProject1 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (i InternalRouteProject1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProject1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProject1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *InternalRouteProject1) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectInternalRouteUnion1Type string

const (
	ProjectInternalRouteUnion1TypeInternalRouteProject1 ProjectInternalRouteUnion1Type = "internalRoute_project_1"
	ProjectInternalRouteUnion1TypeInternalRouteProject2 ProjectInternalRouteUnion1Type = "internalRoute_project_2"
)

type ProjectInternalRouteUnion1 struct {
	InternalRouteProject1 *InternalRouteProject1 `queryParam:"inline"`
	InternalRouteProject2 *InternalRouteProject2 `queryParam:"inline"`

	Type ProjectInternalRouteUnion1Type
}

func CreateProjectInternalRouteUnion1InternalRouteProject1(internalRouteProject1 InternalRouteProject1) ProjectInternalRouteUnion1 {
	typ := ProjectInternalRouteUnion1TypeInternalRouteProject1

	return ProjectInternalRouteUnion1{
		InternalRouteProject1: &internalRouteProject1,
		Type:                  typ,
	}
}

func CreateProjectInternalRouteUnion1InternalRouteProject2(internalRouteProject2 InternalRouteProject2) ProjectInternalRouteUnion1 {
	typ := ProjectInternalRouteUnion1TypeInternalRouteProject2

	return ProjectInternalRouteUnion1{
		InternalRouteProject2: &internalRouteProject2,
		Type:                  typ,
	}
}

func (u *ProjectInternalRouteUnion1) UnmarshalJSON(data []byte) error {

	var internalRouteProject1 InternalRouteProject1 = InternalRouteProject1{}
	if err := utils.UnmarshalJSON(data, &internalRouteProject1, "", true, nil); err == nil {
		u.InternalRouteProject1 = &internalRouteProject1
		u.Type = ProjectInternalRouteUnion1TypeInternalRouteProject1
		return nil
	}

	var internalRouteProject2 InternalRouteProject2 = InternalRouteProject2{}
	if err := utils.UnmarshalJSON(data, &internalRouteProject2, "", true, nil); err == nil {
		u.InternalRouteProject2 = &internalRouteProject2
		u.Type = ProjectInternalRouteUnion1TypeInternalRouteProject2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectInternalRouteUnion1", string(data))
}

func (u ProjectInternalRouteUnion1) MarshalJSON() ([]byte, error) {
	if u.InternalRouteProject1 != nil {
		return utils.MarshalJSON(u.InternalRouteProject1, "", true)
	}

	if u.InternalRouteProject2 != nil {
		return utils.MarshalJSON(u.InternalRouteProject2, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectInternalRouteUnion1: all fields are null")
}

type GetProjectsProject1 struct {
	AccountID                        string             `json:"accountId"`
	Alias                            []ProjectAlias     `json:"alias"`
	Analytics                        *ProjectAnalytics1 `json:"analytics,omitempty"`
	AppliedCve55182Migration         *bool              `json:"appliedCve55182Migration,omitempty"`
	AutoExposeSystemEnvs             *bool              `json:"autoExposeSystemEnvs,omitempty"`
	AutoAssignCustomDomains          *bool              `json:"autoAssignCustomDomains,omitempty"`
	AutoAssignCustomDomainsUpdatedBy *string            `json:"autoAssignCustomDomainsUpdatedBy,omitempty"`
	BuildCommand                     *string            `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep      *string            `json:"commandForIgnoringBuildStep,omitempty"`
	CustomerSupportCodeVisibility    *bool              `json:"customerSupportCodeVisibility,omitempty"`
	CreatedAt                        *float64           `json:"createdAt,omitempty"`
	DevCommand                       *string            `json:"devCommand,omitempty"`
	DirectoryListing                 bool               `json:"directoryListing"`
	// Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
	DeploymentExpiration ProjectDeploymentExpiration1 `json:"deploymentExpiration"`
	InstallCommand       *string                      `json:"installCommand,omitempty"`
	IPBuckets            []ProjectIPBucket1           `json:"ipBuckets,omitempty"`
	Env                  []ProjectEnv1                `json:"env,omitempty"`
	Framework            *ProjectFramework1           `json:"framework,omitempty"`
	GitForkProtection    *bool                        `json:"gitForkProtection,omitempty"`
	ID                   string                       `json:"id"`
	LatestDeployments    []ProjectLatestDeployment1   `json:"latestDeployments,omitempty"`
	Link                 *ProjectLinkUnion1           `json:"link,omitempty"`
	Name                 string                       `json:"name"`
	NodeVersion          ProjectNodeVersion1          `json:"nodeVersion"`
	OutputDirectory      *string                      `json:"outputDirectory,omitempty"`
	PasswordProtection   *ProjectPasswordProtection1  `json:"passwordProtection,omitempty"`
	PublicSource         *bool                        `json:"publicSource,omitempty"`
	ResourceConfig       ProjectResourceConfig1       `json:"resourceConfig"`
	// Project-level rolling release configuration that defines how deployments should be gradually rolled out
	RollingRelease                       *ProjectRollingRelease1      `json:"rollingRelease,omitempty"`
	RootDirectory                        *string                      `json:"rootDirectory,omitempty"`
	ServerlessFunctionRegion             string                       `json:"serverlessFunctionRegion"`
	ServerlessFunctionZeroConfigFailover *bool                        `json:"serverlessFunctionZeroConfigFailover,omitempty"`
	SpeedInsights                        *ProjectSpeedInsights1       `json:"speedInsights,omitempty"`
	SkipGitConnectDuringLink             *bool                        `json:"skipGitConnectDuringLink,omitempty"`
	SourceFilesOutsideRootDirectory      *bool                        `json:"sourceFilesOutsideRootDirectory,omitempty"`
	SsoProtection                        *ProjectSsoProtection1       `json:"ssoProtection,omitempty"`
	Targets                              map[string]*ProjectTargets1  `json:"targets,omitempty"`
	TransferCompletedAt                  *float64                     `json:"transferCompletedAt,omitempty"`
	TransferStartedAt                    *float64                     `json:"transferStartedAt,omitempty"`
	TransferToAccountID                  *string                      `json:"transferToAccountId,omitempty"`
	TransferredFromAccountID             *string                      `json:"transferredFromAccountId,omitempty"`
	UpdatedAt                            *float64                     `json:"updatedAt,omitempty"`
	Live                                 *bool                        `json:"live,omitempty"`
	HasActiveBranches                    *bool                        `json:"hasActiveBranches,omitempty"`
	GitComments                          *ProjectGitComments1         `json:"gitComments,omitempty"`
	GitProviderOptions                   *ProjectGitProviderOptions1  `json:"gitProviderOptions,omitempty"`
	Paused                               *bool                        `json:"paused,omitempty"`
	WebAnalytics                         *ProjectWebAnalytics1        `json:"webAnalytics,omitempty"`
	Security                             *ProjectSecurity1            `json:"security,omitempty"`
	OidcTokenConfig                      *ProjectOidcTokenConfig1     `json:"oidcTokenConfig,omitempty"`
	Tier                                 *ProjectTier1                `json:"tier,omitempty"`
	Abuse                                *ProjectAbuse1               `json:"abuse,omitempty"`
	InternalRoutes                       []ProjectInternalRouteUnion1 `json:"internalRoutes,omitempty"`
}

func (g GetProjectsProject1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsProject1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"accountId", "alias", "directoryListing", "deploymentExpiration", "id", "name", "nodeVersion", "resourceConfig", "serverlessFunctionRegion"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsProject1) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *GetProjectsProject1) GetAlias() []ProjectAlias {
	if o == nil {
		return []ProjectAlias{}
	}
	return o.Alias
}

func (o *GetProjectsProject1) GetAnalytics() *ProjectAnalytics1 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetProjectsProject1) GetAppliedCve55182Migration() *bool {
	if o == nil {
		return nil
	}
	return o.AppliedCve55182Migration
}

func (o *GetProjectsProject1) GetAutoExposeSystemEnvs() *bool {
	if o == nil {
		return nil
	}
	return o.AutoExposeSystemEnvs
}

func (o *GetProjectsProject1) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *GetProjectsProject1) GetAutoAssignCustomDomainsUpdatedBy() *string {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomainsUpdatedBy
}

func (o *GetProjectsProject1) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *GetProjectsProject1) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *GetProjectsProject1) GetCustomerSupportCodeVisibility() *bool {
	if o == nil {
		return nil
	}
	return o.CustomerSupportCodeVisibility
}

func (o *GetProjectsProject1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsProject1) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *GetProjectsProject1) GetDirectoryListing() bool {
	if o == nil {
		return false
	}
	return o.DirectoryListing
}

func (o *GetProjectsProject1) GetDeploymentExpiration() ProjectDeploymentExpiration1 {
	if o == nil {
		return ProjectDeploymentExpiration1{}
	}
	return o.DeploymentExpiration
}

func (o *GetProjectsProject1) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *GetProjectsProject1) GetIPBuckets() []ProjectIPBucket1 {
	if o == nil {
		return nil
	}
	return o.IPBuckets
}

func (o *GetProjectsProject1) GetEnv() []ProjectEnv1 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetProjectsProject1) GetFramework() *ProjectFramework1 {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *GetProjectsProject1) GetGitForkProtection() *bool {
	if o == nil {
		return nil
	}
	return o.GitForkProtection
}

func (o *GetProjectsProject1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsProject1) GetLatestDeployments() []ProjectLatestDeployment1 {
	if o == nil {
		return nil
	}
	return o.LatestDeployments
}

func (o *GetProjectsProject1) GetLink() *ProjectLinkUnion1 {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *GetProjectsProject1) GetLinkGithub() *LinkProjectGithub1 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithub1
	}
	return nil
}

func (o *GetProjectsProject1) GetLinkGithubLimited() *LinkProjectGithubLimited1 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithubLimited1
	}
	return nil
}

func (o *GetProjectsProject1) GetLinkGithubCustomHost() *LinkProjectGithubCustomHost1 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithubCustomHost1
	}
	return nil
}

func (o *GetProjectsProject1) GetLinkGitlab() *LinkProjectGitlab1 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGitlab1
	}
	return nil
}

func (o *GetProjectsProject1) GetLinkBitbucket() *LinkProjectBitbucket1 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectBitbucket1
	}
	return nil
}

func (o *GetProjectsProject1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsProject1) GetNodeVersion() ProjectNodeVersion1 {
	if o == nil {
		return ProjectNodeVersion1("")
	}
	return o.NodeVersion
}

func (o *GetProjectsProject1) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *GetProjectsProject1) GetPasswordProtection() *ProjectPasswordProtection1 {
	if o == nil {
		return nil
	}
	return o.PasswordProtection
}

func (o *GetProjectsProject1) GetPublicSource() *bool {
	if o == nil {
		return nil
	}
	return o.PublicSource
}

func (o *GetProjectsProject1) GetResourceConfig() ProjectResourceConfig1 {
	if o == nil {
		return ProjectResourceConfig1{}
	}
	return o.ResourceConfig
}

func (o *GetProjectsProject1) GetRollingRelease() *ProjectRollingRelease1 {
	if o == nil {
		return nil
	}
	return o.RollingRelease
}

func (o *GetProjectsProject1) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *GetProjectsProject1) GetServerlessFunctionRegion() string {
	if o == nil {
		return ""
	}
	return o.ServerlessFunctionRegion
}

func (o *GetProjectsProject1) GetServerlessFunctionZeroConfigFailover() *bool {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionZeroConfigFailover
}

func (o *GetProjectsProject1) GetSpeedInsights() *ProjectSpeedInsights1 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

func (o *GetProjectsProject1) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *GetProjectsProject1) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

func (o *GetProjectsProject1) GetSsoProtection() *ProjectSsoProtection1 {
	if o == nil {
		return nil
	}
	return o.SsoProtection
}

func (o *GetProjectsProject1) GetTargets() map[string]*ProjectTargets1 {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *GetProjectsProject1) GetTransferCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferCompletedAt
}

func (o *GetProjectsProject1) GetTransferStartedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferStartedAt
}

func (o *GetProjectsProject1) GetTransferToAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferToAccountID
}

func (o *GetProjectsProject1) GetTransferredFromAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferredFromAccountID
}

func (o *GetProjectsProject1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsProject1) GetLive() *bool {
	if o == nil {
		return nil
	}
	return o.Live
}

func (o *GetProjectsProject1) GetHasActiveBranches() *bool {
	if o == nil {
		return nil
	}
	return o.HasActiveBranches
}

func (o *GetProjectsProject1) GetGitComments() *ProjectGitComments1 {
	if o == nil {
		return nil
	}
	return o.GitComments
}

func (o *GetProjectsProject1) GetGitProviderOptions() *ProjectGitProviderOptions1 {
	if o == nil {
		return nil
	}
	return o.GitProviderOptions
}

func (o *GetProjectsProject1) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *GetProjectsProject1) GetWebAnalytics() *ProjectWebAnalytics1 {
	if o == nil {
		return nil
	}
	return o.WebAnalytics
}

func (o *GetProjectsProject1) GetSecurity() *ProjectSecurity1 {
	if o == nil {
		return nil
	}
	return o.Security
}

func (o *GetProjectsProject1) GetOidcTokenConfig() *ProjectOidcTokenConfig1 {
	if o == nil {
		return nil
	}
	return o.OidcTokenConfig
}

func (o *GetProjectsProject1) GetTier() *ProjectTier1 {
	if o == nil {
		return nil
	}
	return o.Tier
}

func (o *GetProjectsProject1) GetAbuse() *ProjectAbuse1 {
	if o == nil {
		return nil
	}
	return o.Abuse
}

func (o *GetProjectsProject1) GetInternalRoutes() []ProjectInternalRouteUnion1 {
	if o == nil {
		return nil
	}
	return o.InternalRoutes
}

// GetProjectsPagination1 - This object contains information related to the pagination of the current request using continuation tokens. Since CosmosDB doesn't support going to previous pages, only count and next are provided.
type GetProjectsPagination1 struct {
	// Amount of items in the current page.
	Count float64 `json:"count"`
	// Continuation token that must be used to request the next page. Base32 encoded for safe URL transmission.
	Next *string `json:"next"`
}

func (g GetProjectsPagination1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsPagination1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"count", "next"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsPagination1) GetCount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Count
}

func (o *GetProjectsPagination1) GetNext() *string {
	if o == nil {
		return nil
	}
	return o.Next
}

type PaginationUnion1Type string

const (
	PaginationUnion1TypeGetProjectsPagination1 PaginationUnion1Type = "getProjects_pagination_1"
	PaginationUnion1TypePagination             PaginationUnion1Type = "Pagination"
)

type PaginationUnion1 struct {
	GetProjectsPagination1 *GetProjectsPagination1 `queryParam:"inline"`
	Pagination             *components.Pagination  `queryParam:"inline"`

	Type PaginationUnion1Type
}

func CreatePaginationUnion1GetProjectsPagination1(getProjectsPagination1 GetProjectsPagination1) PaginationUnion1 {
	typ := PaginationUnion1TypeGetProjectsPagination1

	return PaginationUnion1{
		GetProjectsPagination1: &getProjectsPagination1,
		Type:                   typ,
	}
}

func CreatePaginationUnion1Pagination(pagination components.Pagination) PaginationUnion1 {
	typ := PaginationUnion1TypePagination

	return PaginationUnion1{
		Pagination: &pagination,
		Type:       typ,
	}
}

func (u *PaginationUnion1) UnmarshalJSON(data []byte) error {

	var pagination components.Pagination = components.Pagination{}
	if err := utils.UnmarshalJSON(data, &pagination, "", true, nil); err == nil {
		u.Pagination = &pagination
		u.Type = PaginationUnion1TypePagination
		return nil
	}

	var getProjectsPagination1 GetProjectsPagination1 = GetProjectsPagination1{}
	if err := utils.UnmarshalJSON(data, &getProjectsPagination1, "", true, nil); err == nil {
		u.GetProjectsPagination1 = &getProjectsPagination1
		u.Type = PaginationUnion1TypeGetProjectsPagination1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PaginationUnion1", string(data))
}

func (u PaginationUnion1) MarshalJSON() ([]byte, error) {
	if u.GetProjectsPagination1 != nil {
		return utils.MarshalJSON(u.GetProjectsPagination1, "", true)
	}

	if u.Pagination != nil {
		return utils.MarshalJSON(u.Pagination, "", true)
	}

	return nil, errors.New("could not marshal union type PaginationUnion1: all fields are null")
}

type GetProjectsResponseBody2 struct {
	Projects   []GetProjectsProject1 `json:"projects"`
	Pagination PaginationUnion1      `json:"pagination"`
}

func (g GetProjectsResponseBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsResponseBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"projects", "pagination"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsResponseBody2) GetProjects() []GetProjectsProject1 {
	if o == nil {
		return []GetProjectsProject1{}
	}
	return o.Projects
}

func (o *GetProjectsResponseBody2) GetPagination() PaginationUnion1 {
	if o == nil {
		return PaginationUnion1{}
	}
	return o.Pagination
}

type GetProjectsConfiguredBy string

const (
	GetProjectsConfiguredByA     GetProjectsConfiguredBy = "A"
	GetProjectsConfiguredByCname GetProjectsConfiguredBy = "CNAME"
	GetProjectsConfiguredByHTTP  GetProjectsConfiguredBy = "http"
	GetProjectsConfiguredByDns01 GetProjectsConfiguredBy = "dns-01"
)

func (e GetProjectsConfiguredBy) ToPointer() *GetProjectsConfiguredBy {
	return &e
}
func (e *GetProjectsConfiguredBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "A":
		fallthrough
	case "CNAME":
		fallthrough
	case "http":
		fallthrough
	case "dns-01":
		*e = GetProjectsConfiguredBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsConfiguredBy: %v", v)
	}
}

type DeploymentAliasAssignedType string

const (
	DeploymentAliasAssignedTypeNumber  DeploymentAliasAssignedType = "number"
	DeploymentAliasAssignedTypeBoolean DeploymentAliasAssignedType = "boolean"
)

type DeploymentAliasAssigned struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type DeploymentAliasAssignedType
}

func CreateDeploymentAliasAssignedNumber(number float64) DeploymentAliasAssigned {
	typ := DeploymentAliasAssignedTypeNumber

	return DeploymentAliasAssigned{
		Number: &number,
		Type:   typ,
	}
}

func CreateDeploymentAliasAssignedBoolean(boolean bool) DeploymentAliasAssigned {
	typ := DeploymentAliasAssignedTypeBoolean

	return DeploymentAliasAssigned{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *DeploymentAliasAssigned) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = DeploymentAliasAssignedTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = DeploymentAliasAssignedTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for DeploymentAliasAssigned", string(data))
}

func (u DeploymentAliasAssigned) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type DeploymentAliasAssigned: all fields are null")
}

type DeploymentBuild struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (d DeploymentBuild) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DeploymentBuild) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *DeploymentBuild) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *DeploymentBuild) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *DeploymentBuild) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type DeploymentCreator struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (d DeploymentCreator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(d, "", false)
}

func (d *DeploymentCreator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &d, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *DeploymentCreator) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *DeploymentCreator) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *DeploymentCreator) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *DeploymentCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *DeploymentCreator) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type GetProjectsDeployment struct {
	Alias              []string                 `json:"alias,omitempty"`
	AliasAssigned      *DeploymentAliasAssigned `json:"aliasAssigned,omitempty"`
	Builds             []DeploymentBuild        `json:"builds,omitempty"`
	CreatedAt          float64                  `json:"createdAt"`
	CreatedIn          string                   `json:"createdIn"`
	Creator            *DeploymentCreator       `json:"creator"`
	DeploymentHostname string                   `json:"deploymentHostname"`
	Name               string                   `json:"name"`
	Forced             *bool                    `json:"forced,omitempty"`
	ID                 string                   `json:"id"`
	Meta               map[string]string        `json:"meta,omitempty"`
	Plan               string                   `json:"plan"`
	Private            bool                     `json:"private"`
	ReadyState         string                   `json:"readyState"`
	RequestedAt        *float64                 `json:"requestedAt,omitempty"`
	Target             *string                  `json:"target,omitempty"`
	TeamID             *string                  `json:"teamId,omitempty"`
	Type               string                   `json:"type"`
	URL                string                   `json:"url"`
	UserID             string                   `json:"userId"`
	WithCache          *bool                    `json:"withCache,omitempty"`
}

func (g GetProjectsDeployment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployment) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *GetProjectsDeployment) GetAliasAssigned() *DeploymentAliasAssigned {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *GetProjectsDeployment) GetBuilds() []DeploymentBuild {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *GetProjectsDeployment) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployment) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *GetProjectsDeployment) GetCreator() *DeploymentCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *GetProjectsDeployment) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *GetProjectsDeployment) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployment) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *GetProjectsDeployment) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployment) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *GetProjectsDeployment) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *GetProjectsDeployment) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetProjectsDeployment) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *GetProjectsDeployment) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *GetProjectsDeployment) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *GetProjectsDeployment) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetProjectsDeployment) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *GetProjectsDeployment) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GetProjectsDeployment) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *GetProjectsDeployment) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type GetProjectsEnvironment string

const (
	GetProjectsEnvironmentProduction GetProjectsEnvironment = "production"
	GetProjectsEnvironmentPreview    GetProjectsEnvironment = "preview"
)

func (e GetProjectsEnvironment) ToPointer() *GetProjectsEnvironment {
	return &e
}
func (e *GetProjectsEnvironment) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = GetProjectsEnvironment(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsEnvironment: %v", v)
	}
}

type AliasTarget string

const (
	AliasTargetProduction AliasTarget = "PRODUCTION"
	AliasTargetStaging    AliasTarget = "STAGING"
	AliasTargetPreview    AliasTarget = "PREVIEW"
)

func (e AliasTarget) ToPointer() *AliasTarget {
	return &e
}
func (e *AliasTarget) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PRODUCTION":
		fallthrough
	case "STAGING":
		fallthrough
	case "PREVIEW":
		*e = AliasTarget(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AliasTarget: %v", v)
	}
}

type GetProjectsAlias struct {
	ConfiguredBy        *GetProjectsConfiguredBy `json:"configuredBy,omitempty"`
	ConfiguredChangedAt *float64                 `json:"configuredChangedAt,omitempty"`
	CreatedAt           *float64                 `json:"createdAt,omitempty"`
	Deployment          *GetProjectsDeployment   `json:"deployment"`
	Domain              string                   `json:"domain"`
	Environment         GetProjectsEnvironment   `json:"environment"`
	GitBranch           *string                  `json:"gitBranch,omitempty"`
	Redirect            *string                  `json:"redirect,omitempty"`
	RedirectStatusCode  *float64                 `json:"redirectStatusCode,omitempty"`
	Target              AliasTarget              `json:"target"`
}

func (g GetProjectsAlias) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsAlias) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"deployment", "domain", "environment", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsAlias) GetConfiguredBy() *GetProjectsConfiguredBy {
	if o == nil {
		return nil
	}
	return o.ConfiguredBy
}

func (o *GetProjectsAlias) GetConfiguredChangedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfiguredChangedAt
}

func (o *GetProjectsAlias) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsAlias) GetDeployment() *GetProjectsDeployment {
	if o == nil {
		return nil
	}
	return o.Deployment
}

func (o *GetProjectsAlias) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *GetProjectsAlias) GetEnvironment() GetProjectsEnvironment {
	if o == nil {
		return GetProjectsEnvironment("")
	}
	return o.Environment
}

func (o *GetProjectsAlias) GetGitBranch() *string {
	if o == nil {
		return nil
	}
	return o.GitBranch
}

func (o *GetProjectsAlias) GetRedirect() *string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *GetProjectsAlias) GetRedirectStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.RedirectStatusCode
}

func (o *GetProjectsAlias) GetTarget() AliasTarget {
	if o == nil {
		return AliasTarget("")
	}
	return o.Target
}

type GetProjectsAnalytics struct {
	ID                  string   `json:"id"`
	CanceledAt          *float64 `json:"canceledAt,omitempty"`
	DisabledAt          float64  `json:"disabledAt"`
	EnabledAt           float64  `json:"enabledAt"`
	PaidAt              *float64 `json:"paidAt,omitempty"`
	SampleRatePercent   *float64 `json:"sampleRatePercent,omitempty"`
	SpendLimitInDollars *float64 `json:"spendLimitInDollars,omitempty"`
}

func (g GetProjectsAnalytics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsAnalytics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "disabledAt", "enabledAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsAnalytics) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsAnalytics) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *GetProjectsAnalytics) GetDisabledAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.DisabledAt
}

func (o *GetProjectsAnalytics) GetEnabledAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.EnabledAt
}

func (o *GetProjectsAnalytics) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

func (o *GetProjectsAnalytics) GetSampleRatePercent() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRatePercent
}

func (o *GetProjectsAnalytics) GetSpendLimitInDollars() *float64 {
	if o == nil {
		return nil
	}
	return o.SpendLimitInDollars
}

// GetProjectsDeploymentExpiration - Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
type GetProjectsDeploymentExpiration struct {
	// Number of days to keep non-production deployments (mostly preview deployments) before soft deletion.
	ExpirationDays *float64 `json:"expirationDays,omitempty"`
	// Number of days to keep production deployments before soft deletion.
	ExpirationDaysProduction *float64 `json:"expirationDaysProduction,omitempty"`
	// Number of days to keep canceled deployments before soft deletion.
	ExpirationDaysCanceled *float64 `json:"expirationDaysCanceled,omitempty"`
	// Number of days to keep errored deployments before soft deletion.
	ExpirationDaysErrored *float64 `json:"expirationDaysErrored,omitempty"`
	// Minimum number of production deployments to keep for this project, even if they are over the production expiration limit.
	DeploymentsToKeep *float64 `json:"deploymentsToKeep,omitempty"`
}

func (g GetProjectsDeploymentExpiration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeploymentExpiration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeploymentExpiration) GetExpirationDays() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDays
}

func (o *GetProjectsDeploymentExpiration) GetExpirationDaysProduction() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysProduction
}

func (o *GetProjectsDeploymentExpiration) GetExpirationDaysCanceled() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysCanceled
}

func (o *GetProjectsDeploymentExpiration) GetExpirationDaysErrored() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysErrored
}

func (o *GetProjectsDeploymentExpiration) GetDeploymentsToKeep() *float64 {
	if o == nil {
		return nil
	}
	return o.DeploymentsToKeep
}

type GetProjectsIPBucket struct {
	Bucket       string   `json:"bucket"`
	SupportUntil *float64 `json:"supportUntil,omitempty"`
}

func (g GetProjectsIPBucket) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsIPBucket) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsIPBucket) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *GetProjectsIPBucket) GetSupportUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.SupportUntil
}

type GetProjectsTargetEnvEnum2 string

const (
	GetProjectsTargetEnvEnum2Production  GetProjectsTargetEnvEnum2 = "production"
	GetProjectsTargetEnvEnum2Preview     GetProjectsTargetEnvEnum2 = "preview"
	GetProjectsTargetEnvEnum2Development GetProjectsTargetEnvEnum2 = "development"
)

func (e GetProjectsTargetEnvEnum2) ToPointer() *GetProjectsTargetEnvEnum2 {
	return &e
}
func (e *GetProjectsTargetEnvEnum2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		fallthrough
	case "development":
		*e = GetProjectsTargetEnvEnum2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTargetEnvEnum2: %v", v)
	}
}

type GetProjectsTargetEnvEnum1 string

const (
	GetProjectsTargetEnvEnum1Production  GetProjectsTargetEnvEnum1 = "production"
	GetProjectsTargetEnvEnum1Preview     GetProjectsTargetEnvEnum1 = "preview"
	GetProjectsTargetEnvEnum1Development GetProjectsTargetEnvEnum1 = "development"
)

func (e GetProjectsTargetEnvEnum1) ToPointer() *GetProjectsTargetEnvEnum1 {
	return &e
}
func (e *GetProjectsTargetEnvEnum1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		fallthrough
	case "development":
		*e = GetProjectsTargetEnvEnum1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTargetEnvEnum1: %v", v)
	}
}

type GetProjectsTargetUnionType string

const (
	GetProjectsTargetUnionTypeArrayOfGetProjectsTargetEnvEnum1 GetProjectsTargetUnionType = "arrayOfGetProjectsTargetEnvEnum1"
	GetProjectsTargetUnionTypeGetProjectsTargetEnvEnum2        GetProjectsTargetUnionType = "getProjects_target_env_enum_2"
)

type GetProjectsTargetUnion struct {
	ArrayOfGetProjectsTargetEnvEnum1 []GetProjectsTargetEnvEnum1 `queryParam:"inline"`
	GetProjectsTargetEnvEnum2        *GetProjectsTargetEnvEnum2  `queryParam:"inline"`

	Type GetProjectsTargetUnionType
}

func CreateGetProjectsTargetUnionArrayOfGetProjectsTargetEnvEnum1(arrayOfGetProjectsTargetEnvEnum1 []GetProjectsTargetEnvEnum1) GetProjectsTargetUnion {
	typ := GetProjectsTargetUnionTypeArrayOfGetProjectsTargetEnvEnum1

	return GetProjectsTargetUnion{
		ArrayOfGetProjectsTargetEnvEnum1: arrayOfGetProjectsTargetEnvEnum1,
		Type:                             typ,
	}
}

func CreateGetProjectsTargetUnionGetProjectsTargetEnvEnum2(getProjectsTargetEnvEnum2 GetProjectsTargetEnvEnum2) GetProjectsTargetUnion {
	typ := GetProjectsTargetUnionTypeGetProjectsTargetEnvEnum2

	return GetProjectsTargetUnion{
		GetProjectsTargetEnvEnum2: &getProjectsTargetEnvEnum2,
		Type:                      typ,
	}
}

func (u *GetProjectsTargetUnion) UnmarshalJSON(data []byte) error {

	var arrayOfGetProjectsTargetEnvEnum1 []GetProjectsTargetEnvEnum1 = []GetProjectsTargetEnvEnum1{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetProjectsTargetEnvEnum1, "", true, nil); err == nil {
		u.ArrayOfGetProjectsTargetEnvEnum1 = arrayOfGetProjectsTargetEnvEnum1
		u.Type = GetProjectsTargetUnionTypeArrayOfGetProjectsTargetEnvEnum1
		return nil
	}

	var getProjectsTargetEnvEnum2 GetProjectsTargetEnvEnum2 = GetProjectsTargetEnvEnum2("")
	if err := utils.UnmarshalJSON(data, &getProjectsTargetEnvEnum2, "", true, nil); err == nil {
		u.GetProjectsTargetEnvEnum2 = &getProjectsTargetEnvEnum2
		u.Type = GetProjectsTargetUnionTypeGetProjectsTargetEnvEnum2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsTargetUnion", string(data))
}

func (u GetProjectsTargetUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfGetProjectsTargetEnvEnum1 != nil {
		return utils.MarshalJSON(u.ArrayOfGetProjectsTargetEnvEnum1, "", true)
	}

	if u.GetProjectsTargetEnvEnum2 != nil {
		return utils.MarshalJSON(u.GetProjectsTargetEnvEnum2, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsTargetUnion: all fields are null")
}

type GetProjectsEnvType string

const (
	GetProjectsEnvTypeSecret    GetProjectsEnvType = "secret"
	GetProjectsEnvTypeSystem    GetProjectsEnvType = "system"
	GetProjectsEnvTypeEncrypted GetProjectsEnvType = "encrypted"
	GetProjectsEnvTypePlain     GetProjectsEnvType = "plain"
	GetProjectsEnvTypeSensitive GetProjectsEnvType = "sensitive"
)

func (e GetProjectsEnvType) ToPointer() *GetProjectsEnvType {
	return &e
}
func (e *GetProjectsEnvType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "system":
		fallthrough
	case "encrypted":
		fallthrough
	case "plain":
		fallthrough
	case "sensitive":
		*e = GetProjectsEnvType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsEnvType: %v", v)
	}
}

type GetProjectsTypeFlagsConnectionString string

const (
	GetProjectsTypeFlagsConnectionStringFlagsConnectionString GetProjectsTypeFlagsConnectionString = "flags-connection-string"
)

func (e GetProjectsTypeFlagsConnectionString) ToPointer() *GetProjectsTypeFlagsConnectionString {
	return &e
}
func (e *GetProjectsTypeFlagsConnectionString) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flags-connection-string":
		*e = GetProjectsTypeFlagsConnectionString(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeFlagsConnectionString: %v", v)
	}
}

type GetProjectsContentHintFlagsConnectionString struct {
	Type      GetProjectsTypeFlagsConnectionString `json:"type"`
	ProjectID string                               `json:"projectId"`
}

func (g GetProjectsContentHintFlagsConnectionString) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintFlagsConnectionString) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "projectId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintFlagsConnectionString) GetType() GetProjectsTypeFlagsConnectionString {
	if o == nil {
		return GetProjectsTypeFlagsConnectionString("")
	}
	return o.Type
}

func (o *GetProjectsContentHintFlagsConnectionString) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

type GetProjectsTypeIntegrationStoreSecret string

const (
	GetProjectsTypeIntegrationStoreSecretIntegrationStoreSecret GetProjectsTypeIntegrationStoreSecret = "integration-store-secret"
)

func (e GetProjectsTypeIntegrationStoreSecret) ToPointer() *GetProjectsTypeIntegrationStoreSecret {
	return &e
}
func (e *GetProjectsTypeIntegrationStoreSecret) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-store-secret":
		*e = GetProjectsTypeIntegrationStoreSecret(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeIntegrationStoreSecret: %v", v)
	}
}

type GetProjectsContentHintIntegrationStoreSecret struct {
	Type                       GetProjectsTypeIntegrationStoreSecret `json:"type"`
	StoreID                    string                                `json:"storeId"`
	IntegrationID              string                                `json:"integrationId"`
	IntegrationProductID       string                                `json:"integrationProductId"`
	IntegrationConfigurationID string                                `json:"integrationConfigurationId"`
}

func (g GetProjectsContentHintIntegrationStoreSecret) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintIntegrationStoreSecret) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId", "integrationId", "integrationProductId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintIntegrationStoreSecret) GetType() GetProjectsTypeIntegrationStoreSecret {
	if o == nil {
		return GetProjectsTypeIntegrationStoreSecret("")
	}
	return o.Type
}

func (o *GetProjectsContentHintIntegrationStoreSecret) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

func (o *GetProjectsContentHintIntegrationStoreSecret) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *GetProjectsContentHintIntegrationStoreSecret) GetIntegrationProductID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationProductID
}

func (o *GetProjectsContentHintIntegrationStoreSecret) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type GetProjectsTypePostgresURLNoSsl string

const (
	GetProjectsTypePostgresURLNoSslPostgresURLNoSsl GetProjectsTypePostgresURLNoSsl = "postgres-url-no-ssl"
)

func (e GetProjectsTypePostgresURLNoSsl) ToPointer() *GetProjectsTypePostgresURLNoSsl {
	return &e
}
func (e *GetProjectsTypePostgresURLNoSsl) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url-no-ssl":
		*e = GetProjectsTypePostgresURLNoSsl(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresURLNoSsl: %v", v)
	}
}

type GetProjectsContentHintPostgresURLNoSsl struct {
	Type    GetProjectsTypePostgresURLNoSsl `json:"type"`
	StoreID string                          `json:"storeId"`
}

func (g GetProjectsContentHintPostgresURLNoSsl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresURLNoSsl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresURLNoSsl) GetType() GetProjectsTypePostgresURLNoSsl {
	if o == nil {
		return GetProjectsTypePostgresURLNoSsl("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresURLNoSsl) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresDatabase string

const (
	GetProjectsTypePostgresDatabasePostgresDatabase GetProjectsTypePostgresDatabase = "postgres-database"
)

func (e GetProjectsTypePostgresDatabase) ToPointer() *GetProjectsTypePostgresDatabase {
	return &e
}
func (e *GetProjectsTypePostgresDatabase) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-database":
		*e = GetProjectsTypePostgresDatabase(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresDatabase: %v", v)
	}
}

type GetProjectsContentHintPostgresDatabase struct {
	Type    GetProjectsTypePostgresDatabase `json:"type"`
	StoreID string                          `json:"storeId"`
}

func (g GetProjectsContentHintPostgresDatabase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresDatabase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresDatabase) GetType() GetProjectsTypePostgresDatabase {
	if o == nil {
		return GetProjectsTypePostgresDatabase("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresDatabase) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresPassword string

const (
	GetProjectsTypePostgresPasswordPostgresPassword GetProjectsTypePostgresPassword = "postgres-password"
)

func (e GetProjectsTypePostgresPassword) ToPointer() *GetProjectsTypePostgresPassword {
	return &e
}
func (e *GetProjectsTypePostgresPassword) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-password":
		*e = GetProjectsTypePostgresPassword(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresPassword: %v", v)
	}
}

type GetProjectsContentHintPostgresPassword struct {
	Type    GetProjectsTypePostgresPassword `json:"type"`
	StoreID string                          `json:"storeId"`
}

func (g GetProjectsContentHintPostgresPassword) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresPassword) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresPassword) GetType() GetProjectsTypePostgresPassword {
	if o == nil {
		return GetProjectsTypePostgresPassword("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresPassword) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresHost string

const (
	GetProjectsTypePostgresHostPostgresHost GetProjectsTypePostgresHost = "postgres-host"
)

func (e GetProjectsTypePostgresHost) ToPointer() *GetProjectsTypePostgresHost {
	return &e
}
func (e *GetProjectsTypePostgresHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-host":
		*e = GetProjectsTypePostgresHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresHost: %v", v)
	}
}

type GetProjectsContentHintPostgresHost struct {
	Type    GetProjectsTypePostgresHost `json:"type"`
	StoreID string                      `json:"storeId"`
}

func (g GetProjectsContentHintPostgresHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresHost) GetType() GetProjectsTypePostgresHost {
	if o == nil {
		return GetProjectsTypePostgresHost("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresHost) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresUser string

const (
	GetProjectsTypePostgresUserPostgresUser GetProjectsTypePostgresUser = "postgres-user"
)

func (e GetProjectsTypePostgresUser) ToPointer() *GetProjectsTypePostgresUser {
	return &e
}
func (e *GetProjectsTypePostgresUser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-user":
		*e = GetProjectsTypePostgresUser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresUser: %v", v)
	}
}

type GetProjectsContentHintPostgresUser struct {
	Type    GetProjectsTypePostgresUser `json:"type"`
	StoreID string                      `json:"storeId"`
}

func (g GetProjectsContentHintPostgresUser) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresUser) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresUser) GetType() GetProjectsTypePostgresUser {
	if o == nil {
		return GetProjectsTypePostgresUser("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresUser) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresPrismaURL string

const (
	GetProjectsTypePostgresPrismaURLPostgresPrismaURL GetProjectsTypePostgresPrismaURL = "postgres-prisma-url"
)

func (e GetProjectsTypePostgresPrismaURL) ToPointer() *GetProjectsTypePostgresPrismaURL {
	return &e
}
func (e *GetProjectsTypePostgresPrismaURL) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-prisma-url":
		*e = GetProjectsTypePostgresPrismaURL(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresPrismaURL: %v", v)
	}
}

type GetProjectsContentHintPostgresPrismaURL struct {
	Type    GetProjectsTypePostgresPrismaURL `json:"type"`
	StoreID string                           `json:"storeId"`
}

func (g GetProjectsContentHintPostgresPrismaURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresPrismaURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresPrismaURL) GetType() GetProjectsTypePostgresPrismaURL {
	if o == nil {
		return GetProjectsTypePostgresPrismaURL("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresPrismaURL) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresURLNonPooling string

const (
	GetProjectsTypePostgresURLNonPoolingPostgresURLNonPooling GetProjectsTypePostgresURLNonPooling = "postgres-url-non-pooling"
)

func (e GetProjectsTypePostgresURLNonPooling) ToPointer() *GetProjectsTypePostgresURLNonPooling {
	return &e
}
func (e *GetProjectsTypePostgresURLNonPooling) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url-non-pooling":
		*e = GetProjectsTypePostgresURLNonPooling(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresURLNonPooling: %v", v)
	}
}

type GetProjectsContentHintPostgresURLNonPooling struct {
	Type    GetProjectsTypePostgresURLNonPooling `json:"type"`
	StoreID string                               `json:"storeId"`
}

func (g GetProjectsContentHintPostgresURLNonPooling) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresURLNonPooling) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresURLNonPooling) GetType() GetProjectsTypePostgresURLNonPooling {
	if o == nil {
		return GetProjectsTypePostgresURLNonPooling("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresURLNonPooling) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypePostgresURL string

const (
	GetProjectsTypePostgresURLPostgresURL GetProjectsTypePostgresURL = "postgres-url"
)

func (e GetProjectsTypePostgresURL) ToPointer() *GetProjectsTypePostgresURL {
	return &e
}
func (e *GetProjectsTypePostgresURL) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url":
		*e = GetProjectsTypePostgresURL(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypePostgresURL: %v", v)
	}
}

type GetProjectsContentHintPostgresURL struct {
	Type    GetProjectsTypePostgresURL `json:"type"`
	StoreID string                     `json:"storeId"`
}

func (g GetProjectsContentHintPostgresURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintPostgresURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintPostgresURL) GetType() GetProjectsTypePostgresURL {
	if o == nil {
		return GetProjectsTypePostgresURL("")
	}
	return o.Type
}

func (o *GetProjectsContentHintPostgresURL) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypeBlobReadWriteToken string

const (
	GetProjectsTypeBlobReadWriteTokenBlobReadWriteToken GetProjectsTypeBlobReadWriteToken = "blob-read-write-token"
)

func (e GetProjectsTypeBlobReadWriteToken) ToPointer() *GetProjectsTypeBlobReadWriteToken {
	return &e
}
func (e *GetProjectsTypeBlobReadWriteToken) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blob-read-write-token":
		*e = GetProjectsTypeBlobReadWriteToken(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeBlobReadWriteToken: %v", v)
	}
}

type GetProjectsContentHintBlobReadWriteToken struct {
	Type    GetProjectsTypeBlobReadWriteToken `json:"type"`
	StoreID string                            `json:"storeId"`
}

func (g GetProjectsContentHintBlobReadWriteToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintBlobReadWriteToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintBlobReadWriteToken) GetType() GetProjectsTypeBlobReadWriteToken {
	if o == nil {
		return GetProjectsTypeBlobReadWriteToken("")
	}
	return o.Type
}

func (o *GetProjectsContentHintBlobReadWriteToken) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypeRedisRestAPIReadOnlyToken string

const (
	GetProjectsTypeRedisRestAPIReadOnlyTokenRedisRestAPIReadOnlyToken GetProjectsTypeRedisRestAPIReadOnlyToken = "redis-rest-api-read-only-token"
)

func (e GetProjectsTypeRedisRestAPIReadOnlyToken) ToPointer() *GetProjectsTypeRedisRestAPIReadOnlyToken {
	return &e
}
func (e *GetProjectsTypeRedisRestAPIReadOnlyToken) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-read-only-token":
		*e = GetProjectsTypeRedisRestAPIReadOnlyToken(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeRedisRestAPIReadOnlyToken: %v", v)
	}
}

type GetProjectsContentHintRedisRestAPIReadOnlyToken struct {
	Type    GetProjectsTypeRedisRestAPIReadOnlyToken `json:"type"`
	StoreID string                                   `json:"storeId"`
}

func (g GetProjectsContentHintRedisRestAPIReadOnlyToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintRedisRestAPIReadOnlyToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintRedisRestAPIReadOnlyToken) GetType() GetProjectsTypeRedisRestAPIReadOnlyToken {
	if o == nil {
		return GetProjectsTypeRedisRestAPIReadOnlyToken("")
	}
	return o.Type
}

func (o *GetProjectsContentHintRedisRestAPIReadOnlyToken) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypeRedisRestAPIToken string

const (
	GetProjectsTypeRedisRestAPITokenRedisRestAPIToken GetProjectsTypeRedisRestAPIToken = "redis-rest-api-token"
)

func (e GetProjectsTypeRedisRestAPIToken) ToPointer() *GetProjectsTypeRedisRestAPIToken {
	return &e
}
func (e *GetProjectsTypeRedisRestAPIToken) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-token":
		*e = GetProjectsTypeRedisRestAPIToken(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeRedisRestAPIToken: %v", v)
	}
}

type GetProjectsContentHintRedisRestAPIToken struct {
	Type    GetProjectsTypeRedisRestAPIToken `json:"type"`
	StoreID string                           `json:"storeId"`
}

func (g GetProjectsContentHintRedisRestAPIToken) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintRedisRestAPIToken) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintRedisRestAPIToken) GetType() GetProjectsTypeRedisRestAPIToken {
	if o == nil {
		return GetProjectsTypeRedisRestAPIToken("")
	}
	return o.Type
}

func (o *GetProjectsContentHintRedisRestAPIToken) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypeRedisRestAPIURL string

const (
	GetProjectsTypeRedisRestAPIURLRedisRestAPIURL GetProjectsTypeRedisRestAPIURL = "redis-rest-api-url"
)

func (e GetProjectsTypeRedisRestAPIURL) ToPointer() *GetProjectsTypeRedisRestAPIURL {
	return &e
}
func (e *GetProjectsTypeRedisRestAPIURL) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-url":
		*e = GetProjectsTypeRedisRestAPIURL(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeRedisRestAPIURL: %v", v)
	}
}

type GetProjectsContentHintRedisRestAPIURL struct {
	Type    GetProjectsTypeRedisRestAPIURL `json:"type"`
	StoreID string                         `json:"storeId"`
}

func (g GetProjectsContentHintRedisRestAPIURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintRedisRestAPIURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintRedisRestAPIURL) GetType() GetProjectsTypeRedisRestAPIURL {
	if o == nil {
		return GetProjectsTypeRedisRestAPIURL("")
	}
	return o.Type
}

func (o *GetProjectsContentHintRedisRestAPIURL) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsTypeRedisURL string

const (
	GetProjectsTypeRedisURLRedisURL GetProjectsTypeRedisURL = "redis-url"
)

func (e GetProjectsTypeRedisURL) ToPointer() *GetProjectsTypeRedisURL {
	return &e
}
func (e *GetProjectsTypeRedisURL) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-url":
		*e = GetProjectsTypeRedisURL(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeRedisURL: %v", v)
	}
}

type GetProjectsContentHintRedisURL struct {
	Type    GetProjectsTypeRedisURL `json:"type"`
	StoreID string                  `json:"storeId"`
}

func (g GetProjectsContentHintRedisURL) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsContentHintRedisURL) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsContentHintRedisURL) GetType() GetProjectsTypeRedisURL {
	if o == nil {
		return GetProjectsTypeRedisURL("")
	}
	return o.Type
}

func (o *GetProjectsContentHintRedisURL) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type GetProjectsContentHintUnionType string

const (
	GetProjectsContentHintUnionTypeRedisURL                  GetProjectsContentHintUnionType = "redis-url"
	GetProjectsContentHintUnionTypeRedisRestAPIURL           GetProjectsContentHintUnionType = "redis-rest-api-url"
	GetProjectsContentHintUnionTypeRedisRestAPIToken         GetProjectsContentHintUnionType = "redis-rest-api-token"
	GetProjectsContentHintUnionTypeRedisRestAPIReadOnlyToken GetProjectsContentHintUnionType = "redis-rest-api-read-only-token"
	GetProjectsContentHintUnionTypeBlobReadWriteToken        GetProjectsContentHintUnionType = "blob-read-write-token"
	GetProjectsContentHintUnionTypePostgresURL               GetProjectsContentHintUnionType = "postgres-url"
	GetProjectsContentHintUnionTypePostgresURLNonPooling     GetProjectsContentHintUnionType = "postgres-url-non-pooling"
	GetProjectsContentHintUnionTypePostgresPrismaURL         GetProjectsContentHintUnionType = "postgres-prisma-url"
	GetProjectsContentHintUnionTypePostgresUser              GetProjectsContentHintUnionType = "postgres-user"
	GetProjectsContentHintUnionTypePostgresHost              GetProjectsContentHintUnionType = "postgres-host"
	GetProjectsContentHintUnionTypePostgresPassword          GetProjectsContentHintUnionType = "postgres-password"
	GetProjectsContentHintUnionTypePostgresDatabase          GetProjectsContentHintUnionType = "postgres-database"
	GetProjectsContentHintUnionTypePostgresURLNoSsl          GetProjectsContentHintUnionType = "postgres-url-no-ssl"
	GetProjectsContentHintUnionTypeIntegrationStoreSecret    GetProjectsContentHintUnionType = "integration-store-secret"
	GetProjectsContentHintUnionTypeFlagsConnectionString     GetProjectsContentHintUnionType = "flags-connection-string"
)

type GetProjectsContentHintUnion struct {
	GetProjectsContentHintRedisURL                  *GetProjectsContentHintRedisURL                  `queryParam:"inline"`
	GetProjectsContentHintRedisRestAPIURL           *GetProjectsContentHintRedisRestAPIURL           `queryParam:"inline"`
	GetProjectsContentHintRedisRestAPIToken         *GetProjectsContentHintRedisRestAPIToken         `queryParam:"inline"`
	GetProjectsContentHintRedisRestAPIReadOnlyToken *GetProjectsContentHintRedisRestAPIReadOnlyToken `queryParam:"inline"`
	GetProjectsContentHintBlobReadWriteToken        *GetProjectsContentHintBlobReadWriteToken        `queryParam:"inline"`
	GetProjectsContentHintPostgresURL               *GetProjectsContentHintPostgresURL               `queryParam:"inline"`
	GetProjectsContentHintPostgresURLNonPooling     *GetProjectsContentHintPostgresURLNonPooling     `queryParam:"inline"`
	GetProjectsContentHintPostgresPrismaURL         *GetProjectsContentHintPostgresPrismaURL         `queryParam:"inline"`
	GetProjectsContentHintPostgresUser              *GetProjectsContentHintPostgresUser              `queryParam:"inline"`
	GetProjectsContentHintPostgresHost              *GetProjectsContentHintPostgresHost              `queryParam:"inline"`
	GetProjectsContentHintPostgresPassword          *GetProjectsContentHintPostgresPassword          `queryParam:"inline"`
	GetProjectsContentHintPostgresDatabase          *GetProjectsContentHintPostgresDatabase          `queryParam:"inline"`
	GetProjectsContentHintPostgresURLNoSsl          *GetProjectsContentHintPostgresURLNoSsl          `queryParam:"inline"`
	GetProjectsContentHintIntegrationStoreSecret    *GetProjectsContentHintIntegrationStoreSecret    `queryParam:"inline"`
	GetProjectsContentHintFlagsConnectionString     *GetProjectsContentHintFlagsConnectionString     `queryParam:"inline"`

	Type GetProjectsContentHintUnionType
}

func CreateGetProjectsContentHintUnionRedisURL(redisURL GetProjectsContentHintRedisURL) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeRedisURL

	typStr := GetProjectsTypeRedisURL(typ)
	redisURL.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintRedisURL: &redisURL,
		Type:                           typ,
	}
}

func CreateGetProjectsContentHintUnionRedisRestAPIURL(redisRestAPIURL GetProjectsContentHintRedisRestAPIURL) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeRedisRestAPIURL

	typStr := GetProjectsTypeRedisRestAPIURL(typ)
	redisRestAPIURL.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintRedisRestAPIURL: &redisRestAPIURL,
		Type:                                  typ,
	}
}

func CreateGetProjectsContentHintUnionRedisRestAPIToken(redisRestAPIToken GetProjectsContentHintRedisRestAPIToken) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeRedisRestAPIToken

	typStr := GetProjectsTypeRedisRestAPIToken(typ)
	redisRestAPIToken.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintRedisRestAPIToken: &redisRestAPIToken,
		Type:                                    typ,
	}
}

func CreateGetProjectsContentHintUnionRedisRestAPIReadOnlyToken(redisRestAPIReadOnlyToken GetProjectsContentHintRedisRestAPIReadOnlyToken) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeRedisRestAPIReadOnlyToken

	typStr := GetProjectsTypeRedisRestAPIReadOnlyToken(typ)
	redisRestAPIReadOnlyToken.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintRedisRestAPIReadOnlyToken: &redisRestAPIReadOnlyToken,
		Type: typ,
	}
}

func CreateGetProjectsContentHintUnionBlobReadWriteToken(blobReadWriteToken GetProjectsContentHintBlobReadWriteToken) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeBlobReadWriteToken

	typStr := GetProjectsTypeBlobReadWriteToken(typ)
	blobReadWriteToken.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintBlobReadWriteToken: &blobReadWriteToken,
		Type:                                     typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresURL(postgresURL GetProjectsContentHintPostgresURL) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresURL

	typStr := GetProjectsTypePostgresURL(typ)
	postgresURL.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresURL: &postgresURL,
		Type:                              typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresURLNonPooling(postgresURLNonPooling GetProjectsContentHintPostgresURLNonPooling) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresURLNonPooling

	typStr := GetProjectsTypePostgresURLNonPooling(typ)
	postgresURLNonPooling.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresURLNonPooling: &postgresURLNonPooling,
		Type: typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresPrismaURL(postgresPrismaURL GetProjectsContentHintPostgresPrismaURL) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresPrismaURL

	typStr := GetProjectsTypePostgresPrismaURL(typ)
	postgresPrismaURL.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresPrismaURL: &postgresPrismaURL,
		Type:                                    typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresUser(postgresUser GetProjectsContentHintPostgresUser) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresUser

	typStr := GetProjectsTypePostgresUser(typ)
	postgresUser.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresUser: &postgresUser,
		Type:                               typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresHost(postgresHost GetProjectsContentHintPostgresHost) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresHost

	typStr := GetProjectsTypePostgresHost(typ)
	postgresHost.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresHost: &postgresHost,
		Type:                               typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresPassword(postgresPassword GetProjectsContentHintPostgresPassword) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresPassword

	typStr := GetProjectsTypePostgresPassword(typ)
	postgresPassword.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresPassword: &postgresPassword,
		Type:                                   typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresDatabase(postgresDatabase GetProjectsContentHintPostgresDatabase) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresDatabase

	typStr := GetProjectsTypePostgresDatabase(typ)
	postgresDatabase.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresDatabase: &postgresDatabase,
		Type:                                   typ,
	}
}

func CreateGetProjectsContentHintUnionPostgresURLNoSsl(postgresURLNoSsl GetProjectsContentHintPostgresURLNoSsl) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypePostgresURLNoSsl

	typStr := GetProjectsTypePostgresURLNoSsl(typ)
	postgresURLNoSsl.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintPostgresURLNoSsl: &postgresURLNoSsl,
		Type:                                   typ,
	}
}

func CreateGetProjectsContentHintUnionIntegrationStoreSecret(integrationStoreSecret GetProjectsContentHintIntegrationStoreSecret) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeIntegrationStoreSecret

	typStr := GetProjectsTypeIntegrationStoreSecret(typ)
	integrationStoreSecret.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintIntegrationStoreSecret: &integrationStoreSecret,
		Type: typ,
	}
}

func CreateGetProjectsContentHintUnionFlagsConnectionString(flagsConnectionString GetProjectsContentHintFlagsConnectionString) GetProjectsContentHintUnion {
	typ := GetProjectsContentHintUnionTypeFlagsConnectionString

	typStr := GetProjectsTypeFlagsConnectionString(typ)
	flagsConnectionString.Type = typStr

	return GetProjectsContentHintUnion{
		GetProjectsContentHintFlagsConnectionString: &flagsConnectionString,
		Type: typ,
	}
}

func (u *GetProjectsContentHintUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "redis-url":
		getProjectsContentHintRedisURL := new(GetProjectsContentHintRedisURL)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintRedisURL, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-url) type GetProjectsContentHintRedisURL within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintRedisURL = getProjectsContentHintRedisURL
		u.Type = GetProjectsContentHintUnionTypeRedisURL
		return nil
	case "redis-rest-api-url":
		getProjectsContentHintRedisRestAPIURL := new(GetProjectsContentHintRedisRestAPIURL)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintRedisRestAPIURL, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-url) type GetProjectsContentHintRedisRestAPIURL within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintRedisRestAPIURL = getProjectsContentHintRedisRestAPIURL
		u.Type = GetProjectsContentHintUnionTypeRedisRestAPIURL
		return nil
	case "redis-rest-api-token":
		getProjectsContentHintRedisRestAPIToken := new(GetProjectsContentHintRedisRestAPIToken)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintRedisRestAPIToken, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-token) type GetProjectsContentHintRedisRestAPIToken within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintRedisRestAPIToken = getProjectsContentHintRedisRestAPIToken
		u.Type = GetProjectsContentHintUnionTypeRedisRestAPIToken
		return nil
	case "redis-rest-api-read-only-token":
		getProjectsContentHintRedisRestAPIReadOnlyToken := new(GetProjectsContentHintRedisRestAPIReadOnlyToken)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintRedisRestAPIReadOnlyToken, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-read-only-token) type GetProjectsContentHintRedisRestAPIReadOnlyToken within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintRedisRestAPIReadOnlyToken = getProjectsContentHintRedisRestAPIReadOnlyToken
		u.Type = GetProjectsContentHintUnionTypeRedisRestAPIReadOnlyToken
		return nil
	case "blob-read-write-token":
		getProjectsContentHintBlobReadWriteToken := new(GetProjectsContentHintBlobReadWriteToken)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintBlobReadWriteToken, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == blob-read-write-token) type GetProjectsContentHintBlobReadWriteToken within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintBlobReadWriteToken = getProjectsContentHintBlobReadWriteToken
		u.Type = GetProjectsContentHintUnionTypeBlobReadWriteToken
		return nil
	case "postgres-url":
		getProjectsContentHintPostgresURL := new(GetProjectsContentHintPostgresURL)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresURL, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url) type GetProjectsContentHintPostgresURL within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresURL = getProjectsContentHintPostgresURL
		u.Type = GetProjectsContentHintUnionTypePostgresURL
		return nil
	case "postgres-url-non-pooling":
		getProjectsContentHintPostgresURLNonPooling := new(GetProjectsContentHintPostgresURLNonPooling)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresURLNonPooling, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url-non-pooling) type GetProjectsContentHintPostgresURLNonPooling within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresURLNonPooling = getProjectsContentHintPostgresURLNonPooling
		u.Type = GetProjectsContentHintUnionTypePostgresURLNonPooling
		return nil
	case "postgres-prisma-url":
		getProjectsContentHintPostgresPrismaURL := new(GetProjectsContentHintPostgresPrismaURL)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresPrismaURL, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-prisma-url) type GetProjectsContentHintPostgresPrismaURL within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresPrismaURL = getProjectsContentHintPostgresPrismaURL
		u.Type = GetProjectsContentHintUnionTypePostgresPrismaURL
		return nil
	case "postgres-user":
		getProjectsContentHintPostgresUser := new(GetProjectsContentHintPostgresUser)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresUser, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-user) type GetProjectsContentHintPostgresUser within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresUser = getProjectsContentHintPostgresUser
		u.Type = GetProjectsContentHintUnionTypePostgresUser
		return nil
	case "postgres-host":
		getProjectsContentHintPostgresHost := new(GetProjectsContentHintPostgresHost)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresHost, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-host) type GetProjectsContentHintPostgresHost within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresHost = getProjectsContentHintPostgresHost
		u.Type = GetProjectsContentHintUnionTypePostgresHost
		return nil
	case "postgres-password":
		getProjectsContentHintPostgresPassword := new(GetProjectsContentHintPostgresPassword)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresPassword, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-password) type GetProjectsContentHintPostgresPassword within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresPassword = getProjectsContentHintPostgresPassword
		u.Type = GetProjectsContentHintUnionTypePostgresPassword
		return nil
	case "postgres-database":
		getProjectsContentHintPostgresDatabase := new(GetProjectsContentHintPostgresDatabase)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresDatabase, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-database) type GetProjectsContentHintPostgresDatabase within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresDatabase = getProjectsContentHintPostgresDatabase
		u.Type = GetProjectsContentHintUnionTypePostgresDatabase
		return nil
	case "postgres-url-no-ssl":
		getProjectsContentHintPostgresURLNoSsl := new(GetProjectsContentHintPostgresURLNoSsl)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintPostgresURLNoSsl, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url-no-ssl) type GetProjectsContentHintPostgresURLNoSsl within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintPostgresURLNoSsl = getProjectsContentHintPostgresURLNoSsl
		u.Type = GetProjectsContentHintUnionTypePostgresURLNoSsl
		return nil
	case "integration-store-secret":
		getProjectsContentHintIntegrationStoreSecret := new(GetProjectsContentHintIntegrationStoreSecret)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintIntegrationStoreSecret, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == integration-store-secret) type GetProjectsContentHintIntegrationStoreSecret within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintIntegrationStoreSecret = getProjectsContentHintIntegrationStoreSecret
		u.Type = GetProjectsContentHintUnionTypeIntegrationStoreSecret
		return nil
	case "flags-connection-string":
		getProjectsContentHintFlagsConnectionString := new(GetProjectsContentHintFlagsConnectionString)
		if err := utils.UnmarshalJSON(data, &getProjectsContentHintFlagsConnectionString, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == flags-connection-string) type GetProjectsContentHintFlagsConnectionString within GetProjectsContentHintUnion: %w", string(data), err)
		}

		u.GetProjectsContentHintFlagsConnectionString = getProjectsContentHintFlagsConnectionString
		u.Type = GetProjectsContentHintUnionTypeFlagsConnectionString
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsContentHintUnion", string(data))
}

func (u GetProjectsContentHintUnion) MarshalJSON() ([]byte, error) {
	if u.GetProjectsContentHintRedisURL != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintRedisURL, "", true)
	}

	if u.GetProjectsContentHintRedisRestAPIURL != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintRedisRestAPIURL, "", true)
	}

	if u.GetProjectsContentHintRedisRestAPIToken != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintRedisRestAPIToken, "", true)
	}

	if u.GetProjectsContentHintRedisRestAPIReadOnlyToken != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintRedisRestAPIReadOnlyToken, "", true)
	}

	if u.GetProjectsContentHintBlobReadWriteToken != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintBlobReadWriteToken, "", true)
	}

	if u.GetProjectsContentHintPostgresURL != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresURL, "", true)
	}

	if u.GetProjectsContentHintPostgresURLNonPooling != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresURLNonPooling, "", true)
	}

	if u.GetProjectsContentHintPostgresPrismaURL != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresPrismaURL, "", true)
	}

	if u.GetProjectsContentHintPostgresUser != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresUser, "", true)
	}

	if u.GetProjectsContentHintPostgresHost != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresHost, "", true)
	}

	if u.GetProjectsContentHintPostgresPassword != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresPassword, "", true)
	}

	if u.GetProjectsContentHintPostgresDatabase != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresDatabase, "", true)
	}

	if u.GetProjectsContentHintPostgresURLNoSsl != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintPostgresURLNoSsl, "", true)
	}

	if u.GetProjectsContentHintIntegrationStoreSecret != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintIntegrationStoreSecret, "", true)
	}

	if u.GetProjectsContentHintFlagsConnectionString != nil {
		return utils.MarshalJSON(u.GetProjectsContentHintFlagsConnectionString, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsContentHintUnion: all fields are null")
}

type GetProjectsTypeFlagsSecret string

const (
	GetProjectsTypeFlagsSecretFlagsSecret GetProjectsTypeFlagsSecret = "flags-secret"
)

func (e GetProjectsTypeFlagsSecret) ToPointer() *GetProjectsTypeFlagsSecret {
	return &e
}
func (e *GetProjectsTypeFlagsSecret) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flags-secret":
		*e = GetProjectsTypeFlagsSecret(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeFlagsSecret: %v", v)
	}
}

// GetProjectsInternalContentHint - Similar to `contentHints`, but should not be exposed to the user.
type GetProjectsInternalContentHint struct {
	Type GetProjectsTypeFlagsSecret `json:"type"`
	// Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
	EncryptedValue string `json:"encryptedValue"`
}

func (g GetProjectsInternalContentHint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalContentHint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "encryptedValue"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalContentHint) GetType() GetProjectsTypeFlagsSecret {
	if o == nil {
		return GetProjectsTypeFlagsSecret("")
	}
	return o.Type
}

func (o *GetProjectsInternalContentHint) GetEncryptedValue() string {
	if o == nil {
		return ""
	}
	return o.EncryptedValue
}

type GetProjectsEnv struct {
	Target *GetProjectsTargetUnion `json:"target,omitempty"`
	Type   GetProjectsEnvType      `json:"type"`
	// This is used to identify variables that have been migrated from type secret to sensitive.
	SunsetSecretID *string `json:"sunsetSecretId,omitempty"`
	// Legacy now-encryption ciphertext, present after migration swaps value/vsmValue
	LegacyValue       *string                      `json:"legacyValue,omitempty"`
	Decrypted         *bool                        `json:"decrypted,omitempty"`
	Value             string                       `json:"value"`
	VsmValue          *string                      `json:"vsmValue,omitempty"`
	ID                *string                      `json:"id,omitempty"`
	Key               string                       `json:"key"`
	ConfigurationID   *string                      `json:"configurationId,omitempty"`
	CreatedAt         *float64                     `json:"createdAt,omitempty"`
	UpdatedAt         *float64                     `json:"updatedAt,omitempty"`
	CreatedBy         *string                      `json:"createdBy,omitempty"`
	UpdatedBy         *string                      `json:"updatedBy,omitempty"`
	GitBranch         *string                      `json:"gitBranch,omitempty"`
	EdgeConfigID      *string                      `json:"edgeConfigId,omitempty"`
	EdgeConfigTokenID *string                      `json:"edgeConfigTokenId,omitempty"`
	ContentHint       *GetProjectsContentHintUnion `json:"contentHint,omitempty"`
	// Similar to `contentHints`, but should not be exposed to the user.
	InternalContentHint  *GetProjectsInternalContentHint `json:"internalContentHint,omitempty"`
	Comment              *string                         `json:"comment,omitempty"`
	CustomEnvironmentIds []string                        `json:"customEnvironmentIds,omitempty"`
}

func (g GetProjectsEnv) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsEnv) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsEnv) GetTarget() *GetProjectsTargetUnion {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *GetProjectsEnv) GetType() GetProjectsEnvType {
	if o == nil {
		return GetProjectsEnvType("")
	}
	return o.Type
}

func (o *GetProjectsEnv) GetSunsetSecretID() *string {
	if o == nil {
		return nil
	}
	return o.SunsetSecretID
}

func (o *GetProjectsEnv) GetLegacyValue() *string {
	if o == nil {
		return nil
	}
	return o.LegacyValue
}

func (o *GetProjectsEnv) GetDecrypted() *bool {
	if o == nil {
		return nil
	}
	return o.Decrypted
}

func (o *GetProjectsEnv) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

func (o *GetProjectsEnv) GetVsmValue() *string {
	if o == nil {
		return nil
	}
	return o.VsmValue
}

func (o *GetProjectsEnv) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *GetProjectsEnv) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *GetProjectsEnv) GetConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConfigurationID
}

func (o *GetProjectsEnv) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsEnv) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsEnv) GetCreatedBy() *string {
	if o == nil {
		return nil
	}
	return o.CreatedBy
}

func (o *GetProjectsEnv) GetUpdatedBy() *string {
	if o == nil {
		return nil
	}
	return o.UpdatedBy
}

func (o *GetProjectsEnv) GetGitBranch() *string {
	if o == nil {
		return nil
	}
	return o.GitBranch
}

func (o *GetProjectsEnv) GetEdgeConfigID() *string {
	if o == nil {
		return nil
	}
	return o.EdgeConfigID
}

func (o *GetProjectsEnv) GetEdgeConfigTokenID() *string {
	if o == nil {
		return nil
	}
	return o.EdgeConfigTokenID
}

func (o *GetProjectsEnv) GetContentHint() *GetProjectsContentHintUnion {
	if o == nil {
		return nil
	}
	return o.ContentHint
}

func (o *GetProjectsEnv) GetContentHintRedisURL() *GetProjectsContentHintRedisURL {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintRedisURL
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintRedisRestAPIURL() *GetProjectsContentHintRedisRestAPIURL {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintRedisRestAPIURL
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintRedisRestAPIToken() *GetProjectsContentHintRedisRestAPIToken {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintRedisRestAPIToken
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintRedisRestAPIReadOnlyToken() *GetProjectsContentHintRedisRestAPIReadOnlyToken {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintRedisRestAPIReadOnlyToken
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintBlobReadWriteToken() *GetProjectsContentHintBlobReadWriteToken {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintBlobReadWriteToken
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresURL() *GetProjectsContentHintPostgresURL {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresURL
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresURLNonPooling() *GetProjectsContentHintPostgresURLNonPooling {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresURLNonPooling
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresPrismaURL() *GetProjectsContentHintPostgresPrismaURL {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresPrismaURL
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresUser() *GetProjectsContentHintPostgresUser {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresUser
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresHost() *GetProjectsContentHintPostgresHost {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresHost
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresPassword() *GetProjectsContentHintPostgresPassword {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresPassword
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresDatabase() *GetProjectsContentHintPostgresDatabase {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresDatabase
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintPostgresURLNoSsl() *GetProjectsContentHintPostgresURLNoSsl {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintPostgresURLNoSsl
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintIntegrationStoreSecret() *GetProjectsContentHintIntegrationStoreSecret {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintIntegrationStoreSecret
	}
	return nil
}

func (o *GetProjectsEnv) GetContentHintFlagsConnectionString() *GetProjectsContentHintFlagsConnectionString {
	if v := o.GetContentHint(); v != nil {
		return v.GetProjectsContentHintFlagsConnectionString
	}
	return nil
}

func (o *GetProjectsEnv) GetInternalContentHint() *GetProjectsInternalContentHint {
	if o == nil {
		return nil
	}
	return o.InternalContentHint
}

func (o *GetProjectsEnv) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsEnv) GetCustomEnvironmentIds() []string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentIds
}

type GetProjectsFramework string

const (
	GetProjectsFrameworkServices       GetProjectsFramework = "services"
	GetProjectsFrameworkBlitzjs        GetProjectsFramework = "blitzjs"
	GetProjectsFrameworkNextjs         GetProjectsFramework = "nextjs"
	GetProjectsFrameworkGatsby         GetProjectsFramework = "gatsby"
	GetProjectsFrameworkRemix          GetProjectsFramework = "remix"
	GetProjectsFrameworkReactRouter    GetProjectsFramework = "react-router"
	GetProjectsFrameworkAstro          GetProjectsFramework = "astro"
	GetProjectsFrameworkHexo           GetProjectsFramework = "hexo"
	GetProjectsFrameworkEleventy       GetProjectsFramework = "eleventy"
	GetProjectsFrameworkDocusaurus2    GetProjectsFramework = "docusaurus-2"
	GetProjectsFrameworkDocusaurus     GetProjectsFramework = "docusaurus"
	GetProjectsFrameworkPreact         GetProjectsFramework = "preact"
	GetProjectsFrameworkSolidstart1    GetProjectsFramework = "solidstart-1"
	GetProjectsFrameworkSolidstart     GetProjectsFramework = "solidstart"
	GetProjectsFrameworkDojo           GetProjectsFramework = "dojo"
	GetProjectsFrameworkEmber          GetProjectsFramework = "ember"
	GetProjectsFrameworkVue            GetProjectsFramework = "vue"
	GetProjectsFrameworkScully         GetProjectsFramework = "scully"
	GetProjectsFrameworkIonicAngular   GetProjectsFramework = "ionic-angular"
	GetProjectsFrameworkAngular        GetProjectsFramework = "angular"
	GetProjectsFrameworkPolymer        GetProjectsFramework = "polymer"
	GetProjectsFrameworkSvelte         GetProjectsFramework = "svelte"
	GetProjectsFrameworkSveltekit      GetProjectsFramework = "sveltekit"
	GetProjectsFrameworkSveltekit1     GetProjectsFramework = "sveltekit-1"
	GetProjectsFrameworkIonicReact     GetProjectsFramework = "ionic-react"
	GetProjectsFrameworkCreateReactApp GetProjectsFramework = "create-react-app"
	GetProjectsFrameworkGridsome       GetProjectsFramework = "gridsome"
	GetProjectsFrameworkUmijs          GetProjectsFramework = "umijs"
	GetProjectsFrameworkSapper         GetProjectsFramework = "sapper"
	GetProjectsFrameworkSaber          GetProjectsFramework = "saber"
	GetProjectsFrameworkStencil        GetProjectsFramework = "stencil"
	GetProjectsFrameworkNuxtjs         GetProjectsFramework = "nuxtjs"
	GetProjectsFrameworkRedwoodjs      GetProjectsFramework = "redwoodjs"
	GetProjectsFrameworkHugo           GetProjectsFramework = "hugo"
	GetProjectsFrameworkJekyll         GetProjectsFramework = "jekyll"
	GetProjectsFrameworkBrunch         GetProjectsFramework = "brunch"
	GetProjectsFrameworkMiddleman      GetProjectsFramework = "middleman"
	GetProjectsFrameworkZola           GetProjectsFramework = "zola"
	GetProjectsFrameworkHydrogen       GetProjectsFramework = "hydrogen"
	GetProjectsFrameworkVite           GetProjectsFramework = "vite"
	GetProjectsFrameworkTanstackStart  GetProjectsFramework = "tanstack-start"
	GetProjectsFrameworkVitepress      GetProjectsFramework = "vitepress"
	GetProjectsFrameworkVuepress       GetProjectsFramework = "vuepress"
	GetProjectsFrameworkParcel         GetProjectsFramework = "parcel"
	GetProjectsFrameworkFastapi        GetProjectsFramework = "fastapi"
	GetProjectsFrameworkFlask          GetProjectsFramework = "flask"
	GetProjectsFrameworkFasthtml       GetProjectsFramework = "fasthtml"
	GetProjectsFrameworkSanityV3       GetProjectsFramework = "sanity-v3"
	GetProjectsFrameworkSanity         GetProjectsFramework = "sanity"
	GetProjectsFrameworkStorybook      GetProjectsFramework = "storybook"
	GetProjectsFrameworkNitro          GetProjectsFramework = "nitro"
	GetProjectsFrameworkHono           GetProjectsFramework = "hono"
	GetProjectsFrameworkExpress        GetProjectsFramework = "express"
	GetProjectsFrameworkH3             GetProjectsFramework = "h3"
	GetProjectsFrameworkKoa            GetProjectsFramework = "koa"
	GetProjectsFrameworkNestjs         GetProjectsFramework = "nestjs"
	GetProjectsFrameworkElysia         GetProjectsFramework = "elysia"
	GetProjectsFrameworkFastify        GetProjectsFramework = "fastify"
	GetProjectsFrameworkXmcp           GetProjectsFramework = "xmcp"
	GetProjectsFrameworkPython         GetProjectsFramework = "python"
	GetProjectsFrameworkRuby           GetProjectsFramework = "ruby"
	GetProjectsFrameworkRust           GetProjectsFramework = "rust"
	GetProjectsFrameworkNode           GetProjectsFramework = "node"
	GetProjectsFrameworkGo             GetProjectsFramework = "go"
)

func (e GetProjectsFramework) ToPointer() *GetProjectsFramework {
	return &e
}
func (e *GetProjectsFramework) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "services":
		fallthrough
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "react-router":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "tanstack-start":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fastapi":
		fallthrough
	case "flask":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		fallthrough
	case "nitro":
		fallthrough
	case "hono":
		fallthrough
	case "express":
		fallthrough
	case "h3":
		fallthrough
	case "koa":
		fallthrough
	case "nestjs":
		fallthrough
	case "elysia":
		fallthrough
	case "fastify":
		fallthrough
	case "xmcp":
		fallthrough
	case "python":
		fallthrough
	case "ruby":
		fallthrough
	case "rust":
		fallthrough
	case "node":
		fallthrough
	case "go":
		*e = GetProjectsFramework(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsFramework: %v", v)
	}
}

type GetProjectsLatestDeploymentAliasAssignedType string

const (
	GetProjectsLatestDeploymentAliasAssignedTypeNumber  GetProjectsLatestDeploymentAliasAssignedType = "number"
	GetProjectsLatestDeploymentAliasAssignedTypeBoolean GetProjectsLatestDeploymentAliasAssignedType = "boolean"
)

type GetProjectsLatestDeploymentAliasAssigned struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type GetProjectsLatestDeploymentAliasAssignedType
}

func CreateGetProjectsLatestDeploymentAliasAssignedNumber(number float64) GetProjectsLatestDeploymentAliasAssigned {
	typ := GetProjectsLatestDeploymentAliasAssignedTypeNumber

	return GetProjectsLatestDeploymentAliasAssigned{
		Number: &number,
		Type:   typ,
	}
}

func CreateGetProjectsLatestDeploymentAliasAssignedBoolean(boolean bool) GetProjectsLatestDeploymentAliasAssigned {
	typ := GetProjectsLatestDeploymentAliasAssignedTypeBoolean

	return GetProjectsLatestDeploymentAliasAssigned{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *GetProjectsLatestDeploymentAliasAssigned) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetProjectsLatestDeploymentAliasAssignedTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = GetProjectsLatestDeploymentAliasAssignedTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsLatestDeploymentAliasAssigned", string(data))
}

func (u GetProjectsLatestDeploymentAliasAssigned) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsLatestDeploymentAliasAssigned: all fields are null")
}

type GetProjectsLatestDeploymentBuild struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (g GetProjectsLatestDeploymentBuild) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLatestDeploymentBuild) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLatestDeploymentBuild) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *GetProjectsLatestDeploymentBuild) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *GetProjectsLatestDeploymentBuild) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type GetProjectsLatestDeploymentCreator struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (g GetProjectsLatestDeploymentCreator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLatestDeploymentCreator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLatestDeploymentCreator) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *GetProjectsLatestDeploymentCreator) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *GetProjectsLatestDeploymentCreator) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *GetProjectsLatestDeploymentCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *GetProjectsLatestDeploymentCreator) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type GetProjectsLatestDeployment struct {
	Alias              []string                                  `json:"alias,omitempty"`
	AliasAssigned      *GetProjectsLatestDeploymentAliasAssigned `json:"aliasAssigned,omitempty"`
	Builds             []GetProjectsLatestDeploymentBuild        `json:"builds,omitempty"`
	CreatedAt          float64                                   `json:"createdAt"`
	CreatedIn          string                                    `json:"createdIn"`
	Creator            *GetProjectsLatestDeploymentCreator       `json:"creator"`
	DeploymentHostname string                                    `json:"deploymentHostname"`
	Name               string                                    `json:"name"`
	Forced             *bool                                     `json:"forced,omitempty"`
	ID                 string                                    `json:"id"`
	Meta               map[string]string                         `json:"meta,omitempty"`
	Plan               string                                    `json:"plan"`
	Private            bool                                      `json:"private"`
	ReadyState         string                                    `json:"readyState"`
	RequestedAt        *float64                                  `json:"requestedAt,omitempty"`
	Target             *string                                   `json:"target,omitempty"`
	TeamID             *string                                   `json:"teamId,omitempty"`
	Type               string                                    `json:"type"`
	URL                string                                    `json:"url"`
	UserID             string                                    `json:"userId"`
	WithCache          *bool                                     `json:"withCache,omitempty"`
}

func (g GetProjectsLatestDeployment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLatestDeployment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLatestDeployment) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *GetProjectsLatestDeployment) GetAliasAssigned() *GetProjectsLatestDeploymentAliasAssigned {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *GetProjectsLatestDeployment) GetBuilds() []GetProjectsLatestDeploymentBuild {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *GetProjectsLatestDeployment) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsLatestDeployment) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *GetProjectsLatestDeployment) GetCreator() *GetProjectsLatestDeploymentCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *GetProjectsLatestDeployment) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *GetProjectsLatestDeployment) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsLatestDeployment) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *GetProjectsLatestDeployment) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsLatestDeployment) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *GetProjectsLatestDeployment) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *GetProjectsLatestDeployment) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetProjectsLatestDeployment) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *GetProjectsLatestDeployment) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *GetProjectsLatestDeployment) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *GetProjectsLatestDeployment) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetProjectsLatestDeployment) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *GetProjectsLatestDeployment) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GetProjectsLatestDeployment) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *GetProjectsLatestDeployment) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type GetProjectsTypeBitbucket string

const (
	GetProjectsTypeBitbucketBitbucket GetProjectsTypeBitbucket = "bitbucket"
)

func (e GetProjectsTypeBitbucket) ToPointer() *GetProjectsTypeBitbucket {
	return &e
}
func (e *GetProjectsTypeBitbucket) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = GetProjectsTypeBitbucket(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeBitbucket: %v", v)
	}
}

type GetProjectsDeployHook5 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (g GetProjectsDeployHook5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployHook5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployHook5) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployHook5) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployHook5) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployHook5) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GetProjectsDeployHook5) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type GetProjectsLinkBitbucket struct {
	Name             string                   `json:"name"`
	Slug             string                   `json:"slug"`
	Owner            string                   `json:"owner"`
	Type             GetProjectsTypeBitbucket `json:"type"`
	UUID             string                   `json:"uuid"`
	WorkspaceUUID    string                   `json:"workspaceUuid"`
	CreatedAt        *float64                 `json:"createdAt,omitempty"`
	DeployHooks      []GetProjectsDeployHook5 `json:"deployHooks"`
	GitCredentialID  string                   `json:"gitCredentialId"`
	UpdatedAt        *float64                 `json:"updatedAt,omitempty"`
	Sourceless       *bool                    `json:"sourceless,omitempty"`
	ProductionBranch string                   `json:"productionBranch"`
}

func (g GetProjectsLinkBitbucket) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLinkBitbucket) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"name", "slug", "owner", "type", "uuid", "workspaceUuid", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLinkBitbucket) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsLinkBitbucket) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *GetProjectsLinkBitbucket) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *GetProjectsLinkBitbucket) GetType() GetProjectsTypeBitbucket {
	if o == nil {
		return GetProjectsTypeBitbucket("")
	}
	return o.Type
}

func (o *GetProjectsLinkBitbucket) GetUUID() string {
	if o == nil {
		return ""
	}
	return o.UUID
}

func (o *GetProjectsLinkBitbucket) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *GetProjectsLinkBitbucket) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsLinkBitbucket) GetDeployHooks() []GetProjectsDeployHook5 {
	if o == nil {
		return []GetProjectsDeployHook5{}
	}
	return o.DeployHooks
}

func (o *GetProjectsLinkBitbucket) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *GetProjectsLinkBitbucket) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsLinkBitbucket) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *GetProjectsLinkBitbucket) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type GetProjectsTypeGitlab string

const (
	GetProjectsTypeGitlabGitlab GetProjectsTypeGitlab = "gitlab"
)

func (e GetProjectsTypeGitlab) ToPointer() *GetProjectsTypeGitlab {
	return &e
}
func (e *GetProjectsTypeGitlab) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = GetProjectsTypeGitlab(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeGitlab: %v", v)
	}
}

type GetProjectsDeployHook4 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (g GetProjectsDeployHook4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployHook4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployHook4) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployHook4) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployHook4) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployHook4) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GetProjectsDeployHook4) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type GetProjectsLinkGitlab struct {
	ProjectID                string `json:"projectId"`
	ProjectName              string `json:"projectName"`
	ProjectNameWithNamespace string `json:"projectNameWithNamespace"`
	ProjectNamespace         string `json:"projectNamespace"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).
	ProjectOwnerID   *float64                 `json:"projectOwnerId,omitempty"`
	ProjectURL       string                   `json:"projectUrl"`
	Type             GetProjectsTypeGitlab    `json:"type"`
	CreatedAt        *float64                 `json:"createdAt,omitempty"`
	DeployHooks      []GetProjectsDeployHook4 `json:"deployHooks"`
	GitCredentialID  string                   `json:"gitCredentialId"`
	UpdatedAt        *float64                 `json:"updatedAt,omitempty"`
	Sourceless       *bool                    `json:"sourceless,omitempty"`
	ProductionBranch string                   `json:"productionBranch"`
}

func (g GetProjectsLinkGitlab) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLinkGitlab) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"projectId", "projectName", "projectNameWithNamespace", "projectNamespace", "projectUrl", "type", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLinkGitlab) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *GetProjectsLinkGitlab) GetProjectName() string {
	if o == nil {
		return ""
	}
	return o.ProjectName
}

func (o *GetProjectsLinkGitlab) GetProjectNameWithNamespace() string {
	if o == nil {
		return ""
	}
	return o.ProjectNameWithNamespace
}

func (o *GetProjectsLinkGitlab) GetProjectNamespace() string {
	if o == nil {
		return ""
	}
	return o.ProjectNamespace
}

func (o *GetProjectsLinkGitlab) GetProjectOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.ProjectOwnerID
}

func (o *GetProjectsLinkGitlab) GetProjectURL() string {
	if o == nil {
		return ""
	}
	return o.ProjectURL
}

func (o *GetProjectsLinkGitlab) GetType() GetProjectsTypeGitlab {
	if o == nil {
		return GetProjectsTypeGitlab("")
	}
	return o.Type
}

func (o *GetProjectsLinkGitlab) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsLinkGitlab) GetDeployHooks() []GetProjectsDeployHook4 {
	if o == nil {
		return []GetProjectsDeployHook4{}
	}
	return o.DeployHooks
}

func (o *GetProjectsLinkGitlab) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *GetProjectsLinkGitlab) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsLinkGitlab) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *GetProjectsLinkGitlab) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type GetProjectsTypeGithubCustomHost string

const (
	GetProjectsTypeGithubCustomHostGithubCustomHost GetProjectsTypeGithubCustomHost = "github-custom-host"
)

func (e GetProjectsTypeGithubCustomHost) ToPointer() *GetProjectsTypeGithubCustomHost {
	return &e
}
func (e *GetProjectsTypeGithubCustomHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-custom-host":
		*e = GetProjectsTypeGithubCustomHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeGithubCustomHost: %v", v)
	}
}

type GetProjectsDeployHook3 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (g GetProjectsDeployHook3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployHook3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployHook3) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployHook3) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployHook3) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployHook3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GetProjectsDeployHook3) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type GetProjectsLinkGithubCustomHost struct {
	Org string `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64                        `json:"repoOwnerId,omitempty"`
	Repo             *string                         `json:"repo,omitempty"`
	RepoID           *float64                        `json:"repoId,omitempty"`
	Type             GetProjectsTypeGithubCustomHost `json:"type"`
	Host             string                          `json:"host"`
	CreatedAt        *float64                        `json:"createdAt,omitempty"`
	DeployHooks      []GetProjectsDeployHook3        `json:"deployHooks"`
	GitCredentialID  string                          `json:"gitCredentialId"`
	UpdatedAt        *float64                        `json:"updatedAt,omitempty"`
	Sourceless       *bool                           `json:"sourceless,omitempty"`
	ProductionBranch string                          `json:"productionBranch"`
}

func (g GetProjectsLinkGithubCustomHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLinkGithubCustomHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"org", "type", "host", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLinkGithubCustomHost) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GetProjectsLinkGithubCustomHost) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *GetProjectsLinkGithubCustomHost) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *GetProjectsLinkGithubCustomHost) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *GetProjectsLinkGithubCustomHost) GetType() GetProjectsTypeGithubCustomHost {
	if o == nil {
		return GetProjectsTypeGithubCustomHost("")
	}
	return o.Type
}

func (o *GetProjectsLinkGithubCustomHost) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *GetProjectsLinkGithubCustomHost) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsLinkGithubCustomHost) GetDeployHooks() []GetProjectsDeployHook3 {
	if o == nil {
		return []GetProjectsDeployHook3{}
	}
	return o.DeployHooks
}

func (o *GetProjectsLinkGithubCustomHost) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *GetProjectsLinkGithubCustomHost) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsLinkGithubCustomHost) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *GetProjectsLinkGithubCustomHost) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type GetProjectsTypeGithubLimited string

const (
	GetProjectsTypeGithubLimitedGithubLimited GetProjectsTypeGithubLimited = "github-limited"
)

func (e GetProjectsTypeGithubLimited) ToPointer() *GetProjectsTypeGithubLimited {
	return &e
}
func (e *GetProjectsTypeGithubLimited) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = GetProjectsTypeGithubLimited(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeGithubLimited: %v", v)
	}
}

type GetProjectsDeployHook2 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (g GetProjectsDeployHook2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployHook2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployHook2) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployHook2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployHook2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployHook2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GetProjectsDeployHook2) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}
