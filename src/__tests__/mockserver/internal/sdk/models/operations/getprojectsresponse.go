// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type GetProjectsLinkGithubLimited struct {
	Type      GetProjectsTypeGithubLimited `json:"type"`
	Repo      *string                      `json:"repo,omitempty"`
	RepoID    *float64                     `json:"repoId,omitempty"`
	CreatedAt *float64                     `json:"createdAt,omitempty"`
	UpdatedAt *float64                     `json:"updatedAt,omitempty"`
	Org       string                       `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64                 `json:"repoOwnerId,omitempty"`
	DeployHooks      []GetProjectsDeployHook2 `json:"deployHooks"`
	GitCredentialID  string                   `json:"gitCredentialId"`
	Sourceless       *bool                    `json:"sourceless,omitempty"`
	ProductionBranch string                   `json:"productionBranch"`
}

func (g GetProjectsLinkGithubLimited) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLinkGithubLimited) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "org", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLinkGithubLimited) GetType() GetProjectsTypeGithubLimited {
	if o == nil {
		return GetProjectsTypeGithubLimited("")
	}
	return o.Type
}

func (o *GetProjectsLinkGithubLimited) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *GetProjectsLinkGithubLimited) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *GetProjectsLinkGithubLimited) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsLinkGithubLimited) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsLinkGithubLimited) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GetProjectsLinkGithubLimited) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *GetProjectsLinkGithubLimited) GetDeployHooks() []GetProjectsDeployHook2 {
	if o == nil {
		return []GetProjectsDeployHook2{}
	}
	return o.DeployHooks
}

func (o *GetProjectsLinkGithubLimited) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *GetProjectsLinkGithubLimited) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *GetProjectsLinkGithubLimited) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type GetProjectsTypeGithub string

const (
	GetProjectsTypeGithubGithub GetProjectsTypeGithub = "github"
)

func (e GetProjectsTypeGithub) ToPointer() *GetProjectsTypeGithub {
	return &e
}
func (e *GetProjectsTypeGithub) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = GetProjectsTypeGithub(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTypeGithub: %v", v)
	}
}

type GetProjectsDeployHook1 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (g GetProjectsDeployHook1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDeployHook1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDeployHook1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsDeployHook1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsDeployHook1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsDeployHook1) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *GetProjectsDeployHook1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type GetProjectsLinkGithub struct {
	Org string `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64                 `json:"repoOwnerId,omitempty"`
	Repo             *string                  `json:"repo,omitempty"`
	RepoID           *float64                 `json:"repoId,omitempty"`
	Type             GetProjectsTypeGithub    `json:"type"`
	CreatedAt        *float64                 `json:"createdAt,omitempty"`
	DeployHooks      []GetProjectsDeployHook1 `json:"deployHooks"`
	GitCredentialID  string                   `json:"gitCredentialId"`
	UpdatedAt        *float64                 `json:"updatedAt,omitempty"`
	Sourceless       *bool                    `json:"sourceless,omitempty"`
	ProductionBranch string                   `json:"productionBranch"`
}

func (g GetProjectsLinkGithub) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsLinkGithub) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"org", "type", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsLinkGithub) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *GetProjectsLinkGithub) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *GetProjectsLinkGithub) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *GetProjectsLinkGithub) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *GetProjectsLinkGithub) GetType() GetProjectsTypeGithub {
	if o == nil {
		return GetProjectsTypeGithub("")
	}
	return o.Type
}

func (o *GetProjectsLinkGithub) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsLinkGithub) GetDeployHooks() []GetProjectsDeployHook1 {
	if o == nil {
		return []GetProjectsDeployHook1{}
	}
	return o.DeployHooks
}

func (o *GetProjectsLinkGithub) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *GetProjectsLinkGithub) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsLinkGithub) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *GetProjectsLinkGithub) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type GetProjectsLinkUnionType string

const (
	GetProjectsLinkUnionTypeGithub           GetProjectsLinkUnionType = "github"
	GetProjectsLinkUnionTypeGithubLimited    GetProjectsLinkUnionType = "github-limited"
	GetProjectsLinkUnionTypeGithubCustomHost GetProjectsLinkUnionType = "github-custom-host"
	GetProjectsLinkUnionTypeGitlab           GetProjectsLinkUnionType = "gitlab"
	GetProjectsLinkUnionTypeBitbucket        GetProjectsLinkUnionType = "bitbucket"
)

type GetProjectsLinkUnion struct {
	GetProjectsLinkGithub           *GetProjectsLinkGithub           `queryParam:"inline"`
	GetProjectsLinkGithubLimited    *GetProjectsLinkGithubLimited    `queryParam:"inline"`
	GetProjectsLinkGithubCustomHost *GetProjectsLinkGithubCustomHost `queryParam:"inline"`
	GetProjectsLinkGitlab           *GetProjectsLinkGitlab           `queryParam:"inline"`
	GetProjectsLinkBitbucket        *GetProjectsLinkBitbucket        `queryParam:"inline"`

	Type GetProjectsLinkUnionType
}

func CreateGetProjectsLinkUnionGithub(github GetProjectsLinkGithub) GetProjectsLinkUnion {
	typ := GetProjectsLinkUnionTypeGithub

	typStr := GetProjectsTypeGithub(typ)
	github.Type = typStr

	return GetProjectsLinkUnion{
		GetProjectsLinkGithub: &github,
		Type:                  typ,
	}
}

func CreateGetProjectsLinkUnionGithubLimited(githubLimited GetProjectsLinkGithubLimited) GetProjectsLinkUnion {
	typ := GetProjectsLinkUnionTypeGithubLimited

	typStr := GetProjectsTypeGithubLimited(typ)
	githubLimited.Type = typStr

	return GetProjectsLinkUnion{
		GetProjectsLinkGithubLimited: &githubLimited,
		Type:                         typ,
	}
}

func CreateGetProjectsLinkUnionGithubCustomHost(githubCustomHost GetProjectsLinkGithubCustomHost) GetProjectsLinkUnion {
	typ := GetProjectsLinkUnionTypeGithubCustomHost

	typStr := GetProjectsTypeGithubCustomHost(typ)
	githubCustomHost.Type = typStr

	return GetProjectsLinkUnion{
		GetProjectsLinkGithubCustomHost: &githubCustomHost,
		Type:                            typ,
	}
}

func CreateGetProjectsLinkUnionGitlab(gitlab GetProjectsLinkGitlab) GetProjectsLinkUnion {
	typ := GetProjectsLinkUnionTypeGitlab

	typStr := GetProjectsTypeGitlab(typ)
	gitlab.Type = typStr

	return GetProjectsLinkUnion{
		GetProjectsLinkGitlab: &gitlab,
		Type:                  typ,
	}
}

func CreateGetProjectsLinkUnionBitbucket(bitbucket GetProjectsLinkBitbucket) GetProjectsLinkUnion {
	typ := GetProjectsLinkUnionTypeBitbucket

	typStr := GetProjectsTypeBitbucket(typ)
	bitbucket.Type = typStr

	return GetProjectsLinkUnion{
		GetProjectsLinkBitbucket: &bitbucket,
		Type:                     typ,
	}
}

func (u *GetProjectsLinkUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "github":
		getProjectsLinkGithub := new(GetProjectsLinkGithub)
		if err := utils.UnmarshalJSON(data, &getProjectsLinkGithub, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github) type GetProjectsLinkGithub within GetProjectsLinkUnion: %w", string(data), err)
		}

		u.GetProjectsLinkGithub = getProjectsLinkGithub
		u.Type = GetProjectsLinkUnionTypeGithub
		return nil
	case "github-limited":
		getProjectsLinkGithubLimited := new(GetProjectsLinkGithubLimited)
		if err := utils.UnmarshalJSON(data, &getProjectsLinkGithubLimited, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github-limited) type GetProjectsLinkGithubLimited within GetProjectsLinkUnion: %w", string(data), err)
		}

		u.GetProjectsLinkGithubLimited = getProjectsLinkGithubLimited
		u.Type = GetProjectsLinkUnionTypeGithubLimited
		return nil
	case "github-custom-host":
		getProjectsLinkGithubCustomHost := new(GetProjectsLinkGithubCustomHost)
		if err := utils.UnmarshalJSON(data, &getProjectsLinkGithubCustomHost, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github-custom-host) type GetProjectsLinkGithubCustomHost within GetProjectsLinkUnion: %w", string(data), err)
		}

		u.GetProjectsLinkGithubCustomHost = getProjectsLinkGithubCustomHost
		u.Type = GetProjectsLinkUnionTypeGithubCustomHost
		return nil
	case "gitlab":
		getProjectsLinkGitlab := new(GetProjectsLinkGitlab)
		if err := utils.UnmarshalJSON(data, &getProjectsLinkGitlab, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == gitlab) type GetProjectsLinkGitlab within GetProjectsLinkUnion: %w", string(data), err)
		}

		u.GetProjectsLinkGitlab = getProjectsLinkGitlab
		u.Type = GetProjectsLinkUnionTypeGitlab
		return nil
	case "bitbucket":
		getProjectsLinkBitbucket := new(GetProjectsLinkBitbucket)
		if err := utils.UnmarshalJSON(data, &getProjectsLinkBitbucket, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == bitbucket) type GetProjectsLinkBitbucket within GetProjectsLinkUnion: %w", string(data), err)
		}

		u.GetProjectsLinkBitbucket = getProjectsLinkBitbucket
		u.Type = GetProjectsLinkUnionTypeBitbucket
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsLinkUnion", string(data))
}

func (u GetProjectsLinkUnion) MarshalJSON() ([]byte, error) {
	if u.GetProjectsLinkGithub != nil {
		return utils.MarshalJSON(u.GetProjectsLinkGithub, "", true)
	}

	if u.GetProjectsLinkGithubLimited != nil {
		return utils.MarshalJSON(u.GetProjectsLinkGithubLimited, "", true)
	}

	if u.GetProjectsLinkGithubCustomHost != nil {
		return utils.MarshalJSON(u.GetProjectsLinkGithubCustomHost, "", true)
	}

	if u.GetProjectsLinkGitlab != nil {
		return utils.MarshalJSON(u.GetProjectsLinkGitlab, "", true)
	}

	if u.GetProjectsLinkBitbucket != nil {
		return utils.MarshalJSON(u.GetProjectsLinkBitbucket, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsLinkUnion: all fields are null")
}

type GetProjectsNodeVersion string

const (
	GetProjectsNodeVersionTwentyFourDotX GetProjectsNodeVersion = "24.x"
	GetProjectsNodeVersionTwentyTwoDotX  GetProjectsNodeVersion = "22.x"
	GetProjectsNodeVersionTwentyDotX     GetProjectsNodeVersion = "20.x"
	GetProjectsNodeVersionEighteenDotX   GetProjectsNodeVersion = "18.x"
	GetProjectsNodeVersionSixteenDotX    GetProjectsNodeVersion = "16.x"
	GetProjectsNodeVersionFourteenDotX   GetProjectsNodeVersion = "14.x"
	GetProjectsNodeVersionTwelveDotX     GetProjectsNodeVersion = "12.x"
	GetProjectsNodeVersionTenDotX        GetProjectsNodeVersion = "10.x"
	GetProjectsNodeVersionEightDot10DotX GetProjectsNodeVersion = "8.10.x"
)

func (e GetProjectsNodeVersion) ToPointer() *GetProjectsNodeVersion {
	return &e
}
func (e *GetProjectsNodeVersion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "24.x":
		fallthrough
	case "22.x":
		fallthrough
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		fallthrough
	case "14.x":
		fallthrough
	case "12.x":
		fallthrough
	case "10.x":
		fallthrough
	case "8.10.x":
		*e = GetProjectsNodeVersion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsNodeVersion: %v", v)
	}
}

type GetProjectsPasswordProtection struct {
}

func (g GetProjectsPasswordProtection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsPasswordProtection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

type GetProjectsResourceConfigFunctionDefaultMemoryType string

const (
	GetProjectsResourceConfigFunctionDefaultMemoryTypeStandardLegacy GetProjectsResourceConfigFunctionDefaultMemoryType = "standard_legacy"
	GetProjectsResourceConfigFunctionDefaultMemoryTypeStandard       GetProjectsResourceConfigFunctionDefaultMemoryType = "standard"
	GetProjectsResourceConfigFunctionDefaultMemoryTypePerformance    GetProjectsResourceConfigFunctionDefaultMemoryType = "performance"
)

func (e GetProjectsResourceConfigFunctionDefaultMemoryType) ToPointer() *GetProjectsResourceConfigFunctionDefaultMemoryType {
	return &e
}
func (e *GetProjectsResourceConfigFunctionDefaultMemoryType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard_legacy":
		fallthrough
	case "standard":
		fallthrough
	case "performance":
		*e = GetProjectsResourceConfigFunctionDefaultMemoryType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsResourceConfigFunctionDefaultMemoryType: %v", v)
	}
}

type GetProjectsResourceConfigBuildMachineType string

const (
	GetProjectsResourceConfigBuildMachineTypeStandard GetProjectsResourceConfigBuildMachineType = "standard"
	GetProjectsResourceConfigBuildMachineTypeEnhanced GetProjectsResourceConfigBuildMachineType = "enhanced"
	GetProjectsResourceConfigBuildMachineTypeTurbo    GetProjectsResourceConfigBuildMachineType = "turbo"
	GetProjectsResourceConfigBuildMachineTypeElastic  GetProjectsResourceConfigBuildMachineType = "elastic"
)

func (e GetProjectsResourceConfigBuildMachineType) ToPointer() *GetProjectsResourceConfigBuildMachineType {
	return &e
}
func (e *GetProjectsResourceConfigBuildMachineType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "enhanced":
		fallthrough
	case "turbo":
		fallthrough
	case "elastic":
		*e = GetProjectsResourceConfigBuildMachineType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsResourceConfigBuildMachineType: %v", v)
	}
}

type GetProjectsResourceConfigConfiguration string

const (
	GetProjectsResourceConfigConfigurationSkipNamespaceQueue    GetProjectsResourceConfigConfiguration = "SKIP_NAMESPACE_QUEUE"
	GetProjectsResourceConfigConfigurationWaitForNamespaceQueue GetProjectsResourceConfigConfiguration = "WAIT_FOR_NAMESPACE_QUEUE"
)

func (e GetProjectsResourceConfigConfiguration) ToPointer() *GetProjectsResourceConfigConfiguration {
	return &e
}
func (e *GetProjectsResourceConfigConfiguration) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SKIP_NAMESPACE_QUEUE":
		fallthrough
	case "WAIT_FOR_NAMESPACE_QUEUE":
		*e = GetProjectsResourceConfigConfiguration(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsResourceConfigConfiguration: %v", v)
	}
}

type GetProjectsResourceConfigBuildQueue struct {
	Configuration *GetProjectsResourceConfigConfiguration `json:"configuration,omitempty"`
}

func (g GetProjectsResourceConfigBuildQueue) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsResourceConfigBuildQueue) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsResourceConfigBuildQueue) GetConfiguration() *GetProjectsResourceConfigConfiguration {
	if o == nil {
		return nil
	}
	return o.Configuration
}

type GetProjectsResourceConfig struct {
	ElasticConcurrencyEnabled  *bool                                               `json:"elasticConcurrencyEnabled,omitempty"`
	Fluid                      *bool                                               `json:"fluid,omitempty"`
	FunctionDefaultRegions     []string                                            `json:"functionDefaultRegions"`
	FunctionDefaultTimeout     *float64                                            `json:"functionDefaultTimeout,omitempty"`
	FunctionDefaultMemoryType  *GetProjectsResourceConfigFunctionDefaultMemoryType `json:"functionDefaultMemoryType,omitempty"`
	FunctionZeroConfigFailover *bool                                               `json:"functionZeroConfigFailover,omitempty"`
	BuildMachineType           *GetProjectsResourceConfigBuildMachineType          `json:"buildMachineType,omitempty"`
	IsNSNBDisabled             *bool                                               `json:"isNSNBDisabled,omitempty"`
	BuildQueue                 *GetProjectsResourceConfigBuildQueue                `json:"buildQueue,omitempty"`
}

func (g GetProjectsResourceConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsResourceConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"functionDefaultRegions"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsResourceConfig) GetElasticConcurrencyEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ElasticConcurrencyEnabled
}

func (o *GetProjectsResourceConfig) GetFluid() *bool {
	if o == nil {
		return nil
	}
	return o.Fluid
}

func (o *GetProjectsResourceConfig) GetFunctionDefaultRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.FunctionDefaultRegions
}

func (o *GetProjectsResourceConfig) GetFunctionDefaultTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.FunctionDefaultTimeout
}

func (o *GetProjectsResourceConfig) GetFunctionDefaultMemoryType() *GetProjectsResourceConfigFunctionDefaultMemoryType {
	if o == nil {
		return nil
	}
	return o.FunctionDefaultMemoryType
}

func (o *GetProjectsResourceConfig) GetFunctionZeroConfigFailover() *bool {
	if o == nil {
		return nil
	}
	return o.FunctionZeroConfigFailover
}

func (o *GetProjectsResourceConfig) GetBuildMachineType() *GetProjectsResourceConfigBuildMachineType {
	if o == nil {
		return nil
	}
	return o.BuildMachineType
}

func (o *GetProjectsResourceConfig) GetIsNSNBDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.IsNSNBDisabled
}

func (o *GetProjectsResourceConfig) GetBuildQueue() *GetProjectsResourceConfigBuildQueue {
	if o == nil {
		return nil
	}
	return o.BuildQueue
}

// GetProjectsStage - An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
type GetProjectsStage struct {
	// The percentage of traffic to serve to the canary deployment (0-100)
	TargetPercentage float64 `json:"targetPercentage"`
	// Whether or not this stage requires manual approval to proceed
	RequireApproval *bool `json:"requireApproval,omitempty"`
	// Duration in minutes for automatic advancement to the next stage
	Duration *float64 `json:"duration,omitempty"`
	// Whether to linearly shift traffic over the duration of this stage
	LinearShift *bool `json:"linearShift,omitempty"`
}

func (g GetProjectsStage) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsStage) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"targetPercentage"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsStage) GetTargetPercentage() float64 {
	if o == nil {
		return 0.0
	}
	return o.TargetPercentage
}

func (o *GetProjectsStage) GetRequireApproval() *bool {
	if o == nil {
		return nil
	}
	return o.RequireApproval
}

func (o *GetProjectsStage) GetDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *GetProjectsStage) GetLinearShift() *bool {
	if o == nil {
		return nil
	}
	return o.LinearShift
}

// GetProjectsRollingRelease - Project-level rolling release configuration that defines how deployments should be gradually rolled out
type GetProjectsRollingRelease struct {
	// The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.
	Target string `json:"target"`
	// An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
	Stages []GetProjectsStage `json:"stages,omitempty"`
	// Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.
	CanaryResponseHeader *bool `json:"canaryResponseHeader,omitempty"`
}

func (g GetProjectsRollingRelease) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsRollingRelease) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"target"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsRollingRelease) GetTarget() string {
	if o == nil {
		return ""
	}
	return o.Target
}

func (o *GetProjectsRollingRelease) GetStages() []GetProjectsStage {
	if o == nil {
		return nil
	}
	return o.Stages
}

func (o *GetProjectsRollingRelease) GetCanaryResponseHeader() *bool {
	if o == nil {
		return nil
	}
	return o.CanaryResponseHeader
}

type GetProjectsSpeedInsights struct {
	ID         string   `json:"id"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
	PaidAt     *float64 `json:"paidAt,omitempty"`
}

func (g GetProjectsSpeedInsights) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsSpeedInsights) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsSpeedInsights) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsSpeedInsights) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *GetProjectsSpeedInsights) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetProjectsSpeedInsights) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *GetProjectsSpeedInsights) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

func (o *GetProjectsSpeedInsights) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

type GetProjectsSsoProtectionDeploymentType string

const (
	GetProjectsSsoProtectionDeploymentTypePreview                          GetProjectsSsoProtectionDeploymentType = "preview"
	GetProjectsSsoProtectionDeploymentTypeAll                              GetProjectsSsoProtectionDeploymentType = "all"
	GetProjectsSsoProtectionDeploymentTypeProdDeploymentUrlsAndAllPreviews GetProjectsSsoProtectionDeploymentType = "prod_deployment_urls_and_all_previews"
	GetProjectsSsoProtectionDeploymentTypeAllExceptCustomDomains           GetProjectsSsoProtectionDeploymentType = "all_except_custom_domains"
)

func (e GetProjectsSsoProtectionDeploymentType) ToPointer() *GetProjectsSsoProtectionDeploymentType {
	return &e
}
func (e *GetProjectsSsoProtectionDeploymentType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preview":
		fallthrough
	case "all":
		fallthrough
	case "prod_deployment_urls_and_all_previews":
		fallthrough
	case "all_except_custom_domains":
		*e = GetProjectsSsoProtectionDeploymentType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsSsoProtectionDeploymentType: %v", v)
	}
}

type GetProjectsCve55182MigrationAppliedFrom string

const (
	GetProjectsCve55182MigrationAppliedFromPreview                          GetProjectsCve55182MigrationAppliedFrom = "preview"
	GetProjectsCve55182MigrationAppliedFromAll                              GetProjectsCve55182MigrationAppliedFrom = "all"
	GetProjectsCve55182MigrationAppliedFromProdDeploymentUrlsAndAllPreviews GetProjectsCve55182MigrationAppliedFrom = "prod_deployment_urls_and_all_previews"
	GetProjectsCve55182MigrationAppliedFromAllExceptCustomDomains           GetProjectsCve55182MigrationAppliedFrom = "all_except_custom_domains"
)

func (e GetProjectsCve55182MigrationAppliedFrom) ToPointer() *GetProjectsCve55182MigrationAppliedFrom {
	return &e
}
func (e *GetProjectsCve55182MigrationAppliedFrom) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preview":
		fallthrough
	case "all":
		fallthrough
	case "prod_deployment_urls_and_all_previews":
		fallthrough
	case "all_except_custom_domains":
		*e = GetProjectsCve55182MigrationAppliedFrom(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsCve55182MigrationAppliedFrom: %v", v)
	}
}

type GetProjectsSsoProtection struct {
	DeploymentType               GetProjectsSsoProtectionDeploymentType   `json:"deploymentType"`
	Cve55182MigrationAppliedFrom *GetProjectsCve55182MigrationAppliedFrom `json:"cve55182MigrationAppliedFrom,omitempty"`
}

func (g GetProjectsSsoProtection) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsSsoProtection) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"deploymentType"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsSsoProtection) GetDeploymentType() GetProjectsSsoProtectionDeploymentType {
	if o == nil {
		return GetProjectsSsoProtectionDeploymentType("")
	}
	return o.DeploymentType
}

func (o *GetProjectsSsoProtection) GetCve55182MigrationAppliedFrom() *GetProjectsCve55182MigrationAppliedFrom {
	if o == nil {
		return nil
	}
	return o.Cve55182MigrationAppliedFrom
}

type GetProjectsTargetsAliasAssignedType string

const (
	GetProjectsTargetsAliasAssignedTypeNumber  GetProjectsTargetsAliasAssignedType = "number"
	GetProjectsTargetsAliasAssignedTypeBoolean GetProjectsTargetsAliasAssignedType = "boolean"
)

type GetProjectsTargetsAliasAssigned struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type GetProjectsTargetsAliasAssignedType
}

func CreateGetProjectsTargetsAliasAssignedNumber(number float64) GetProjectsTargetsAliasAssigned {
	typ := GetProjectsTargetsAliasAssignedTypeNumber

	return GetProjectsTargetsAliasAssigned{
		Number: &number,
		Type:   typ,
	}
}

func CreateGetProjectsTargetsAliasAssignedBoolean(boolean bool) GetProjectsTargetsAliasAssigned {
	typ := GetProjectsTargetsAliasAssignedTypeBoolean

	return GetProjectsTargetsAliasAssigned{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *GetProjectsTargetsAliasAssigned) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetProjectsTargetsAliasAssignedTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = GetProjectsTargetsAliasAssignedTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsTargetsAliasAssigned", string(data))
}

func (u GetProjectsTargetsAliasAssigned) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsTargetsAliasAssigned: all fields are null")
}

type GetProjectsTargetsBuild struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (g GetProjectsTargetsBuild) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsTargetsBuild) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsTargetsBuild) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *GetProjectsTargetsBuild) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *GetProjectsTargetsBuild) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type GetProjectsTargetsCreator struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (g GetProjectsTargetsCreator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsTargetsCreator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsTargetsCreator) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *GetProjectsTargetsCreator) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *GetProjectsTargetsCreator) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *GetProjectsTargetsCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *GetProjectsTargetsCreator) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type GetProjectsTargets struct {
	Alias              []string                         `json:"alias,omitempty"`
	AliasAssigned      *GetProjectsTargetsAliasAssigned `json:"aliasAssigned,omitempty"`
	Builds             []GetProjectsTargetsBuild        `json:"builds,omitempty"`
	CreatedAt          float64                          `json:"createdAt"`
	CreatedIn          string                           `json:"createdIn"`
	Creator            *GetProjectsTargetsCreator       `json:"creator"`
	DeploymentHostname string                           `json:"deploymentHostname"`
	Name               string                           `json:"name"`
	Forced             *bool                            `json:"forced,omitempty"`
	ID                 string                           `json:"id"`
	Meta               map[string]string                `json:"meta,omitempty"`
	Plan               string                           `json:"plan"`
	Private            bool                             `json:"private"`
	ReadyState         string                           `json:"readyState"`
	RequestedAt        *float64                         `json:"requestedAt,omitempty"`
	Target             *string                          `json:"target,omitempty"`
	TeamID             *string                          `json:"teamId,omitempty"`
	Type               string                           `json:"type"`
	URL                string                           `json:"url"`
	UserID             string                           `json:"userId"`
	WithCache          *bool                            `json:"withCache,omitempty"`
}

func (g GetProjectsTargets) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsTargets) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsTargets) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *GetProjectsTargets) GetAliasAssigned() *GetProjectsTargetsAliasAssigned {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *GetProjectsTargets) GetBuilds() []GetProjectsTargetsBuild {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *GetProjectsTargets) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsTargets) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *GetProjectsTargets) GetCreator() *GetProjectsTargetsCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *GetProjectsTargets) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *GetProjectsTargets) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsTargets) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *GetProjectsTargets) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsTargets) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *GetProjectsTargets) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *GetProjectsTargets) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *GetProjectsTargets) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *GetProjectsTargets) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *GetProjectsTargets) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *GetProjectsTargets) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetProjectsTargets) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *GetProjectsTargets) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *GetProjectsTargets) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *GetProjectsTargets) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type GetProjectsGitComments struct {
	// Whether the Vercel bot should comment on PRs
	OnPullRequest bool `json:"onPullRequest"`
	// Whether the Vercel bot should comment on commits
	OnCommit bool `json:"onCommit"`
}

func (g GetProjectsGitComments) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsGitComments) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"onPullRequest", "onCommit"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsGitComments) GetOnPullRequest() bool {
	if o == nil {
		return false
	}
	return o.OnPullRequest
}

func (o *GetProjectsGitComments) GetOnCommit() bool {
	if o == nil {
		return false
	}
	return o.OnCommit
}

// GetProjectsCreateDeployments - Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
type GetProjectsCreateDeployments string

const (
	GetProjectsCreateDeploymentsEnabled  GetProjectsCreateDeployments = "enabled"
	GetProjectsCreateDeploymentsDisabled GetProjectsCreateDeployments = "disabled"
)

func (e GetProjectsCreateDeployments) ToPointer() *GetProjectsCreateDeployments {
	return &e
}
func (e *GetProjectsCreateDeployments) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		*e = GetProjectsCreateDeployments(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsCreateDeployments: %v", v)
	}
}

type GetProjectsGitProviderOptions struct {
	// Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
	CreateDeployments GetProjectsCreateDeployments `json:"createDeployments"`
	// Whether the Vercel bot should not automatically create GitHub repository-dispatch events on deployment events. https://vercel.com/docs/git/vercel-for-github#repository-dispatch-events
	DisableRepositoryDispatchEvents *bool `json:"disableRepositoryDispatchEvents,omitempty"`
	// Whether the project requires commits to be signed before deployments will be created.
	RequireVerifiedCommits *bool `json:"requireVerifiedCommits,omitempty"`
}

func (g GetProjectsGitProviderOptions) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsGitProviderOptions) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"createDeployments"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsGitProviderOptions) GetCreateDeployments() GetProjectsCreateDeployments {
	if o == nil {
		return GetProjectsCreateDeployments("")
	}
	return o.CreateDeployments
}

func (o *GetProjectsGitProviderOptions) GetDisableRepositoryDispatchEvents() *bool {
	if o == nil {
		return nil
	}
	return o.DisableRepositoryDispatchEvents
}

func (o *GetProjectsGitProviderOptions) GetRequireVerifiedCommits() *bool {
	if o == nil {
		return nil
	}
	return o.RequireVerifiedCommits
}

type GetProjectsWebAnalytics struct {
	ID         string   `json:"id"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
}

func (g GetProjectsWebAnalytics) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsWebAnalytics) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsWebAnalytics) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsWebAnalytics) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *GetProjectsWebAnalytics) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *GetProjectsWebAnalytics) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *GetProjectsWebAnalytics) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

type Src struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (s Src) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *Src) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Src) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *Src) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *Src) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *Src) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *Src) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *Src) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *Src) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *Src) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *Src) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *Src) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *Src) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type SrcUnionType string

const (
	SrcUnionTypeStr SrcUnionType = "str"
	SrcUnionTypeSrc SrcUnionType = "src"
)

type SrcUnion struct {
	Str *string `queryParam:"inline"`
	Src *Src    `queryParam:"inline"`

	Type SrcUnionType
}

func CreateSrcUnionStr(str string) SrcUnion {
	typ := SrcUnionTypeStr

	return SrcUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateSrcUnionSrc(src Src) SrcUnion {
	typ := SrcUnionTypeSrc

	return SrcUnion{
		Src:  &src,
		Type: typ,
	}
}

func (u *SrcUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SrcUnionTypeStr
		return nil
	}

	var src Src = Src{}
	if err := utils.UnmarshalJSON(data, &src, "", true, nil); err == nil {
		u.Src = &src
		u.Type = SrcUnionTypeSrc
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SrcUnion", string(data))
}

func (u SrcUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Src != nil {
		return utils.MarshalJSON(u.Src, "", true)
	}

	return nil, errors.New("could not marshal union type SrcUnion: all fields are null")
}

type FirewallRouteHasType string

const (
	FirewallRouteHasTypePath               FirewallRouteHasType = "path"
	FirewallRouteHasTypeQuery              FirewallRouteHasType = "query"
	FirewallRouteHasTypeHost               FirewallRouteHasType = "host"
	FirewallRouteHasTypeMethod             FirewallRouteHasType = "method"
	FirewallRouteHasTypeHeader             FirewallRouteHasType = "header"
	FirewallRouteHasTypeCookie             FirewallRouteHasType = "cookie"
	FirewallRouteHasTypeIPAddress          FirewallRouteHasType = "ip_address"
	FirewallRouteHasTypeProtocol           FirewallRouteHasType = "protocol"
	FirewallRouteHasTypeScheme             FirewallRouteHasType = "scheme"
	FirewallRouteHasTypeEnvironment        FirewallRouteHasType = "environment"
	FirewallRouteHasTypeRegion             FirewallRouteHasType = "region"
	FirewallRouteHasTypeInitialRequestPath FirewallRouteHasType = "initial_request_path"
)

func (e FirewallRouteHasType) ToPointer() *FirewallRouteHasType {
	return &e
}
func (e *FirewallRouteHasType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "path":
		fallthrough
	case "query":
		fallthrough
	case "host":
		fallthrough
	case "method":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "ip_address":
		fallthrough
	case "protocol":
		fallthrough
	case "scheme":
		fallthrough
	case "environment":
		fallthrough
	case "region":
		fallthrough
	case "initial_request_path":
		*e = FirewallRouteHasType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FirewallRouteHasType: %v", v)
	}
}

type ValueFirewallRouteHas struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (v ValueFirewallRouteHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *ValueFirewallRouteHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ValueFirewallRouteHas) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *ValueFirewallRouteHas) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *ValueFirewallRouteHas) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *ValueFirewallRouteHas) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *ValueFirewallRouteHas) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *ValueFirewallRouteHas) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *ValueFirewallRouteHas) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *ValueFirewallRouteHas) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *ValueFirewallRouteHas) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *ValueFirewallRouteHas) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *ValueFirewallRouteHas) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type FirewallRouteHasValueUnionType string

const (
	FirewallRouteHasValueUnionTypeStr                   FirewallRouteHasValueUnionType = "str"
	FirewallRouteHasValueUnionTypeValueFirewallRouteHas FirewallRouteHasValueUnionType = "value_firewallRoute_has"
)

type FirewallRouteHasValueUnion struct {
	Str                   *string                `queryParam:"inline"`
	ValueFirewallRouteHas *ValueFirewallRouteHas `queryParam:"inline"`

	Type FirewallRouteHasValueUnionType
}

func CreateFirewallRouteHasValueUnionStr(str string) FirewallRouteHasValueUnion {
	typ := FirewallRouteHasValueUnionTypeStr

	return FirewallRouteHasValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateFirewallRouteHasValueUnionValueFirewallRouteHas(valueFirewallRouteHas ValueFirewallRouteHas) FirewallRouteHasValueUnion {
	typ := FirewallRouteHasValueUnionTypeValueFirewallRouteHas

	return FirewallRouteHasValueUnion{
		ValueFirewallRouteHas: &valueFirewallRouteHas,
		Type:                  typ,
	}
}

func (u *FirewallRouteHasValueUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = FirewallRouteHasValueUnionTypeStr
		return nil
	}

	var valueFirewallRouteHas ValueFirewallRouteHas = ValueFirewallRouteHas{}
	if err := utils.UnmarshalJSON(data, &valueFirewallRouteHas, "", true, nil); err == nil {
		u.ValueFirewallRouteHas = &valueFirewallRouteHas
		u.Type = FirewallRouteHasValueUnionTypeValueFirewallRouteHas
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FirewallRouteHasValueUnion", string(data))
}

func (u FirewallRouteHasValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueFirewallRouteHas != nil {
		return utils.MarshalJSON(u.ValueFirewallRouteHas, "", true)
	}

	return nil, errors.New("could not marshal union type FirewallRouteHasValueUnion: all fields are null")
}

type FirewallRouteHas struct {
	Type  FirewallRouteHasType        `json:"type"`
	Key   *string                     `json:"key,omitempty"`
	Value *FirewallRouteHasValueUnion `json:"value,omitempty"`
}

func (f FirewallRouteHas) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FirewallRouteHas) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *FirewallRouteHas) GetType() FirewallRouteHasType {
	if o == nil {
		return FirewallRouteHasType("")
	}
	return o.Type
}

func (o *FirewallRouteHas) GetKey() *string {
	if o == nil {
		return nil
	}
	return o.Key
}

func (o *FirewallRouteHas) GetValue() *FirewallRouteHasValueUnion {
	if o == nil {
		return nil
	}
	return o.Value
}

type FirewallRouteMissingType string

const (
	FirewallRouteMissingTypePath               FirewallRouteMissingType = "path"
	FirewallRouteMissingTypeQuery              FirewallRouteMissingType = "query"
	FirewallRouteMissingTypeHost               FirewallRouteMissingType = "host"
	FirewallRouteMissingTypeMethod             FirewallRouteMissingType = "method"
	FirewallRouteMissingTypeHeader             FirewallRouteMissingType = "header"
	FirewallRouteMissingTypeCookie             FirewallRouteMissingType = "cookie"
	FirewallRouteMissingTypeIPAddress          FirewallRouteMissingType = "ip_address"
	FirewallRouteMissingTypeProtocol           FirewallRouteMissingType = "protocol"
	FirewallRouteMissingTypeScheme             FirewallRouteMissingType = "scheme"
	FirewallRouteMissingTypeEnvironment        FirewallRouteMissingType = "environment"
	FirewallRouteMissingTypeRegion             FirewallRouteMissingType = "region"
	FirewallRouteMissingTypeInitialRequestPath FirewallRouteMissingType = "initial_request_path"
)

func (e FirewallRouteMissingType) ToPointer() *FirewallRouteMissingType {
	return &e
}
func (e *FirewallRouteMissingType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "path":
		fallthrough
	case "query":
		fallthrough
	case "host":
		fallthrough
	case "method":
		fallthrough
	case "header":
		fallthrough
	case "cookie":
		fallthrough
	case "ip_address":
		fallthrough
	case "protocol":
		fallthrough
	case "scheme":
		fallthrough
	case "environment":
		fallthrough
	case "region":
		fallthrough
	case "initial_request_path":
		*e = FirewallRouteMissingType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FirewallRouteMissingType: %v", v)
	}
}

type ValueFirewallRouteMissing struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (v ValueFirewallRouteMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *ValueFirewallRouteMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ValueFirewallRouteMissing) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *ValueFirewallRouteMissing) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *ValueFirewallRouteMissing) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *ValueFirewallRouteMissing) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *ValueFirewallRouteMissing) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *ValueFirewallRouteMissing) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *ValueFirewallRouteMissing) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *ValueFirewallRouteMissing) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *ValueFirewallRouteMissing) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *ValueFirewallRouteMissing) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *ValueFirewallRouteMissing) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type FirewallRouteMissingValueUnionType string

const (
	FirewallRouteMissingValueUnionTypeStr                       FirewallRouteMissingValueUnionType = "str"
	FirewallRouteMissingValueUnionTypeValueFirewallRouteMissing FirewallRouteMissingValueUnionType = "value_firewallRoute_missing"
)

type FirewallRouteMissingValueUnion struct {
	Str                       *string                    `queryParam:"inline"`
	ValueFirewallRouteMissing *ValueFirewallRouteMissing `queryParam:"inline"`

	Type FirewallRouteMissingValueUnionType
}

func CreateFirewallRouteMissingValueUnionStr(str string) FirewallRouteMissingValueUnion {
	typ := FirewallRouteMissingValueUnionTypeStr

	return FirewallRouteMissingValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateFirewallRouteMissingValueUnionValueFirewallRouteMissing(valueFirewallRouteMissing ValueFirewallRouteMissing) FirewallRouteMissingValueUnion {
	typ := FirewallRouteMissingValueUnionTypeValueFirewallRouteMissing

	return FirewallRouteMissingValueUnion{
		ValueFirewallRouteMissing: &valueFirewallRouteMissing,
		Type:                      typ,
	}
}

func (u *FirewallRouteMissingValueUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = FirewallRouteMissingValueUnionTypeStr
		return nil
	}

	var valueFirewallRouteMissing ValueFirewallRouteMissing = ValueFirewallRouteMissing{}
	if err := utils.UnmarshalJSON(data, &valueFirewallRouteMissing, "", true, nil); err == nil {
		u.ValueFirewallRouteMissing = &valueFirewallRouteMissing
		u.Type = FirewallRouteMissingValueUnionTypeValueFirewallRouteMissing
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for FirewallRouteMissingValueUnion", string(data))
}

func (u FirewallRouteMissingValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.ValueFirewallRouteMissing != nil {
		return utils.MarshalJSON(u.ValueFirewallRouteMissing, "", true)
	}

	return nil, errors.New("could not marshal union type FirewallRouteMissingValueUnion: all fields are null")
}

type GetProjectsMissing struct {
	Type  FirewallRouteMissingType        `json:"type"`
	Key   *string                         `json:"key,omitempty"`
	Value *FirewallRouteMissingValueUnion `json:"value,omitempty"`
}

func (g GetProjectsMissing) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsMissing) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsMissing) GetType() FirewallRouteMissingType {
	if o == nil {
		return FirewallRouteMissingType("")
	}
	return o.Type
}

func (o *GetProjectsMissing) GetKey() *string {
	if o == nil {
		return nil
	}
	return o.Key
}

func (o *GetProjectsMissing) GetValue() *FirewallRouteMissingValueUnion {
	if o == nil {
		return nil
	}
	return o.Value
}

type GetProjectsHandle string

const (
	GetProjectsHandleInit     GetProjectsHandle = "init"
	GetProjectsHandleFinalize GetProjectsHandle = "finalize"
)

func (e GetProjectsHandle) ToPointer() *GetProjectsHandle {
	return &e
}
func (e *GetProjectsHandle) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "init":
		fallthrough
	case "finalize":
		*e = GetProjectsHandle(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsHandle: %v", v)
	}
}

type FirewallRouteAction string

const (
	FirewallRouteActionLog       FirewallRouteAction = "log"
	FirewallRouteActionDeny      FirewallRouteAction = "deny"
	FirewallRouteActionChallenge FirewallRouteAction = "challenge"
	FirewallRouteActionBypass    FirewallRouteAction = "bypass"
	FirewallRouteActionRateLimit FirewallRouteAction = "rate_limit"
	FirewallRouteActionRedirect  FirewallRouteAction = "redirect"
)

func (e FirewallRouteAction) ToPointer() *FirewallRouteAction {
	return &e
}
func (e *FirewallRouteAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		fallthrough
	case "bypass":
		fallthrough
	case "rate_limit":
		fallthrough
	case "redirect":
		*e = FirewallRouteAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for FirewallRouteAction: %v", v)
	}
}

type GetProjectsAlgo string

const (
	GetProjectsAlgoFixedWindow GetProjectsAlgo = "fixed_window"
	GetProjectsAlgoTokenBucket GetProjectsAlgo = "token_bucket"
)

func (e GetProjectsAlgo) ToPointer() *GetProjectsAlgo {
	return &e
}
func (e *GetProjectsAlgo) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "fixed_window":
		fallthrough
	case "token_bucket":
		*e = GetProjectsAlgo(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsAlgo: %v", v)
	}
}

type Erl struct {
	Algo   GetProjectsAlgo `json:"algo"`
	Window float64         `json:"window"`
	Limit  float64         `json:"limit"`
	Keys   []string        `json:"keys"`
}

func (e Erl) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(e, "", false)
}

func (e *Erl) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &e, "", false, []string{"algo", "window", "limit", "keys"}); err != nil {
		return err
	}
	return nil
}

func (o *Erl) GetAlgo() GetProjectsAlgo {
	if o == nil {
		return GetProjectsAlgo("")
	}
	return o.Algo
}

func (o *Erl) GetWindow() float64 {
	if o == nil {
		return 0.0
	}
	return o.Window
}

func (o *Erl) GetLimit() float64 {
	if o == nil {
		return 0.0
	}
	return o.Limit
}

func (o *Erl) GetKeys() []string {
	if o == nil {
		return []string{}
	}
	return o.Keys
}

type GetProjectsLogHeadersEnum string

const (
	GetProjectsLogHeadersEnumWildcard GetProjectsLogHeadersEnum = "*"
)

func (e GetProjectsLogHeadersEnum) ToPointer() *GetProjectsLogHeadersEnum {
	return &e
}
func (e *GetProjectsLogHeadersEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "*":
		*e = GetProjectsLogHeadersEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsLogHeadersEnum: %v", v)
	}
}

type GetProjectsLogHeadersUnionType string

const (
	GetProjectsLogHeadersUnionTypeArrayOfStr                GetProjectsLogHeadersUnionType = "arrayOfStr"
	GetProjectsLogHeadersUnionTypeGetProjectsLogHeadersEnum GetProjectsLogHeadersUnionType = "getProjects_log_headers_enum"
)

type GetProjectsLogHeadersUnion struct {
	ArrayOfStr                []string                   `queryParam:"inline"`
	GetProjectsLogHeadersEnum *GetProjectsLogHeadersEnum `queryParam:"inline"`

	Type GetProjectsLogHeadersUnionType
}

func CreateGetProjectsLogHeadersUnionArrayOfStr(arrayOfStr []string) GetProjectsLogHeadersUnion {
	typ := GetProjectsLogHeadersUnionTypeArrayOfStr

	return GetProjectsLogHeadersUnion{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func CreateGetProjectsLogHeadersUnionGetProjectsLogHeadersEnum(getProjectsLogHeadersEnum GetProjectsLogHeadersEnum) GetProjectsLogHeadersUnion {
	typ := GetProjectsLogHeadersUnionTypeGetProjectsLogHeadersEnum

	return GetProjectsLogHeadersUnion{
		GetProjectsLogHeadersEnum: &getProjectsLogHeadersEnum,
		Type:                      typ,
	}
}

func (u *GetProjectsLogHeadersUnion) UnmarshalJSON(data []byte) error {

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, nil); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = GetProjectsLogHeadersUnionTypeArrayOfStr
		return nil
	}

	var getProjectsLogHeadersEnum GetProjectsLogHeadersEnum = GetProjectsLogHeadersEnum("")
	if err := utils.UnmarshalJSON(data, &getProjectsLogHeadersEnum, "", true, nil); err == nil {
		u.GetProjectsLogHeadersEnum = &getProjectsLogHeadersEnum
		u.Type = GetProjectsLogHeadersUnionTypeGetProjectsLogHeadersEnum
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsLogHeadersUnion", string(data))
}

func (u GetProjectsLogHeadersUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	if u.GetProjectsLogHeadersEnum != nil {
		return utils.MarshalJSON(u.GetProjectsLogHeadersEnum, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsLogHeadersUnion: all fields are null")
}

type FirewallRouteMitigate struct {
	Action     FirewallRouteAction         `json:"action"`
	RuleID     string                      `json:"rule_id"`
	TTL        *float64                    `json:"ttl,omitempty"`
	Erl        *Erl                        `json:"erl,omitempty"`
	LogHeaders *GetProjectsLogHeadersUnion `json:"log_headers,omitempty"`
}

func (f FirewallRouteMitigate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FirewallRouteMitigate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, []string{"action", "rule_id"}); err != nil {
		return err
	}
	return nil
}

func (o *FirewallRouteMitigate) GetAction() FirewallRouteAction {
	if o == nil {
		return FirewallRouteAction("")
	}
	return o.Action
}

func (o *FirewallRouteMitigate) GetRuleID() string {
	if o == nil {
		return ""
	}
	return o.RuleID
}

func (o *FirewallRouteMitigate) GetTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.TTL
}

func (o *FirewallRouteMitigate) GetErl() *Erl {
	if o == nil {
		return nil
	}
	return o.Erl
}

func (o *FirewallRouteMitigate) GetLogHeaders() *GetProjectsLogHeadersUnion {
	if o == nil {
		return nil
	}
	return o.LogHeaders
}

type FirewallRoute struct {
	Src      *SrcUnion              `json:"src,omitempty"`
	Has      []FirewallRouteHas     `json:"has,omitempty"`
	Missing  []GetProjectsMissing   `json:"missing,omitempty"`
	Dest     *string                `json:"dest,omitempty"`
	Status   *float64               `json:"status,omitempty"`
	Handle   *GetProjectsHandle     `json:"handle,omitempty"`
	Mitigate *FirewallRouteMitigate `json:"mitigate,omitempty"`
}

func (f FirewallRoute) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(f, "", false)
}

func (f *FirewallRoute) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &f, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *FirewallRoute) GetSrc() *SrcUnion {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *FirewallRoute) GetHas() []FirewallRouteHas {
	if o == nil {
		return nil
	}
	return o.Has
}

func (o *FirewallRoute) GetMissing() []GetProjectsMissing {
	if o == nil {
		return nil
	}
	return o.Missing
}

func (o *FirewallRoute) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

func (o *FirewallRoute) GetStatus() *float64 {
	if o == nil {
		return nil
	}
	return o.Status
}

func (o *FirewallRoute) GetHandle() *GetProjectsHandle {
	if o == nil {
		return nil
	}
	return o.Handle
}

func (o *FirewallRoute) GetMitigate() *FirewallRouteMitigate {
	if o == nil {
		return nil
	}
	return o.Mitigate
}

type GetProjectsVercelRulesetAction string

const (
	GetProjectsVercelRulesetActionLog       GetProjectsVercelRulesetAction = "log"
	GetProjectsVercelRulesetActionDeny      GetProjectsVercelRulesetAction = "deny"
	GetProjectsVercelRulesetActionChallenge GetProjectsVercelRulesetAction = "challenge"
)

func (e GetProjectsVercelRulesetAction) ToPointer() *GetProjectsVercelRulesetAction {
	return &e
}
func (e *GetProjectsVercelRulesetAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = GetProjectsVercelRulesetAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsVercelRulesetAction: %v", v)
	}
}

type GetProjectsVercelRuleset struct {
	Active bool                            `json:"active"`
	Action *GetProjectsVercelRulesetAction `json:"action,omitempty"`
}

func (g GetProjectsVercelRuleset) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsVercelRuleset) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsVercelRuleset) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *GetProjectsVercelRuleset) GetAction() *GetProjectsVercelRulesetAction {
	if o == nil {
		return nil
	}
	return o.Action
}

type GetProjectsBotFilterAction string

const (
	GetProjectsBotFilterActionLog       GetProjectsBotFilterAction = "log"
	GetProjectsBotFilterActionDeny      GetProjectsBotFilterAction = "deny"
	GetProjectsBotFilterActionChallenge GetProjectsBotFilterAction = "challenge"
)

func (e GetProjectsBotFilterAction) ToPointer() *GetProjectsBotFilterAction {
	return &e
}
func (e *GetProjectsBotFilterAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = GetProjectsBotFilterAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBotFilterAction: %v", v)
	}
}

type GetProjectsBotFilter struct {
	Active bool                        `json:"active"`
	Action *GetProjectsBotFilterAction `json:"action,omitempty"`
}

func (g GetProjectsBotFilter) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBotFilter) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBotFilter) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *GetProjectsBotFilter) GetAction() *GetProjectsBotFilterAction {
	if o == nil {
		return nil
	}
	return o.Action
}

type GetProjectsAiBotsAction string

const (
	GetProjectsAiBotsActionLog       GetProjectsAiBotsAction = "log"
	GetProjectsAiBotsActionDeny      GetProjectsAiBotsAction = "deny"
	GetProjectsAiBotsActionChallenge GetProjectsAiBotsAction = "challenge"
)

func (e GetProjectsAiBotsAction) ToPointer() *GetProjectsAiBotsAction {
	return &e
}
func (e *GetProjectsAiBotsAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = GetProjectsAiBotsAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsAiBotsAction: %v", v)
	}
}

type GetProjectsAiBots struct {
	Active bool                     `json:"active"`
	Action *GetProjectsAiBotsAction `json:"action,omitempty"`
}

func (g GetProjectsAiBots) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsAiBots) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsAiBots) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *GetProjectsAiBots) GetAction() *GetProjectsAiBotsAction {
	if o == nil {
		return nil
	}
	return o.Action
}

type GetProjectsOwaspAction string

const (
	GetProjectsOwaspActionLog       GetProjectsOwaspAction = "log"
	GetProjectsOwaspActionDeny      GetProjectsOwaspAction = "deny"
	GetProjectsOwaspActionChallenge GetProjectsOwaspAction = "challenge"
)

func (e GetProjectsOwaspAction) ToPointer() *GetProjectsOwaspAction {
	return &e
}
func (e *GetProjectsOwaspAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "log":
		fallthrough
	case "deny":
		fallthrough
	case "challenge":
		*e = GetProjectsOwaspAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsOwaspAction: %v", v)
	}
}

type GetProjectsOwasp struct {
	Active bool                    `json:"active"`
	Action *GetProjectsOwaspAction `json:"action,omitempty"`
}

func (g GetProjectsOwasp) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsOwasp) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"active"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsOwasp) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *GetProjectsOwasp) GetAction() *GetProjectsOwaspAction {
	if o == nil {
		return nil
	}
	return o.Action
}

type GetProjectsManagedRules struct {
	VercelRuleset GetProjectsVercelRuleset `json:"vercel_ruleset"`
	BotFilter     GetProjectsBotFilter     `json:"bot_filter"`
	AiBots        GetProjectsAiBots        `json:"ai_bots"`
	Owasp         GetProjectsOwasp         `json:"owasp"`
}

func (g GetProjectsManagedRules) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsManagedRules) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"vercel_ruleset", "bot_filter", "ai_bots", "owasp"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsManagedRules) GetVercelRuleset() GetProjectsVercelRuleset {
	if o == nil {
		return GetProjectsVercelRuleset{}
	}
	return o.VercelRuleset
}

func (o *GetProjectsManagedRules) GetBotFilter() GetProjectsBotFilter {
	if o == nil {
		return GetProjectsBotFilter{}
	}
	return o.BotFilter
}

func (o *GetProjectsManagedRules) GetAiBots() GetProjectsAiBots {
	if o == nil {
		return GetProjectsAiBots{}
	}
	return o.AiBots
}

func (o *GetProjectsManagedRules) GetOwasp() GetProjectsOwasp {
	if o == nil {
		return GetProjectsOwasp{}
	}
	return o.Owasp
}

type GetProjectsSecurity struct {
	AttackModeEnabled      *bool                    `json:"attackModeEnabled,omitempty"`
	AttackModeUpdatedAt    *float64                 `json:"attackModeUpdatedAt,omitempty"`
	FirewallEnabled        *bool                    `json:"firewallEnabled,omitempty"`
	FirewallUpdatedAt      *float64                 `json:"firewallUpdatedAt,omitempty"`
	AttackModeActiveUntil  *float64                 `json:"attackModeActiveUntil,omitempty"`
	FirewallConfigVersion  *float64                 `json:"firewallConfigVersion,omitempty"`
	FirewallRoutes         []FirewallRoute          `json:"firewallRoutes,omitempty"`
	FirewallSeawallEnabled *bool                    `json:"firewallSeawallEnabled,omitempty"`
	Ja3Enabled             *bool                    `json:"ja3Enabled,omitempty"`
	Ja4Enabled             *bool                    `json:"ja4Enabled,omitempty"`
	FirewallBypassIps      []string                 `json:"firewallBypassIps,omitempty"`
	ManagedRules           *GetProjectsManagedRules `json:"managedRules,omitempty"`
	BotIDEnabled           *bool                    `json:"botIdEnabled,omitempty"`
}

func (g GetProjectsSecurity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsSecurity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsSecurity) GetAttackModeEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.AttackModeEnabled
}

func (o *GetProjectsSecurity) GetAttackModeUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.AttackModeUpdatedAt
}

func (o *GetProjectsSecurity) GetFirewallEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.FirewallEnabled
}

func (o *GetProjectsSecurity) GetFirewallUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.FirewallUpdatedAt
}

func (o *GetProjectsSecurity) GetAttackModeActiveUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.AttackModeActiveUntil
}

func (o *GetProjectsSecurity) GetFirewallConfigVersion() *float64 {
	if o == nil {
		return nil
	}
	return o.FirewallConfigVersion
}

func (o *GetProjectsSecurity) GetFirewallRoutes() []FirewallRoute {
	if o == nil {
		return nil
	}
	return o.FirewallRoutes
}

func (o *GetProjectsSecurity) GetFirewallSeawallEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.FirewallSeawallEnabled
}

func (o *GetProjectsSecurity) GetJa3Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.Ja3Enabled
}

func (o *GetProjectsSecurity) GetJa4Enabled() *bool {
	if o == nil {
		return nil
	}
	return o.Ja4Enabled
}

func (o *GetProjectsSecurity) GetFirewallBypassIps() []string {
	if o == nil {
		return nil
	}
	return o.FirewallBypassIps
}

func (o *GetProjectsSecurity) GetManagedRules() *GetProjectsManagedRules {
	if o == nil {
		return nil
	}
	return o.ManagedRules
}

func (o *GetProjectsSecurity) GetBotIDEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.BotIDEnabled
}

// GetProjectsIssuerMode - - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
type GetProjectsIssuerMode string

const (
	GetProjectsIssuerModeTeam   GetProjectsIssuerMode = "team"
	GetProjectsIssuerModeGlobal GetProjectsIssuerMode = "global"
)

func (e GetProjectsIssuerMode) ToPointer() *GetProjectsIssuerMode {
	return &e
}
func (e *GetProjectsIssuerMode) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "team":
		fallthrough
	case "global":
		*e = GetProjectsIssuerMode(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsIssuerMode: %v", v)
	}
}

type GetProjectsOidcTokenConfig struct {
	// Whether or not to generate OpenID Connect JSON Web Tokens.
	Enabled *bool `json:"enabled,omitempty"`
	// - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
	IssuerMode *GetProjectsIssuerMode `json:"issuerMode,omitempty"`
}

func (g GetProjectsOidcTokenConfig) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsOidcTokenConfig) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsOidcTokenConfig) GetEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.Enabled
}

func (o *GetProjectsOidcTokenConfig) GetIssuerMode() *GetProjectsIssuerMode {
	if o == nil {
		return nil
	}
	return o.IssuerMode
}

type GetProjectsTier string

const (
	GetProjectsTierStandard GetProjectsTier = "standard"
	GetProjectsTierAdvanced GetProjectsTier = "advanced"
	GetProjectsTierCritical GetProjectsTier = "critical"
)

func (e GetProjectsTier) ToPointer() *GetProjectsTier {
	return &e
}
func (e *GetProjectsTier) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "advanced":
		fallthrough
	case "critical":
		*e = GetProjectsTier(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsTier: %v", v)
	}
}

type GetProjectsHistory struct {
	Scanner string  `json:"scanner"`
	Reason  string  `json:"reason"`
	By      string  `json:"by"`
	ByID    string  `json:"byId"`
	At      float64 `json:"at"`
}

func (g GetProjectsHistory) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsHistory) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"scanner", "reason", "by", "byId", "at"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsHistory) GetScanner() string {
	if o == nil {
		return ""
	}
	return o.Scanner
}

func (o *GetProjectsHistory) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *GetProjectsHistory) GetBy() string {
	if o == nil {
		return ""
	}
	return o.By
}

func (o *GetProjectsHistory) GetByID() string {
	if o == nil {
		return ""
	}
	return o.ByID
}

func (o *GetProjectsHistory) GetAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.At
}

type GetProjectsActionBlocked string

const (
	GetProjectsActionBlockedBlocked GetProjectsActionBlocked = "blocked"
)

func (e GetProjectsActionBlocked) ToPointer() *GetProjectsActionBlocked {
	return &e
}
func (e *GetProjectsActionBlocked) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blocked":
		*e = GetProjectsActionBlocked(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsActionBlocked: %v", v)
	}
}

type GetProjectsBlock struct {
	Action              GetProjectsActionBlocked `json:"action"`
	Reason              string                   `json:"reason"`
	StatusCode          float64                  `json:"statusCode"`
	CreatedAt           float64                  `json:"createdAt"`
	CaseID              *string                  `json:"caseId,omitempty"`
	Actor               *string                  `json:"actor,omitempty"`
	Comment             *string                  `json:"comment,omitempty"`
	IneligibleForAppeal *bool                    `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                    `json:"isCascading,omitempty"`
}

func (g GetProjectsBlock) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlock) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action", "reason", "statusCode", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlock) GetAction() GetProjectsActionBlocked {
	if o == nil {
		return GetProjectsActionBlocked("")
	}
	return o.Action
}

func (o *GetProjectsBlock) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *GetProjectsBlock) GetStatusCode() float64 {
	if o == nil {
		return 0.0
	}
	return o.StatusCode
}

func (o *GetProjectsBlock) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsBlock) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *GetProjectsBlock) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *GetProjectsBlock) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsBlock) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *GetProjectsBlock) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type GetProjectsActionRouteUnblocked string

const (
	GetProjectsActionRouteUnblockedRouteUnblocked GetProjectsActionRouteUnblocked = "route-unblocked"
)

func (e GetProjectsActionRouteUnblocked) ToPointer() *GetProjectsActionRouteUnblocked {
	return &e
}
func (e *GetProjectsActionRouteUnblocked) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "route-unblocked":
		*e = GetProjectsActionRouteUnblocked(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsActionRouteUnblocked: %v", v)
	}
}

type GetProjectsBlockHistoryTypeHost2 string

const (
	GetProjectsBlockHistoryTypeHost2Host GetProjectsBlockHistoryTypeHost2 = "host"
)

func (e GetProjectsBlockHistoryTypeHost2) ToPointer() *GetProjectsBlockHistoryTypeHost2 {
	return &e
}
func (e *GetProjectsBlockHistoryTypeHost2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = GetProjectsBlockHistoryTypeHost2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryTypeHost2: %v", v)
	}
}

type GetProjectsBlockHistoryValue4 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsBlockHistoryValue4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryValue4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryValue4) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsBlockHistoryHasHost2 struct {
	Type  GetProjectsBlockHistoryTypeHost2 `json:"type"`
	Value GetProjectsBlockHistoryValue4    `json:"value"`
}

func (g GetProjectsBlockHistoryHasHost2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryHasHost2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryHasHost2) GetType() GetProjectsBlockHistoryTypeHost2 {
	if o == nil {
		return GetProjectsBlockHistoryTypeHost2("")
	}
	return o.Type
}

func (o *GetProjectsBlockHistoryHasHost2) GetValue() GetProjectsBlockHistoryValue4 {
	if o == nil {
		return GetProjectsBlockHistoryValue4{}
	}
	return o.Value
}

type GetProjectsBlockHistoryTypeHeader2 string

const (
	GetProjectsBlockHistoryTypeHeader2Header GetProjectsBlockHistoryTypeHeader2 = "header"
)

func (e GetProjectsBlockHistoryTypeHeader2) ToPointer() *GetProjectsBlockHistoryTypeHeader2 {
	return &e
}
func (e *GetProjectsBlockHistoryTypeHeader2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = GetProjectsBlockHistoryTypeHeader2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryTypeHeader2: %v", v)
	}
}

type GetProjectsBlockHistoryKey2 string

const (
	GetProjectsBlockHistoryKey2XVercelIPCountry GetProjectsBlockHistoryKey2 = "x-vercel-ip-country"
)

func (e GetProjectsBlockHistoryKey2) ToPointer() *GetProjectsBlockHistoryKey2 {
	return &e
}
func (e *GetProjectsBlockHistoryKey2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = GetProjectsBlockHistoryKey2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryKey2: %v", v)
	}
}

type GetProjectsBlockHistoryValue3 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsBlockHistoryValue3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryValue3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryValue3) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsBlockHistoryHasXVercelIPCountry2 struct {
	Type  GetProjectsBlockHistoryTypeHeader2 `json:"type"`
	Key   GetProjectsBlockHistoryKey2        `json:"key"`
	Value GetProjectsBlockHistoryValue3      `json:"value"`
}

func (g GetProjectsBlockHistoryHasXVercelIPCountry2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryHasXVercelIPCountry2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry2) GetType() GetProjectsBlockHistoryTypeHeader2 {
	if o == nil {
		return GetProjectsBlockHistoryTypeHeader2("")
	}
	return o.Type
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry2) GetKey() GetProjectsBlockHistoryKey2 {
	if o == nil {
		return GetProjectsBlockHistoryKey2("")
	}
	return o.Key
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry2) GetValue() GetProjectsBlockHistoryValue3 {
	if o == nil {
		return GetProjectsBlockHistoryValue3{}
	}
	return o.Value
}

type GetProjectsBlockHistoryHasUnion2Type string

const (
	GetProjectsBlockHistoryHasUnion2TypeHeader GetProjectsBlockHistoryHasUnion2Type = "header"
	GetProjectsBlockHistoryHasUnion2TypeHost   GetProjectsBlockHistoryHasUnion2Type = "host"
)

type GetProjectsBlockHistoryHasUnion2 struct {
	GetProjectsBlockHistoryHasXVercelIPCountry2 *GetProjectsBlockHistoryHasXVercelIPCountry2 `queryParam:"inline"`
	GetProjectsBlockHistoryHasHost2             *GetProjectsBlockHistoryHasHost2             `queryParam:"inline"`

	Type GetProjectsBlockHistoryHasUnion2Type
}

func CreateGetProjectsBlockHistoryHasUnion2Header(header GetProjectsBlockHistoryHasXVercelIPCountry2) GetProjectsBlockHistoryHasUnion2 {
	typ := GetProjectsBlockHistoryHasUnion2TypeHeader

	typStr := GetProjectsBlockHistoryTypeHeader2(typ)
	header.Type = typStr

	return GetProjectsBlockHistoryHasUnion2{
		GetProjectsBlockHistoryHasXVercelIPCountry2: &header,
		Type: typ,
	}
}

func CreateGetProjectsBlockHistoryHasUnion2Host(host GetProjectsBlockHistoryHasHost2) GetProjectsBlockHistoryHasUnion2 {
	typ := GetProjectsBlockHistoryHasUnion2TypeHost

	typStr := GetProjectsBlockHistoryTypeHost2(typ)
	host.Type = typStr

	return GetProjectsBlockHistoryHasUnion2{
		GetProjectsBlockHistoryHasHost2: &host,
		Type:                            typ,
	}
}

func (u *GetProjectsBlockHistoryHasUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		getProjectsBlockHistoryHasXVercelIPCountry2 := new(GetProjectsBlockHistoryHasXVercelIPCountry2)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryHasXVercelIPCountry2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type GetProjectsBlockHistoryHasXVercelIPCountry2 within GetProjectsBlockHistoryHasUnion2: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryHasXVercelIPCountry2 = getProjectsBlockHistoryHasXVercelIPCountry2
		u.Type = GetProjectsBlockHistoryHasUnion2TypeHeader
		return nil
	case "host":
		getProjectsBlockHistoryHasHost2 := new(GetProjectsBlockHistoryHasHost2)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryHasHost2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type GetProjectsBlockHistoryHasHost2 within GetProjectsBlockHistoryHasUnion2: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryHasHost2 = getProjectsBlockHistoryHasHost2
		u.Type = GetProjectsBlockHistoryHasUnion2TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsBlockHistoryHasUnion2", string(data))
}

func (u GetProjectsBlockHistoryHasUnion2) MarshalJSON() ([]byte, error) {
	if u.GetProjectsBlockHistoryHasXVercelIPCountry2 != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryHasXVercelIPCountry2, "", true)
	}

	if u.GetProjectsBlockHistoryHasHost2 != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryHasHost2, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsBlockHistoryHasUnion2: all fields are null")
}

type GetProjectsRouteAction2 string

const (
	GetProjectsRouteAction2BlockLegalCwc GetProjectsRouteAction2 = "block_legal_cwc"
)

func (e GetProjectsRouteAction2) ToPointer() *GetProjectsRouteAction2 {
	return &e
}
func (e *GetProjectsRouteAction2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = GetProjectsRouteAction2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsRouteAction2: %v", v)
	}
}

type GetProjectsBlockHistoryMitigate2 struct {
	Action GetProjectsRouteAction2 `json:"action"`
}

func (g GetProjectsBlockHistoryMitigate2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryMitigate2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryMitigate2) GetAction() GetProjectsRouteAction2 {
	if o == nil {
		return GetProjectsRouteAction2("")
	}
	return o.Action
}

type GetProjectsRoute4 struct {
	Has      []GetProjectsBlockHistoryHasUnion2 `json:"has"`
	Mitigate GetProjectsBlockHistoryMitigate2   `json:"mitigate"`
	Src      *string                            `json:"src,omitempty"`
}

func (g GetProjectsRoute4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsRoute4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsRoute4) GetHas() []GetProjectsBlockHistoryHasUnion2 {
	if o == nil {
		return []GetProjectsBlockHistoryHasUnion2{}
	}
	return o.Has
}

func (o *GetProjectsRoute4) GetMitigate() GetProjectsBlockHistoryMitigate2 {
	if o == nil {
		return GetProjectsBlockHistoryMitigate2{}
	}
	return o.Mitigate
}

func (o *GetProjectsRoute4) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type GetProjectsRoute3 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (g GetProjectsRoute3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsRoute3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsRoute3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *GetProjectsRoute3) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type GetProjectsRouteUnion2Type string

const (
	GetProjectsRouteUnion2TypeGetProjectsRoute3 GetProjectsRouteUnion2Type = "getProjects_route_3"
	GetProjectsRouteUnion2TypeGetProjectsRoute4 GetProjectsRouteUnion2Type = "getProjects_route_4"
)

type GetProjectsRouteUnion2 struct {
	GetProjectsRoute3 *GetProjectsRoute3 `queryParam:"inline"`
	GetProjectsRoute4 *GetProjectsRoute4 `queryParam:"inline"`

	Type GetProjectsRouteUnion2Type
}

func CreateGetProjectsRouteUnion2GetProjectsRoute3(getProjectsRoute3 GetProjectsRoute3) GetProjectsRouteUnion2 {
	typ := GetProjectsRouteUnion2TypeGetProjectsRoute3

	return GetProjectsRouteUnion2{
		GetProjectsRoute3: &getProjectsRoute3,
		Type:              typ,
	}
}

func CreateGetProjectsRouteUnion2GetProjectsRoute4(getProjectsRoute4 GetProjectsRoute4) GetProjectsRouteUnion2 {
	typ := GetProjectsRouteUnion2TypeGetProjectsRoute4

	return GetProjectsRouteUnion2{
		GetProjectsRoute4: &getProjectsRoute4,
		Type:              typ,
	}
}

func (u *GetProjectsRouteUnion2) UnmarshalJSON(data []byte) error {

	var getProjectsRoute3 GetProjectsRoute3 = GetProjectsRoute3{}
	if err := utils.UnmarshalJSON(data, &getProjectsRoute3, "", true, nil); err == nil {
		u.GetProjectsRoute3 = &getProjectsRoute3
		u.Type = GetProjectsRouteUnion2TypeGetProjectsRoute3
		return nil
	}

	var getProjectsRoute4 GetProjectsRoute4 = GetProjectsRoute4{}
	if err := utils.UnmarshalJSON(data, &getProjectsRoute4, "", true, nil); err == nil {
		u.GetProjectsRoute4 = &getProjectsRoute4
		u.Type = GetProjectsRouteUnion2TypeGetProjectsRoute4
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsRouteUnion2", string(data))
}

func (u GetProjectsRouteUnion2) MarshalJSON() ([]byte, error) {
	if u.GetProjectsRoute3 != nil {
		return utils.MarshalJSON(u.GetProjectsRoute3, "", true)
	}

	if u.GetProjectsRoute4 != nil {
		return utils.MarshalJSON(u.GetProjectsRoute4, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsRouteUnion2: all fields are null")
}

type GetProjectsBlockHistoryRouteUnblocked struct {
	Action              GetProjectsActionRouteUnblocked `json:"action"`
	Route               GetProjectsRouteUnion2          `json:"route"`
	StatusCode          *float64                        `json:"statusCode,omitempty"`
	CreatedAt           float64                         `json:"createdAt"`
	CaseID              *string                         `json:"caseId,omitempty"`
	Actor               *string                         `json:"actor,omitempty"`
	Comment             *string                         `json:"comment,omitempty"`
	IneligibleForAppeal *bool                           `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                           `json:"isCascading,omitempty"`
}

func (g GetProjectsBlockHistoryRouteUnblocked) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryRouteUnblocked) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action", "route", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetAction() GetProjectsActionRouteUnblocked {
	if o == nil {
		return GetProjectsActionRouteUnblocked("")
	}
	return o.Action
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetRoute() GetProjectsRouteUnion2 {
	if o == nil {
		return GetProjectsRouteUnion2{}
	}
	return o.Route
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.StatusCode
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *GetProjectsBlockHistoryRouteUnblocked) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type GetProjectsActionRouteBlocked string

const (
	GetProjectsActionRouteBlockedRouteBlocked GetProjectsActionRouteBlocked = "route-blocked"
)

func (e GetProjectsActionRouteBlocked) ToPointer() *GetProjectsActionRouteBlocked {
	return &e
}
func (e *GetProjectsActionRouteBlocked) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "route-blocked":
		*e = GetProjectsActionRouteBlocked(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsActionRouteBlocked: %v", v)
	}
}

type GetProjectsBlockHistoryTypeHost1 string

const (
	GetProjectsBlockHistoryTypeHost1Host GetProjectsBlockHistoryTypeHost1 = "host"
)

func (e GetProjectsBlockHistoryTypeHost1) ToPointer() *GetProjectsBlockHistoryTypeHost1 {
	return &e
}
func (e *GetProjectsBlockHistoryTypeHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = GetProjectsBlockHistoryTypeHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryTypeHost1: %v", v)
	}
}

type GetProjectsBlockHistoryValue2 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsBlockHistoryValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryValue2) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsBlockHistoryHasHost1 struct {
	Type  GetProjectsBlockHistoryTypeHost1 `json:"type"`
	Value GetProjectsBlockHistoryValue2    `json:"value"`
}

func (g GetProjectsBlockHistoryHasHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryHasHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryHasHost1) GetType() GetProjectsBlockHistoryTypeHost1 {
	if o == nil {
		return GetProjectsBlockHistoryTypeHost1("")
	}
	return o.Type
}

func (o *GetProjectsBlockHistoryHasHost1) GetValue() GetProjectsBlockHistoryValue2 {
	if o == nil {
		return GetProjectsBlockHistoryValue2{}
	}
	return o.Value
}

type GetProjectsBlockHistoryTypeHeader1 string

const (
	GetProjectsBlockHistoryTypeHeader1Header GetProjectsBlockHistoryTypeHeader1 = "header"
)

func (e GetProjectsBlockHistoryTypeHeader1) ToPointer() *GetProjectsBlockHistoryTypeHeader1 {
	return &e
}
func (e *GetProjectsBlockHistoryTypeHeader1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = GetProjectsBlockHistoryTypeHeader1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryTypeHeader1: %v", v)
	}
}

type GetProjectsBlockHistoryKey1 string

const (
	GetProjectsBlockHistoryKey1XVercelIPCountry GetProjectsBlockHistoryKey1 = "x-vercel-ip-country"
)

func (e GetProjectsBlockHistoryKey1) ToPointer() *GetProjectsBlockHistoryKey1 {
	return &e
}
func (e *GetProjectsBlockHistoryKey1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = GetProjectsBlockHistoryKey1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryKey1: %v", v)
	}
}

type GetProjectsBlockHistoryValue1 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsBlockHistoryValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryValue1) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsBlockHistoryHasXVercelIPCountry1 struct {
	Type  GetProjectsBlockHistoryTypeHeader1 `json:"type"`
	Key   GetProjectsBlockHistoryKey1        `json:"key"`
	Value GetProjectsBlockHistoryValue1      `json:"value"`
}

func (g GetProjectsBlockHistoryHasXVercelIPCountry1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryHasXVercelIPCountry1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry1) GetType() GetProjectsBlockHistoryTypeHeader1 {
	if o == nil {
		return GetProjectsBlockHistoryTypeHeader1("")
	}
	return o.Type
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry1) GetKey() GetProjectsBlockHistoryKey1 {
	if o == nil {
		return GetProjectsBlockHistoryKey1("")
	}
	return o.Key
}

func (o *GetProjectsBlockHistoryHasXVercelIPCountry1) GetValue() GetProjectsBlockHistoryValue1 {
	if o == nil {
		return GetProjectsBlockHistoryValue1{}
	}
	return o.Value
}

type GetProjectsBlockHistoryHasUnion1Type string

const (
	GetProjectsBlockHistoryHasUnion1TypeHeader GetProjectsBlockHistoryHasUnion1Type = "header"
	GetProjectsBlockHistoryHasUnion1TypeHost   GetProjectsBlockHistoryHasUnion1Type = "host"
)

type GetProjectsBlockHistoryHasUnion1 struct {
	GetProjectsBlockHistoryHasXVercelIPCountry1 *GetProjectsBlockHistoryHasXVercelIPCountry1 `queryParam:"inline"`
	GetProjectsBlockHistoryHasHost1             *GetProjectsBlockHistoryHasHost1             `queryParam:"inline"`

	Type GetProjectsBlockHistoryHasUnion1Type
}

func CreateGetProjectsBlockHistoryHasUnion1Header(header GetProjectsBlockHistoryHasXVercelIPCountry1) GetProjectsBlockHistoryHasUnion1 {
	typ := GetProjectsBlockHistoryHasUnion1TypeHeader

	typStr := GetProjectsBlockHistoryTypeHeader1(typ)
	header.Type = typStr

	return GetProjectsBlockHistoryHasUnion1{
		GetProjectsBlockHistoryHasXVercelIPCountry1: &header,
		Type: typ,
	}
}

func CreateGetProjectsBlockHistoryHasUnion1Host(host GetProjectsBlockHistoryHasHost1) GetProjectsBlockHistoryHasUnion1 {
	typ := GetProjectsBlockHistoryHasUnion1TypeHost

	typStr := GetProjectsBlockHistoryTypeHost1(typ)
	host.Type = typStr

	return GetProjectsBlockHistoryHasUnion1{
		GetProjectsBlockHistoryHasHost1: &host,
		Type:                            typ,
	}
}

func (u *GetProjectsBlockHistoryHasUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		getProjectsBlockHistoryHasXVercelIPCountry1 := new(GetProjectsBlockHistoryHasXVercelIPCountry1)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryHasXVercelIPCountry1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type GetProjectsBlockHistoryHasXVercelIPCountry1 within GetProjectsBlockHistoryHasUnion1: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryHasXVercelIPCountry1 = getProjectsBlockHistoryHasXVercelIPCountry1
		u.Type = GetProjectsBlockHistoryHasUnion1TypeHeader
		return nil
	case "host":
		getProjectsBlockHistoryHasHost1 := new(GetProjectsBlockHistoryHasHost1)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryHasHost1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type GetProjectsBlockHistoryHasHost1 within GetProjectsBlockHistoryHasUnion1: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryHasHost1 = getProjectsBlockHistoryHasHost1
		u.Type = GetProjectsBlockHistoryHasUnion1TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsBlockHistoryHasUnion1", string(data))
}

func (u GetProjectsBlockHistoryHasUnion1) MarshalJSON() ([]byte, error) {
	if u.GetProjectsBlockHistoryHasXVercelIPCountry1 != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryHasXVercelIPCountry1, "", true)
	}

	if u.GetProjectsBlockHistoryHasHost1 != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryHasHost1, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsBlockHistoryHasUnion1: all fields are null")
}

type GetProjectsRouteAction1 string

const (
	GetProjectsRouteAction1BlockLegalCwc GetProjectsRouteAction1 = "block_legal_cwc"
)

func (e GetProjectsRouteAction1) ToPointer() *GetProjectsRouteAction1 {
	return &e
}
func (e *GetProjectsRouteAction1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = GetProjectsRouteAction1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsRouteAction1: %v", v)
	}
}

type GetProjectsBlockHistoryMitigate1 struct {
	Action GetProjectsRouteAction1 `json:"action"`
}

func (g GetProjectsBlockHistoryMitigate1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryMitigate1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryMitigate1) GetAction() GetProjectsRouteAction1 {
	if o == nil {
		return GetProjectsRouteAction1("")
	}
	return o.Action
}

type GetProjectsRoute2 struct {
	Has      []GetProjectsBlockHistoryHasUnion1 `json:"has"`
	Mitigate GetProjectsBlockHistoryMitigate1   `json:"mitigate"`
	Src      *string                            `json:"src,omitempty"`
}

func (g GetProjectsRoute2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsRoute2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsRoute2) GetHas() []GetProjectsBlockHistoryHasUnion1 {
	if o == nil {
		return []GetProjectsBlockHistoryHasUnion1{}
	}
	return o.Has
}

func (o *GetProjectsRoute2) GetMitigate() GetProjectsBlockHistoryMitigate1 {
	if o == nil {
		return GetProjectsBlockHistoryMitigate1{}
	}
	return o.Mitigate
}

func (o *GetProjectsRoute2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type GetProjectsRoute1 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (g GetProjectsRoute1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsRoute1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsRoute1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *GetProjectsRoute1) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type GetProjectsRouteUnion1Type string

const (
	GetProjectsRouteUnion1TypeGetProjectsRoute1 GetProjectsRouteUnion1Type = "getProjects_route_1"
	GetProjectsRouteUnion1TypeGetProjectsRoute2 GetProjectsRouteUnion1Type = "getProjects_route_2"
)

type GetProjectsRouteUnion1 struct {
	GetProjectsRoute1 *GetProjectsRoute1 `queryParam:"inline"`
	GetProjectsRoute2 *GetProjectsRoute2 `queryParam:"inline"`

	Type GetProjectsRouteUnion1Type
}

func CreateGetProjectsRouteUnion1GetProjectsRoute1(getProjectsRoute1 GetProjectsRoute1) GetProjectsRouteUnion1 {
	typ := GetProjectsRouteUnion1TypeGetProjectsRoute1

	return GetProjectsRouteUnion1{
		GetProjectsRoute1: &getProjectsRoute1,
		Type:              typ,
	}
}

func CreateGetProjectsRouteUnion1GetProjectsRoute2(getProjectsRoute2 GetProjectsRoute2) GetProjectsRouteUnion1 {
	typ := GetProjectsRouteUnion1TypeGetProjectsRoute2

	return GetProjectsRouteUnion1{
		GetProjectsRoute2: &getProjectsRoute2,
		Type:              typ,
	}
}

func (u *GetProjectsRouteUnion1) UnmarshalJSON(data []byte) error {

	var getProjectsRoute1 GetProjectsRoute1 = GetProjectsRoute1{}
	if err := utils.UnmarshalJSON(data, &getProjectsRoute1, "", true, nil); err == nil {
		u.GetProjectsRoute1 = &getProjectsRoute1
		u.Type = GetProjectsRouteUnion1TypeGetProjectsRoute1
		return nil
	}

	var getProjectsRoute2 GetProjectsRoute2 = GetProjectsRoute2{}
	if err := utils.UnmarshalJSON(data, &getProjectsRoute2, "", true, nil); err == nil {
		u.GetProjectsRoute2 = &getProjectsRoute2
		u.Type = GetProjectsRouteUnion1TypeGetProjectsRoute2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsRouteUnion1", string(data))
}

func (u GetProjectsRouteUnion1) MarshalJSON() ([]byte, error) {
	if u.GetProjectsRoute1 != nil {
		return utils.MarshalJSON(u.GetProjectsRoute1, "", true)
	}

	if u.GetProjectsRoute2 != nil {
		return utils.MarshalJSON(u.GetProjectsRoute2, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsRouteUnion1: all fields are null")
}

type GetProjectsBlockHistoryRouteBlocked struct {
	Action              GetProjectsActionRouteBlocked `json:"action"`
	Route               GetProjectsRouteUnion1        `json:"route"`
	Reason              string                        `json:"reason"`
	CreatedAt           float64                       `json:"createdAt"`
	CaseID              *string                       `json:"caseId,omitempty"`
	Actor               *string                       `json:"actor,omitempty"`
	Comment             *string                       `json:"comment,omitempty"`
	IneligibleForAppeal *bool                         `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                         `json:"isCascading,omitempty"`
}

func (g GetProjectsBlockHistoryRouteBlocked) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryRouteBlocked) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action", "route", "reason", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetAction() GetProjectsActionRouteBlocked {
	if o == nil {
		return GetProjectsActionRouteBlocked("")
	}
	return o.Action
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetRoute() GetProjectsRouteUnion1 {
	if o == nil {
		return GetProjectsRouteUnion1{}
	}
	return o.Route
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *GetProjectsBlockHistoryRouteBlocked) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type GetProjectsActionUnblocked string

const (
	GetProjectsActionUnblockedUnblocked GetProjectsActionUnblocked = "unblocked"
)

func (e GetProjectsActionUnblocked) ToPointer() *GetProjectsActionUnblocked {
	return &e
}
func (e *GetProjectsActionUnblocked) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unblocked":
		*e = GetProjectsActionUnblocked(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsActionUnblocked: %v", v)
	}
}

type GetProjectsBlockHistoryUnblocked struct {
	Action              GetProjectsActionUnblocked `json:"action"`
	CreatedAt           float64                    `json:"createdAt"`
	CaseID              *string                    `json:"caseId,omitempty"`
	Actor               *string                    `json:"actor,omitempty"`
	Comment             *string                    `json:"comment,omitempty"`
	IneligibleForAppeal *bool                      `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                      `json:"isCascading,omitempty"`
}

func (g GetProjectsBlockHistoryUnblocked) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryUnblocked) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryUnblocked) GetAction() GetProjectsActionUnblocked {
	if o == nil {
		return GetProjectsActionUnblocked("")
	}
	return o.Action
}

func (o *GetProjectsBlockHistoryUnblocked) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsBlockHistoryUnblocked) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *GetProjectsBlockHistoryUnblocked) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *GetProjectsBlockHistoryUnblocked) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsBlockHistoryUnblocked) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *GetProjectsBlockHistoryUnblocked) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type GetProjectsBlockHistoryActionBlocked string

const (
	GetProjectsBlockHistoryActionBlockedBlocked GetProjectsBlockHistoryActionBlocked = "blocked"
)

func (e GetProjectsBlockHistoryActionBlocked) ToPointer() *GetProjectsBlockHistoryActionBlocked {
	return &e
}
func (e *GetProjectsBlockHistoryActionBlocked) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blocked":
		*e = GetProjectsBlockHistoryActionBlocked(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsBlockHistoryActionBlocked: %v", v)
	}
}

type GetProjectsBlockHistoryBlocked struct {
	Action              GetProjectsBlockHistoryActionBlocked `json:"action"`
	Reason              string                               `json:"reason"`
	StatusCode          float64                              `json:"statusCode"`
	CreatedAt           float64                              `json:"createdAt"`
	CaseID              *string                              `json:"caseId,omitempty"`
	Actor               *string                              `json:"actor,omitempty"`
	Comment             *string                              `json:"comment,omitempty"`
	IneligibleForAppeal *bool                                `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                                `json:"isCascading,omitempty"`
}

func (g GetProjectsBlockHistoryBlocked) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsBlockHistoryBlocked) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action", "reason", "statusCode", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsBlockHistoryBlocked) GetAction() GetProjectsBlockHistoryActionBlocked {
	if o == nil {
		return GetProjectsBlockHistoryActionBlocked("")
	}
	return o.Action
}

func (o *GetProjectsBlockHistoryBlocked) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *GetProjectsBlockHistoryBlocked) GetStatusCode() float64 {
	if o == nil {
		return 0.0
	}
	return o.StatusCode
}

func (o *GetProjectsBlockHistoryBlocked) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *GetProjectsBlockHistoryBlocked) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *GetProjectsBlockHistoryBlocked) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *GetProjectsBlockHistoryBlocked) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *GetProjectsBlockHistoryBlocked) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *GetProjectsBlockHistoryBlocked) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type GetProjectsBlockHistoryUnionType string

const (
	GetProjectsBlockHistoryUnionTypeBlocked        GetProjectsBlockHistoryUnionType = "blocked"
	GetProjectsBlockHistoryUnionTypeUnblocked      GetProjectsBlockHistoryUnionType = "unblocked"
	GetProjectsBlockHistoryUnionTypeRouteBlocked   GetProjectsBlockHistoryUnionType = "route-blocked"
	GetProjectsBlockHistoryUnionTypeRouteUnblocked GetProjectsBlockHistoryUnionType = "route-unblocked"
)

type GetProjectsBlockHistoryUnion struct {
	GetProjectsBlockHistoryBlocked        *GetProjectsBlockHistoryBlocked        `queryParam:"inline"`
	GetProjectsBlockHistoryUnblocked      *GetProjectsBlockHistoryUnblocked      `queryParam:"inline"`
	GetProjectsBlockHistoryRouteBlocked   *GetProjectsBlockHistoryRouteBlocked   `queryParam:"inline"`
	GetProjectsBlockHistoryRouteUnblocked *GetProjectsBlockHistoryRouteUnblocked `queryParam:"inline"`

	Type GetProjectsBlockHistoryUnionType
}

func CreateGetProjectsBlockHistoryUnionBlocked(blocked GetProjectsBlockHistoryBlocked) GetProjectsBlockHistoryUnion {
	typ := GetProjectsBlockHistoryUnionTypeBlocked

	typStr := GetProjectsBlockHistoryActionBlocked(typ)
	blocked.Action = typStr

	return GetProjectsBlockHistoryUnion{
		GetProjectsBlockHistoryBlocked: &blocked,
		Type:                           typ,
	}
}

func CreateGetProjectsBlockHistoryUnionUnblocked(unblocked GetProjectsBlockHistoryUnblocked) GetProjectsBlockHistoryUnion {
	typ := GetProjectsBlockHistoryUnionTypeUnblocked

	typStr := GetProjectsActionUnblocked(typ)
	unblocked.Action = typStr

	return GetProjectsBlockHistoryUnion{
		GetProjectsBlockHistoryUnblocked: &unblocked,
		Type:                             typ,
	}
}

func CreateGetProjectsBlockHistoryUnionRouteBlocked(routeBlocked GetProjectsBlockHistoryRouteBlocked) GetProjectsBlockHistoryUnion {
	typ := GetProjectsBlockHistoryUnionTypeRouteBlocked

	typStr := GetProjectsActionRouteBlocked(typ)
	routeBlocked.Action = typStr

	return GetProjectsBlockHistoryUnion{
		GetProjectsBlockHistoryRouteBlocked: &routeBlocked,
		Type:                                typ,
	}
}

func CreateGetProjectsBlockHistoryUnionRouteUnblocked(routeUnblocked GetProjectsBlockHistoryRouteUnblocked) GetProjectsBlockHistoryUnion {
	typ := GetProjectsBlockHistoryUnionTypeRouteUnblocked

	typStr := GetProjectsActionRouteUnblocked(typ)
	routeUnblocked.Action = typStr

	return GetProjectsBlockHistoryUnion{
		GetProjectsBlockHistoryRouteUnblocked: &routeUnblocked,
		Type:                                  typ,
	}
}

func (u *GetProjectsBlockHistoryUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Action string `json:"action"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Action {
	case "blocked":
		getProjectsBlockHistoryBlocked := new(GetProjectsBlockHistoryBlocked)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryBlocked, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == blocked) type GetProjectsBlockHistoryBlocked within GetProjectsBlockHistoryUnion: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryBlocked = getProjectsBlockHistoryBlocked
		u.Type = GetProjectsBlockHistoryUnionTypeBlocked
		return nil
	case "unblocked":
		getProjectsBlockHistoryUnblocked := new(GetProjectsBlockHistoryUnblocked)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryUnblocked, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == unblocked) type GetProjectsBlockHistoryUnblocked within GetProjectsBlockHistoryUnion: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryUnblocked = getProjectsBlockHistoryUnblocked
		u.Type = GetProjectsBlockHistoryUnionTypeUnblocked
		return nil
	case "route-blocked":
		getProjectsBlockHistoryRouteBlocked := new(GetProjectsBlockHistoryRouteBlocked)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryRouteBlocked, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-blocked) type GetProjectsBlockHistoryRouteBlocked within GetProjectsBlockHistoryUnion: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryRouteBlocked = getProjectsBlockHistoryRouteBlocked
		u.Type = GetProjectsBlockHistoryUnionTypeRouteBlocked
		return nil
	case "route-unblocked":
		getProjectsBlockHistoryRouteUnblocked := new(GetProjectsBlockHistoryRouteUnblocked)
		if err := utils.UnmarshalJSON(data, &getProjectsBlockHistoryRouteUnblocked, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-unblocked) type GetProjectsBlockHistoryRouteUnblocked within GetProjectsBlockHistoryUnion: %w", string(data), err)
		}

		u.GetProjectsBlockHistoryRouteUnblocked = getProjectsBlockHistoryRouteUnblocked
		u.Type = GetProjectsBlockHistoryUnionTypeRouteUnblocked
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsBlockHistoryUnion", string(data))
}

func (u GetProjectsBlockHistoryUnion) MarshalJSON() ([]byte, error) {
	if u.GetProjectsBlockHistoryBlocked != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryBlocked, "", true)
	}

	if u.GetProjectsBlockHistoryUnblocked != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryUnblocked, "", true)
	}

	if u.GetProjectsBlockHistoryRouteBlocked != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryRouteBlocked, "", true)
	}

	if u.GetProjectsBlockHistoryRouteUnblocked != nil {
		return utils.MarshalJSON(u.GetProjectsBlockHistoryRouteUnblocked, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsBlockHistoryUnion: all fields are null")
}

type GetProjectsAbuse struct {
	Scanner      *string                        `json:"scanner,omitempty"`
	History      []GetProjectsHistory           `json:"history"`
	UpdatedAt    float64                        `json:"updatedAt"`
	Block        *GetProjectsBlock              `json:"block,omitempty"`
	BlockHistory []GetProjectsBlockHistoryUnion `json:"blockHistory,omitempty"`
	Interstitial *bool                          `json:"interstitial,omitempty"`
}

func (g GetProjectsAbuse) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsAbuse) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"history", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsAbuse) GetScanner() *string {
	if o == nil {
		return nil
	}
	return o.Scanner
}

func (o *GetProjectsAbuse) GetHistory() []GetProjectsHistory {
	if o == nil {
		return []GetProjectsHistory{}
	}
	return o.History
}

func (o *GetProjectsAbuse) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *GetProjectsAbuse) GetBlock() *GetProjectsBlock {
	if o == nil {
		return nil
	}
	return o.Block
}

func (o *GetProjectsAbuse) GetBlockHistory() []GetProjectsBlockHistoryUnion {
	if o == nil {
		return nil
	}
	return o.BlockHistory
}

func (o *GetProjectsAbuse) GetInterstitial() *bool {
	if o == nil {
		return nil
	}
	return o.Interstitial
}

type GetProjectsInternalRouteTypeHost string

const (
	GetProjectsInternalRouteTypeHostHost GetProjectsInternalRouteTypeHost = "host"
)

func (e GetProjectsInternalRouteTypeHost) ToPointer() *GetProjectsInternalRouteTypeHost {
	return &e
}
func (e *GetProjectsInternalRouteTypeHost) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = GetProjectsInternalRouteTypeHost(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsInternalRouteTypeHost: %v", v)
	}
}

type GetProjectsInternalRouteValue2 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsInternalRouteValue2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRouteValue2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRouteValue2) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsInternalRouteHasHost struct {
	Type  GetProjectsInternalRouteTypeHost `json:"type"`
	Value GetProjectsInternalRouteValue2   `json:"value"`
}

func (g GetProjectsInternalRouteHasHost) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRouteHasHost) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRouteHasHost) GetType() GetProjectsInternalRouteTypeHost {
	if o == nil {
		return GetProjectsInternalRouteTypeHost("")
	}
	return o.Type
}

func (o *GetProjectsInternalRouteHasHost) GetValue() GetProjectsInternalRouteValue2 {
	if o == nil {
		return GetProjectsInternalRouteValue2{}
	}
	return o.Value
}

type GetProjectsInternalRouteTypeHeader string

const (
	GetProjectsInternalRouteTypeHeaderHeader GetProjectsInternalRouteTypeHeader = "header"
)

func (e GetProjectsInternalRouteTypeHeader) ToPointer() *GetProjectsInternalRouteTypeHeader {
	return &e
}
func (e *GetProjectsInternalRouteTypeHeader) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = GetProjectsInternalRouteTypeHeader(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsInternalRouteTypeHeader: %v", v)
	}
}

type GetProjectsInternalRouteKey string

const (
	GetProjectsInternalRouteKeyXVercelIPCountry GetProjectsInternalRouteKey = "x-vercel-ip-country"
)

func (e GetProjectsInternalRouteKey) ToPointer() *GetProjectsInternalRouteKey {
	return &e
}
func (e *GetProjectsInternalRouteKey) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = GetProjectsInternalRouteKey(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsInternalRouteKey: %v", v)
	}
}

type GetProjectsInternalRouteValue1 struct {
	Eq string `json:"eq"`
}

func (g GetProjectsInternalRouteValue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRouteValue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRouteValue1) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type GetProjectsInternalRouteHasXVercelIPCountry struct {
	Type  GetProjectsInternalRouteTypeHeader `json:"type"`
	Key   GetProjectsInternalRouteKey        `json:"key"`
	Value GetProjectsInternalRouteValue1     `json:"value"`
}

func (g GetProjectsInternalRouteHasXVercelIPCountry) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRouteHasXVercelIPCountry) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRouteHasXVercelIPCountry) GetType() GetProjectsInternalRouteTypeHeader {
	if o == nil {
		return GetProjectsInternalRouteTypeHeader("")
	}
	return o.Type
}

func (o *GetProjectsInternalRouteHasXVercelIPCountry) GetKey() GetProjectsInternalRouteKey {
	if o == nil {
		return GetProjectsInternalRouteKey("")
	}
	return o.Key
}

func (o *GetProjectsInternalRouteHasXVercelIPCountry) GetValue() GetProjectsInternalRouteValue1 {
	if o == nil {
		return GetProjectsInternalRouteValue1{}
	}
	return o.Value
}

type GetProjectsInternalRouteHasUnionType string

const (
	GetProjectsInternalRouteHasUnionTypeHeader GetProjectsInternalRouteHasUnionType = "header"
	GetProjectsInternalRouteHasUnionTypeHost   GetProjectsInternalRouteHasUnionType = "host"
)

type GetProjectsInternalRouteHasUnion struct {
	GetProjectsInternalRouteHasXVercelIPCountry *GetProjectsInternalRouteHasXVercelIPCountry `queryParam:"inline"`
	GetProjectsInternalRouteHasHost             *GetProjectsInternalRouteHasHost             `queryParam:"inline"`

	Type GetProjectsInternalRouteHasUnionType
}

func CreateGetProjectsInternalRouteHasUnionHeader(header GetProjectsInternalRouteHasXVercelIPCountry) GetProjectsInternalRouteHasUnion {
	typ := GetProjectsInternalRouteHasUnionTypeHeader

	typStr := GetProjectsInternalRouteTypeHeader(typ)
	header.Type = typStr

	return GetProjectsInternalRouteHasUnion{
		GetProjectsInternalRouteHasXVercelIPCountry: &header,
		Type: typ,
	}
}

func CreateGetProjectsInternalRouteHasUnionHost(host GetProjectsInternalRouteHasHost) GetProjectsInternalRouteHasUnion {
	typ := GetProjectsInternalRouteHasUnionTypeHost

	typStr := GetProjectsInternalRouteTypeHost(typ)
	host.Type = typStr

	return GetProjectsInternalRouteHasUnion{
		GetProjectsInternalRouteHasHost: &host,
		Type:                            typ,
	}
}

func (u *GetProjectsInternalRouteHasUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		getProjectsInternalRouteHasXVercelIPCountry := new(GetProjectsInternalRouteHasXVercelIPCountry)
		if err := utils.UnmarshalJSON(data, &getProjectsInternalRouteHasXVercelIPCountry, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type GetProjectsInternalRouteHasXVercelIPCountry within GetProjectsInternalRouteHasUnion: %w", string(data), err)
		}

		u.GetProjectsInternalRouteHasXVercelIPCountry = getProjectsInternalRouteHasXVercelIPCountry
		u.Type = GetProjectsInternalRouteHasUnionTypeHeader
		return nil
	case "host":
		getProjectsInternalRouteHasHost := new(GetProjectsInternalRouteHasHost)
		if err := utils.UnmarshalJSON(data, &getProjectsInternalRouteHasHost, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type GetProjectsInternalRouteHasHost within GetProjectsInternalRouteHasUnion: %w", string(data), err)
		}

		u.GetProjectsInternalRouteHasHost = getProjectsInternalRouteHasHost
		u.Type = GetProjectsInternalRouteHasUnionTypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsInternalRouteHasUnion", string(data))
}

func (u GetProjectsInternalRouteHasUnion) MarshalJSON() ([]byte, error) {
	if u.GetProjectsInternalRouteHasXVercelIPCountry != nil {
		return utils.MarshalJSON(u.GetProjectsInternalRouteHasXVercelIPCountry, "", true)
	}

	if u.GetProjectsInternalRouteHasHost != nil {
		return utils.MarshalJSON(u.GetProjectsInternalRouteHasHost, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsInternalRouteHasUnion: all fields are null")
}

type GetProjectsInternalRouteAction string

const (
	GetProjectsInternalRouteActionBlockLegalCwc GetProjectsInternalRouteAction = "block_legal_cwc"
)

func (e GetProjectsInternalRouteAction) ToPointer() *GetProjectsInternalRouteAction {
	return &e
}
func (e *GetProjectsInternalRouteAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = GetProjectsInternalRouteAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GetProjectsInternalRouteAction: %v", v)
	}
}

type GetProjectsInternalRouteMitigate struct {
	Action GetProjectsInternalRouteAction `json:"action"`
}

func (g GetProjectsInternalRouteMitigate) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRouteMitigate) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRouteMitigate) GetAction() GetProjectsInternalRouteAction {
	if o == nil {
		return GetProjectsInternalRouteAction("")
	}
	return o.Action
}

type GetProjectsInternalRoute2 struct {
	Has      []GetProjectsInternalRouteHasUnion `json:"has"`
	Mitigate GetProjectsInternalRouteMitigate   `json:"mitigate"`
	Src      *string                            `json:"src,omitempty"`
}

func (g GetProjectsInternalRoute2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRoute2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRoute2) GetHas() []GetProjectsInternalRouteHasUnion {
	if o == nil {
		return []GetProjectsInternalRouteHasUnion{}
	}
	return o.Has
}

func (o *GetProjectsInternalRoute2) GetMitigate() GetProjectsInternalRouteMitigate {
	if o == nil {
		return GetProjectsInternalRouteMitigate{}
	}
	return o.Mitigate
}

func (o *GetProjectsInternalRoute2) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type GetProjectsInternalRoute1 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (g GetProjectsInternalRoute1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsInternalRoute1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsInternalRoute1) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *GetProjectsInternalRoute1) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type GetProjectsInternalRouteUnionType string

const (
	GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute1 GetProjectsInternalRouteUnionType = "getProjects_internalRoute_1"
	GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute2 GetProjectsInternalRouteUnionType = "getProjects_internalRoute_2"
)

type GetProjectsInternalRouteUnion struct {
	GetProjectsInternalRoute1 *GetProjectsInternalRoute1 `queryParam:"inline"`
	GetProjectsInternalRoute2 *GetProjectsInternalRoute2 `queryParam:"inline"`

	Type GetProjectsInternalRouteUnionType
}

func CreateGetProjectsInternalRouteUnionGetProjectsInternalRoute1(getProjectsInternalRoute1 GetProjectsInternalRoute1) GetProjectsInternalRouteUnion {
	typ := GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute1

	return GetProjectsInternalRouteUnion{
		GetProjectsInternalRoute1: &getProjectsInternalRoute1,
		Type:                      typ,
	}
}

func CreateGetProjectsInternalRouteUnionGetProjectsInternalRoute2(getProjectsInternalRoute2 GetProjectsInternalRoute2) GetProjectsInternalRouteUnion {
	typ := GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute2

	return GetProjectsInternalRouteUnion{
		GetProjectsInternalRoute2: &getProjectsInternalRoute2,
		Type:                      typ,
	}
}

func (u *GetProjectsInternalRouteUnion) UnmarshalJSON(data []byte) error {

	var getProjectsInternalRoute1 GetProjectsInternalRoute1 = GetProjectsInternalRoute1{}
	if err := utils.UnmarshalJSON(data, &getProjectsInternalRoute1, "", true, nil); err == nil {
		u.GetProjectsInternalRoute1 = &getProjectsInternalRoute1
		u.Type = GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute1
		return nil
	}

	var getProjectsInternalRoute2 GetProjectsInternalRoute2 = GetProjectsInternalRoute2{}
	if err := utils.UnmarshalJSON(data, &getProjectsInternalRoute2, "", true, nil); err == nil {
		u.GetProjectsInternalRoute2 = &getProjectsInternalRoute2
		u.Type = GetProjectsInternalRouteUnionTypeGetProjectsInternalRoute2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsInternalRouteUnion", string(data))
}

func (u GetProjectsInternalRouteUnion) MarshalJSON() ([]byte, error) {
	if u.GetProjectsInternalRoute1 != nil {
		return utils.MarshalJSON(u.GetProjectsInternalRoute1, "", true)
	}

	if u.GetProjectsInternalRoute2 != nil {
		return utils.MarshalJSON(u.GetProjectsInternalRoute2, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsInternalRouteUnion: all fields are null")
}

type GetProjectsResponseBody1 struct {
	AccountID                        string                `json:"accountId"`
	Alias                            []GetProjectsAlias    `json:"alias"`
	Analytics                        *GetProjectsAnalytics `json:"analytics,omitempty"`
	AppliedCve55182Migration         *bool                 `json:"appliedCve55182Migration,omitempty"`
	AutoExposeSystemEnvs             *bool                 `json:"autoExposeSystemEnvs,omitempty"`
	AutoAssignCustomDomains          *bool                 `json:"autoAssignCustomDomains,omitempty"`
	AutoAssignCustomDomainsUpdatedBy *string               `json:"autoAssignCustomDomainsUpdatedBy,omitempty"`
	BuildCommand                     *string               `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep      *string               `json:"commandForIgnoringBuildStep,omitempty"`
	CustomerSupportCodeVisibility    *bool                 `json:"customerSupportCodeVisibility,omitempty"`
	CreatedAt                        *float64              `json:"createdAt,omitempty"`
	DevCommand                       *string               `json:"devCommand,omitempty"`
	DirectoryListing                 bool                  `json:"directoryListing"`
	// Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
	DeploymentExpiration GetProjectsDeploymentExpiration `json:"deploymentExpiration"`
	InstallCommand       *string                         `json:"installCommand,omitempty"`
	IPBuckets            []GetProjectsIPBucket           `json:"ipBuckets,omitempty"`
	Env                  []GetProjectsEnv                `json:"env,omitempty"`
	Framework            *GetProjectsFramework           `json:"framework,omitempty"`
	GitForkProtection    *bool                           `json:"gitForkProtection,omitempty"`
	ID                   string                          `json:"id"`
	LatestDeployments    []GetProjectsLatestDeployment   `json:"latestDeployments,omitempty"`
	Link                 *GetProjectsLinkUnion           `json:"link,omitempty"`
	Name                 string                          `json:"name"`
	NodeVersion          GetProjectsNodeVersion          `json:"nodeVersion"`
	OutputDirectory      *string                         `json:"outputDirectory,omitempty"`
	PasswordProtection   *GetProjectsPasswordProtection  `json:"passwordProtection,omitempty"`
	PublicSource         *bool                           `json:"publicSource,omitempty"`
	ResourceConfig       GetProjectsResourceConfig       `json:"resourceConfig"`
	// Project-level rolling release configuration that defines how deployments should be gradually rolled out
	RollingRelease                       *GetProjectsRollingRelease      `json:"rollingRelease,omitempty"`
	RootDirectory                        *string                         `json:"rootDirectory,omitempty"`
	ServerlessFunctionRegion             string                          `json:"serverlessFunctionRegion"`
	ServerlessFunctionZeroConfigFailover *bool                           `json:"serverlessFunctionZeroConfigFailover,omitempty"`
	SpeedInsights                        *GetProjectsSpeedInsights       `json:"speedInsights,omitempty"`
	SkipGitConnectDuringLink             *bool                           `json:"skipGitConnectDuringLink,omitempty"`
	SourceFilesOutsideRootDirectory      *bool                           `json:"sourceFilesOutsideRootDirectory,omitempty"`
	SsoProtection                        *GetProjectsSsoProtection       `json:"ssoProtection,omitempty"`
	Targets                              map[string]*GetProjectsTargets  `json:"targets,omitempty"`
	TransferCompletedAt                  *float64                        `json:"transferCompletedAt,omitempty"`
	TransferStartedAt                    *float64                        `json:"transferStartedAt,omitempty"`
	TransferToAccountID                  *string                         `json:"transferToAccountId,omitempty"`
	TransferredFromAccountID             *string                         `json:"transferredFromAccountId,omitempty"`
	UpdatedAt                            *float64                        `json:"updatedAt,omitempty"`
	Live                                 *bool                           `json:"live,omitempty"`
	HasActiveBranches                    *bool                           `json:"hasActiveBranches,omitempty"`
	GitComments                          *GetProjectsGitComments         `json:"gitComments,omitempty"`
	GitProviderOptions                   *GetProjectsGitProviderOptions  `json:"gitProviderOptions,omitempty"`
	Paused                               *bool                           `json:"paused,omitempty"`
	WebAnalytics                         *GetProjectsWebAnalytics        `json:"webAnalytics,omitempty"`
	Security                             *GetProjectsSecurity            `json:"security,omitempty"`
	OidcTokenConfig                      *GetProjectsOidcTokenConfig     `json:"oidcTokenConfig,omitempty"`
	Tier                                 *GetProjectsTier                `json:"tier,omitempty"`
	Abuse                                *GetProjectsAbuse               `json:"abuse,omitempty"`
	InternalRoutes                       []GetProjectsInternalRouteUnion `json:"internalRoutes,omitempty"`
}

func (g GetProjectsResponseBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsResponseBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"accountId", "alias", "directoryListing", "deploymentExpiration", "id", "name", "nodeVersion", "resourceConfig", "serverlessFunctionRegion"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *GetProjectsResponseBody1) GetAlias() []GetProjectsAlias {
	if o == nil {
		return []GetProjectsAlias{}
	}
	return o.Alias
}

func (o *GetProjectsResponseBody1) GetAnalytics() *GetProjectsAnalytics {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetProjectsResponseBody1) GetAppliedCve55182Migration() *bool {
	if o == nil {
		return nil
	}
	return o.AppliedCve55182Migration
}

func (o *GetProjectsResponseBody1) GetAutoExposeSystemEnvs() *bool {
	if o == nil {
		return nil
	}
	return o.AutoExposeSystemEnvs
}

func (o *GetProjectsResponseBody1) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *GetProjectsResponseBody1) GetAutoAssignCustomDomainsUpdatedBy() *string {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomainsUpdatedBy
}

func (o *GetProjectsResponseBody1) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *GetProjectsResponseBody1) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *GetProjectsResponseBody1) GetCustomerSupportCodeVisibility() *bool {
	if o == nil {
		return nil
	}
	return o.CustomerSupportCodeVisibility
}

func (o *GetProjectsResponseBody1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsResponseBody1) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *GetProjectsResponseBody1) GetDirectoryListing() bool {
	if o == nil {
		return false
	}
	return o.DirectoryListing
}

func (o *GetProjectsResponseBody1) GetDeploymentExpiration() GetProjectsDeploymentExpiration {
	if o == nil {
		return GetProjectsDeploymentExpiration{}
	}
	return o.DeploymentExpiration
}

func (o *GetProjectsResponseBody1) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *GetProjectsResponseBody1) GetIPBuckets() []GetProjectsIPBucket {
	if o == nil {
		return nil
	}
	return o.IPBuckets
}

func (o *GetProjectsResponseBody1) GetEnv() []GetProjectsEnv {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetProjectsResponseBody1) GetFramework() *GetProjectsFramework {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *GetProjectsResponseBody1) GetGitForkProtection() *bool {
	if o == nil {
		return nil
	}
	return o.GitForkProtection
}

func (o *GetProjectsResponseBody1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsResponseBody1) GetLatestDeployments() []GetProjectsLatestDeployment {
	if o == nil {
		return nil
	}
	return o.LatestDeployments
}

func (o *GetProjectsResponseBody1) GetLink() *GetProjectsLinkUnion {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *GetProjectsResponseBody1) GetLinkGithub() *GetProjectsLinkGithub {
	if v := o.GetLink(); v != nil {
		return v.GetProjectsLinkGithub
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetLinkGithubLimited() *GetProjectsLinkGithubLimited {
	if v := o.GetLink(); v != nil {
		return v.GetProjectsLinkGithubLimited
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetLinkGithubCustomHost() *GetProjectsLinkGithubCustomHost {
	if v := o.GetLink(); v != nil {
		return v.GetProjectsLinkGithubCustomHost
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetLinkGitlab() *GetProjectsLinkGitlab {
	if v := o.GetLink(); v != nil {
		return v.GetProjectsLinkGitlab
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetLinkBitbucket() *GetProjectsLinkBitbucket {
	if v := o.GetLink(); v != nil {
		return v.GetProjectsLinkBitbucket
	}
	return nil
}

func (o *GetProjectsResponseBody1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsResponseBody1) GetNodeVersion() GetProjectsNodeVersion {
	if o == nil {
		return GetProjectsNodeVersion("")
	}
	return o.NodeVersion
}

func (o *GetProjectsResponseBody1) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *GetProjectsResponseBody1) GetPasswordProtection() *GetProjectsPasswordProtection {
	if o == nil {
		return nil
	}
	return o.PasswordProtection
}

func (o *GetProjectsResponseBody1) GetPublicSource() *bool {
	if o == nil {
		return nil
	}
	return o.PublicSource
}

func (o *GetProjectsResponseBody1) GetResourceConfig() GetProjectsResourceConfig {
	if o == nil {
		return GetProjectsResourceConfig{}
	}
	return o.ResourceConfig
}

func (o *GetProjectsResponseBody1) GetRollingRelease() *GetProjectsRollingRelease {
	if o == nil {
		return nil
	}
	return o.RollingRelease
}

func (o *GetProjectsResponseBody1) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *GetProjectsResponseBody1) GetServerlessFunctionRegion() string {
	if o == nil {
		return ""
	}
	return o.ServerlessFunctionRegion
}

func (o *GetProjectsResponseBody1) GetServerlessFunctionZeroConfigFailover() *bool {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionZeroConfigFailover
}

func (o *GetProjectsResponseBody1) GetSpeedInsights() *GetProjectsSpeedInsights {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

func (o *GetProjectsResponseBody1) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *GetProjectsResponseBody1) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

func (o *GetProjectsResponseBody1) GetSsoProtection() *GetProjectsSsoProtection {
	if o == nil {
		return nil
	}
	return o.SsoProtection
}

func (o *GetProjectsResponseBody1) GetTargets() map[string]*GetProjectsTargets {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *GetProjectsResponseBody1) GetTransferCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferCompletedAt
}

func (o *GetProjectsResponseBody1) GetTransferStartedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferStartedAt
}

func (o *GetProjectsResponseBody1) GetTransferToAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferToAccountID
}

func (o *GetProjectsResponseBody1) GetTransferredFromAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferredFromAccountID
}

func (o *GetProjectsResponseBody1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsResponseBody1) GetLive() *bool {
	if o == nil {
		return nil
	}
	return o.Live
}

func (o *GetProjectsResponseBody1) GetHasActiveBranches() *bool {
	if o == nil {
		return nil
	}
	return o.HasActiveBranches
}

func (o *GetProjectsResponseBody1) GetGitComments() *GetProjectsGitComments {
	if o == nil {
		return nil
	}
	return o.GitComments
}

func (o *GetProjectsResponseBody1) GetGitProviderOptions() *GetProjectsGitProviderOptions {
	if o == nil {
		return nil
	}
	return o.GitProviderOptions
}

func (o *GetProjectsResponseBody1) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *GetProjectsResponseBody1) GetWebAnalytics() *GetProjectsWebAnalytics {
	if o == nil {
		return nil
	}
	return o.WebAnalytics
}

func (o *GetProjectsResponseBody1) GetSecurity() *GetProjectsSecurity {
	if o == nil {
		return nil
	}
	return o.Security
}

func (o *GetProjectsResponseBody1) GetOidcTokenConfig() *GetProjectsOidcTokenConfig {
	if o == nil {
		return nil
	}
	return o.OidcTokenConfig
}

func (o *GetProjectsResponseBody1) GetTier() *GetProjectsTier {
	if o == nil {
		return nil
	}
	return o.Tier
}

func (o *GetProjectsResponseBody1) GetAbuse() *GetProjectsAbuse {
	if o == nil {
		return nil
	}
	return o.Abuse
}

func (o *GetProjectsResponseBody1) GetInternalRoutes() []GetProjectsInternalRouteUnion {
	if o == nil {
		return nil
	}
	return o.InternalRoutes
}

type GetProjectsResponseBodyType string

const (
	GetProjectsResponseBodyTypeArrayOfGetProjectsResponseBody1 GetProjectsResponseBodyType = "arrayOfGetProjectsResponseBody1"
	GetProjectsResponseBodyTypeGetProjectsResponseBody2        GetProjectsResponseBodyType = "getProjects_ResponseBody_2"
	GetProjectsResponseBodyTypeGetProjectsResponseBody3        GetProjectsResponseBodyType = "getProjects_ResponseBody_3"
)

type GetProjectsResponseBody struct {
	ArrayOfGetProjectsResponseBody1 []GetProjectsResponseBody1 `queryParam:"inline"`
	GetProjectsResponseBody2        *GetProjectsResponseBody2  `queryParam:"inline"`
	GetProjectsResponseBody3        *GetProjectsResponseBody3  `queryParam:"inline"`

	Type GetProjectsResponseBodyType
}

func CreateGetProjectsResponseBodyArrayOfGetProjectsResponseBody1(arrayOfGetProjectsResponseBody1 []GetProjectsResponseBody1) GetProjectsResponseBody {
	typ := GetProjectsResponseBodyTypeArrayOfGetProjectsResponseBody1

	return GetProjectsResponseBody{
		ArrayOfGetProjectsResponseBody1: arrayOfGetProjectsResponseBody1,
		Type:                            typ,
	}
}

func CreateGetProjectsResponseBodyGetProjectsResponseBody2(getProjectsResponseBody2 GetProjectsResponseBody2) GetProjectsResponseBody {
	typ := GetProjectsResponseBodyTypeGetProjectsResponseBody2

	return GetProjectsResponseBody{
		GetProjectsResponseBody2: &getProjectsResponseBody2,
		Type:                     typ,
	}
}

func CreateGetProjectsResponseBodyGetProjectsResponseBody3(getProjectsResponseBody3 GetProjectsResponseBody3) GetProjectsResponseBody {
	typ := GetProjectsResponseBodyTypeGetProjectsResponseBody3

	return GetProjectsResponseBody{
		GetProjectsResponseBody3: &getProjectsResponseBody3,
		Type:                     typ,
	}
}

func (u *GetProjectsResponseBody) UnmarshalJSON(data []byte) error {

	var getProjectsResponseBody2 GetProjectsResponseBody2 = GetProjectsResponseBody2{}
	if err := utils.UnmarshalJSON(data, &getProjectsResponseBody2, "", true, nil); err == nil {
		u.GetProjectsResponseBody2 = &getProjectsResponseBody2
		u.Type = GetProjectsResponseBodyTypeGetProjectsResponseBody2
		return nil
	}

	var getProjectsResponseBody3 GetProjectsResponseBody3 = GetProjectsResponseBody3{}
	if err := utils.UnmarshalJSON(data, &getProjectsResponseBody3, "", true, nil); err == nil {
		u.GetProjectsResponseBody3 = &getProjectsResponseBody3
		u.Type = GetProjectsResponseBodyTypeGetProjectsResponseBody3
		return nil
	}

	var arrayOfGetProjectsResponseBody1 []GetProjectsResponseBody1 = []GetProjectsResponseBody1{}
	if err := utils.UnmarshalJSON(data, &arrayOfGetProjectsResponseBody1, "", true, nil); err == nil {
		u.ArrayOfGetProjectsResponseBody1 = arrayOfGetProjectsResponseBody1
		u.Type = GetProjectsResponseBodyTypeArrayOfGetProjectsResponseBody1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsResponseBody", string(data))
}

func (u GetProjectsResponseBody) MarshalJSON() ([]byte, error) {
	if u.ArrayOfGetProjectsResponseBody1 != nil {
		return utils.MarshalJSON(u.ArrayOfGetProjectsResponseBody1, "", true)
	}

	if u.GetProjectsResponseBody2 != nil {
		return utils.MarshalJSON(u.GetProjectsResponseBody2, "", true)
	}

	if u.GetProjectsResponseBody3 != nil {
		return utils.MarshalJSON(u.GetProjectsResponseBody3, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsResponseBody: all fields are null")
}

type GetProjectsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *GetProjectsResponseBody
}

func (o *GetProjectsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetProjectsResponse) GetOneOf() *GetProjectsResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
