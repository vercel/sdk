// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type GetRollingReleaseBillingStatusRequest struct {
	// Project ID or project name (URL-encoded)
	IDOrName string `pathParam:"style=simple,explode=false,name=idOrName"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *GetRollingReleaseBillingStatusRequest) GetIDOrName() string {
	if o == nil {
		return ""
	}
	return o.IDOrName
}

func (o *GetRollingReleaseBillingStatusRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *GetRollingReleaseBillingStatusRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type ReasonAvailableSlots string

const (
	ReasonAvailableSlotsAvailableSlots ReasonAvailableSlots = "available_slots"
)

func (e ReasonAvailableSlots) ToPointer() *ReasonAvailableSlots {
	return &e
}
func (e *ReasonAvailableSlots) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "available_slots":
		*e = ReasonAvailableSlots(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReasonAvailableSlots: %v", v)
	}
}

type AvailableSlots struct {
	AvailableSlots float64              `json:"availableSlots"`
	Reason         ReasonAvailableSlots `json:"reason"`
	Message        string               `json:"message"`
}

func (a AvailableSlots) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(a, "", false)
}

func (a *AvailableSlots) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &a, "", false, []string{"availableSlots", "reason", "message"}); err != nil {
		return err
	}
	return nil
}

func (o *AvailableSlots) GetAvailableSlots() float64 {
	if o == nil {
		return 0.0
	}
	return o.AvailableSlots
}

func (o *AvailableSlots) GetReason() ReasonAvailableSlots {
	if o == nil {
		return ReasonAvailableSlots("")
	}
	return o.Reason
}

func (o *AvailableSlots) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type ReasonNoAvailableSlots string

const (
	ReasonNoAvailableSlotsNoAvailableSlots ReasonNoAvailableSlots = "no_available_slots"
)

func (e ReasonNoAvailableSlots) ToPointer() *ReasonNoAvailableSlots {
	return &e
}
func (e *ReasonNoAvailableSlots) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "no_available_slots":
		*e = ReasonNoAvailableSlots(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReasonNoAvailableSlots: %v", v)
	}
}

type NoAvailableSlots struct {
	AvailableSlots  float64                `json:"availableSlots"`
	Reason          ReasonNoAvailableSlots `json:"reason"`
	Message         string                 `json:"message"`
	EnabledProjects []string               `json:"enabledProjects"`
}

func (n NoAvailableSlots) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *NoAvailableSlots) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, []string{"availableSlots", "reason", "message", "enabledProjects"}); err != nil {
		return err
	}
	return nil
}

func (o *NoAvailableSlots) GetAvailableSlots() float64 {
	if o == nil {
		return 0.0
	}
	return o.AvailableSlots
}

func (o *NoAvailableSlots) GetReason() ReasonNoAvailableSlots {
	if o == nil {
		return ReasonNoAvailableSlots("")
	}
	return o.Reason
}

func (o *NoAvailableSlots) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

func (o *NoAvailableSlots) GetEnabledProjects() []string {
	if o == nil {
		return []string{}
	}
	return o.EnabledProjects
}

type AvailableSlotsEnum string

const (
	AvailableSlotsEnumUnlimited AvailableSlotsEnum = "unlimited"
)

func (e AvailableSlotsEnum) ToPointer() *AvailableSlotsEnum {
	return &e
}
func (e *AvailableSlotsEnum) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unlimited":
		*e = AvailableSlotsEnum(v)
		return nil
	default:
		return fmt.Errorf("invalid value for AvailableSlotsEnum: %v", v)
	}
}

type ReasonUnlimitedSlots string

const (
	ReasonUnlimitedSlotsUnlimitedSlots ReasonUnlimitedSlots = "unlimited_slots"
)

func (e ReasonUnlimitedSlots) ToPointer() *ReasonUnlimitedSlots {
	return &e
}
func (e *ReasonUnlimitedSlots) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unlimited_slots":
		*e = ReasonUnlimitedSlots(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReasonUnlimitedSlots: %v", v)
	}
}

type UnlimitedSlots struct {
	AvailableSlots AvailableSlotsEnum   `json:"availableSlots"`
	Reason         ReasonUnlimitedSlots `json:"reason"`
	Message        string               `json:"message"`
}

func (u UnlimitedSlots) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UnlimitedSlots) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"availableSlots", "reason", "message"}); err != nil {
		return err
	}
	return nil
}

func (o *UnlimitedSlots) GetAvailableSlots() AvailableSlotsEnum {
	if o == nil {
		return AvailableSlotsEnum("")
	}
	return o.AvailableSlots
}

func (o *UnlimitedSlots) GetReason() ReasonUnlimitedSlots {
	if o == nil {
		return ReasonUnlimitedSlots("")
	}
	return o.Reason
}

func (o *UnlimitedSlots) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type ReasonPlanNotSupported string

const (
	ReasonPlanNotSupportedPlanNotSupported ReasonPlanNotSupported = "plan_not_supported"
)

func (e ReasonPlanNotSupported) ToPointer() *ReasonPlanNotSupported {
	return &e
}
func (e *ReasonPlanNotSupported) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "plan_not_supported":
		*e = ReasonPlanNotSupported(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ReasonPlanNotSupported: %v", v)
	}
}

type PlanNotSupported struct {
	AvailableSlots float64                `json:"availableSlots"`
	Reason         ReasonPlanNotSupported `json:"reason"`
	Message        string                 `json:"message"`
}

func (p PlanNotSupported) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PlanNotSupported) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"availableSlots", "reason", "message"}); err != nil {
		return err
	}
	return nil
}

func (o *PlanNotSupported) GetAvailableSlots() float64 {
	if o == nil {
		return 0.0
	}
	return o.AvailableSlots
}

func (o *PlanNotSupported) GetReason() ReasonPlanNotSupported {
	if o == nil {
		return ReasonPlanNotSupported("")
	}
	return o.Reason
}

func (o *PlanNotSupported) GetMessage() string {
	if o == nil {
		return ""
	}
	return o.Message
}

type GetRollingReleaseBillingStatusResponseBodyType string

const (
	GetRollingReleaseBillingStatusResponseBodyTypePlanNotSupported GetRollingReleaseBillingStatusResponseBodyType = "plan_not_supported"
	GetRollingReleaseBillingStatusResponseBodyTypeUnlimitedSlots   GetRollingReleaseBillingStatusResponseBodyType = "unlimited_slots"
	GetRollingReleaseBillingStatusResponseBodyTypeNoAvailableSlots GetRollingReleaseBillingStatusResponseBodyType = "no_available_slots"
	GetRollingReleaseBillingStatusResponseBodyTypeAvailableSlots   GetRollingReleaseBillingStatusResponseBodyType = "available_slots"
)

type GetRollingReleaseBillingStatusResponseBody struct {
	PlanNotSupported *PlanNotSupported `queryParam:"inline"`
	UnlimitedSlots   *UnlimitedSlots   `queryParam:"inline"`
	NoAvailableSlots *NoAvailableSlots `queryParam:"inline"`
	AvailableSlots   *AvailableSlots   `queryParam:"inline"`

	Type GetRollingReleaseBillingStatusResponseBodyType
}

func CreateGetRollingReleaseBillingStatusResponseBodyPlanNotSupported(planNotSupported PlanNotSupported) GetRollingReleaseBillingStatusResponseBody {
	typ := GetRollingReleaseBillingStatusResponseBodyTypePlanNotSupported

	typStr := ReasonPlanNotSupported(typ)
	planNotSupported.Reason = typStr

	return GetRollingReleaseBillingStatusResponseBody{
		PlanNotSupported: &planNotSupported,
		Type:             typ,
	}
}

func CreateGetRollingReleaseBillingStatusResponseBodyUnlimitedSlots(unlimitedSlots UnlimitedSlots) GetRollingReleaseBillingStatusResponseBody {
	typ := GetRollingReleaseBillingStatusResponseBodyTypeUnlimitedSlots

	typStr := ReasonUnlimitedSlots(typ)
	unlimitedSlots.Reason = typStr

	return GetRollingReleaseBillingStatusResponseBody{
		UnlimitedSlots: &unlimitedSlots,
		Type:           typ,
	}
}

func CreateGetRollingReleaseBillingStatusResponseBodyNoAvailableSlots(noAvailableSlots NoAvailableSlots) GetRollingReleaseBillingStatusResponseBody {
	typ := GetRollingReleaseBillingStatusResponseBodyTypeNoAvailableSlots

	typStr := ReasonNoAvailableSlots(typ)
	noAvailableSlots.Reason = typStr

	return GetRollingReleaseBillingStatusResponseBody{
		NoAvailableSlots: &noAvailableSlots,
		Type:             typ,
	}
}

func CreateGetRollingReleaseBillingStatusResponseBodyAvailableSlots(availableSlots AvailableSlots) GetRollingReleaseBillingStatusResponseBody {
	typ := GetRollingReleaseBillingStatusResponseBodyTypeAvailableSlots

	typStr := ReasonAvailableSlots(typ)
	availableSlots.Reason = typStr

	return GetRollingReleaseBillingStatusResponseBody{
		AvailableSlots: &availableSlots,
		Type:           typ,
	}
}

func (u *GetRollingReleaseBillingStatusResponseBody) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Reason string `json:"reason"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Reason {
	case "plan_not_supported":
		planNotSupported := new(PlanNotSupported)
		if err := utils.UnmarshalJSON(data, &planNotSupported, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Reason == plan_not_supported) type PlanNotSupported within GetRollingReleaseBillingStatusResponseBody: %w", string(data), err)
		}

		u.PlanNotSupported = planNotSupported
		u.Type = GetRollingReleaseBillingStatusResponseBodyTypePlanNotSupported
		return nil
	case "unlimited_slots":
		unlimitedSlots := new(UnlimitedSlots)
		if err := utils.UnmarshalJSON(data, &unlimitedSlots, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Reason == unlimited_slots) type UnlimitedSlots within GetRollingReleaseBillingStatusResponseBody: %w", string(data), err)
		}

		u.UnlimitedSlots = unlimitedSlots
		u.Type = GetRollingReleaseBillingStatusResponseBodyTypeUnlimitedSlots
		return nil
	case "no_available_slots":
		noAvailableSlots := new(NoAvailableSlots)
		if err := utils.UnmarshalJSON(data, &noAvailableSlots, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Reason == no_available_slots) type NoAvailableSlots within GetRollingReleaseBillingStatusResponseBody: %w", string(data), err)
		}

		u.NoAvailableSlots = noAvailableSlots
		u.Type = GetRollingReleaseBillingStatusResponseBodyTypeNoAvailableSlots
		return nil
	case "available_slots":
		availableSlots := new(AvailableSlots)
		if err := utils.UnmarshalJSON(data, &availableSlots, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Reason == available_slots) type AvailableSlots within GetRollingReleaseBillingStatusResponseBody: %w", string(data), err)
		}

		u.AvailableSlots = availableSlots
		u.Type = GetRollingReleaseBillingStatusResponseBodyTypeAvailableSlots
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetRollingReleaseBillingStatusResponseBody", string(data))
}

func (u GetRollingReleaseBillingStatusResponseBody) MarshalJSON() ([]byte, error) {
	if u.PlanNotSupported != nil {
		return utils.MarshalJSON(u.PlanNotSupported, "", true)
	}

	if u.UnlimitedSlots != nil {
		return utils.MarshalJSON(u.UnlimitedSlots, "", true)
	}

	if u.NoAvailableSlots != nil {
		return utils.MarshalJSON(u.NoAvailableSlots, "", true)
	}

	if u.AvailableSlots != nil {
		return utils.MarshalJSON(u.AvailableSlots, "", true)
	}

	return nil, errors.New("could not marshal union type GetRollingReleaseBillingStatusResponseBody: all fields are null")
}

type GetRollingReleaseBillingStatusResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *GetRollingReleaseBillingStatusResponseBody
}

func (o *GetRollingReleaseBillingStatusResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetRollingReleaseBillingStatusResponse) GetOneOf() *GetRollingReleaseBillingStatusResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}

func (o *GetRollingReleaseBillingStatusResponse) GetOneOfPlanNotSupported() *PlanNotSupported {
	if v := o.GetOneOf(); v != nil {
		return v.PlanNotSupported
	}
	return nil
}

func (o *GetRollingReleaseBillingStatusResponse) GetOneOfUnlimitedSlots() *UnlimitedSlots {
	if v := o.GetOneOf(); v != nil {
		return v.UnlimitedSlots
	}
	return nil
}

func (o *GetRollingReleaseBillingStatusResponse) GetOneOfNoAvailableSlots() *NoAvailableSlots {
	if v := o.GetOneOf(); v != nil {
		return v.NoAvailableSlots
	}
	return nil
}

func (o *GetRollingReleaseBillingStatusResponse) GetOneOfAvailableSlots() *AvailableSlots {
	if v := o.GetOneOf(); v != nil {
		return v.AvailableSlots
	}
	return nil
}
