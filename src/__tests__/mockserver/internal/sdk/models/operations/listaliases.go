// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
	"time"
)

type ListAliasesDomainType string

const (
	ListAliasesDomainTypeArrayOfStr ListAliasesDomainType = "arrayOfStr"
	ListAliasesDomainTypeStr        ListAliasesDomainType = "str"
)

// ListAliasesDomain - Get only aliases of the given domain name
type ListAliasesDomain struct {
	ArrayOfStr []string `queryParam:"inline"`
	Str        *string  `queryParam:"inline"`

	Type ListAliasesDomainType
}

func CreateListAliasesDomainArrayOfStr(arrayOfStr []string) ListAliasesDomain {
	typ := ListAliasesDomainTypeArrayOfStr

	return ListAliasesDomain{
		ArrayOfStr: arrayOfStr,
		Type:       typ,
	}
}

func CreateListAliasesDomainStr(str string) ListAliasesDomain {
	typ := ListAliasesDomainTypeStr

	return ListAliasesDomain{
		Str:  &str,
		Type: typ,
	}
}

func (u *ListAliasesDomain) UnmarshalJSON(data []byte) error {

	var arrayOfStr []string = []string{}
	if err := utils.UnmarshalJSON(data, &arrayOfStr, "", true, true); err == nil {
		u.ArrayOfStr = arrayOfStr
		u.Type = ListAliasesDomainTypeArrayOfStr
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = ListAliasesDomainTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListAliasesDomain", string(data))
}

func (u ListAliasesDomain) MarshalJSON() ([]byte, error) {
	if u.ArrayOfStr != nil {
		return utils.MarshalJSON(u.ArrayOfStr, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type ListAliasesDomain: all fields are null")
}

type ListAliasesRequest struct {
	// Get only aliases of the given domain name
	Domain *ListAliasesDomain `queryParam:"style=form,explode=true,name=domain"`
	// Get only aliases created after the provided timestamp
	From *float64 `queryParam:"style=form,explode=true,name=from"`
	// Maximum number of aliases to list from a request
	Limit *float64 `queryParam:"style=form,explode=true,name=limit"`
	// Filter aliases from the given `projectId`
	ProjectID *string `queryParam:"style=form,explode=true,name=projectId"`
	// Get aliases created after this JavaScript timestamp
	Since *float64 `queryParam:"style=form,explode=true,name=since"`
	// Get aliases created before this JavaScript timestamp
	Until *float64 `queryParam:"style=form,explode=true,name=until"`
	// Get aliases that would be rolled back for the given deployment
	RollbackDeploymentID *string `queryParam:"style=form,explode=true,name=rollbackDeploymentId"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *ListAliasesRequest) GetDomain() *ListAliasesDomain {
	if o == nil {
		return nil
	}
	return o.Domain
}

func (o *ListAliasesRequest) GetFrom() *float64 {
	if o == nil {
		return nil
	}
	return o.From
}

func (o *ListAliasesRequest) GetLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *ListAliasesRequest) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *ListAliasesRequest) GetSince() *float64 {
	if o == nil {
		return nil
	}
	return o.Since
}

func (o *ListAliasesRequest) GetUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.Until
}

func (o *ListAliasesRequest) GetRollbackDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.RollbackDeploymentID
}

func (o *ListAliasesRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ListAliasesRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

// ListAliasesCreator - Information of the user who created the alias
type ListAliasesCreator struct {
	// ID of the user who created the alias
	UID string `json:"uid"`
	// Email of the user who created the alias
	Email string `json:"email"`
	// Username of the user who created the alias
	Username string `json:"username"`
}

func (o *ListAliasesCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *ListAliasesCreator) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *ListAliasesCreator) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

// ListAliasesDeployment - A map with the deployment ID, URL and metadata
type ListAliasesDeployment struct {
	// The deployment unique identifier
	ID string `json:"id"`
	// The deployment unique URL
	URL string `json:"url"`
	// The deployment metadata
	Meta *string `json:"meta,omitempty"`
}

func (o *ListAliasesDeployment) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListAliasesDeployment) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *ListAliasesDeployment) GetMeta() *string {
	if o == nil {
		return nil
	}
	return o.Meta
}

type ListAliasesScopeEmailInvite string

const (
	ListAliasesScopeEmailInviteEmailInvite ListAliasesScopeEmailInvite = "email_invite"
)

func (e ListAliasesScopeEmailInvite) ToPointer() *ListAliasesScopeEmailInvite {
	return &e
}
func (e *ListAliasesScopeEmailInvite) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "email_invite":
		*e = ListAliasesScopeEmailInvite(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListAliasesScopeEmailInvite: %v", v)
	}
}

// ListAliasesProtectionBypassEmailInvite - The protection bypass for the alias
type ListAliasesProtectionBypassEmailInvite struct {
	CreatedAt     float64                     `json:"createdAt"`
	LastUpdatedAt float64                     `json:"lastUpdatedAt"`
	LastUpdatedBy string                      `json:"lastUpdatedBy"`
	Scope         ListAliasesScopeEmailInvite `json:"scope"`
}

func (o *ListAliasesProtectionBypassEmailInvite) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListAliasesProtectionBypassEmailInvite) GetLastUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.LastUpdatedAt
}

func (o *ListAliasesProtectionBypassEmailInvite) GetLastUpdatedBy() string {
	if o == nil {
		return ""
	}
	return o.LastUpdatedBy
}

func (o *ListAliasesProtectionBypassEmailInvite) GetScope() ListAliasesScopeEmailInvite {
	if o == nil {
		return ListAliasesScopeEmailInvite("")
	}
	return o.Scope
}

type ListAliasesScopeAliasProtectionOverride string

const (
	ListAliasesScopeAliasProtectionOverrideAliasProtectionOverride ListAliasesScopeAliasProtectionOverride = "alias-protection-override"
)

func (e ListAliasesScopeAliasProtectionOverride) ToPointer() *ListAliasesScopeAliasProtectionOverride {
	return &e
}
func (e *ListAliasesScopeAliasProtectionOverride) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alias-protection-override":
		*e = ListAliasesScopeAliasProtectionOverride(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListAliasesScopeAliasProtectionOverride: %v", v)
	}
}

// ListAliasesProtectionBypassAliasProtectionOverride - The protection bypass for the alias
type ListAliasesProtectionBypassAliasProtectionOverride struct {
	CreatedAt float64                                 `json:"createdAt"`
	CreatedBy string                                  `json:"createdBy"`
	Scope     ListAliasesScopeAliasProtectionOverride `json:"scope"`
}

func (o *ListAliasesProtectionBypassAliasProtectionOverride) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListAliasesProtectionBypassAliasProtectionOverride) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *ListAliasesProtectionBypassAliasProtectionOverride) GetScope() ListAliasesScopeAliasProtectionOverride {
	if o == nil {
		return ListAliasesScopeAliasProtectionOverride("")
	}
	return o.Scope
}

type ListAliasesAccess string

const (
	ListAliasesAccessRequested ListAliasesAccess = "requested"
	ListAliasesAccessGranted   ListAliasesAccess = "granted"
)

func (e ListAliasesAccess) ToPointer() *ListAliasesAccess {
	return &e
}
func (e *ListAliasesAccess) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "requested":
		fallthrough
	case "granted":
		*e = ListAliasesAccess(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListAliasesAccess: %v", v)
	}
}

type ListAliasesScopeUser string

const (
	ListAliasesScopeUserUser ListAliasesScopeUser = "user"
)

func (e ListAliasesScopeUser) ToPointer() *ListAliasesScopeUser {
	return &e
}
func (e *ListAliasesScopeUser) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		*e = ListAliasesScopeUser(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListAliasesScopeUser: %v", v)
	}
}

// ListAliasesProtectionBypassUser - The protection bypass for the alias
type ListAliasesProtectionBypassUser struct {
	CreatedAt     float64              `json:"createdAt"`
	LastUpdatedAt float64              `json:"lastUpdatedAt"`
	LastUpdatedBy string               `json:"lastUpdatedBy"`
	Access        ListAliasesAccess    `json:"access"`
	Scope         ListAliasesScopeUser `json:"scope"`
}

func (o *ListAliasesProtectionBypassUser) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListAliasesProtectionBypassUser) GetLastUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.LastUpdatedAt
}

func (o *ListAliasesProtectionBypassUser) GetLastUpdatedBy() string {
	if o == nil {
		return ""
	}
	return o.LastUpdatedBy
}

func (o *ListAliasesProtectionBypassUser) GetAccess() ListAliasesAccess {
	if o == nil {
		return ListAliasesAccess("")
	}
	return o.Access
}

func (o *ListAliasesProtectionBypassUser) GetScope() ListAliasesScopeUser {
	if o == nil {
		return ListAliasesScopeUser("")
	}
	return o.Scope
}

type ListAliasesScopeShareableLink string

const (
	ListAliasesScopeShareableLinkShareableLink ListAliasesScopeShareableLink = "shareable-link"
)

func (e ListAliasesScopeShareableLink) ToPointer() *ListAliasesScopeShareableLink {
	return &e
}
func (e *ListAliasesScopeShareableLink) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "shareable-link":
		*e = ListAliasesScopeShareableLink(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListAliasesScopeShareableLink: %v", v)
	}
}

// ListAliasesProtectionBypassShareableLink - The protection bypass for the alias
type ListAliasesProtectionBypassShareableLink struct {
	CreatedAt float64                       `json:"createdAt"`
	CreatedBy string                        `json:"createdBy"`
	Scope     ListAliasesScopeShareableLink `json:"scope"`
	Expires   *float64                      `json:"expires,omitempty"`
}

func (o *ListAliasesProtectionBypassShareableLink) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListAliasesProtectionBypassShareableLink) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *ListAliasesProtectionBypassShareableLink) GetScope() ListAliasesScopeShareableLink {
	if o == nil {
		return ListAliasesScopeShareableLink("")
	}
	return o.Scope
}

func (o *ListAliasesProtectionBypassShareableLink) GetExpires() *float64 {
	if o == nil {
		return nil
	}
	return o.Expires
}

type ListAliasesProtectionBypassUnionType string

const (
	ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassShareableLink           ListAliasesProtectionBypassUnionType = "listAliases_protectionBypass_ShareableLink"
	ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassUser                    ListAliasesProtectionBypassUnionType = "listAliases_protectionBypass_User"
	ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassAliasProtectionOverride ListAliasesProtectionBypassUnionType = "listAliases_protectionBypass_AliasProtectionOverride"
	ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassEmailInvite             ListAliasesProtectionBypassUnionType = "listAliases_protectionBypass_EmailInvite"
)

type ListAliasesProtectionBypassUnion struct {
	ListAliasesProtectionBypassShareableLink           *ListAliasesProtectionBypassShareableLink           `queryParam:"inline"`
	ListAliasesProtectionBypassUser                    *ListAliasesProtectionBypassUser                    `queryParam:"inline"`
	ListAliasesProtectionBypassAliasProtectionOverride *ListAliasesProtectionBypassAliasProtectionOverride `queryParam:"inline"`
	ListAliasesProtectionBypassEmailInvite             *ListAliasesProtectionBypassEmailInvite             `queryParam:"inline"`

	Type ListAliasesProtectionBypassUnionType
}

func CreateListAliasesProtectionBypassUnionListAliasesProtectionBypassShareableLink(listAliasesProtectionBypassShareableLink ListAliasesProtectionBypassShareableLink) ListAliasesProtectionBypassUnion {
	typ := ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassShareableLink

	return ListAliasesProtectionBypassUnion{
		ListAliasesProtectionBypassShareableLink: &listAliasesProtectionBypassShareableLink,
		Type:                                     typ,
	}
}

func CreateListAliasesProtectionBypassUnionListAliasesProtectionBypassUser(listAliasesProtectionBypassUser ListAliasesProtectionBypassUser) ListAliasesProtectionBypassUnion {
	typ := ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassUser

	return ListAliasesProtectionBypassUnion{
		ListAliasesProtectionBypassUser: &listAliasesProtectionBypassUser,
		Type:                            typ,
	}
}

func CreateListAliasesProtectionBypassUnionListAliasesProtectionBypassAliasProtectionOverride(listAliasesProtectionBypassAliasProtectionOverride ListAliasesProtectionBypassAliasProtectionOverride) ListAliasesProtectionBypassUnion {
	typ := ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassAliasProtectionOverride

	return ListAliasesProtectionBypassUnion{
		ListAliasesProtectionBypassAliasProtectionOverride: &listAliasesProtectionBypassAliasProtectionOverride,
		Type: typ,
	}
}

func CreateListAliasesProtectionBypassUnionListAliasesProtectionBypassEmailInvite(listAliasesProtectionBypassEmailInvite ListAliasesProtectionBypassEmailInvite) ListAliasesProtectionBypassUnion {
	typ := ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassEmailInvite

	return ListAliasesProtectionBypassUnion{
		ListAliasesProtectionBypassEmailInvite: &listAliasesProtectionBypassEmailInvite,
		Type:                                   typ,
	}
}

func (u *ListAliasesProtectionBypassUnion) UnmarshalJSON(data []byte) error {

	var listAliasesProtectionBypassAliasProtectionOverride ListAliasesProtectionBypassAliasProtectionOverride = ListAliasesProtectionBypassAliasProtectionOverride{}
	if err := utils.UnmarshalJSON(data, &listAliasesProtectionBypassAliasProtectionOverride, "", true, true); err == nil {
		u.ListAliasesProtectionBypassAliasProtectionOverride = &listAliasesProtectionBypassAliasProtectionOverride
		u.Type = ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassAliasProtectionOverride
		return nil
	}

	var listAliasesProtectionBypassShareableLink ListAliasesProtectionBypassShareableLink = ListAliasesProtectionBypassShareableLink{}
	if err := utils.UnmarshalJSON(data, &listAliasesProtectionBypassShareableLink, "", true, true); err == nil {
		u.ListAliasesProtectionBypassShareableLink = &listAliasesProtectionBypassShareableLink
		u.Type = ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassShareableLink
		return nil
	}

	var listAliasesProtectionBypassEmailInvite ListAliasesProtectionBypassEmailInvite = ListAliasesProtectionBypassEmailInvite{}
	if err := utils.UnmarshalJSON(data, &listAliasesProtectionBypassEmailInvite, "", true, true); err == nil {
		u.ListAliasesProtectionBypassEmailInvite = &listAliasesProtectionBypassEmailInvite
		u.Type = ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassEmailInvite
		return nil
	}

	var listAliasesProtectionBypassUser ListAliasesProtectionBypassUser = ListAliasesProtectionBypassUser{}
	if err := utils.UnmarshalJSON(data, &listAliasesProtectionBypassUser, "", true, true); err == nil {
		u.ListAliasesProtectionBypassUser = &listAliasesProtectionBypassUser
		u.Type = ListAliasesProtectionBypassUnionTypeListAliasesProtectionBypassUser
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListAliasesProtectionBypassUnion", string(data))
}

func (u ListAliasesProtectionBypassUnion) MarshalJSON() ([]byte, error) {
	if u.ListAliasesProtectionBypassShareableLink != nil {
		return utils.MarshalJSON(u.ListAliasesProtectionBypassShareableLink, "", true)
	}

	if u.ListAliasesProtectionBypassUser != nil {
		return utils.MarshalJSON(u.ListAliasesProtectionBypassUser, "", true)
	}

	if u.ListAliasesProtectionBypassAliasProtectionOverride != nil {
		return utils.MarshalJSON(u.ListAliasesProtectionBypassAliasProtectionOverride, "", true)
	}

	if u.ListAliasesProtectionBypassEmailInvite != nil {
		return utils.MarshalJSON(u.ListAliasesProtectionBypassEmailInvite, "", true)
	}

	return nil, errors.New("could not marshal union type ListAliasesProtectionBypassUnion: all fields are null")
}

type ListAliasesDefaultApp struct {
	ProjectID string `json:"projectId"`
}

func (o *ListAliasesDefaultApp) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

// ListAliasesApplications3 - A list of the deployment routing information for each project.
type ListAliasesApplications3 struct {
	// This is the deployment for the same commit, it could be a cancelled deployment. The proxy will fallback to the branchDeploymentId and then the fallbackDeploymentId.
	DeploymentID *string `json:"deploymentId,omitempty"`
	// This is the latest non-cancelled deployment of the branch alias at the time the commit alias was created. It is possible there is no deployment for the branch, or this was set before the deployment was canceled, in which case this will point to a cancelled deployment, in either case the proxy will fallback to the fallbackDeploymentId.
	BranchDeploymentID *string `json:"branchDeploymentId,omitempty"`
	// This is the deployment of the fallback host at the time the commit alias was created. It is possible for this to be a deleted deployment, in which case the proxy will show that the deployment is deleted. It will not use the fallbackHost, as a future deployment on the fallback host could be invalid for this deployment, and it could lead to confusion / incorrect behavior for the commit alias.
	FallbackDeploymentID *string `json:"fallbackDeploymentId,omitempty"`
	// Temporary for backwards compatibility. Can remove when metadata change is released
	FallbackHost *string `json:"fallbackHost,omitempty"`
	BranchAlias  *string `json:"branchAlias,omitempty"`
	// The project ID of the microfrontends application.
	ProjectID string `json:"projectId"`
}

func (o *ListAliasesApplications3) GetDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentID
}

func (o *ListAliasesApplications3) GetBranchDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.BranchDeploymentID
}

func (o *ListAliasesApplications3) GetFallbackDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.FallbackDeploymentID
}

func (o *ListAliasesApplications3) GetFallbackHost() *string {
	if o == nil {
		return nil
	}
	return o.FallbackHost
}

func (o *ListAliasesApplications3) GetBranchAlias() *string {
	if o == nil {
		return nil
	}
	return o.BranchAlias
}

func (o *ListAliasesApplications3) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

// ListAliasesApplications2 - A list of the deployment routing information for each project.
type ListAliasesApplications2 struct {
	// This is always set. For branch aliases, it's used as the fallback if there is no deployment for the branch.
	FallbackHost string `json:"fallbackHost"`
	// Could point to a branch without a deployment if the project was never deployed. The proxy will fallback to the fallbackHost if there is no deployment.
	BranchAlias string `json:"branchAlias"`
	// The project ID of the microfrontends application.
	ProjectID string `json:"projectId"`
}

func (o *ListAliasesApplications2) GetFallbackHost() string {
	if o == nil {
		return ""
	}
	return o.FallbackHost
}

func (o *ListAliasesApplications2) GetBranchAlias() string {
	if o == nil {
		return ""
	}
	return o.BranchAlias
}

func (o *ListAliasesApplications2) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

// ListAliasesApplications1 - A list of the deployment routing information for each project.
type ListAliasesApplications1 struct {
	// This is always set. In production it is used as a pointer to each apps production deployment. For pre-production, it's used as the fallback if there is no deployment for the branch.
	FallbackHost string `json:"fallbackHost"`
	// The project ID of the microfrontends application.
	ProjectID string `json:"projectId"`
}

func (o *ListAliasesApplications1) GetFallbackHost() string {
	if o == nil {
		return ""
	}
	return o.FallbackHost
}

func (o *ListAliasesApplications1) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

type ListAliasesApplicationsUnionType string

const (
	ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications1 ListAliasesApplicationsUnionType = "arrayOfListAliasesApplications1"
	ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications2 ListAliasesApplicationsUnionType = "arrayOfListAliasesApplications2"
	ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications3 ListAliasesApplicationsUnionType = "arrayOfListAliasesApplications3"
)

type ListAliasesApplicationsUnion struct {
	ArrayOfListAliasesApplications1 []ListAliasesApplications1 `queryParam:"inline"`
	ArrayOfListAliasesApplications2 []ListAliasesApplications2 `queryParam:"inline"`
	ArrayOfListAliasesApplications3 []ListAliasesApplications3 `queryParam:"inline"`

	Type ListAliasesApplicationsUnionType
}

func CreateListAliasesApplicationsUnionArrayOfListAliasesApplications1(arrayOfListAliasesApplications1 []ListAliasesApplications1) ListAliasesApplicationsUnion {
	typ := ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications1

	return ListAliasesApplicationsUnion{
		ArrayOfListAliasesApplications1: arrayOfListAliasesApplications1,
		Type:                            typ,
	}
}

func CreateListAliasesApplicationsUnionArrayOfListAliasesApplications2(arrayOfListAliasesApplications2 []ListAliasesApplications2) ListAliasesApplicationsUnion {
	typ := ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications2

	return ListAliasesApplicationsUnion{
		ArrayOfListAliasesApplications2: arrayOfListAliasesApplications2,
		Type:                            typ,
	}
}

func CreateListAliasesApplicationsUnionArrayOfListAliasesApplications3(arrayOfListAliasesApplications3 []ListAliasesApplications3) ListAliasesApplicationsUnion {
	typ := ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications3

	return ListAliasesApplicationsUnion{
		ArrayOfListAliasesApplications3: arrayOfListAliasesApplications3,
		Type:                            typ,
	}
}

func (u *ListAliasesApplicationsUnion) UnmarshalJSON(data []byte) error {

	var arrayOfListAliasesApplications1 []ListAliasesApplications1 = []ListAliasesApplications1{}
	if err := utils.UnmarshalJSON(data, &arrayOfListAliasesApplications1, "", true, true); err == nil {
		u.ArrayOfListAliasesApplications1 = arrayOfListAliasesApplications1
		u.Type = ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications1
		return nil
	}

	var arrayOfListAliasesApplications2 []ListAliasesApplications2 = []ListAliasesApplications2{}
	if err := utils.UnmarshalJSON(data, &arrayOfListAliasesApplications2, "", true, true); err == nil {
		u.ArrayOfListAliasesApplications2 = arrayOfListAliasesApplications2
		u.Type = ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications2
		return nil
	}

	var arrayOfListAliasesApplications3 []ListAliasesApplications3 = []ListAliasesApplications3{}
	if err := utils.UnmarshalJSON(data, &arrayOfListAliasesApplications3, "", true, true); err == nil {
		u.ArrayOfListAliasesApplications3 = arrayOfListAliasesApplications3
		u.Type = ListAliasesApplicationsUnionTypeArrayOfListAliasesApplications3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListAliasesApplicationsUnion", string(data))
}

func (u ListAliasesApplicationsUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfListAliasesApplications1 != nil {
		return utils.MarshalJSON(u.ArrayOfListAliasesApplications1, "", true)
	}

	if u.ArrayOfListAliasesApplications2 != nil {
		return utils.MarshalJSON(u.ArrayOfListAliasesApplications2, "", true)
	}

	if u.ArrayOfListAliasesApplications3 != nil {
		return utils.MarshalJSON(u.ArrayOfListAliasesApplications3, "", true)
	}

	return nil, errors.New("could not marshal union type ListAliasesApplicationsUnion: all fields are null")
}

// ListAliasesMicrofrontends - The microfrontends for the alias including the routing configuration
type ListAliasesMicrofrontends struct {
	DefaultApp   ListAliasesDefaultApp        `json:"defaultApp"`
	Applications ListAliasesApplicationsUnion `json:"applications"`
}

func (o *ListAliasesMicrofrontends) GetDefaultApp() ListAliasesDefaultApp {
	if o == nil {
		return ListAliasesDefaultApp{}
	}
	return o.DefaultApp
}

func (o *ListAliasesMicrofrontends) GetApplications() ListAliasesApplicationsUnion {
	if o == nil {
		return ListAliasesApplicationsUnion{}
	}
	return o.Applications
}

type ListAliasesAlias struct {
	// The alias name, it could be a `.vercel.app` subdomain or a custom domain
	Alias string `json:"alias"`
	// The date when the alias was created
	Created time.Time `json:"created"`
	// The date when the alias was created in milliseconds since the UNIX epoch
	CreatedAt *float64 `json:"createdAt,omitempty"`
	// Information of the user who created the alias
	Creator *ListAliasesCreator `json:"creator,omitempty"`
	// The date when the alias was deleted in milliseconds since the UNIX epoch
	DeletedAt *float64 `json:"deletedAt,omitempty"`
	// A map with the deployment ID, URL and metadata
	Deployment *ListAliasesDeployment `json:"deployment,omitempty"`
	// The deployment ID
	DeploymentID *string `json:"deploymentId"`
	// The unique identifier of the project
	ProjectID *string `json:"projectId"`
	// Target destination domain for redirect when the alias is a redirect
	Redirect *string `json:"redirect,omitempty"`
	// Status code to be used on redirect
	RedirectStatusCode *float64 `json:"redirectStatusCode,omitempty"`
	// The unique identifier of the alias
	UID string `json:"uid"`
	// The date when the alias was updated in milliseconds since the UNIX epoch
	UpdatedAt *float64 `json:"updatedAt,omitempty"`
	// The protection bypass for the alias
	ProtectionBypass map[string]ListAliasesProtectionBypassUnion `json:"protectionBypass,omitempty"`
	// The microfrontends for the alias including the routing configuration
	Microfrontends *ListAliasesMicrofrontends `json:"microfrontends,omitempty"`
}

func (l ListAliasesAlias) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListAliasesAlias) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, false); err != nil {
		return err
	}
	return nil
}

func (o *ListAliasesAlias) GetAlias() string {
	if o == nil {
		return ""
	}
	return o.Alias
}

func (o *ListAliasesAlias) GetCreated() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Created
}

func (o *ListAliasesAlias) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ListAliasesAlias) GetCreator() *ListAliasesCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *ListAliasesAlias) GetDeletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DeletedAt
}

func (o *ListAliasesAlias) GetDeployment() *ListAliasesDeployment {
	if o == nil {
		return nil
	}
	return o.Deployment
}

func (o *ListAliasesAlias) GetDeploymentID() *string {
	if o == nil {
		return nil
	}
	return o.DeploymentID
}

func (o *ListAliasesAlias) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *ListAliasesAlias) GetRedirect() *string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *ListAliasesAlias) GetRedirectStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.RedirectStatusCode
}

func (o *ListAliasesAlias) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *ListAliasesAlias) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *ListAliasesAlias) GetProtectionBypass() map[string]ListAliasesProtectionBypassUnion {
	if o == nil {
		return nil
	}
	return o.ProtectionBypass
}

func (o *ListAliasesAlias) GetMicrofrontends() *ListAliasesMicrofrontends {
	if o == nil {
		return nil
	}
	return o.Microfrontends
}

// ListAliasesResponseBody - The paginated list of aliases
type ListAliasesResponseBody struct {
	Aliases []ListAliasesAlias `json:"aliases"`
	// This object contains information related to the pagination of the current request, including the necessary parameters to get the next or previous page of data.
	Pagination components.Pagination `json:"pagination"`
}

func (o *ListAliasesResponseBody) GetAliases() []ListAliasesAlias {
	if o == nil {
		return []ListAliasesAlias{}
	}
	return o.Aliases
}

func (o *ListAliasesResponseBody) GetPagination() components.Pagination {
	if o == nil {
		return components.Pagination{}
	}
	return o.Pagination
}

type ListAliasesResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// The paginated list of aliases
	Object *ListAliasesResponseBody
}

func (o *ListAliasesResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListAliasesResponse) GetObject() *ListAliasesResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
