// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type ListCheckRunsRequest struct {
	ProjectIDOrName string `pathParam:"style=simple,explode=false,name=projectIdOrName"`
	// The ID of the resource that will be updated.
	CheckID string `pathParam:"style=simple,explode=false,name=checkId"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *ListCheckRunsRequest) GetProjectIDOrName() string {
	if o == nil {
		return ""
	}
	return o.ProjectIDOrName
}

func (o *ListCheckRunsRequest) GetCheckID() string {
	if o == nil {
		return ""
	}
	return o.CheckID
}

func (o *ListCheckRunsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ListCheckRunsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type ListCheckRunsKindGitProvider string

const (
	ListCheckRunsKindGitProviderGitProvider ListCheckRunsKindGitProvider = "git-provider"
)

func (e ListCheckRunsKindGitProvider) ToPointer() *ListCheckRunsKindGitProvider {
	return &e
}
func (e *ListCheckRunsKindGitProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "git-provider":
		*e = ListCheckRunsKindGitProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsKindGitProvider: %v", v)
	}
}

type ListCheckRunsProvider string

const (
	ListCheckRunsProviderGithub    ListCheckRunsProvider = "github"
	ListCheckRunsProviderGitlab    ListCheckRunsProvider = "gitlab"
	ListCheckRunsProviderBitbucket ListCheckRunsProvider = "bitbucket"
)

func (e ListCheckRunsProvider) ToPointer() *ListCheckRunsProvider {
	return &e
}
func (e *ListCheckRunsProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		*e = ListCheckRunsProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsProvider: %v", v)
	}
}

type ListCheckRunsSourceGitProvider struct {
	Kind              ListCheckRunsKindGitProvider `json:"kind"`
	Provider          ListCheckRunsProvider        `json:"provider"`
	ExternalCheckName string                       `json:"externalCheckName"`
}

func (l ListCheckRunsSourceGitProvider) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListCheckRunsSourceGitProvider) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"kind", "provider", "externalCheckName"}); err != nil {
		return err
	}
	return nil
}

func (o *ListCheckRunsSourceGitProvider) GetKind() ListCheckRunsKindGitProvider {
	if o == nil {
		return ListCheckRunsKindGitProvider("")
	}
	return o.Kind
}

func (o *ListCheckRunsSourceGitProvider) GetProvider() ListCheckRunsProvider {
	if o == nil {
		return ListCheckRunsProvider("")
	}
	return o.Provider
}

func (o *ListCheckRunsSourceGitProvider) GetExternalCheckName() string {
	if o == nil {
		return ""
	}
	return o.ExternalCheckName
}

type ListCheckRunsKindWebhook string

const (
	ListCheckRunsKindWebhookWebhook ListCheckRunsKindWebhook = "webhook"
)

func (e ListCheckRunsKindWebhook) ToPointer() *ListCheckRunsKindWebhook {
	return &e
}
func (e *ListCheckRunsKindWebhook) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "webhook":
		*e = ListCheckRunsKindWebhook(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsKindWebhook: %v", v)
	}
}

type ListCheckRunsSourceWebhook struct {
	Kind      ListCheckRunsKindWebhook `json:"kind"`
	WebhookID *string                  `json:"webhookId,omitempty"`
}

func (l ListCheckRunsSourceWebhook) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListCheckRunsSourceWebhook) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"kind"}); err != nil {
		return err
	}
	return nil
}

func (o *ListCheckRunsSourceWebhook) GetKind() ListCheckRunsKindWebhook {
	if o == nil {
		return ListCheckRunsKindWebhook("")
	}
	return o.Kind
}

func (o *ListCheckRunsSourceWebhook) GetWebhookID() *string {
	if o == nil {
		return nil
	}
	return o.WebhookID
}

type ListCheckRunsKindIntegration string

const (
	ListCheckRunsKindIntegrationIntegration ListCheckRunsKindIntegration = "integration"
)

func (e ListCheckRunsKindIntegration) ToPointer() *ListCheckRunsKindIntegration {
	return &e
}
func (e *ListCheckRunsKindIntegration) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration":
		*e = ListCheckRunsKindIntegration(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsKindIntegration: %v", v)
	}
}

type ListCheckRunsSourceIntegration struct {
	Kind                       ListCheckRunsKindIntegration `json:"kind"`
	IntegrationID              string                       `json:"integrationId"`
	IntegrationConfigurationID string                       `json:"integrationConfigurationId"`
	ResourceID                 *string                      `json:"resourceId,omitempty"`
	ExternalResourceID         *string                      `json:"externalResourceId,omitempty"`
}

func (l ListCheckRunsSourceIntegration) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListCheckRunsSourceIntegration) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"kind", "integrationId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *ListCheckRunsSourceIntegration) GetKind() ListCheckRunsKindIntegration {
	if o == nil {
		return ListCheckRunsKindIntegration("")
	}
	return o.Kind
}

func (o *ListCheckRunsSourceIntegration) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *ListCheckRunsSourceIntegration) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

func (o *ListCheckRunsSourceIntegration) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *ListCheckRunsSourceIntegration) GetExternalResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalResourceID
}

type ListCheckRunsSourceUnionType string

const (
	ListCheckRunsSourceUnionTypeIntegration ListCheckRunsSourceUnionType = "integration"
	ListCheckRunsSourceUnionTypeWebhook     ListCheckRunsSourceUnionType = "webhook"
	ListCheckRunsSourceUnionTypeGitProvider ListCheckRunsSourceUnionType = "git-provider"
)

type ListCheckRunsSourceUnion struct {
	ListCheckRunsSourceIntegration *ListCheckRunsSourceIntegration `queryParam:"inline"`
	ListCheckRunsSourceWebhook     *ListCheckRunsSourceWebhook     `queryParam:"inline"`
	ListCheckRunsSourceGitProvider *ListCheckRunsSourceGitProvider `queryParam:"inline"`

	Type ListCheckRunsSourceUnionType
}

func CreateListCheckRunsSourceUnionIntegration(integration ListCheckRunsSourceIntegration) ListCheckRunsSourceUnion {
	typ := ListCheckRunsSourceUnionTypeIntegration

	typStr := ListCheckRunsKindIntegration(typ)
	integration.Kind = typStr

	return ListCheckRunsSourceUnion{
		ListCheckRunsSourceIntegration: &integration,
		Type:                           typ,
	}
}

func CreateListCheckRunsSourceUnionWebhook(webhook ListCheckRunsSourceWebhook) ListCheckRunsSourceUnion {
	typ := ListCheckRunsSourceUnionTypeWebhook

	typStr := ListCheckRunsKindWebhook(typ)
	webhook.Kind = typStr

	return ListCheckRunsSourceUnion{
		ListCheckRunsSourceWebhook: &webhook,
		Type:                       typ,
	}
}

func CreateListCheckRunsSourceUnionGitProvider(gitProvider ListCheckRunsSourceGitProvider) ListCheckRunsSourceUnion {
	typ := ListCheckRunsSourceUnionTypeGitProvider

	typStr := ListCheckRunsKindGitProvider(typ)
	gitProvider.Kind = typStr

	return ListCheckRunsSourceUnion{
		ListCheckRunsSourceGitProvider: &gitProvider,
		Type:                           typ,
	}
}

func (u *ListCheckRunsSourceUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Kind string `json:"kind"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Kind {
	case "integration":
		listCheckRunsSourceIntegration := new(ListCheckRunsSourceIntegration)
		if err := utils.UnmarshalJSON(data, &listCheckRunsSourceIntegration, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == integration) type ListCheckRunsSourceIntegration within ListCheckRunsSourceUnion: %w", string(data), err)
		}

		u.ListCheckRunsSourceIntegration = listCheckRunsSourceIntegration
		u.Type = ListCheckRunsSourceUnionTypeIntegration
		return nil
	case "webhook":
		listCheckRunsSourceWebhook := new(ListCheckRunsSourceWebhook)
		if err := utils.UnmarshalJSON(data, &listCheckRunsSourceWebhook, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == webhook) type ListCheckRunsSourceWebhook within ListCheckRunsSourceUnion: %w", string(data), err)
		}

		u.ListCheckRunsSourceWebhook = listCheckRunsSourceWebhook
		u.Type = ListCheckRunsSourceUnionTypeWebhook
		return nil
	case "git-provider":
		listCheckRunsSourceGitProvider := new(ListCheckRunsSourceGitProvider)
		if err := utils.UnmarshalJSON(data, &listCheckRunsSourceGitProvider, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Kind == git-provider) type ListCheckRunsSourceGitProvider within ListCheckRunsSourceUnion: %w", string(data), err)
		}

		u.ListCheckRunsSourceGitProvider = listCheckRunsSourceGitProvider
		u.Type = ListCheckRunsSourceUnionTypeGitProvider
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListCheckRunsSourceUnion", string(data))
}

func (u ListCheckRunsSourceUnion) MarshalJSON() ([]byte, error) {
	if u.ListCheckRunsSourceIntegration != nil {
		return utils.MarshalJSON(u.ListCheckRunsSourceIntegration, "", true)
	}

	if u.ListCheckRunsSourceWebhook != nil {
		return utils.MarshalJSON(u.ListCheckRunsSourceWebhook, "", true)
	}

	if u.ListCheckRunsSourceGitProvider != nil {
		return utils.MarshalJSON(u.ListCheckRunsSourceGitProvider, "", true)
	}

	return nil, errors.New("could not marshal union type ListCheckRunsSourceUnion: all fields are null")
}

type ListCheckRunsRequires string

const (
	ListCheckRunsRequiresBuildReady    ListCheckRunsRequires = "build-ready"
	ListCheckRunsRequiresDeploymentURL ListCheckRunsRequires = "deployment-url"
	ListCheckRunsRequiresNone          ListCheckRunsRequires = "none"
)

func (e ListCheckRunsRequires) ToPointer() *ListCheckRunsRequires {
	return &e
}
func (e *ListCheckRunsRequires) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "build-ready":
		fallthrough
	case "deployment-url":
		fallthrough
	case "none":
		*e = ListCheckRunsRequires(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsRequires: %v", v)
	}
}

type ListCheckRunsBlocks string

const (
	ListCheckRunsBlocksNone                ListCheckRunsBlocks = "none"
	ListCheckRunsBlocksBuildStart          ListCheckRunsBlocks = "build-start"
	ListCheckRunsBlocksDeploymentStart     ListCheckRunsBlocks = "deployment-start"
	ListCheckRunsBlocksDeploymentAlias     ListCheckRunsBlocks = "deployment-alias"
	ListCheckRunsBlocksDeploymentPromotion ListCheckRunsBlocks = "deployment-promotion"
)

func (e ListCheckRunsBlocks) ToPointer() *ListCheckRunsBlocks {
	return &e
}
func (e *ListCheckRunsBlocks) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "none":
		fallthrough
	case "build-start":
		fallthrough
	case "deployment-start":
		fallthrough
	case "deployment-alias":
		fallthrough
	case "deployment-promotion":
		*e = ListCheckRunsBlocks(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsBlocks: %v", v)
	}
}

type ListCheckRunsStatus string

const (
	ListCheckRunsStatusQueued    ListCheckRunsStatus = "queued"
	ListCheckRunsStatusRunning   ListCheckRunsStatus = "running"
	ListCheckRunsStatusCompleted ListCheckRunsStatus = "completed"
)

func (e ListCheckRunsStatus) ToPointer() *ListCheckRunsStatus {
	return &e
}
func (e *ListCheckRunsStatus) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "queued":
		fallthrough
	case "running":
		fallthrough
	case "completed":
		*e = ListCheckRunsStatus(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsStatus: %v", v)
	}
}

type ListCheckRunsConclusion string

const (
	ListCheckRunsConclusionTimeout   ListCheckRunsConclusion = "timeout"
	ListCheckRunsConclusionCanceled  ListCheckRunsConclusion = "canceled"
	ListCheckRunsConclusionSkipped   ListCheckRunsConclusion = "skipped"
	ListCheckRunsConclusionFailed    ListCheckRunsConclusion = "failed"
	ListCheckRunsConclusionNeutral   ListCheckRunsConclusion = "neutral"
	ListCheckRunsConclusionSucceeded ListCheckRunsConclusion = "succeeded"
)

func (e ListCheckRunsConclusion) ToPointer() *ListCheckRunsConclusion {
	return &e
}
func (e *ListCheckRunsConclusion) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "timeout":
		fallthrough
	case "canceled":
		fallthrough
	case "skipped":
		fallthrough
	case "failed":
		fallthrough
	case "neutral":
		fallthrough
	case "succeeded":
		*e = ListCheckRunsConclusion(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListCheckRunsConclusion: %v", v)
	}
}

type ListCheckRunsRun struct {
	ID             string                   `json:"id"`
	Name           string                   `json:"name"`
	CheckID        string                   `json:"checkId"`
	OwnerID        string                   `json:"ownerId"`
	DeploymentID   string                   `json:"deploymentId"`
	ProjectID      *string                  `json:"projectId,omitempty"`
	Source         ListCheckRunsSourceUnion `json:"source"`
	Requires       *ListCheckRunsRequires   `json:"requires,omitempty"`
	Blocks         *ListCheckRunsBlocks     `json:"blocks,omitempty"`
	Targets        []string                 `json:"targets,omitempty"`
	Status         ListCheckRunsStatus      `json:"status"`
	Conclusion     *ListCheckRunsConclusion `json:"conclusion,omitempty"`
	ConclusionText *string                  `json:"conclusionText,omitempty"`
	ExternalID     *string                  `json:"externalId,omitempty"`
	ExternalURL    *string                  `json:"externalUrl,omitempty"`
	Output         map[string]any           `json:"output,omitempty"`
	Timeout        float64                  `json:"timeout"`
	CreatedAt      float64                  `json:"createdAt"`
	UpdatedAt      float64                  `json:"updatedAt"`
	CompletedAt    *float64                 `json:"completedAt,omitempty"`
}

func (o *ListCheckRunsRun) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListCheckRunsRun) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ListCheckRunsRun) GetCheckID() string {
	if o == nil {
		return ""
	}
	return o.CheckID
}

func (o *ListCheckRunsRun) GetOwnerID() string {
	if o == nil {
		return ""
	}
	return o.OwnerID
}

func (o *ListCheckRunsRun) GetDeploymentID() string {
	if o == nil {
		return ""
	}
	return o.DeploymentID
}

func (o *ListCheckRunsRun) GetProjectID() *string {
	if o == nil {
		return nil
	}
	return o.ProjectID
}

func (o *ListCheckRunsRun) GetSource() ListCheckRunsSourceUnion {
	if o == nil {
		return ListCheckRunsSourceUnion{}
	}
	return o.Source
}

func (o *ListCheckRunsRun) GetSourceIntegration() *ListCheckRunsSourceIntegration {
	return o.GetSource().ListCheckRunsSourceIntegration
}

func (o *ListCheckRunsRun) GetSourceWebhook() *ListCheckRunsSourceWebhook {
	return o.GetSource().ListCheckRunsSourceWebhook
}

func (o *ListCheckRunsRun) GetSourceGitProvider() *ListCheckRunsSourceGitProvider {
	return o.GetSource().ListCheckRunsSourceGitProvider
}

func (o *ListCheckRunsRun) GetRequires() *ListCheckRunsRequires {
	if o == nil {
		return nil
	}
	return o.Requires
}

func (o *ListCheckRunsRun) GetBlocks() *ListCheckRunsBlocks {
	if o == nil {
		return nil
	}
	return o.Blocks
}

func (o *ListCheckRunsRun) GetTargets() []string {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *ListCheckRunsRun) GetStatus() ListCheckRunsStatus {
	if o == nil {
		return ListCheckRunsStatus("")
	}
	return o.Status
}

func (o *ListCheckRunsRun) GetConclusion() *ListCheckRunsConclusion {
	if o == nil {
		return nil
	}
	return o.Conclusion
}

func (o *ListCheckRunsRun) GetConclusionText() *string {
	if o == nil {
		return nil
	}
	return o.ConclusionText
}

func (o *ListCheckRunsRun) GetExternalID() *string {
	if o == nil {
		return nil
	}
	return o.ExternalID
}

func (o *ListCheckRunsRun) GetExternalURL() *string {
	if o == nil {
		return nil
	}
	return o.ExternalURL
}

func (o *ListCheckRunsRun) GetOutput() map[string]any {
	if o == nil {
		return nil
	}
	return o.Output
}

func (o *ListCheckRunsRun) GetTimeout() float64 {
	if o == nil {
		return 0.0
	}
	return o.Timeout
}

func (o *ListCheckRunsRun) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListCheckRunsRun) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *ListCheckRunsRun) GetCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CompletedAt
}

type ListCheckRunsResponseBody struct {
	Runs []ListCheckRunsRun `json:"runs"`
}

func (o *ListCheckRunsResponseBody) GetRuns() []ListCheckRunsRun {
	if o == nil {
		return []ListCheckRunsRun{}
	}
	return o.Runs
}

type ListCheckRunsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *ListCheckRunsResponseBody
}

func (o *ListCheckRunsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListCheckRunsResponse) GetObject() *ListCheckRunsResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
