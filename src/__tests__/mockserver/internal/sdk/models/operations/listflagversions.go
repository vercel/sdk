// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type ListFlagVersionsRequest struct {
	ProjectIDOrName string   `pathParam:"style=simple,explode=false,name=projectIdOrName"`
	FlagIDOrSlug    string   `pathParam:"style=simple,explode=false,name=flagIdOrSlug"`
	Limit           *float64 `default:"20" queryParam:"style=form,explode=true,name=limit"`
	// Pagination cursor
	Cursor *string `queryParam:"style=form,explode=true,name=cursor"`
	// Environment to filter by
	Environment *string `queryParam:"style=form,explode=true,name=environment"`
	// Whether to include metadata
	WithMetadata *bool `default:"false" queryParam:"style=form,explode=true,name=withMetadata"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (l ListFlagVersionsRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"projectIdOrName", "flagIdOrSlug"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsRequest) GetProjectIDOrName() string {
	if o == nil {
		return ""
	}
	return o.ProjectIDOrName
}

func (o *ListFlagVersionsRequest) GetFlagIDOrSlug() string {
	if o == nil {
		return ""
	}
	return o.FlagIDOrSlug
}

func (o *ListFlagVersionsRequest) GetLimit() *float64 {
	if o == nil {
		return nil
	}
	return o.Limit
}

func (o *ListFlagVersionsRequest) GetCursor() *string {
	if o == nil {
		return nil
	}
	return o.Cursor
}

func (o *ListFlagVersionsRequest) GetEnvironment() *string {
	if o == nil {
		return nil
	}
	return o.Environment
}

func (o *ListFlagVersionsRequest) GetWithMetadata() *bool {
	if o == nil {
		return nil
	}
	return o.WithMetadata
}

func (o *ListFlagVersionsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ListFlagVersionsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type ListFlagVersionsValueType string

const (
	ListFlagVersionsValueTypeStr     ListFlagVersionsValueType = "str"
	ListFlagVersionsValueTypeNumber  ListFlagVersionsValueType = "number"
	ListFlagVersionsValueTypeBoolean ListFlagVersionsValueType = "boolean"
)

type ListFlagVersionsValue struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ListFlagVersionsValueType
}

func CreateListFlagVersionsValueStr(str string) ListFlagVersionsValue {
	typ := ListFlagVersionsValueTypeStr

	return ListFlagVersionsValue{
		Str:  &str,
		Type: typ,
	}
}

func CreateListFlagVersionsValueNumber(number float64) ListFlagVersionsValue {
	typ := ListFlagVersionsValueTypeNumber

	return ListFlagVersionsValue{
		Number: &number,
		Type:   typ,
	}
}

func CreateListFlagVersionsValueBoolean(boolean bool) ListFlagVersionsValue {
	typ := ListFlagVersionsValueTypeBoolean

	return ListFlagVersionsValue{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ListFlagVersionsValue) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ListFlagVersionsValueTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ListFlagVersionsValueTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ListFlagVersionsValueTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsValue", string(data))
}

func (u ListFlagVersionsValue) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsValue: all fields are null")
}

type ListFlagVersionsVariant struct {
	Description *string               `json:"description,omitempty"`
	Label       *string               `json:"label,omitempty"`
	Value       ListFlagVersionsValue `json:"value"`
	ID          string                `json:"id"`
}

func (o *ListFlagVersionsVariant) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ListFlagVersionsVariant) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *ListFlagVersionsVariant) GetValue() ListFlagVersionsValue {
	if o == nil {
		return ListFlagVersionsValue{}
	}
	return o.Value
}

func (o *ListFlagVersionsVariant) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

type ListFlagVersionsReuse struct {
	Active      bool   `json:"active"`
	Environment string `json:"environment"`
}

func (o *ListFlagVersionsReuse) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ListFlagVersionsReuse) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type ListFlagVersionsTarget struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *ListFlagVersionsTarget) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *ListFlagVersionsTarget) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type ListFlagVersionsTypeVariant string

const (
	ListFlagVersionsTypeVariantVariant ListFlagVersionsTypeVariant = "variant"
)

func (e ListFlagVersionsTypeVariant) ToPointer() *ListFlagVersionsTypeVariant {
	return &e
}
func (e *ListFlagVersionsTypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = ListFlagVersionsTypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsTypeVariant: %v", v)
	}
}

type ListFlagVersionsPausedOutcome struct {
	Type      ListFlagVersionsTypeVariant `json:"type"`
	VariantID string                      `json:"variantId"`
}

func (o *ListFlagVersionsPausedOutcome) GetType() ListFlagVersionsTypeVariant {
	if o == nil {
		return ListFlagVersionsTypeVariant("")
	}
	return o.Type
}

func (o *ListFlagVersionsPausedOutcome) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type ListFlagVersionsFallthroughTypeSplit string

const (
	ListFlagVersionsFallthroughTypeSplitSplit ListFlagVersionsFallthroughTypeSplit = "split"
)

func (e ListFlagVersionsFallthroughTypeSplit) ToPointer() *ListFlagVersionsFallthroughTypeSplit {
	return &e
}
func (e *ListFlagVersionsFallthroughTypeSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = ListFlagVersionsFallthroughTypeSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsFallthroughTypeSplit: %v", v)
	}
}

type ListFlagVersionsFallthroughTypeEntity string

const (
	ListFlagVersionsFallthroughTypeEntityEntity ListFlagVersionsFallthroughTypeEntity = "entity"
)

func (e ListFlagVersionsFallthroughTypeEntity) ToPointer() *ListFlagVersionsFallthroughTypeEntity {
	return &e
}
func (e *ListFlagVersionsFallthroughTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = ListFlagVersionsFallthroughTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsFallthroughTypeEntity: %v", v)
	}
}

type ListFlagVersionsFallthroughBase struct {
	Type      ListFlagVersionsFallthroughTypeEntity `json:"type"`
	Kind      string                                `json:"kind"`
	Attribute string                                `json:"attribute"`
}

func (l ListFlagVersionsFallthroughBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsFallthroughBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsFallthroughBase) GetType() ListFlagVersionsFallthroughTypeEntity {
	if o == nil {
		return ListFlagVersionsFallthroughTypeEntity("")
	}
	return o.Type
}

func (o *ListFlagVersionsFallthroughBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *ListFlagVersionsFallthroughBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type ListFlagVersionsFallthroughSplit struct {
	Type             ListFlagVersionsFallthroughTypeSplit `json:"type"`
	Base             ListFlagVersionsFallthroughBase      `json:"base"`
	Weights          map[string]float64                   `json:"weights"`
	DefaultVariantID string                               `json:"defaultVariantId"`
}

func (l ListFlagVersionsFallthroughSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsFallthroughSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsFallthroughSplit) GetType() ListFlagVersionsFallthroughTypeSplit {
	if o == nil {
		return ListFlagVersionsFallthroughTypeSplit("")
	}
	return o.Type
}

func (o *ListFlagVersionsFallthroughSplit) GetBase() ListFlagVersionsFallthroughBase {
	if o == nil {
		return ListFlagVersionsFallthroughBase{}
	}
	return o.Base
}

func (o *ListFlagVersionsFallthroughSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *ListFlagVersionsFallthroughSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type ListFlagVersionsFallthroughTypeVariant string

const (
	ListFlagVersionsFallthroughTypeVariantVariant ListFlagVersionsFallthroughTypeVariant = "variant"
)

func (e ListFlagVersionsFallthroughTypeVariant) ToPointer() *ListFlagVersionsFallthroughTypeVariant {
	return &e
}
func (e *ListFlagVersionsFallthroughTypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = ListFlagVersionsFallthroughTypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsFallthroughTypeVariant: %v", v)
	}
}

type ListFlagVersionsFallthroughVariant struct {
	Type      ListFlagVersionsFallthroughTypeVariant `json:"type"`
	VariantID string                                 `json:"variantId"`
}

func (l ListFlagVersionsFallthroughVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsFallthroughVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsFallthroughVariant) GetType() ListFlagVersionsFallthroughTypeVariant {
	if o == nil {
		return ListFlagVersionsFallthroughTypeVariant("")
	}
	return o.Type
}

func (o *ListFlagVersionsFallthroughVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type ListFlagVersionsFallthroughUnionType string

const (
	ListFlagVersionsFallthroughUnionTypeVariant ListFlagVersionsFallthroughUnionType = "variant"
	ListFlagVersionsFallthroughUnionTypeSplit   ListFlagVersionsFallthroughUnionType = "split"
)

type ListFlagVersionsFallthroughUnion struct {
	ListFlagVersionsFallthroughVariant *ListFlagVersionsFallthroughVariant `queryParam:"inline"`
	ListFlagVersionsFallthroughSplit   *ListFlagVersionsFallthroughSplit   `queryParam:"inline"`

	Type ListFlagVersionsFallthroughUnionType
}

func CreateListFlagVersionsFallthroughUnionVariant(variant ListFlagVersionsFallthroughVariant) ListFlagVersionsFallthroughUnion {
	typ := ListFlagVersionsFallthroughUnionTypeVariant

	typStr := ListFlagVersionsFallthroughTypeVariant(typ)
	variant.Type = typStr

	return ListFlagVersionsFallthroughUnion{
		ListFlagVersionsFallthroughVariant: &variant,
		Type:                               typ,
	}
}

func CreateListFlagVersionsFallthroughUnionSplit(split ListFlagVersionsFallthroughSplit) ListFlagVersionsFallthroughUnion {
	typ := ListFlagVersionsFallthroughUnionTypeSplit

	typStr := ListFlagVersionsFallthroughTypeSplit(typ)
	split.Type = typStr

	return ListFlagVersionsFallthroughUnion{
		ListFlagVersionsFallthroughSplit: &split,
		Type:                             typ,
	}
}

func (u *ListFlagVersionsFallthroughUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		listFlagVersionsFallthroughVariant := new(ListFlagVersionsFallthroughVariant)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsFallthroughVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type ListFlagVersionsFallthroughVariant within ListFlagVersionsFallthroughUnion: %w", string(data), err)
		}

		u.ListFlagVersionsFallthroughVariant = listFlagVersionsFallthroughVariant
		u.Type = ListFlagVersionsFallthroughUnionTypeVariant
		return nil
	case "split":
		listFlagVersionsFallthroughSplit := new(ListFlagVersionsFallthroughSplit)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsFallthroughSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type ListFlagVersionsFallthroughSplit within ListFlagVersionsFallthroughUnion: %w", string(data), err)
		}

		u.ListFlagVersionsFallthroughSplit = listFlagVersionsFallthroughSplit
		u.Type = ListFlagVersionsFallthroughUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsFallthroughUnion", string(data))
}

func (u ListFlagVersionsFallthroughUnion) MarshalJSON() ([]byte, error) {
	if u.ListFlagVersionsFallthroughVariant != nil {
		return utils.MarshalJSON(u.ListFlagVersionsFallthroughVariant, "", true)
	}

	if u.ListFlagVersionsFallthroughSplit != nil {
		return utils.MarshalJSON(u.ListFlagVersionsFallthroughSplit, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsFallthroughUnion: all fields are null")
}

type ListFlagVersionsOutcomeTypeSplit string

const (
	ListFlagVersionsOutcomeTypeSplitSplit ListFlagVersionsOutcomeTypeSplit = "split"
)

func (e ListFlagVersionsOutcomeTypeSplit) ToPointer() *ListFlagVersionsOutcomeTypeSplit {
	return &e
}
func (e *ListFlagVersionsOutcomeTypeSplit) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "split":
		*e = ListFlagVersionsOutcomeTypeSplit(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsOutcomeTypeSplit: %v", v)
	}
}

type ListFlagVersionsOutcomeTypeEntity string

const (
	ListFlagVersionsOutcomeTypeEntityEntity ListFlagVersionsOutcomeTypeEntity = "entity"
)

func (e ListFlagVersionsOutcomeTypeEntity) ToPointer() *ListFlagVersionsOutcomeTypeEntity {
	return &e
}
func (e *ListFlagVersionsOutcomeTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = ListFlagVersionsOutcomeTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsOutcomeTypeEntity: %v", v)
	}
}

type ListFlagVersionsOutcomeBase struct {
	Type      ListFlagVersionsOutcomeTypeEntity `json:"type"`
	Kind      string                            `json:"kind"`
	Attribute string                            `json:"attribute"`
}

func (l ListFlagVersionsOutcomeBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsOutcomeBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsOutcomeBase) GetType() ListFlagVersionsOutcomeTypeEntity {
	if o == nil {
		return ListFlagVersionsOutcomeTypeEntity("")
	}
	return o.Type
}

func (o *ListFlagVersionsOutcomeBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *ListFlagVersionsOutcomeBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type ListFlagVersionsOutcomeSplit struct {
	Type             ListFlagVersionsOutcomeTypeSplit `json:"type"`
	Base             ListFlagVersionsOutcomeBase      `json:"base"`
	Weights          map[string]float64               `json:"weights"`
	DefaultVariantID string                           `json:"defaultVariantId"`
}

func (l ListFlagVersionsOutcomeSplit) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsOutcomeSplit) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsOutcomeSplit) GetType() ListFlagVersionsOutcomeTypeSplit {
	if o == nil {
		return ListFlagVersionsOutcomeTypeSplit("")
	}
	return o.Type
}

func (o *ListFlagVersionsOutcomeSplit) GetBase() ListFlagVersionsOutcomeBase {
	if o == nil {
		return ListFlagVersionsOutcomeBase{}
	}
	return o.Base
}

func (o *ListFlagVersionsOutcomeSplit) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *ListFlagVersionsOutcomeSplit) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type ListFlagVersionsOutcomeTypeVariant string

const (
	ListFlagVersionsOutcomeTypeVariantVariant ListFlagVersionsOutcomeTypeVariant = "variant"
)

func (e ListFlagVersionsOutcomeTypeVariant) ToPointer() *ListFlagVersionsOutcomeTypeVariant {
	return &e
}
func (e *ListFlagVersionsOutcomeTypeVariant) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "variant":
		*e = ListFlagVersionsOutcomeTypeVariant(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsOutcomeTypeVariant: %v", v)
	}
}

type ListFlagVersionsOutcomeVariant struct {
	Type      ListFlagVersionsOutcomeTypeVariant `json:"type"`
	VariantID string                             `json:"variantId"`
}

func (l ListFlagVersionsOutcomeVariant) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsOutcomeVariant) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsOutcomeVariant) GetType() ListFlagVersionsOutcomeTypeVariant {
	if o == nil {
		return ListFlagVersionsOutcomeTypeVariant("")
	}
	return o.Type
}

func (o *ListFlagVersionsOutcomeVariant) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type ListFlagVersionsOutcomeUnionType string

const (
	ListFlagVersionsOutcomeUnionTypeVariant ListFlagVersionsOutcomeUnionType = "variant"
	ListFlagVersionsOutcomeUnionTypeSplit   ListFlagVersionsOutcomeUnionType = "split"
)

type ListFlagVersionsOutcomeUnion struct {
	ListFlagVersionsOutcomeVariant *ListFlagVersionsOutcomeVariant `queryParam:"inline"`
	ListFlagVersionsOutcomeSplit   *ListFlagVersionsOutcomeSplit   `queryParam:"inline"`

	Type ListFlagVersionsOutcomeUnionType
}

func CreateListFlagVersionsOutcomeUnionVariant(variant ListFlagVersionsOutcomeVariant) ListFlagVersionsOutcomeUnion {
	typ := ListFlagVersionsOutcomeUnionTypeVariant

	typStr := ListFlagVersionsOutcomeTypeVariant(typ)
	variant.Type = typStr

	return ListFlagVersionsOutcomeUnion{
		ListFlagVersionsOutcomeVariant: &variant,
		Type:                           typ,
	}
}

func CreateListFlagVersionsOutcomeUnionSplit(split ListFlagVersionsOutcomeSplit) ListFlagVersionsOutcomeUnion {
	typ := ListFlagVersionsOutcomeUnionTypeSplit

	typStr := ListFlagVersionsOutcomeTypeSplit(typ)
	split.Type = typStr

	return ListFlagVersionsOutcomeUnion{
		ListFlagVersionsOutcomeSplit: &split,
		Type:                         typ,
	}
}

func (u *ListFlagVersionsOutcomeUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "variant":
		listFlagVersionsOutcomeVariant := new(ListFlagVersionsOutcomeVariant)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsOutcomeVariant, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == variant) type ListFlagVersionsOutcomeVariant within ListFlagVersionsOutcomeUnion: %w", string(data), err)
		}

		u.ListFlagVersionsOutcomeVariant = listFlagVersionsOutcomeVariant
		u.Type = ListFlagVersionsOutcomeUnionTypeVariant
		return nil
	case "split":
		listFlagVersionsOutcomeSplit := new(ListFlagVersionsOutcomeSplit)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsOutcomeSplit, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == split) type ListFlagVersionsOutcomeSplit within ListFlagVersionsOutcomeUnion: %w", string(data), err)
		}

		u.ListFlagVersionsOutcomeSplit = listFlagVersionsOutcomeSplit
		u.Type = ListFlagVersionsOutcomeUnionTypeSplit
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsOutcomeUnion", string(data))
}

func (u ListFlagVersionsOutcomeUnion) MarshalJSON() ([]byte, error) {
	if u.ListFlagVersionsOutcomeVariant != nil {
		return utils.MarshalJSON(u.ListFlagVersionsOutcomeVariant, "", true)
	}

	if u.ListFlagVersionsOutcomeSplit != nil {
		return utils.MarshalJSON(u.ListFlagVersionsOutcomeSplit, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsOutcomeUnion: all fields are null")
}

type ListFlagVersionsTypeRegex string

const (
	ListFlagVersionsTypeRegexRegex ListFlagVersionsTypeRegex = "regex"
)

func (e ListFlagVersionsTypeRegex) ToPointer() *ListFlagVersionsTypeRegex {
	return &e
}
func (e *ListFlagVersionsTypeRegex) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "regex":
		*e = ListFlagVersionsTypeRegex(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsTypeRegex: %v", v)
	}
}

type ListFlagVersionsRHSRegex struct {
	Type    ListFlagVersionsTypeRegex `json:"type"`
	Pattern string                    `json:"pattern"`
	Flags   string                    `json:"flags"`
}

func (l ListFlagVersionsRHSRegex) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsRHSRegex) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsRHSRegex) GetType() ListFlagVersionsTypeRegex {
	if o == nil {
		return ListFlagVersionsTypeRegex("")
	}
	return o.Type
}

func (o *ListFlagVersionsRHSRegex) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *ListFlagVersionsRHSRegex) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type ListFlagVersionsRHSType string

const (
	ListFlagVersionsRHSTypeListInline ListFlagVersionsRHSType = "list/inline"
	ListFlagVersionsRHSTypeList       ListFlagVersionsRHSType = "list"
)

func (e ListFlagVersionsRHSType) ToPointer() *ListFlagVersionsRHSType {
	return &e
}
func (e *ListFlagVersionsRHSType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = ListFlagVersionsRHSType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsRHSType: %v", v)
	}
}

type ListFlagVersionsItem2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (l ListFlagVersionsItem2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsItem2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsItem2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *ListFlagVersionsItem2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *ListFlagVersionsItem2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type ListFlagVersionsItem1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (l ListFlagVersionsItem1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsItem1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsItem1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *ListFlagVersionsItem1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *ListFlagVersionsItem1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type ListFlagVersionsItemUnionType string

const (
	ListFlagVersionsItemUnionTypeListFlagVersionsItem1 ListFlagVersionsItemUnionType = "listFlagVersions_item_1"
	ListFlagVersionsItemUnionTypeListFlagVersionsItem2 ListFlagVersionsItemUnionType = "listFlagVersions_item_2"
)

type ListFlagVersionsItemUnion struct {
	ListFlagVersionsItem1 *ListFlagVersionsItem1 `queryParam:"inline"`
	ListFlagVersionsItem2 *ListFlagVersionsItem2 `queryParam:"inline"`

	Type ListFlagVersionsItemUnionType
}

func CreateListFlagVersionsItemUnionListFlagVersionsItem1(listFlagVersionsItem1 ListFlagVersionsItem1) ListFlagVersionsItemUnion {
	typ := ListFlagVersionsItemUnionTypeListFlagVersionsItem1

	return ListFlagVersionsItemUnion{
		ListFlagVersionsItem1: &listFlagVersionsItem1,
		Type:                  typ,
	}
}

func CreateListFlagVersionsItemUnionListFlagVersionsItem2(listFlagVersionsItem2 ListFlagVersionsItem2) ListFlagVersionsItemUnion {
	typ := ListFlagVersionsItemUnionTypeListFlagVersionsItem2

	return ListFlagVersionsItemUnion{
		ListFlagVersionsItem2: &listFlagVersionsItem2,
		Type:                  typ,
	}
}

func (u *ListFlagVersionsItemUnion) UnmarshalJSON(data []byte) error {

	var listFlagVersionsItem1 ListFlagVersionsItem1 = ListFlagVersionsItem1{}
	if err := utils.UnmarshalJSON(data, &listFlagVersionsItem1, "", true, nil); err == nil {
		u.ListFlagVersionsItem1 = &listFlagVersionsItem1
		u.Type = ListFlagVersionsItemUnionTypeListFlagVersionsItem1
		return nil
	}

	var listFlagVersionsItem2 ListFlagVersionsItem2 = ListFlagVersionsItem2{}
	if err := utils.UnmarshalJSON(data, &listFlagVersionsItem2, "", true, nil); err == nil {
		u.ListFlagVersionsItem2 = &listFlagVersionsItem2
		u.Type = ListFlagVersionsItemUnionTypeListFlagVersionsItem2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsItemUnion", string(data))
}

func (u ListFlagVersionsItemUnion) MarshalJSON() ([]byte, error) {
	if u.ListFlagVersionsItem1 != nil {
		return utils.MarshalJSON(u.ListFlagVersionsItem1, "", true)
	}

	if u.ListFlagVersionsItem2 != nil {
		return utils.MarshalJSON(u.ListFlagVersionsItem2, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsItemUnion: all fields are null")
}

type ListFlagVersionsRHS struct {
	Type  ListFlagVersionsRHSType     `json:"type"`
	Items []ListFlagVersionsItemUnion `json:"items"`
}

func (l ListFlagVersionsRHS) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsRHS) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsRHS) GetType() ListFlagVersionsRHSType {
	if o == nil {
		return ListFlagVersionsRHSType("")
	}
	return o.Type
}

func (o *ListFlagVersionsRHS) GetItems() []ListFlagVersionsItemUnion {
	if o == nil {
		return []ListFlagVersionsItemUnion{}
	}
	return o.Items
}

type ListFlagVersionsRHSUnionType string

const (
	ListFlagVersionsRHSUnionTypeStr                      ListFlagVersionsRHSUnionType = "str"
	ListFlagVersionsRHSUnionTypeNumber                   ListFlagVersionsRHSUnionType = "number"
	ListFlagVersionsRHSUnionTypeListFlagVersionsRHS      ListFlagVersionsRHSUnionType = "listFlagVersions_rhs"
	ListFlagVersionsRHSUnionTypeListFlagVersionsRHSRegex ListFlagVersionsRHSUnionType = "listFlagVersions_rhs_Regex"
	ListFlagVersionsRHSUnionTypeBoolean                  ListFlagVersionsRHSUnionType = "boolean"
)

type ListFlagVersionsRHSUnion struct {
	Str                      *string                   `queryParam:"inline"`
	Number                   *float64                  `queryParam:"inline"`
	ListFlagVersionsRHS      *ListFlagVersionsRHS      `queryParam:"inline"`
	ListFlagVersionsRHSRegex *ListFlagVersionsRHSRegex `queryParam:"inline"`
	Boolean                  *bool                     `queryParam:"inline"`

	Type ListFlagVersionsRHSUnionType
}

func CreateListFlagVersionsRHSUnionStr(str string) ListFlagVersionsRHSUnion {
	typ := ListFlagVersionsRHSUnionTypeStr

	return ListFlagVersionsRHSUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateListFlagVersionsRHSUnionNumber(number float64) ListFlagVersionsRHSUnion {
	typ := ListFlagVersionsRHSUnionTypeNumber

	return ListFlagVersionsRHSUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateListFlagVersionsRHSUnionListFlagVersionsRHS(listFlagVersionsRHS ListFlagVersionsRHS) ListFlagVersionsRHSUnion {
	typ := ListFlagVersionsRHSUnionTypeListFlagVersionsRHS

	return ListFlagVersionsRHSUnion{
		ListFlagVersionsRHS: &listFlagVersionsRHS,
		Type:                typ,
	}
}

func CreateListFlagVersionsRHSUnionListFlagVersionsRHSRegex(listFlagVersionsRHSRegex ListFlagVersionsRHSRegex) ListFlagVersionsRHSUnion {
	typ := ListFlagVersionsRHSUnionTypeListFlagVersionsRHSRegex

	return ListFlagVersionsRHSUnion{
		ListFlagVersionsRHSRegex: &listFlagVersionsRHSRegex,
		Type:                     typ,
	}
}

func CreateListFlagVersionsRHSUnionBoolean(boolean bool) ListFlagVersionsRHSUnion {
	typ := ListFlagVersionsRHSUnionTypeBoolean

	return ListFlagVersionsRHSUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ListFlagVersionsRHSUnion) UnmarshalJSON(data []byte) error {

	var listFlagVersionsRHSRegex ListFlagVersionsRHSRegex = ListFlagVersionsRHSRegex{}
	if err := utils.UnmarshalJSON(data, &listFlagVersionsRHSRegex, "", true, nil); err == nil {
		u.ListFlagVersionsRHSRegex = &listFlagVersionsRHSRegex
		u.Type = ListFlagVersionsRHSUnionTypeListFlagVersionsRHSRegex
		return nil
	}

	var listFlagVersionsRHS ListFlagVersionsRHS = ListFlagVersionsRHS{}
	if err := utils.UnmarshalJSON(data, &listFlagVersionsRHS, "", true, nil); err == nil {
		u.ListFlagVersionsRHS = &listFlagVersionsRHS
		u.Type = ListFlagVersionsRHSUnionTypeListFlagVersionsRHS
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ListFlagVersionsRHSUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ListFlagVersionsRHSUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ListFlagVersionsRHSUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsRHSUnion", string(data))
}

func (u ListFlagVersionsRHSUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.ListFlagVersionsRHS != nil {
		return utils.MarshalJSON(u.ListFlagVersionsRHS, "", true)
	}

	if u.ListFlagVersionsRHSRegex != nil {
		return utils.MarshalJSON(u.ListFlagVersionsRHSRegex, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsRHSUnion: all fields are null")
}

type ListFlagVersionsLHSTypeEntity string

const (
	ListFlagVersionsLHSTypeEntityEntity ListFlagVersionsLHSTypeEntity = "entity"
)

func (e ListFlagVersionsLHSTypeEntity) ToPointer() *ListFlagVersionsLHSTypeEntity {
	return &e
}
func (e *ListFlagVersionsLHSTypeEntity) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "entity":
		*e = ListFlagVersionsLHSTypeEntity(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsLHSTypeEntity: %v", v)
	}
}

type ListFlagVersionsLHSEntity struct {
	Type      ListFlagVersionsLHSTypeEntity `json:"type"`
	Kind      string                        `json:"kind"`
	Attribute string                        `json:"attribute"`
}

func (l ListFlagVersionsLHSEntity) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsLHSEntity) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsLHSEntity) GetType() ListFlagVersionsLHSTypeEntity {
	if o == nil {
		return ListFlagVersionsLHSTypeEntity("")
	}
	return o.Type
}

func (o *ListFlagVersionsLHSEntity) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *ListFlagVersionsLHSEntity) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type ListFlagVersionsTypeSegment string

const (
	ListFlagVersionsTypeSegmentSegment ListFlagVersionsTypeSegment = "segment"
)

func (e ListFlagVersionsTypeSegment) ToPointer() *ListFlagVersionsTypeSegment {
	return &e
}
func (e *ListFlagVersionsTypeSegment) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "segment":
		*e = ListFlagVersionsTypeSegment(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsTypeSegment: %v", v)
	}
}

type ListFlagVersionsLHSSegment struct {
	Type ListFlagVersionsTypeSegment `json:"type"`
}

func (l ListFlagVersionsLHSSegment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *ListFlagVersionsLHSSegment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *ListFlagVersionsLHSSegment) GetType() ListFlagVersionsTypeSegment {
	if o == nil {
		return ListFlagVersionsTypeSegment("")
	}
	return o.Type
}

type ListFlagVersionsLHSUnionType string

const (
	ListFlagVersionsLHSUnionTypeSegment ListFlagVersionsLHSUnionType = "segment"
	ListFlagVersionsLHSUnionTypeEntity  ListFlagVersionsLHSUnionType = "entity"
)

type ListFlagVersionsLHSUnion struct {
	ListFlagVersionsLHSSegment *ListFlagVersionsLHSSegment `queryParam:"inline"`
	ListFlagVersionsLHSEntity  *ListFlagVersionsLHSEntity  `queryParam:"inline"`

	Type ListFlagVersionsLHSUnionType
}

func CreateListFlagVersionsLHSUnionSegment(segment ListFlagVersionsLHSSegment) ListFlagVersionsLHSUnion {
	typ := ListFlagVersionsLHSUnionTypeSegment

	typStr := ListFlagVersionsTypeSegment(typ)
	segment.Type = typStr

	return ListFlagVersionsLHSUnion{
		ListFlagVersionsLHSSegment: &segment,
		Type:                       typ,
	}
}

func CreateListFlagVersionsLHSUnionEntity(entity ListFlagVersionsLHSEntity) ListFlagVersionsLHSUnion {
	typ := ListFlagVersionsLHSUnionTypeEntity

	typStr := ListFlagVersionsLHSTypeEntity(typ)
	entity.Type = typStr

	return ListFlagVersionsLHSUnion{
		ListFlagVersionsLHSEntity: &entity,
		Type:                      typ,
	}
}

func (u *ListFlagVersionsLHSUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "segment":
		listFlagVersionsLHSSegment := new(ListFlagVersionsLHSSegment)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsLHSSegment, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == segment) type ListFlagVersionsLHSSegment within ListFlagVersionsLHSUnion: %w", string(data), err)
		}

		u.ListFlagVersionsLHSSegment = listFlagVersionsLHSSegment
		u.Type = ListFlagVersionsLHSUnionTypeSegment
		return nil
	case "entity":
		listFlagVersionsLHSEntity := new(ListFlagVersionsLHSEntity)
		if err := utils.UnmarshalJSON(data, &listFlagVersionsLHSEntity, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == entity) type ListFlagVersionsLHSEntity within ListFlagVersionsLHSUnion: %w", string(data), err)
		}

		u.ListFlagVersionsLHSEntity = listFlagVersionsLHSEntity
		u.Type = ListFlagVersionsLHSUnionTypeEntity
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ListFlagVersionsLHSUnion", string(data))
}

func (u ListFlagVersionsLHSUnion) MarshalJSON() ([]byte, error) {
	if u.ListFlagVersionsLHSSegment != nil {
		return utils.MarshalJSON(u.ListFlagVersionsLHSSegment, "", true)
	}

	if u.ListFlagVersionsLHSEntity != nil {
		return utils.MarshalJSON(u.ListFlagVersionsLHSEntity, "", true)
	}

	return nil, errors.New("could not marshal union type ListFlagVersionsLHSUnion: all fields are null")
}

type ListFlagVersionsCmp string

const (
	ListFlagVersionsCmpEq             ListFlagVersionsCmp = "eq"
	ListFlagVersionsCmpNotEq          ListFlagVersionsCmp = "!eq"
	ListFlagVersionsCmpOneOf          ListFlagVersionsCmp = "oneOf"
	ListFlagVersionsCmpNotOneOf       ListFlagVersionsCmp = "!oneOf"
	ListFlagVersionsCmpContainsAllOf  ListFlagVersionsCmp = "containsAllOf"
	ListFlagVersionsCmpContainsAnyOf  ListFlagVersionsCmp = "containsAnyOf"
	ListFlagVersionsCmpContainsNoneOf ListFlagVersionsCmp = "containsNoneOf"
	ListFlagVersionsCmpStartsWith     ListFlagVersionsCmp = "startsWith"
	ListFlagVersionsCmpNotStartsWith  ListFlagVersionsCmp = "!startsWith"
	ListFlagVersionsCmpEndsWith       ListFlagVersionsCmp = "endsWith"
	ListFlagVersionsCmpNotEndsWith    ListFlagVersionsCmp = "!endsWith"
	ListFlagVersionsCmpEx             ListFlagVersionsCmp = "ex"
	ListFlagVersionsCmpNotEx          ListFlagVersionsCmp = "!ex"
	ListFlagVersionsCmpGt             ListFlagVersionsCmp = "gt"
	ListFlagVersionsCmpGte            ListFlagVersionsCmp = "gte"
	ListFlagVersionsCmpLt             ListFlagVersionsCmp = "lt"
	ListFlagVersionsCmpLte            ListFlagVersionsCmp = "lte"
	ListFlagVersionsCmpRegex          ListFlagVersionsCmp = "regex"
	ListFlagVersionsCmpNotRegex       ListFlagVersionsCmp = "!regex"
	ListFlagVersionsCmpBefore         ListFlagVersionsCmp = "before"
	ListFlagVersionsCmpAfter          ListFlagVersionsCmp = "after"
)

func (e ListFlagVersionsCmp) ToPointer() *ListFlagVersionsCmp {
	return &e
}
func (e *ListFlagVersionsCmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = ListFlagVersionsCmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsCmp: %v", v)
	}
}

type ListFlagVersionsCondition struct {
	RHS *ListFlagVersionsRHSUnion `json:"rhs,omitempty"`
	LHS ListFlagVersionsLHSUnion  `json:"lhs"`
	Cmp ListFlagVersionsCmp       `json:"cmp"`
}

func (o *ListFlagVersionsCondition) GetRHS() *ListFlagVersionsRHSUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

func (o *ListFlagVersionsCondition) GetLHS() ListFlagVersionsLHSUnion {
	if o == nil {
		return ListFlagVersionsLHSUnion{}
	}
	return o.LHS
}

func (o *ListFlagVersionsCondition) GetLHSSegment() *ListFlagVersionsLHSSegment {
	return o.GetLHS().ListFlagVersionsLHSSegment
}

func (o *ListFlagVersionsCondition) GetLHSEntity() *ListFlagVersionsLHSEntity {
	return o.GetLHS().ListFlagVersionsLHSEntity
}

func (o *ListFlagVersionsCondition) GetCmp() ListFlagVersionsCmp {
	if o == nil {
		return ListFlagVersionsCmp("")
	}
	return o.Cmp
}

type ListFlagVersionsRule struct {
	ID         string                       `json:"id"`
	Outcome    ListFlagVersionsOutcomeUnion `json:"outcome"`
	Conditions []ListFlagVersionsCondition  `json:"conditions"`
}

func (o *ListFlagVersionsRule) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListFlagVersionsRule) GetOutcome() ListFlagVersionsOutcomeUnion {
	if o == nil {
		return ListFlagVersionsOutcomeUnion{}
	}
	return o.Outcome
}

func (o *ListFlagVersionsRule) GetOutcomeVariant() *ListFlagVersionsOutcomeVariant {
	return o.GetOutcome().ListFlagVersionsOutcomeVariant
}

func (o *ListFlagVersionsRule) GetOutcomeSplit() *ListFlagVersionsOutcomeSplit {
	return o.GetOutcome().ListFlagVersionsOutcomeSplit
}

func (o *ListFlagVersionsRule) GetConditions() []ListFlagVersionsCondition {
	if o == nil {
		return []ListFlagVersionsCondition{}
	}
	return o.Conditions
}

type ListFlagVersionsEnvironments struct {
	Reuse         *ListFlagVersionsReuse                                    `json:"reuse,omitempty"`
	Targets       map[string]map[string]map[string][]ListFlagVersionsTarget `json:"targets,omitempty"`
	Revision      *float64                                                  `json:"revision,omitempty"`
	PausedOutcome ListFlagVersionsPausedOutcome                             `json:"pausedOutcome"`
	Fallthrough   ListFlagVersionsFallthroughUnion                          `json:"fallthrough"`
	Active        bool                                                      `json:"active"`
	Rules         []ListFlagVersionsRule                                    `json:"rules"`
}

func (o *ListFlagVersionsEnvironments) GetReuse() *ListFlagVersionsReuse {
	if o == nil {
		return nil
	}
	return o.Reuse
}

func (o *ListFlagVersionsEnvironments) GetTargets() map[string]map[string]map[string][]ListFlagVersionsTarget {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *ListFlagVersionsEnvironments) GetRevision() *float64 {
	if o == nil {
		return nil
	}
	return o.Revision
}

func (o *ListFlagVersionsEnvironments) GetPausedOutcome() ListFlagVersionsPausedOutcome {
	if o == nil {
		return ListFlagVersionsPausedOutcome{}
	}
	return o.PausedOutcome
}

func (o *ListFlagVersionsEnvironments) GetFallthrough() ListFlagVersionsFallthroughUnion {
	if o == nil {
		return ListFlagVersionsFallthroughUnion{}
	}
	return o.Fallthrough
}

func (o *ListFlagVersionsEnvironments) GetFallthroughVariant() *ListFlagVersionsFallthroughVariant {
	return o.GetFallthrough().ListFlagVersionsFallthroughVariant
}

func (o *ListFlagVersionsEnvironments) GetFallthroughSplit() *ListFlagVersionsFallthroughSplit {
	return o.GetFallthrough().ListFlagVersionsFallthroughSplit
}

func (o *ListFlagVersionsEnvironments) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *ListFlagVersionsEnvironments) GetRules() []ListFlagVersionsRule {
	if o == nil {
		return []ListFlagVersionsRule{}
	}
	return o.Rules
}

type ListFlagVersionsState string

const (
	ListFlagVersionsStateActive   ListFlagVersionsState = "active"
	ListFlagVersionsStateArchived ListFlagVersionsState = "archived"
)

func (e ListFlagVersionsState) ToPointer() *ListFlagVersionsState {
	return &e
}
func (e *ListFlagVersionsState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "archived":
		*e = ListFlagVersionsState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ListFlagVersionsState: %v", v)
	}
}

type ListFlagVersionsData struct {
	Description  *string                                 `json:"description,omitempty"`
	Variants     []ListFlagVersionsVariant               `json:"variants"`
	Environments map[string]ListFlagVersionsEnvironments `json:"environments"`
	Seed         float64                                 `json:"seed"`
	State        ListFlagVersionsState                   `json:"state"`
}

func (o *ListFlagVersionsData) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *ListFlagVersionsData) GetVariants() []ListFlagVersionsVariant {
	if o == nil {
		return []ListFlagVersionsVariant{}
	}
	return o.Variants
}

func (o *ListFlagVersionsData) GetEnvironments() map[string]ListFlagVersionsEnvironments {
	if o == nil {
		return map[string]ListFlagVersionsEnvironments{}
	}
	return o.Environments
}

func (o *ListFlagVersionsData) GetSeed() float64 {
	if o == nil {
		return 0.0
	}
	return o.Seed
}

func (o *ListFlagVersionsData) GetState() ListFlagVersionsState {
	if o == nil {
		return ListFlagVersionsState("")
	}
	return o.State
}

type ListFlagVersionsCreator struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

func (o *ListFlagVersionsCreator) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListFlagVersionsCreator) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

type ListFlagVersionsMetadata struct {
	Creator *ListFlagVersionsCreator `json:"creator,omitempty"`
}

func (o *ListFlagVersionsMetadata) GetCreator() *ListFlagVersionsCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

type ListFlagVersionsVersion struct {
	CreatedBy           *string                   `json:"createdBy,omitempty"`
	Message             *string                   `json:"message,omitempty"`
	ID                  string                    `json:"id"`
	Revision            float64                   `json:"revision"`
	CreatedAt           float64                   `json:"createdAt"`
	Data                ListFlagVersionsData      `json:"data"`
	FlagID              string                    `json:"flagId"`
	ChangedEnvironments []string                  `json:"changedEnvironments"`
	Metadata            *ListFlagVersionsMetadata `json:"metadata,omitempty"`
}

func (o *ListFlagVersionsVersion) GetCreatedBy() *string {
	if o == nil {
		return nil
	}
	return o.CreatedBy
}

func (o *ListFlagVersionsVersion) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *ListFlagVersionsVersion) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ListFlagVersionsVersion) GetRevision() float64 {
	if o == nil {
		return 0.0
	}
	return o.Revision
}

func (o *ListFlagVersionsVersion) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ListFlagVersionsVersion) GetData() ListFlagVersionsData {
	if o == nil {
		return ListFlagVersionsData{}
	}
	return o.Data
}

func (o *ListFlagVersionsVersion) GetFlagID() string {
	if o == nil {
		return ""
	}
	return o.FlagID
}

func (o *ListFlagVersionsVersion) GetChangedEnvironments() []string {
	if o == nil {
		return []string{}
	}
	return o.ChangedEnvironments
}

func (o *ListFlagVersionsVersion) GetMetadata() *ListFlagVersionsMetadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

type ListFlagVersionsPagination struct {
}

type ListFlagVersionsResponseBody struct {
	Versions   []ListFlagVersionsVersion  `json:"versions"`
	Pagination ListFlagVersionsPagination `json:"pagination"`
}

func (o *ListFlagVersionsResponseBody) GetVersions() []ListFlagVersionsVersion {
	if o == nil {
		return []ListFlagVersionsVersion{}
	}
	return o.Versions
}

func (o *ListFlagVersionsResponseBody) GetPagination() ListFlagVersionsPagination {
	if o == nil {
		return ListFlagVersionsPagination{}
	}
	return o.Pagination
}

type ListFlagVersionsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *ListFlagVersionsResponseBody
}

func (o *ListFlagVersionsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *ListFlagVersionsResponse) GetObject() *ListFlagVersionsResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
