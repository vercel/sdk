// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type Operation3 string

const (
	Operation3Create Operation3 = "create"
	Operation3Update Operation3 = "update"
	Operation3Upsert Operation3 = "upsert"
	Operation3Delete Operation3 = "delete"
)

func (e Operation3) ToPointer() *Operation3 {
	return &e
}
func (e *Operation3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "create":
		fallthrough
	case "update":
		fallthrough
	case "upsert":
		fallthrough
	case "delete":
		*e = Operation3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation3: %v", v)
	}
}

type Description3Type string

const (
	Description3TypeStr Description3Type = "str"
	Description3TypeAny Description3Type = "any"
)

type Description3 struct {
	Str *string `queryParam:"inline"`
	Any any     `queryParam:"inline"`

	Type Description3Type
}

func CreateDescription3Str(str string) Description3 {
	typ := Description3TypeStr

	return Description3{
		Str:  &str,
		Type: typ,
	}
}

func CreateDescription3Any(anyT any) Description3 {
	typ := Description3TypeAny

	return Description3{
		Any:  anyT,
		Type: typ,
	}
}

func (u *Description3) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = Description3TypeStr
		return nil
	}

	var anyVar any = nil
	if err := utils.UnmarshalJSON(data, &anyVar, "", true, true); err == nil {
		u.Any = anyVar
		u.Type = Description3TypeAny
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Description3", string(data))
}

func (u Description3) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Any != nil {
		return utils.MarshalJSON(u.Any, "", true)
	}

	return nil, errors.New("could not marshal union type Description3: all fields are null")
}

type PatchEdgeConfigItemsItem3 struct {
	Operation   Operation3    `json:"operation"`
	Key         string        `json:"key"`
	Value       any           `json:"value,omitempty"`
	Description *Description3 `json:"description"`
}

func (o *PatchEdgeConfigItemsItem3) GetOperation() Operation3 {
	if o == nil {
		return Operation3("")
	}
	return o.Operation
}

func (o *PatchEdgeConfigItemsItem3) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *PatchEdgeConfigItemsItem3) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *PatchEdgeConfigItemsItem3) GetDescription() *Description3 {
	if o == nil {
		return nil
	}
	return o.Description
}

type Operation2 string

const (
	Operation2Create Operation2 = "create"
	Operation2Update Operation2 = "update"
	Operation2Upsert Operation2 = "upsert"
	Operation2Delete Operation2 = "delete"
)

func (e Operation2) ToPointer() *Operation2 {
	return &e
}
func (e *Operation2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "create":
		fallthrough
	case "update":
		fallthrough
	case "upsert":
		fallthrough
	case "delete":
		*e = Operation2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation2: %v", v)
	}
}

type Description2Type string

const (
	Description2TypeStr Description2Type = "str"
	Description2TypeAny Description2Type = "any"
)

type Description2 struct {
	Str *string `queryParam:"inline"`
	Any any     `queryParam:"inline"`

	Type Description2Type
}

func CreateDescription2Str(str string) Description2 {
	typ := Description2TypeStr

	return Description2{
		Str:  &str,
		Type: typ,
	}
}

func CreateDescription2Any(anyT any) Description2 {
	typ := Description2TypeAny

	return Description2{
		Any:  anyT,
		Type: typ,
	}
}

func (u *Description2) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = Description2TypeStr
		return nil
	}

	var anyVar any = nil
	if err := utils.UnmarshalJSON(data, &anyVar, "", true, true); err == nil {
		u.Any = anyVar
		u.Type = Description2TypeAny
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Description2", string(data))
}

func (u Description2) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Any != nil {
		return utils.MarshalJSON(u.Any, "", true)
	}

	return nil, errors.New("could not marshal union type Description2: all fields are null")
}

type PatchEdgeConfigItemsItem2 struct {
	Operation   Operation2    `json:"operation"`
	Key         string        `json:"key"`
	Value       any           `json:"value"`
	Description *Description2 `json:"description,omitempty"`
}

func (o *PatchEdgeConfigItemsItem2) GetOperation() Operation2 {
	if o == nil {
		return Operation2("")
	}
	return o.Operation
}

func (o *PatchEdgeConfigItemsItem2) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *PatchEdgeConfigItemsItem2) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *PatchEdgeConfigItemsItem2) GetDescription() *Description2 {
	if o == nil {
		return nil
	}
	return o.Description
}

type Operation1 string

const (
	Operation1Create Operation1 = "create"
	Operation1Update Operation1 = "update"
	Operation1Upsert Operation1 = "upsert"
	Operation1Delete Operation1 = "delete"
)

func (e Operation1) ToPointer() *Operation1 {
	return &e
}
func (e *Operation1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "create":
		fallthrough
	case "update":
		fallthrough
	case "upsert":
		fallthrough
	case "delete":
		*e = Operation1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Operation1: %v", v)
	}
}

type Description1Type string

const (
	Description1TypeStr Description1Type = "str"
	Description1TypeAny Description1Type = "any"
)

type Description1 struct {
	Str *string `queryParam:"inline"`
	Any any     `queryParam:"inline"`

	Type Description1Type
}

func CreateDescription1Str(str string) Description1 {
	typ := Description1TypeStr

	return Description1{
		Str:  &str,
		Type: typ,
	}
}

func CreateDescription1Any(anyT any) Description1 {
	typ := Description1TypeAny

	return Description1{
		Any:  anyT,
		Type: typ,
	}
}

func (u *Description1) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, true); err == nil {
		u.Str = &str
		u.Type = Description1TypeStr
		return nil
	}

	var anyVar any = nil
	if err := utils.UnmarshalJSON(data, &anyVar, "", true, true); err == nil {
		u.Any = anyVar
		u.Type = Description1TypeAny
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Description1", string(data))
}

func (u Description1) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Any != nil {
		return utils.MarshalJSON(u.Any, "", true)
	}

	return nil, errors.New("could not marshal union type Description1: all fields are null")
}

type PatchEdgeConfigItemsItem1 struct {
	Operation   Operation1    `json:"operation"`
	Key         string        `json:"key"`
	Value       any           `json:"value"`
	Description *Description1 `json:"description,omitempty"`
}

func (o *PatchEdgeConfigItemsItem1) GetOperation() Operation1 {
	if o == nil {
		return Operation1("")
	}
	return o.Operation
}

func (o *PatchEdgeConfigItemsItem1) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *PatchEdgeConfigItemsItem1) GetValue() any {
	if o == nil {
		return nil
	}
	return o.Value
}

func (o *PatchEdgeConfigItemsItem1) GetDescription() *Description1 {
	if o == nil {
		return nil
	}
	return o.Description
}

type ItemUnion2Type string

const (
	ItemUnion2TypePatchEdgeConfigItemsItem1 ItemUnion2Type = "patchEdgeConfigItems_item_1"
	ItemUnion2TypePatchEdgeConfigItemsItem2 ItemUnion2Type = "patchEdgeConfigItems_item_2"
	ItemUnion2TypePatchEdgeConfigItemsItem3 ItemUnion2Type = "patchEdgeConfigItems_item_3"
)

type ItemUnion2 struct {
	PatchEdgeConfigItemsItem1 *PatchEdgeConfigItemsItem1 `queryParam:"inline"`
	PatchEdgeConfigItemsItem2 *PatchEdgeConfigItemsItem2 `queryParam:"inline"`
	PatchEdgeConfigItemsItem3 *PatchEdgeConfigItemsItem3 `queryParam:"inline"`

	Type ItemUnion2Type
}

func CreateItemUnion2PatchEdgeConfigItemsItem1(patchEdgeConfigItemsItem1 PatchEdgeConfigItemsItem1) ItemUnion2 {
	typ := ItemUnion2TypePatchEdgeConfigItemsItem1

	return ItemUnion2{
		PatchEdgeConfigItemsItem1: &patchEdgeConfigItemsItem1,
		Type:                      typ,
	}
}

func CreateItemUnion2PatchEdgeConfigItemsItem2(patchEdgeConfigItemsItem2 PatchEdgeConfigItemsItem2) ItemUnion2 {
	typ := ItemUnion2TypePatchEdgeConfigItemsItem2

	return ItemUnion2{
		PatchEdgeConfigItemsItem2: &patchEdgeConfigItemsItem2,
		Type:                      typ,
	}
}

func CreateItemUnion2PatchEdgeConfigItemsItem3(patchEdgeConfigItemsItem3 PatchEdgeConfigItemsItem3) ItemUnion2 {
	typ := ItemUnion2TypePatchEdgeConfigItemsItem3

	return ItemUnion2{
		PatchEdgeConfigItemsItem3: &patchEdgeConfigItemsItem3,
		Type:                      typ,
	}
}

func (u *ItemUnion2) UnmarshalJSON(data []byte) error {

	var patchEdgeConfigItemsItem1 PatchEdgeConfigItemsItem1 = PatchEdgeConfigItemsItem1{}
	if err := utils.UnmarshalJSON(data, &patchEdgeConfigItemsItem1, "", true, true); err == nil {
		u.PatchEdgeConfigItemsItem1 = &patchEdgeConfigItemsItem1
		u.Type = ItemUnion2TypePatchEdgeConfigItemsItem1
		return nil
	}

	var patchEdgeConfigItemsItem2 PatchEdgeConfigItemsItem2 = PatchEdgeConfigItemsItem2{}
	if err := utils.UnmarshalJSON(data, &patchEdgeConfigItemsItem2, "", true, true); err == nil {
		u.PatchEdgeConfigItemsItem2 = &patchEdgeConfigItemsItem2
		u.Type = ItemUnion2TypePatchEdgeConfigItemsItem2
		return nil
	}

	var patchEdgeConfigItemsItem3 PatchEdgeConfigItemsItem3 = PatchEdgeConfigItemsItem3{}
	if err := utils.UnmarshalJSON(data, &patchEdgeConfigItemsItem3, "", true, true); err == nil {
		u.PatchEdgeConfigItemsItem3 = &patchEdgeConfigItemsItem3
		u.Type = ItemUnion2TypePatchEdgeConfigItemsItem3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ItemUnion2", string(data))
}

func (u ItemUnion2) MarshalJSON() ([]byte, error) {
	if u.PatchEdgeConfigItemsItem1 != nil {
		return utils.MarshalJSON(u.PatchEdgeConfigItemsItem1, "", true)
	}

	if u.PatchEdgeConfigItemsItem2 != nil {
		return utils.MarshalJSON(u.PatchEdgeConfigItemsItem2, "", true)
	}

	if u.PatchEdgeConfigItemsItem3 != nil {
		return utils.MarshalJSON(u.PatchEdgeConfigItemsItem3, "", true)
	}

	return nil, errors.New("could not marshal union type ItemUnion2: all fields are null")
}

type ItemUnion1Type string

const (
	ItemUnion1TypeItemUnion2 ItemUnion1Type = "item_union_2"
)

type ItemUnion1 struct {
	ItemUnion2 *ItemUnion2 `queryParam:"inline"`

	Type ItemUnion1Type
}

func CreateItemUnion1ItemUnion2(itemUnion2 ItemUnion2) ItemUnion1 {
	typ := ItemUnion1TypeItemUnion2

	return ItemUnion1{
		ItemUnion2: &itemUnion2,
		Type:       typ,
	}
}

func (u *ItemUnion1) UnmarshalJSON(data []byte) error {

	var itemUnion2 ItemUnion2 = ItemUnion2{}
	if err := utils.UnmarshalJSON(data, &itemUnion2, "", true, true); err == nil {
		u.ItemUnion2 = &itemUnion2
		u.Type = ItemUnion1TypeItemUnion2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ItemUnion1", string(data))
}

func (u ItemUnion1) MarshalJSON() ([]byte, error) {
	if u.ItemUnion2 != nil {
		return utils.MarshalJSON(u.ItemUnion2, "", true)
	}

	return nil, errors.New("could not marshal union type ItemUnion1: all fields are null")
}

type PatchEdgeConfigItemsRequestBody struct {
	Items      []ItemUnion1 `json:"items"`
	Definition any          `json:"definition"`
}

func (o *PatchEdgeConfigItemsRequestBody) GetItems() []ItemUnion1 {
	if o == nil {
		return []ItemUnion1{}
	}
	return o.Items
}

func (o *PatchEdgeConfigItemsRequestBody) GetDefinition() any {
	if o == nil {
		return nil
	}
	return o.Definition
}

type PatchEdgeConfigItemsRequest struct {
	EdgeConfigID string  `pathParam:"style=simple,explode=false,name=edgeConfigId"`
	DryRun       *string `queryParam:"style=form,explode=true,name=dryRun"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string                          `queryParam:"style=form,explode=true,name=slug"`
	RequestBody *PatchEdgeConfigItemsRequestBody `request:"mediaType=application/json"`
}

func (o *PatchEdgeConfigItemsRequest) GetEdgeConfigID() string {
	if o == nil {
		return ""
	}
	return o.EdgeConfigID
}

func (o *PatchEdgeConfigItemsRequest) GetDryRun() *string {
	if o == nil {
		return nil
	}
	return o.DryRun
}

func (o *PatchEdgeConfigItemsRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *PatchEdgeConfigItemsRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *PatchEdgeConfigItemsRequest) GetRequestBody() *PatchEdgeConfigItemsRequestBody {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

type PatchEdgeConfigItemsResponseBody struct {
	Status string `json:"status"`
}

func (o *PatchEdgeConfigItemsResponseBody) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

type PatchEdgeConfigItemsResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *PatchEdgeConfigItemsResponseBody
}

func (o *PatchEdgeConfigItemsResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *PatchEdgeConfigItemsResponse) GetObject() *PatchEdgeConfigItemsResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
