// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type RequestBodyScope string

const (
	RequestBodyScopeAliasProtectionOverride RequestBodyScope = "alias-protection-override"
)

func (e RequestBodyScope) ToPointer() *RequestBodyScope {
	return &e
}
func (e *RequestBodyScope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alias-protection-override":
		*e = RequestBodyScope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RequestBodyScope: %v", v)
	}
}

type PatchURLProtectionBypassRequestBodyAction string

const (
	PatchURLProtectionBypassRequestBodyActionCreate PatchURLProtectionBypassRequestBodyAction = "create"
	PatchURLProtectionBypassRequestBodyActionRevoke PatchURLProtectionBypassRequestBodyAction = "revoke"
)

func (e PatchURLProtectionBypassRequestBodyAction) ToPointer() *PatchURLProtectionBypassRequestBodyAction {
	return &e
}
func (e *PatchURLProtectionBypassRequestBodyAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "create":
		fallthrough
	case "revoke":
		*e = PatchURLProtectionBypassRequestBodyAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchURLProtectionBypassRequestBodyAction: %v", v)
	}
}

type Override struct {
	Scope  RequestBodyScope                          `json:"scope"`
	Action PatchURLProtectionBypassRequestBodyAction `json:"action"`
}

func (o *Override) GetScope() RequestBodyScope {
	if o == nil {
		return RequestBodyScope("")
	}
	return o.Scope
}

func (o *Override) GetAction() PatchURLProtectionBypassRequestBodyAction {
	if o == nil {
		return PatchURLProtectionBypassRequestBodyAction("")
	}
	return o.Action
}

type PatchURLProtectionBypassRequestBody3 struct {
	Override Override `json:"override"`
}

func (o *PatchURLProtectionBypassRequestBody3) GetOverride() Override {
	if o == nil {
		return Override{}
	}
	return o.Override
}

// ScopeAccess - Invitation status for the user scoped bypass.
type ScopeAccess string

const (
	ScopeAccessDenied  ScopeAccess = "denied"
	ScopeAccessGranted ScopeAccess = "granted"
)

func (e ScopeAccess) ToPointer() *ScopeAccess {
	return &e
}
func (e *ScopeAccess) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "denied":
		fallthrough
	case "granted":
		*e = ScopeAccess(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ScopeAccess: %v", v)
	}
}

type Scope2 struct {
	// Specified user id for the scoped bypass.
	UserID *string `json:"userId,omitempty"`
	// Specified email for the scoped bypass.
	Email string `json:"email"`
	// Invitation status for the user scoped bypass.
	Access ScopeAccess `json:"access"`
}

func (o *Scope2) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *Scope2) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *Scope2) GetAccess() ScopeAccess {
	if o == nil {
		return ScopeAccess("")
	}
	return o.Access
}

// Access - Invitation status for the user scoped bypass.
type Access string

const (
	AccessDenied  Access = "denied"
	AccessGranted Access = "granted"
)

func (e Access) ToPointer() *Access {
	return &e
}
func (e *Access) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "denied":
		fallthrough
	case "granted":
		*e = Access(v)
		return nil
	default:
		return fmt.Errorf("invalid value for Access: %v", v)
	}
}

type Scope1 struct {
	// Specified user id for the scoped bypass.
	UserID string `json:"userId"`
	// Specified email for the scoped bypass.
	Email *string `json:"email,omitempty"`
	// Invitation status for the user scoped bypass.
	Access Access `json:"access"`
}

func (o *Scope1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *Scope1) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *Scope1) GetAccess() Access {
	if o == nil {
		return Access("")
	}
	return o.Access
}

type ScopeType string

const (
	ScopeTypeScope1 ScopeType = "scope_1"
	ScopeTypeScope2 ScopeType = "scope_2"
)

// Scope - Instructions for creating a user scoped protection bypass
type Scope struct {
	Scope1 *Scope1
	Scope2 *Scope2

	Type ScopeType
}

func CreateScopeScope1(scope1 Scope1) Scope {
	typ := ScopeTypeScope1

	return Scope{
		Scope1: &scope1,
		Type:   typ,
	}
}

func CreateScopeScope2(scope2 Scope2) Scope {
	typ := ScopeTypeScope2

	return Scope{
		Scope2: &scope2,
		Type:   typ,
	}
}

func (u *Scope) UnmarshalJSON(data []byte) error {

	var scope1 Scope1 = Scope1{}
	if err := utils.UnmarshalJSON(data, &scope1, "", true, true); err == nil {
		u.Scope1 = &scope1
		u.Type = ScopeTypeScope1
		return nil
	}

	var scope2 Scope2 = Scope2{}
	if err := utils.UnmarshalJSON(data, &scope2, "", true, true); err == nil {
		u.Scope2 = &scope2
		u.Type = ScopeTypeScope2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Scope", string(data))
}

func (u Scope) MarshalJSON() ([]byte, error) {
	if u.Scope1 != nil {
		return utils.MarshalJSON(u.Scope1, "", true)
	}

	if u.Scope2 != nil {
		return utils.MarshalJSON(u.Scope2, "", true)
	}

	return nil, errors.New("could not marshal union type Scope: all fields are null")
}

type PatchURLProtectionBypassRequestBody2 struct {
	// Instructions for creating a user scoped protection bypass
	Scope Scope `json:"scope"`
}

func (o *PatchURLProtectionBypassRequestBody2) GetScope() Scope {
	if o == nil {
		return Scope{}
	}
	return o.Scope
}

// RequestBodyRevoke - Optional instructions for revoking and regenerating a shareable link
type RequestBodyRevoke struct {
	// Sharebale link to revoked
	Secret string `json:"secret"`
	// Whether or not a new shareable link should be created after the provided secret is revoked
	Regenerate bool `json:"regenerate"`
}

func (o *RequestBodyRevoke) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

func (o *RequestBodyRevoke) GetRegenerate() bool {
	if o == nil {
		return false
	}
	return o.Regenerate
}

type PatchURLProtectionBypassRequestBody1 struct {
	// Optional instructions for revoking and regenerating a shareable link
	Revoke *RequestBodyRevoke `json:"revoke,omitempty"`
}

func (o *PatchURLProtectionBypassRequestBody1) GetRevoke() *RequestBodyRevoke {
	if o == nil {
		return nil
	}
	return o.Revoke
}

type PatchURLProtectionBypassRequestBodyType string

const (
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_requestBody_1"
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_requestBody_2"
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_requestBody_3"
)

type PatchURLProtectionBypassRequestBody struct {
	PatchURLProtectionBypassRequestBody1 *PatchURLProtectionBypassRequestBody1
	PatchURLProtectionBypassRequestBody2 *PatchURLProtectionBypassRequestBody2
	PatchURLProtectionBypassRequestBody3 *PatchURLProtectionBypassRequestBody3

	Type PatchURLProtectionBypassRequestBodyType
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody1(patchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBody1) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody1: &patchURLProtectionBypassRequestBody1,
		Type:                                 typ,
	}
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody2(patchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBody2) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody2: &patchURLProtectionBypassRequestBody2,
		Type:                                 typ,
	}
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody3(patchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBody3) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody3: &patchURLProtectionBypassRequestBody3,
		Type:                                 typ,
	}
}

func (u *PatchURLProtectionBypassRequestBody) UnmarshalJSON(data []byte) error {

	var patchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBody1 = PatchURLProtectionBypassRequestBody1{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody1, "", true, true); err == nil {
		u.PatchURLProtectionBypassRequestBody1 = &patchURLProtectionBypassRequestBody1
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1
		return nil
	}

	var patchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBody2 = PatchURLProtectionBypassRequestBody2{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody2, "", true, true); err == nil {
		u.PatchURLProtectionBypassRequestBody2 = &patchURLProtectionBypassRequestBody2
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2
		return nil
	}

	var patchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBody3 = PatchURLProtectionBypassRequestBody3{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody3, "", true, true); err == nil {
		u.PatchURLProtectionBypassRequestBody3 = &patchURLProtectionBypassRequestBody3
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatchURLProtectionBypassRequestBody", string(data))
}

func (u PatchURLProtectionBypassRequestBody) MarshalJSON() ([]byte, error) {
	if u.PatchURLProtectionBypassRequestBody1 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody1, "", true)
	}

	if u.PatchURLProtectionBypassRequestBody2 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody2, "", true)
	}

	if u.PatchURLProtectionBypassRequestBody3 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody3, "", true)
	}

	return nil, errors.New("could not marshal union type PatchURLProtectionBypassRequestBody: all fields are null")
}

type PatchURLProtectionBypassRequest struct {
	// The alias or deployment ID
	ID string `pathParam:"style=simple,explode=false,name=id"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string                              `queryParam:"style=form,explode=true,name=slug"`
	RequestBody *PatchURLProtectionBypassRequestBody `request:"mediaType=application/json"`
}

func (o *PatchURLProtectionBypassRequest) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *PatchURLProtectionBypassRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *PatchURLProtectionBypassRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *PatchURLProtectionBypassRequest) GetRequestBody() *PatchURLProtectionBypassRequestBody {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

type PatchURLProtectionBypassResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   map[string]any
}

func (o *PatchURLProtectionBypassResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *PatchURLProtectionBypassResponse) GetObject() map[string]any {
	if o == nil {
		return nil
	}
	return o.Object
}
