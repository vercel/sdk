// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type OverrideScope string

const (
	OverrideScopeAliasProtectionOverride OverrideScope = "alias-protection-override"
)

func (e OverrideScope) ToPointer() *OverrideScope {
	return &e
}
func (e *OverrideScope) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "alias-protection-override":
		*e = OverrideScope(v)
		return nil
	default:
		return fmt.Errorf("invalid value for OverrideScope: %v", v)
	}
}

type PatchURLProtectionBypassAction string

const (
	PatchURLProtectionBypassActionCreate PatchURLProtectionBypassAction = "create"
	PatchURLProtectionBypassActionRevoke PatchURLProtectionBypassAction = "revoke"
)

func (e PatchURLProtectionBypassAction) ToPointer() *PatchURLProtectionBypassAction {
	return &e
}
func (e *PatchURLProtectionBypassAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "create":
		fallthrough
	case "revoke":
		*e = PatchURLProtectionBypassAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchURLProtectionBypassAction: %v", v)
	}
}

type Override struct {
	Scope  OverrideScope                  `json:"scope"`
	Action PatchURLProtectionBypassAction `json:"action"`
}

func (o Override) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *Override) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"scope", "action"}); err != nil {
		return err
	}
	return nil
}

func (o *Override) GetScope() OverrideScope {
	if o == nil {
		return OverrideScope("")
	}
	return o.Scope
}

func (o *Override) GetAction() PatchURLProtectionBypassAction {
	if o == nil {
		return PatchURLProtectionBypassAction("")
	}
	return o.Action
}

type PatchURLProtectionBypassRequestBody3 struct {
	Override Override `json:"override"`
}

func (p PatchURLProtectionBypassRequestBody3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassRequestBody3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"override"}); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassRequestBody3) GetOverride() Override {
	if o == nil {
		return Override{}
	}
	return o.Override
}

// PatchURLProtectionBypassAccess2 - Invitation status for the user scoped bypass.
type PatchURLProtectionBypassAccess2 string

const (
	PatchURLProtectionBypassAccess2Denied  PatchURLProtectionBypassAccess2 = "denied"
	PatchURLProtectionBypassAccess2Granted PatchURLProtectionBypassAccess2 = "granted"
)

func (e PatchURLProtectionBypassAccess2) ToPointer() *PatchURLProtectionBypassAccess2 {
	return &e
}
func (e *PatchURLProtectionBypassAccess2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "denied":
		fallthrough
	case "granted":
		*e = PatchURLProtectionBypassAccess2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchURLProtectionBypassAccess2: %v", v)
	}
}

type PatchURLProtectionBypassScope2 struct {
	// Specified user id for the scoped bypass.
	UserID *string `json:"userId,omitempty"`
	// Specified email for the scoped bypass.
	Email string `json:"email"`
	// Invitation status for the user scoped bypass.
	Access PatchURLProtectionBypassAccess2 `json:"access"`
}

func (p PatchURLProtectionBypassScope2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassScope2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"email", "access"}); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassScope2) GetUserID() *string {
	if o == nil {
		return nil
	}
	return o.UserID
}

func (o *PatchURLProtectionBypassScope2) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *PatchURLProtectionBypassScope2) GetAccess() PatchURLProtectionBypassAccess2 {
	if o == nil {
		return PatchURLProtectionBypassAccess2("")
	}
	return o.Access
}

// PatchURLProtectionBypassAccess1 - Invitation status for the user scoped bypass.
type PatchURLProtectionBypassAccess1 string

const (
	PatchURLProtectionBypassAccess1Denied  PatchURLProtectionBypassAccess1 = "denied"
	PatchURLProtectionBypassAccess1Granted PatchURLProtectionBypassAccess1 = "granted"
)

func (e PatchURLProtectionBypassAccess1) ToPointer() *PatchURLProtectionBypassAccess1 {
	return &e
}
func (e *PatchURLProtectionBypassAccess1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "denied":
		fallthrough
	case "granted":
		*e = PatchURLProtectionBypassAccess1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for PatchURLProtectionBypassAccess1: %v", v)
	}
}

type PatchURLProtectionBypassScope1 struct {
	// Specified user id for the scoped bypass.
	UserID string `json:"userId"`
	// Specified email for the scoped bypass.
	Email *string `json:"email,omitempty"`
	// Invitation status for the user scoped bypass.
	Access PatchURLProtectionBypassAccess1 `json:"access"`
}

func (p PatchURLProtectionBypassScope1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassScope1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"userId", "access"}); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassScope1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *PatchURLProtectionBypassScope1) GetEmail() *string {
	if o == nil {
		return nil
	}
	return o.Email
}

func (o *PatchURLProtectionBypassScope1) GetAccess() PatchURLProtectionBypassAccess1 {
	if o == nil {
		return PatchURLProtectionBypassAccess1("")
	}
	return o.Access
}

type ScopeType string

const (
	ScopeTypePatchURLProtectionBypassScope1 ScopeType = "patchUrlProtectionBypass_scope_1"
	ScopeTypePatchURLProtectionBypassScope2 ScopeType = "patchUrlProtectionBypass_scope_2"
)

// Scope - Instructions for creating a user scoped protection bypass
type Scope struct {
	PatchURLProtectionBypassScope1 *PatchURLProtectionBypassScope1 `queryParam:"inline"`
	PatchURLProtectionBypassScope2 *PatchURLProtectionBypassScope2 `queryParam:"inline"`

	Type ScopeType
}

func CreateScopePatchURLProtectionBypassScope1(patchURLProtectionBypassScope1 PatchURLProtectionBypassScope1) Scope {
	typ := ScopeTypePatchURLProtectionBypassScope1

	return Scope{
		PatchURLProtectionBypassScope1: &patchURLProtectionBypassScope1,
		Type:                           typ,
	}
}

func CreateScopePatchURLProtectionBypassScope2(patchURLProtectionBypassScope2 PatchURLProtectionBypassScope2) Scope {
	typ := ScopeTypePatchURLProtectionBypassScope2

	return Scope{
		PatchURLProtectionBypassScope2: &patchURLProtectionBypassScope2,
		Type:                           typ,
	}
}

func (u *Scope) UnmarshalJSON(data []byte) error {

	var patchURLProtectionBypassScope1 PatchURLProtectionBypassScope1 = PatchURLProtectionBypassScope1{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassScope1, "", true, nil); err == nil {
		u.PatchURLProtectionBypassScope1 = &patchURLProtectionBypassScope1
		u.Type = ScopeTypePatchURLProtectionBypassScope1
		return nil
	}

	var patchURLProtectionBypassScope2 PatchURLProtectionBypassScope2 = PatchURLProtectionBypassScope2{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassScope2, "", true, nil); err == nil {
		u.PatchURLProtectionBypassScope2 = &patchURLProtectionBypassScope2
		u.Type = ScopeTypePatchURLProtectionBypassScope2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Scope", string(data))
}

func (u Scope) MarshalJSON() ([]byte, error) {
	if u.PatchURLProtectionBypassScope1 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassScope1, "", true)
	}

	if u.PatchURLProtectionBypassScope2 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassScope2, "", true)
	}

	return nil, errors.New("could not marshal union type Scope: all fields are null")
}

type PatchURLProtectionBypassRequestBody2 struct {
	// Instructions for creating a user scoped protection bypass
	Scope Scope `json:"scope"`
}

func (p PatchURLProtectionBypassRequestBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassRequestBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"scope"}); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassRequestBody2) GetScope() Scope {
	if o == nil {
		return Scope{}
	}
	return o.Scope
}

// PatchURLProtectionBypassRevoke - Optional instructions for revoking and regenerating a shareable link
type PatchURLProtectionBypassRevoke struct {
	// Sharebale link to revoked
	Secret string `json:"secret"`
	// Whether or not a new shareable link should be created after the provided secret is revoked
	Regenerate bool `json:"regenerate"`
}

func (p PatchURLProtectionBypassRevoke) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassRevoke) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"secret", "regenerate"}); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassRevoke) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

func (o *PatchURLProtectionBypassRevoke) GetRegenerate() bool {
	if o == nil {
		return false
	}
	return o.Regenerate
}

type PatchURLProtectionBypassRequestBody1 struct {
	// Optional time the shareable link is valid for in seconds. If not provided, the shareable link will never expire.
	TTL *float64 `json:"ttl,omitempty"`
	// Optional instructions for revoking and regenerating a shareable link
	Revoke *PatchURLProtectionBypassRevoke `json:"revoke,omitempty"`
}

func (p PatchURLProtectionBypassRequestBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *PatchURLProtectionBypassRequestBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *PatchURLProtectionBypassRequestBody1) GetTTL() *float64 {
	if o == nil {
		return nil
	}
	return o.TTL
}

func (o *PatchURLProtectionBypassRequestBody1) GetRevoke() *PatchURLProtectionBypassRevoke {
	if o == nil {
		return nil
	}
	return o.Revoke
}

type PatchURLProtectionBypassRequestBodyType string

const (
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_RequestBody_1"
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_RequestBody_2"
	PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBodyType = "patchUrlProtectionBypass_RequestBody_3"
)

type PatchURLProtectionBypassRequestBody struct {
	PatchURLProtectionBypassRequestBody1 *PatchURLProtectionBypassRequestBody1 `queryParam:"inline"`
	PatchURLProtectionBypassRequestBody2 *PatchURLProtectionBypassRequestBody2 `queryParam:"inline"`
	PatchURLProtectionBypassRequestBody3 *PatchURLProtectionBypassRequestBody3 `queryParam:"inline"`

	Type PatchURLProtectionBypassRequestBodyType
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody1(patchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBody1) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody1: &patchURLProtectionBypassRequestBody1,
		Type:                                 typ,
	}
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody2(patchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBody2) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody2: &patchURLProtectionBypassRequestBody2,
		Type:                                 typ,
	}
}

func CreatePatchURLProtectionBypassRequestBodyPatchURLProtectionBypassRequestBody3(patchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBody3) PatchURLProtectionBypassRequestBody {
	typ := PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3

	return PatchURLProtectionBypassRequestBody{
		PatchURLProtectionBypassRequestBody3: &patchURLProtectionBypassRequestBody3,
		Type:                                 typ,
	}
}

func (u *PatchURLProtectionBypassRequestBody) UnmarshalJSON(data []byte) error {

	var patchURLProtectionBypassRequestBody2 PatchURLProtectionBypassRequestBody2 = PatchURLProtectionBypassRequestBody2{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody2, "", true, nil); err == nil {
		u.PatchURLProtectionBypassRequestBody2 = &patchURLProtectionBypassRequestBody2
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody2
		return nil
	}

	var patchURLProtectionBypassRequestBody3 PatchURLProtectionBypassRequestBody3 = PatchURLProtectionBypassRequestBody3{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody3, "", true, nil); err == nil {
		u.PatchURLProtectionBypassRequestBody3 = &patchURLProtectionBypassRequestBody3
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody3
		return nil
	}

	var patchURLProtectionBypassRequestBody1 PatchURLProtectionBypassRequestBody1 = PatchURLProtectionBypassRequestBody1{}
	if err := utils.UnmarshalJSON(data, &patchURLProtectionBypassRequestBody1, "", true, nil); err == nil {
		u.PatchURLProtectionBypassRequestBody1 = &patchURLProtectionBypassRequestBody1
		u.Type = PatchURLProtectionBypassRequestBodyTypePatchURLProtectionBypassRequestBody1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PatchURLProtectionBypassRequestBody", string(data))
}

func (u PatchURLProtectionBypassRequestBody) MarshalJSON() ([]byte, error) {
	if u.PatchURLProtectionBypassRequestBody1 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody1, "", true)
	}

	if u.PatchURLProtectionBypassRequestBody2 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody2, "", true)
	}

	if u.PatchURLProtectionBypassRequestBody3 != nil {
		return utils.MarshalJSON(u.PatchURLProtectionBypassRequestBody3, "", true)
	}

	return nil, errors.New("could not marshal union type PatchURLProtectionBypassRequestBody: all fields are null")
}

type PatchURLProtectionBypassRequest struct {
	// The alias or deployment ID
	ID string `pathParam:"style=simple,explode=false,name=id"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string                              `queryParam:"style=form,explode=true,name=slug"`
	Body *PatchURLProtectionBypassRequestBody `request:"mediaType=application/json"`
}

func (o *PatchURLProtectionBypassRequest) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *PatchURLProtectionBypassRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *PatchURLProtectionBypassRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *PatchURLProtectionBypassRequest) GetBody() *PatchURLProtectionBypassRequestBody {
	if o == nil {
		return nil
	}
	return o.Body
}

type PatchURLProtectionBypassResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   map[string]any
}

func (o *PatchURLProtectionBypassResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *PatchURLProtectionBypassResponse) GetObject() map[string]any {
	if o == nil {
		return nil
	}
	return o.Object
}
