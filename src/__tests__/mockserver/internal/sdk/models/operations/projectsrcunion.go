// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type BlockHistoryProjectValue8 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue8) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue8) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue8) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectHost4 struct {
	Type  BlockHistoryProjectTypeHost4 `json:"type"`
	Value BlockHistoryProjectValue8    `json:"value"`
}

func (b BlockHistoryHasProjectHost4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectHost4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectHost4) GetType() BlockHistoryProjectTypeHost4 {
	if o == nil {
		return BlockHistoryProjectTypeHost4("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectHost4) GetValue() BlockHistoryProjectValue8 {
	if o == nil {
		return BlockHistoryProjectValue8{}
	}
	return o.Value
}

type BlockHistoryProjectTypeHeader4 string

const (
	BlockHistoryProjectTypeHeader4Header BlockHistoryProjectTypeHeader4 = "header"
)

func (e BlockHistoryProjectTypeHeader4) ToPointer() *BlockHistoryProjectTypeHeader4 {
	return &e
}
func (e *BlockHistoryProjectTypeHeader4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = BlockHistoryProjectTypeHeader4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHeader4: %v", v)
	}
}

type BlockHistoryProjectKey4 string

const (
	BlockHistoryProjectKey4XVercelIPCountry BlockHistoryProjectKey4 = "x-vercel-ip-country"
)

func (e BlockHistoryProjectKey4) ToPointer() *BlockHistoryProjectKey4 {
	return &e
}
func (e *BlockHistoryProjectKey4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = BlockHistoryProjectKey4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectKey4: %v", v)
	}
}

type BlockHistoryProjectValue7 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue7) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue7) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue7) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectXVercelIPCountry4 struct {
	Type  BlockHistoryProjectTypeHeader4 `json:"type"`
	Key   BlockHistoryProjectKey4        `json:"key"`
	Value BlockHistoryProjectValue7      `json:"value"`
}

func (b BlockHistoryHasProjectXVercelIPCountry4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectXVercelIPCountry4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectXVercelIPCountry4) GetType() BlockHistoryProjectTypeHeader4 {
	if o == nil {
		return BlockHistoryProjectTypeHeader4("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectXVercelIPCountry4) GetKey() BlockHistoryProjectKey4 {
	if o == nil {
		return BlockHistoryProjectKey4("")
	}
	return o.Key
}

func (o *BlockHistoryHasProjectXVercelIPCountry4) GetValue() BlockHistoryProjectValue7 {
	if o == nil {
		return BlockHistoryProjectValue7{}
	}
	return o.Value
}

type BlockHistoryProjectHasUnion4Type string

const (
	BlockHistoryProjectHasUnion4TypeHeader BlockHistoryProjectHasUnion4Type = "header"
	BlockHistoryProjectHasUnion4TypeHost   BlockHistoryProjectHasUnion4Type = "host"
)

type BlockHistoryProjectHasUnion4 struct {
	BlockHistoryHasProjectXVercelIPCountry4 *BlockHistoryHasProjectXVercelIPCountry4 `queryParam:"inline"`
	BlockHistoryHasProjectHost4             *BlockHistoryHasProjectHost4             `queryParam:"inline"`

	Type BlockHistoryProjectHasUnion4Type
}

func CreateBlockHistoryProjectHasUnion4Header(header BlockHistoryHasProjectXVercelIPCountry4) BlockHistoryProjectHasUnion4 {
	typ := BlockHistoryProjectHasUnion4TypeHeader

	typStr := BlockHistoryProjectTypeHeader4(typ)
	header.Type = typStr

	return BlockHistoryProjectHasUnion4{
		BlockHistoryHasProjectXVercelIPCountry4: &header,
		Type:                                    typ,
	}
}

func CreateBlockHistoryProjectHasUnion4Host(host BlockHistoryHasProjectHost4) BlockHistoryProjectHasUnion4 {
	typ := BlockHistoryProjectHasUnion4TypeHost

	typStr := BlockHistoryProjectTypeHost4(typ)
	host.Type = typStr

	return BlockHistoryProjectHasUnion4{
		BlockHistoryHasProjectHost4: &host,
		Type:                        typ,
	}
}

func (u *BlockHistoryProjectHasUnion4) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		blockHistoryHasProjectXVercelIPCountry4 := new(BlockHistoryHasProjectXVercelIPCountry4)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectXVercelIPCountry4, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type BlockHistoryHasProjectXVercelIPCountry4 within BlockHistoryProjectHasUnion4: %w", string(data), err)
		}

		u.BlockHistoryHasProjectXVercelIPCountry4 = blockHistoryHasProjectXVercelIPCountry4
		u.Type = BlockHistoryProjectHasUnion4TypeHeader
		return nil
	case "host":
		blockHistoryHasProjectHost4 := new(BlockHistoryHasProjectHost4)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectHost4, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type BlockHistoryHasProjectHost4 within BlockHistoryProjectHasUnion4: %w", string(data), err)
		}

		u.BlockHistoryHasProjectHost4 = blockHistoryHasProjectHost4
		u.Type = BlockHistoryProjectHasUnion4TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BlockHistoryProjectHasUnion4", string(data))
}

func (u BlockHistoryProjectHasUnion4) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryHasProjectXVercelIPCountry4 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectXVercelIPCountry4, "", true)
	}

	if u.BlockHistoryHasProjectHost4 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectHost4, "", true)
	}

	return nil, errors.New("could not marshal union type BlockHistoryProjectHasUnion4: all fields are null")
}

type RouteProjectAction4 string

const (
	RouteProjectAction4BlockLegalCwc RouteProjectAction4 = "block_legal_cwc"
)

func (e RouteProjectAction4) ToPointer() *RouteProjectAction4 {
	return &e
}
func (e *RouteProjectAction4) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = RouteProjectAction4(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteProjectAction4: %v", v)
	}
}

type BlockHistoryProjectMitigate4 struct {
	Action RouteProjectAction4 `json:"action"`
}

func (b BlockHistoryProjectMitigate4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectMitigate4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectMitigate4) GetAction() RouteProjectAction4 {
	if o == nil {
		return RouteProjectAction4("")
	}
	return o.Action
}

type RouteProject8 struct {
	Has      []BlockHistoryProjectHasUnion4 `json:"has"`
	Mitigate BlockHistoryProjectMitigate4   `json:"mitigate"`
	Src      *string                        `json:"src,omitempty"`
}

func (r RouteProject8) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject8) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject8) GetHas() []BlockHistoryProjectHasUnion4 {
	if o == nil {
		return []BlockHistoryProjectHasUnion4{}
	}
	return o.Has
}

func (o *RouteProject8) GetMitigate() BlockHistoryProjectMitigate4 {
	if o == nil {
		return BlockHistoryProjectMitigate4{}
	}
	return o.Mitigate
}

func (o *RouteProject8) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type RouteProject7 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (r RouteProject7) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject7) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject7) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *RouteProject7) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectRouteUnion4Type string

const (
	ProjectRouteUnion4TypeRouteProject7 ProjectRouteUnion4Type = "route_project_7"
	ProjectRouteUnion4TypeRouteProject8 ProjectRouteUnion4Type = "route_project_8"
)

type ProjectRouteUnion4 struct {
	RouteProject7 *RouteProject7 `queryParam:"inline"`
	RouteProject8 *RouteProject8 `queryParam:"inline"`

	Type ProjectRouteUnion4Type
}

func CreateProjectRouteUnion4RouteProject7(routeProject7 RouteProject7) ProjectRouteUnion4 {
	typ := ProjectRouteUnion4TypeRouteProject7

	return ProjectRouteUnion4{
		RouteProject7: &routeProject7,
		Type:          typ,
	}
}

func CreateProjectRouteUnion4RouteProject8(routeProject8 RouteProject8) ProjectRouteUnion4 {
	typ := ProjectRouteUnion4TypeRouteProject8

	return ProjectRouteUnion4{
		RouteProject8: &routeProject8,
		Type:          typ,
	}
}

func (u *ProjectRouteUnion4) UnmarshalJSON(data []byte) error {

	var routeProject7 RouteProject7 = RouteProject7{}
	if err := utils.UnmarshalJSON(data, &routeProject7, "", true, nil); err == nil {
		u.RouteProject7 = &routeProject7
		u.Type = ProjectRouteUnion4TypeRouteProject7
		return nil
	}

	var routeProject8 RouteProject8 = RouteProject8{}
	if err := utils.UnmarshalJSON(data, &routeProject8, "", true, nil); err == nil {
		u.RouteProject8 = &routeProject8
		u.Type = ProjectRouteUnion4TypeRouteProject8
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectRouteUnion4", string(data))
}

func (u ProjectRouteUnion4) MarshalJSON() ([]byte, error) {
	if u.RouteProject7 != nil {
		return utils.MarshalJSON(u.RouteProject7, "", true)
	}

	if u.RouteProject8 != nil {
		return utils.MarshalJSON(u.RouteProject8, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectRouteUnion4: all fields are null")
}

type BlockHistoryProjectRouteUnblocked2 struct {
	Action              ProjectActionRouteUnblocked2 `json:"action"`
	Route               ProjectRouteUnion4           `json:"route"`
	StatusCode          *float64                     `json:"statusCode,omitempty"`
	CreatedAt           float64                      `json:"createdAt"`
	CaseID              *string                      `json:"caseId,omitempty"`
	Actor               *string                      `json:"actor,omitempty"`
	Comment             *string                      `json:"comment,omitempty"`
	IneligibleForAppeal *bool                        `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                        `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectRouteUnblocked2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectRouteUnblocked2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "route", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectRouteUnblocked2) GetAction() ProjectActionRouteUnblocked2 {
	if o == nil {
		return ProjectActionRouteUnblocked2("")
	}
	return o.Action
}

func (o *BlockHistoryProjectRouteUnblocked2) GetRoute() ProjectRouteUnion4 {
	if o == nil {
		return ProjectRouteUnion4{}
	}
	return o.Route
}

func (o *BlockHistoryProjectRouteUnblocked2) GetStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.StatusCode
}

func (o *BlockHistoryProjectRouteUnblocked2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectRouteUnblocked2) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectRouteUnblocked2) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectRouteUnblocked2) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectRouteUnblocked2) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectRouteUnblocked2) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectActionRouteBlocked2 string

const (
	ProjectActionRouteBlocked2RouteBlocked ProjectActionRouteBlocked2 = "route-blocked"
)

func (e ProjectActionRouteBlocked2) ToPointer() *ProjectActionRouteBlocked2 {
	return &e
}
func (e *ProjectActionRouteBlocked2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "route-blocked":
		*e = ProjectActionRouteBlocked2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionRouteBlocked2: %v", v)
	}
}

type BlockHistoryProjectTypeHost3 string

const (
	BlockHistoryProjectTypeHost3Host BlockHistoryProjectTypeHost3 = "host"
)

func (e BlockHistoryProjectTypeHost3) ToPointer() *BlockHistoryProjectTypeHost3 {
	return &e
}
func (e *BlockHistoryProjectTypeHost3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = BlockHistoryProjectTypeHost3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHost3: %v", v)
	}
}

type BlockHistoryProjectValue6 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue6) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue6) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue6) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectHost3 struct {
	Type  BlockHistoryProjectTypeHost3 `json:"type"`
	Value BlockHistoryProjectValue6    `json:"value"`
}

func (b BlockHistoryHasProjectHost3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectHost3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectHost3) GetType() BlockHistoryProjectTypeHost3 {
	if o == nil {
		return BlockHistoryProjectTypeHost3("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectHost3) GetValue() BlockHistoryProjectValue6 {
	if o == nil {
		return BlockHistoryProjectValue6{}
	}
	return o.Value
}

type BlockHistoryProjectTypeHeader3 string

const (
	BlockHistoryProjectTypeHeader3Header BlockHistoryProjectTypeHeader3 = "header"
)

func (e BlockHistoryProjectTypeHeader3) ToPointer() *BlockHistoryProjectTypeHeader3 {
	return &e
}
func (e *BlockHistoryProjectTypeHeader3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = BlockHistoryProjectTypeHeader3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectTypeHeader3: %v", v)
	}
}

type BlockHistoryProjectKey3 string

const (
	BlockHistoryProjectKey3XVercelIPCountry BlockHistoryProjectKey3 = "x-vercel-ip-country"
)

func (e BlockHistoryProjectKey3) ToPointer() *BlockHistoryProjectKey3 {
	return &e
}
func (e *BlockHistoryProjectKey3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = BlockHistoryProjectKey3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectKey3: %v", v)
	}
}

type BlockHistoryProjectValue5 struct {
	Eq string `json:"eq"`
}

func (b BlockHistoryProjectValue5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectValue5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectValue5) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type BlockHistoryHasProjectXVercelIPCountry3 struct {
	Type  BlockHistoryProjectTypeHeader3 `json:"type"`
	Key   BlockHistoryProjectKey3        `json:"key"`
	Value BlockHistoryProjectValue5      `json:"value"`
}

func (b BlockHistoryHasProjectXVercelIPCountry3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryHasProjectXVercelIPCountry3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryHasProjectXVercelIPCountry3) GetType() BlockHistoryProjectTypeHeader3 {
	if o == nil {
		return BlockHistoryProjectTypeHeader3("")
	}
	return o.Type
}

func (o *BlockHistoryHasProjectXVercelIPCountry3) GetKey() BlockHistoryProjectKey3 {
	if o == nil {
		return BlockHistoryProjectKey3("")
	}
	return o.Key
}

func (o *BlockHistoryHasProjectXVercelIPCountry3) GetValue() BlockHistoryProjectValue5 {
	if o == nil {
		return BlockHistoryProjectValue5{}
	}
	return o.Value
}

type BlockHistoryProjectHasUnion3Type string

const (
	BlockHistoryProjectHasUnion3TypeHeader BlockHistoryProjectHasUnion3Type = "header"
	BlockHistoryProjectHasUnion3TypeHost   BlockHistoryProjectHasUnion3Type = "host"
)

type BlockHistoryProjectHasUnion3 struct {
	BlockHistoryHasProjectXVercelIPCountry3 *BlockHistoryHasProjectXVercelIPCountry3 `queryParam:"inline"`
	BlockHistoryHasProjectHost3             *BlockHistoryHasProjectHost3             `queryParam:"inline"`

	Type BlockHistoryProjectHasUnion3Type
}

func CreateBlockHistoryProjectHasUnion3Header(header BlockHistoryHasProjectXVercelIPCountry3) BlockHistoryProjectHasUnion3 {
	typ := BlockHistoryProjectHasUnion3TypeHeader

	typStr := BlockHistoryProjectTypeHeader3(typ)
	header.Type = typStr

	return BlockHistoryProjectHasUnion3{
		BlockHistoryHasProjectXVercelIPCountry3: &header,
		Type:                                    typ,
	}
}

func CreateBlockHistoryProjectHasUnion3Host(host BlockHistoryHasProjectHost3) BlockHistoryProjectHasUnion3 {
	typ := BlockHistoryProjectHasUnion3TypeHost

	typStr := BlockHistoryProjectTypeHost3(typ)
	host.Type = typStr

	return BlockHistoryProjectHasUnion3{
		BlockHistoryHasProjectHost3: &host,
		Type:                        typ,
	}
}

func (u *BlockHistoryProjectHasUnion3) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		blockHistoryHasProjectXVercelIPCountry3 := new(BlockHistoryHasProjectXVercelIPCountry3)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectXVercelIPCountry3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type BlockHistoryHasProjectXVercelIPCountry3 within BlockHistoryProjectHasUnion3: %w", string(data), err)
		}

		u.BlockHistoryHasProjectXVercelIPCountry3 = blockHistoryHasProjectXVercelIPCountry3
		u.Type = BlockHistoryProjectHasUnion3TypeHeader
		return nil
	case "host":
		blockHistoryHasProjectHost3 := new(BlockHistoryHasProjectHost3)
		if err := utils.UnmarshalJSON(data, &blockHistoryHasProjectHost3, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type BlockHistoryHasProjectHost3 within BlockHistoryProjectHasUnion3: %w", string(data), err)
		}

		u.BlockHistoryHasProjectHost3 = blockHistoryHasProjectHost3
		u.Type = BlockHistoryProjectHasUnion3TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BlockHistoryProjectHasUnion3", string(data))
}

func (u BlockHistoryProjectHasUnion3) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryHasProjectXVercelIPCountry3 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectXVercelIPCountry3, "", true)
	}

	if u.BlockHistoryHasProjectHost3 != nil {
		return utils.MarshalJSON(u.BlockHistoryHasProjectHost3, "", true)
	}

	return nil, errors.New("could not marshal union type BlockHistoryProjectHasUnion3: all fields are null")
}

type RouteProjectAction3 string

const (
	RouteProjectAction3BlockLegalCwc RouteProjectAction3 = "block_legal_cwc"
)

func (e RouteProjectAction3) ToPointer() *RouteProjectAction3 {
	return &e
}
func (e *RouteProjectAction3) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = RouteProjectAction3(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RouteProjectAction3: %v", v)
	}
}

type BlockHistoryProjectMitigate3 struct {
	Action RouteProjectAction3 `json:"action"`
}

func (b BlockHistoryProjectMitigate3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectMitigate3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectMitigate3) GetAction() RouteProjectAction3 {
	if o == nil {
		return RouteProjectAction3("")
	}
	return o.Action
}

type RouteProject6 struct {
	Has      []BlockHistoryProjectHasUnion3 `json:"has"`
	Mitigate BlockHistoryProjectMitigate3   `json:"mitigate"`
	Src      *string                        `json:"src,omitempty"`
}

func (r RouteProject6) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject6) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject6) GetHas() []BlockHistoryProjectHasUnion3 {
	if o == nil {
		return []BlockHistoryProjectHasUnion3{}
	}
	return o.Has
}

func (o *RouteProject6) GetMitigate() BlockHistoryProjectMitigate3 {
	if o == nil {
		return BlockHistoryProjectMitigate3{}
	}
	return o.Mitigate
}

func (o *RouteProject6) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type RouteProject5 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (r RouteProject5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *RouteProject5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *RouteProject5) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *RouteProject5) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectRouteUnion3Type string

const (
	ProjectRouteUnion3TypeRouteProject5 ProjectRouteUnion3Type = "route_project_5"
	ProjectRouteUnion3TypeRouteProject6 ProjectRouteUnion3Type = "route_project_6"
)

type ProjectRouteUnion3 struct {
	RouteProject5 *RouteProject5 `queryParam:"inline"`
	RouteProject6 *RouteProject6 `queryParam:"inline"`

	Type ProjectRouteUnion3Type
}

func CreateProjectRouteUnion3RouteProject5(routeProject5 RouteProject5) ProjectRouteUnion3 {
	typ := ProjectRouteUnion3TypeRouteProject5

	return ProjectRouteUnion3{
		RouteProject5: &routeProject5,
		Type:          typ,
	}
}

func CreateProjectRouteUnion3RouteProject6(routeProject6 RouteProject6) ProjectRouteUnion3 {
	typ := ProjectRouteUnion3TypeRouteProject6

	return ProjectRouteUnion3{
		RouteProject6: &routeProject6,
		Type:          typ,
	}
}

func (u *ProjectRouteUnion3) UnmarshalJSON(data []byte) error {

	var routeProject5 RouteProject5 = RouteProject5{}
	if err := utils.UnmarshalJSON(data, &routeProject5, "", true, nil); err == nil {
		u.RouteProject5 = &routeProject5
		u.Type = ProjectRouteUnion3TypeRouteProject5
		return nil
	}

	var routeProject6 RouteProject6 = RouteProject6{}
	if err := utils.UnmarshalJSON(data, &routeProject6, "", true, nil); err == nil {
		u.RouteProject6 = &routeProject6
		u.Type = ProjectRouteUnion3TypeRouteProject6
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectRouteUnion3", string(data))
}

func (u ProjectRouteUnion3) MarshalJSON() ([]byte, error) {
	if u.RouteProject5 != nil {
		return utils.MarshalJSON(u.RouteProject5, "", true)
	}

	if u.RouteProject6 != nil {
		return utils.MarshalJSON(u.RouteProject6, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectRouteUnion3: all fields are null")
}

type BlockHistoryProjectRouteBlocked2 struct {
	Action              ProjectActionRouteBlocked2 `json:"action"`
	Route               ProjectRouteUnion3         `json:"route"`
	Reason              string                     `json:"reason"`
	CreatedAt           float64                    `json:"createdAt"`
	CaseID              *string                    `json:"caseId,omitempty"`
	Actor               *string                    `json:"actor,omitempty"`
	Comment             *string                    `json:"comment,omitempty"`
	IneligibleForAppeal *bool                      `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                      `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectRouteBlocked2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectRouteBlocked2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "route", "reason", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectRouteBlocked2) GetAction() ProjectActionRouteBlocked2 {
	if o == nil {
		return ProjectActionRouteBlocked2("")
	}
	return o.Action
}

func (o *BlockHistoryProjectRouteBlocked2) GetRoute() ProjectRouteUnion3 {
	if o == nil {
		return ProjectRouteUnion3{}
	}
	return o.Route
}

func (o *BlockHistoryProjectRouteBlocked2) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *BlockHistoryProjectRouteBlocked2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectRouteBlocked2) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectRouteBlocked2) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectRouteBlocked2) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectRouteBlocked2) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectRouteBlocked2) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectActionUnblocked2 string

const (
	ProjectActionUnblocked2Unblocked ProjectActionUnblocked2 = "unblocked"
)

func (e ProjectActionUnblocked2) ToPointer() *ProjectActionUnblocked2 {
	return &e
}
func (e *ProjectActionUnblocked2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "unblocked":
		*e = ProjectActionUnblocked2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectActionUnblocked2: %v", v)
	}
}

type BlockHistoryProjectUnblocked2 struct {
	Action              ProjectActionUnblocked2 `json:"action"`
	CreatedAt           float64                 `json:"createdAt"`
	CaseID              *string                 `json:"caseId,omitempty"`
	Actor               *string                 `json:"actor,omitempty"`
	Comment             *string                 `json:"comment,omitempty"`
	IneligibleForAppeal *bool                   `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                   `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectUnblocked2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectUnblocked2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectUnblocked2) GetAction() ProjectActionUnblocked2 {
	if o == nil {
		return ProjectActionUnblocked2("")
	}
	return o.Action
}

func (o *BlockHistoryProjectUnblocked2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectUnblocked2) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectUnblocked2) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectUnblocked2) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectUnblocked2) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectUnblocked2) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type BlockHistoryProjectActionBlocked2 string

const (
	BlockHistoryProjectActionBlocked2Blocked BlockHistoryProjectActionBlocked2 = "blocked"
)

func (e BlockHistoryProjectActionBlocked2) ToPointer() *BlockHistoryProjectActionBlocked2 {
	return &e
}
func (e *BlockHistoryProjectActionBlocked2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blocked":
		*e = BlockHistoryProjectActionBlocked2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for BlockHistoryProjectActionBlocked2: %v", v)
	}
}

type BlockHistoryProjectBlocked2 struct {
	Action              BlockHistoryProjectActionBlocked2 `json:"action"`
	Reason              string                            `json:"reason"`
	StatusCode          float64                           `json:"statusCode"`
	CreatedAt           float64                           `json:"createdAt"`
	CaseID              *string                           `json:"caseId,omitempty"`
	Actor               *string                           `json:"actor,omitempty"`
	Comment             *string                           `json:"comment,omitempty"`
	IneligibleForAppeal *bool                             `json:"ineligibleForAppeal,omitempty"`
	IsCascading         *bool                             `json:"isCascading,omitempty"`
}

func (b BlockHistoryProjectBlocked2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *BlockHistoryProjectBlocked2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"action", "reason", "statusCode", "createdAt"}); err != nil {
		return err
	}
	return nil
}

func (o *BlockHistoryProjectBlocked2) GetAction() BlockHistoryProjectActionBlocked2 {
	if o == nil {
		return BlockHistoryProjectActionBlocked2("")
	}
	return o.Action
}

func (o *BlockHistoryProjectBlocked2) GetReason() string {
	if o == nil {
		return ""
	}
	return o.Reason
}

func (o *BlockHistoryProjectBlocked2) GetStatusCode() float64 {
	if o == nil {
		return 0.0
	}
	return o.StatusCode
}

func (o *BlockHistoryProjectBlocked2) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *BlockHistoryProjectBlocked2) GetCaseID() *string {
	if o == nil {
		return nil
	}
	return o.CaseID
}

func (o *BlockHistoryProjectBlocked2) GetActor() *string {
	if o == nil {
		return nil
	}
	return o.Actor
}

func (o *BlockHistoryProjectBlocked2) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *BlockHistoryProjectBlocked2) GetIneligibleForAppeal() *bool {
	if o == nil {
		return nil
	}
	return o.IneligibleForAppeal
}

func (o *BlockHistoryProjectBlocked2) GetIsCascading() *bool {
	if o == nil {
		return nil
	}
	return o.IsCascading
}

type ProjectBlockHistoryUnion2Type string

const (
	ProjectBlockHistoryUnion2TypeBlocked        ProjectBlockHistoryUnion2Type = "blocked"
	ProjectBlockHistoryUnion2TypeUnblocked      ProjectBlockHistoryUnion2Type = "unblocked"
	ProjectBlockHistoryUnion2TypeRouteBlocked   ProjectBlockHistoryUnion2Type = "route-blocked"
	ProjectBlockHistoryUnion2TypeRouteUnblocked ProjectBlockHistoryUnion2Type = "route-unblocked"
)

type ProjectBlockHistoryUnion2 struct {
	BlockHistoryProjectBlocked2        *BlockHistoryProjectBlocked2        `queryParam:"inline"`
	BlockHistoryProjectUnblocked2      *BlockHistoryProjectUnblocked2      `queryParam:"inline"`
	BlockHistoryProjectRouteBlocked2   *BlockHistoryProjectRouteBlocked2   `queryParam:"inline"`
	BlockHistoryProjectRouteUnblocked2 *BlockHistoryProjectRouteUnblocked2 `queryParam:"inline"`

	Type ProjectBlockHistoryUnion2Type
}

func CreateProjectBlockHistoryUnion2Blocked(blocked BlockHistoryProjectBlocked2) ProjectBlockHistoryUnion2 {
	typ := ProjectBlockHistoryUnion2TypeBlocked

	typStr := BlockHistoryProjectActionBlocked2(typ)
	blocked.Action = typStr

	return ProjectBlockHistoryUnion2{
		BlockHistoryProjectBlocked2: &blocked,
		Type:                        typ,
	}
}

func CreateProjectBlockHistoryUnion2Unblocked(unblocked BlockHistoryProjectUnblocked2) ProjectBlockHistoryUnion2 {
	typ := ProjectBlockHistoryUnion2TypeUnblocked

	typStr := ProjectActionUnblocked2(typ)
	unblocked.Action = typStr

	return ProjectBlockHistoryUnion2{
		BlockHistoryProjectUnblocked2: &unblocked,
		Type:                          typ,
	}
}

func CreateProjectBlockHistoryUnion2RouteBlocked(routeBlocked BlockHistoryProjectRouteBlocked2) ProjectBlockHistoryUnion2 {
	typ := ProjectBlockHistoryUnion2TypeRouteBlocked

	typStr := ProjectActionRouteBlocked2(typ)
	routeBlocked.Action = typStr

	return ProjectBlockHistoryUnion2{
		BlockHistoryProjectRouteBlocked2: &routeBlocked,
		Type:                             typ,
	}
}

func CreateProjectBlockHistoryUnion2RouteUnblocked(routeUnblocked BlockHistoryProjectRouteUnblocked2) ProjectBlockHistoryUnion2 {
	typ := ProjectBlockHistoryUnion2TypeRouteUnblocked

	typStr := ProjectActionRouteUnblocked2(typ)
	routeUnblocked.Action = typStr

	return ProjectBlockHistoryUnion2{
		BlockHistoryProjectRouteUnblocked2: &routeUnblocked,
		Type:                               typ,
	}
}

func (u *ProjectBlockHistoryUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Action string `json:"action"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Action {
	case "blocked":
		blockHistoryProjectBlocked2 := new(BlockHistoryProjectBlocked2)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectBlocked2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == blocked) type BlockHistoryProjectBlocked2 within ProjectBlockHistoryUnion2: %w", string(data), err)
		}

		u.BlockHistoryProjectBlocked2 = blockHistoryProjectBlocked2
		u.Type = ProjectBlockHistoryUnion2TypeBlocked
		return nil
	case "unblocked":
		blockHistoryProjectUnblocked2 := new(BlockHistoryProjectUnblocked2)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectUnblocked2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == unblocked) type BlockHistoryProjectUnblocked2 within ProjectBlockHistoryUnion2: %w", string(data), err)
		}

		u.BlockHistoryProjectUnblocked2 = blockHistoryProjectUnblocked2
		u.Type = ProjectBlockHistoryUnion2TypeUnblocked
		return nil
	case "route-blocked":
		blockHistoryProjectRouteBlocked2 := new(BlockHistoryProjectRouteBlocked2)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectRouteBlocked2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-blocked) type BlockHistoryProjectRouteBlocked2 within ProjectBlockHistoryUnion2: %w", string(data), err)
		}

		u.BlockHistoryProjectRouteBlocked2 = blockHistoryProjectRouteBlocked2
		u.Type = ProjectBlockHistoryUnion2TypeRouteBlocked
		return nil
	case "route-unblocked":
		blockHistoryProjectRouteUnblocked2 := new(BlockHistoryProjectRouteUnblocked2)
		if err := utils.UnmarshalJSON(data, &blockHistoryProjectRouteUnblocked2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Action == route-unblocked) type BlockHistoryProjectRouteUnblocked2 within ProjectBlockHistoryUnion2: %w", string(data), err)
		}

		u.BlockHistoryProjectRouteUnblocked2 = blockHistoryProjectRouteUnblocked2
		u.Type = ProjectBlockHistoryUnion2TypeRouteUnblocked
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectBlockHistoryUnion2", string(data))
}

func (u ProjectBlockHistoryUnion2) MarshalJSON() ([]byte, error) {
	if u.BlockHistoryProjectBlocked2 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectBlocked2, "", true)
	}

	if u.BlockHistoryProjectUnblocked2 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectUnblocked2, "", true)
	}

	if u.BlockHistoryProjectRouteBlocked2 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectRouteBlocked2, "", true)
	}

	if u.BlockHistoryProjectRouteUnblocked2 != nil {
		return utils.MarshalJSON(u.BlockHistoryProjectRouteUnblocked2, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectBlockHistoryUnion2: all fields are null")
}

type ProjectAbuse2 struct {
	Scanner      *string                     `json:"scanner,omitempty"`
	History      []ProjectHistory2           `json:"history"`
	UpdatedAt    float64                     `json:"updatedAt"`
	Block        *ProjectBlock2              `json:"block,omitempty"`
	BlockHistory []ProjectBlockHistoryUnion2 `json:"blockHistory,omitempty"`
	Interstitial *bool                       `json:"interstitial,omitempty"`
}

func (p ProjectAbuse2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectAbuse2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"history", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectAbuse2) GetScanner() *string {
	if o == nil {
		return nil
	}
	return o.Scanner
}

func (o *ProjectAbuse2) GetHistory() []ProjectHistory2 {
	if o == nil {
		return []ProjectHistory2{}
	}
	return o.History
}

func (o *ProjectAbuse2) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

func (o *ProjectAbuse2) GetBlock() *ProjectBlock2 {
	if o == nil {
		return nil
	}
	return o.Block
}

func (o *ProjectAbuse2) GetBlockHistory() []ProjectBlockHistoryUnion2 {
	if o == nil {
		return nil
	}
	return o.BlockHistory
}

func (o *ProjectAbuse2) GetInterstitial() *bool {
	if o == nil {
		return nil
	}
	return o.Interstitial
}

type InternalRouteProjectTypeHost2 string

const (
	InternalRouteProjectTypeHost2Host InternalRouteProjectTypeHost2 = "host"
)

func (e InternalRouteProjectTypeHost2) ToPointer() *InternalRouteProjectTypeHost2 {
	return &e
}
func (e *InternalRouteProjectTypeHost2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "host":
		*e = InternalRouteProjectTypeHost2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectTypeHost2: %v", v)
	}
}

type InternalRouteProjectValue4 struct {
	Eq string `json:"eq"`
}

func (i InternalRouteProjectValue4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectValue4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectValue4) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type InternalRouteHasProjectHost2 struct {
	Type  InternalRouteProjectTypeHost2 `json:"type"`
	Value InternalRouteProjectValue4    `json:"value"`
}

func (i InternalRouteHasProjectHost2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteHasProjectHost2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteHasProjectHost2) GetType() InternalRouteProjectTypeHost2 {
	if o == nil {
		return InternalRouteProjectTypeHost2("")
	}
	return o.Type
}

func (o *InternalRouteHasProjectHost2) GetValue() InternalRouteProjectValue4 {
	if o == nil {
		return InternalRouteProjectValue4{}
	}
	return o.Value
}

type InternalRouteProjectTypeHeader2 string

const (
	InternalRouteProjectTypeHeader2Header InternalRouteProjectTypeHeader2 = "header"
)

func (e InternalRouteProjectTypeHeader2) ToPointer() *InternalRouteProjectTypeHeader2 {
	return &e
}
func (e *InternalRouteProjectTypeHeader2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "header":
		*e = InternalRouteProjectTypeHeader2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectTypeHeader2: %v", v)
	}
}

type InternalRouteProjectKey2 string

const (
	InternalRouteProjectKey2XVercelIPCountry InternalRouteProjectKey2 = "x-vercel-ip-country"
)

func (e InternalRouteProjectKey2) ToPointer() *InternalRouteProjectKey2 {
	return &e
}
func (e *InternalRouteProjectKey2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "x-vercel-ip-country":
		*e = InternalRouteProjectKey2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectKey2: %v", v)
	}
}

type InternalRouteProjectValue3 struct {
	Eq string `json:"eq"`
}

func (i InternalRouteProjectValue3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectValue3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"eq"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectValue3) GetEq() string {
	if o == nil {
		return ""
	}
	return o.Eq
}

type InternalRouteHasProjectXVercelIPCountry2 struct {
	Type  InternalRouteProjectTypeHeader2 `json:"type"`
	Key   InternalRouteProjectKey2        `json:"key"`
	Value InternalRouteProjectValue3      `json:"value"`
}

func (i InternalRouteHasProjectXVercelIPCountry2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteHasProjectXVercelIPCountry2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"type", "key", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteHasProjectXVercelIPCountry2) GetType() InternalRouteProjectTypeHeader2 {
	if o == nil {
		return InternalRouteProjectTypeHeader2("")
	}
	return o.Type
}

func (o *InternalRouteHasProjectXVercelIPCountry2) GetKey() InternalRouteProjectKey2 {
	if o == nil {
		return InternalRouteProjectKey2("")
	}
	return o.Key
}

func (o *InternalRouteHasProjectXVercelIPCountry2) GetValue() InternalRouteProjectValue3 {
	if o == nil {
		return InternalRouteProjectValue3{}
	}
	return o.Value
}

type InternalRouteProjectHasUnion2Type string

const (
	InternalRouteProjectHasUnion2TypeHeader InternalRouteProjectHasUnion2Type = "header"
	InternalRouteProjectHasUnion2TypeHost   InternalRouteProjectHasUnion2Type = "host"
)

type InternalRouteProjectHasUnion2 struct {
	InternalRouteHasProjectXVercelIPCountry2 *InternalRouteHasProjectXVercelIPCountry2 `queryParam:"inline"`
	InternalRouteHasProjectHost2             *InternalRouteHasProjectHost2             `queryParam:"inline"`

	Type InternalRouteProjectHasUnion2Type
}

func CreateInternalRouteProjectHasUnion2Header(header InternalRouteHasProjectXVercelIPCountry2) InternalRouteProjectHasUnion2 {
	typ := InternalRouteProjectHasUnion2TypeHeader

	typStr := InternalRouteProjectTypeHeader2(typ)
	header.Type = typStr

	return InternalRouteProjectHasUnion2{
		InternalRouteHasProjectXVercelIPCountry2: &header,
		Type:                                     typ,
	}
}

func CreateInternalRouteProjectHasUnion2Host(host InternalRouteHasProjectHost2) InternalRouteProjectHasUnion2 {
	typ := InternalRouteProjectHasUnion2TypeHost

	typStr := InternalRouteProjectTypeHost2(typ)
	host.Type = typStr

	return InternalRouteProjectHasUnion2{
		InternalRouteHasProjectHost2: &host,
		Type:                         typ,
	}
}

func (u *InternalRouteProjectHasUnion2) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "header":
		internalRouteHasProjectXVercelIPCountry2 := new(InternalRouteHasProjectXVercelIPCountry2)
		if err := utils.UnmarshalJSON(data, &internalRouteHasProjectXVercelIPCountry2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == header) type InternalRouteHasProjectXVercelIPCountry2 within InternalRouteProjectHasUnion2: %w", string(data), err)
		}

		u.InternalRouteHasProjectXVercelIPCountry2 = internalRouteHasProjectXVercelIPCountry2
		u.Type = InternalRouteProjectHasUnion2TypeHeader
		return nil
	case "host":
		internalRouteHasProjectHost2 := new(InternalRouteHasProjectHost2)
		if err := utils.UnmarshalJSON(data, &internalRouteHasProjectHost2, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == host) type InternalRouteHasProjectHost2 within InternalRouteProjectHasUnion2: %w", string(data), err)
		}

		u.InternalRouteHasProjectHost2 = internalRouteHasProjectHost2
		u.Type = InternalRouteProjectHasUnion2TypeHost
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for InternalRouteProjectHasUnion2", string(data))
}

func (u InternalRouteProjectHasUnion2) MarshalJSON() ([]byte, error) {
	if u.InternalRouteHasProjectXVercelIPCountry2 != nil {
		return utils.MarshalJSON(u.InternalRouteHasProjectXVercelIPCountry2, "", true)
	}

	if u.InternalRouteHasProjectHost2 != nil {
		return utils.MarshalJSON(u.InternalRouteHasProjectHost2, "", true)
	}

	return nil, errors.New("could not marshal union type InternalRouteProjectHasUnion2: all fields are null")
}

type InternalRouteProjectAction2 string

const (
	InternalRouteProjectAction2BlockLegalCwc InternalRouteProjectAction2 = "block_legal_cwc"
)

func (e InternalRouteProjectAction2) ToPointer() *InternalRouteProjectAction2 {
	return &e
}
func (e *InternalRouteProjectAction2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "block_legal_cwc":
		*e = InternalRouteProjectAction2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for InternalRouteProjectAction2: %v", v)
	}
}

type InternalRouteProjectMitigate2 struct {
	Action InternalRouteProjectAction2 `json:"action"`
}

func (i InternalRouteProjectMitigate2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProjectMitigate2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"action"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProjectMitigate2) GetAction() InternalRouteProjectAction2 {
	if o == nil {
		return InternalRouteProjectAction2("")
	}
	return o.Action
}

type InternalRouteProject4 struct {
	Has      []InternalRouteProjectHasUnion2 `json:"has"`
	Mitigate InternalRouteProjectMitigate2   `json:"mitigate"`
	Src      *string                         `json:"src,omitempty"`
}

func (i InternalRouteProject4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProject4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"has", "mitigate"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProject4) GetHas() []InternalRouteProjectHasUnion2 {
	if o == nil {
		return []InternalRouteProjectHasUnion2{}
	}
	return o.Has
}

func (o *InternalRouteProject4) GetMitigate() InternalRouteProjectMitigate2 {
	if o == nil {
		return InternalRouteProjectMitigate2{}
	}
	return o.Mitigate
}

func (o *InternalRouteProject4) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

type InternalRouteProject3 struct {
	Src    string  `json:"src"`
	Status float64 `json:"status"`
}

func (i InternalRouteProject3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(i, "", false)
}

func (i *InternalRouteProject3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &i, "", false, []string{"src", "status"}); err != nil {
		return err
	}
	return nil
}

func (o *InternalRouteProject3) GetSrc() string {
	if o == nil {
		return ""
	}
	return o.Src
}

func (o *InternalRouteProject3) GetStatus() float64 {
	if o == nil {
		return 0.0
	}
	return o.Status
}

type ProjectInternalRouteUnion2Type string

const (
	ProjectInternalRouteUnion2TypeInternalRouteProject3 ProjectInternalRouteUnion2Type = "internalRoute_project_3"
	ProjectInternalRouteUnion2TypeInternalRouteProject4 ProjectInternalRouteUnion2Type = "internalRoute_project_4"
)

type ProjectInternalRouteUnion2 struct {
	InternalRouteProject3 *InternalRouteProject3 `queryParam:"inline"`
	InternalRouteProject4 *InternalRouteProject4 `queryParam:"inline"`

	Type ProjectInternalRouteUnion2Type
}

func CreateProjectInternalRouteUnion2InternalRouteProject3(internalRouteProject3 InternalRouteProject3) ProjectInternalRouteUnion2 {
	typ := ProjectInternalRouteUnion2TypeInternalRouteProject3

	return ProjectInternalRouteUnion2{
		InternalRouteProject3: &internalRouteProject3,
		Type:                  typ,
	}
}

func CreateProjectInternalRouteUnion2InternalRouteProject4(internalRouteProject4 InternalRouteProject4) ProjectInternalRouteUnion2 {
	typ := ProjectInternalRouteUnion2TypeInternalRouteProject4

	return ProjectInternalRouteUnion2{
		InternalRouteProject4: &internalRouteProject4,
		Type:                  typ,
	}
}

func (u *ProjectInternalRouteUnion2) UnmarshalJSON(data []byte) error {

	var internalRouteProject3 InternalRouteProject3 = InternalRouteProject3{}
	if err := utils.UnmarshalJSON(data, &internalRouteProject3, "", true, nil); err == nil {
		u.InternalRouteProject3 = &internalRouteProject3
		u.Type = ProjectInternalRouteUnion2TypeInternalRouteProject3
		return nil
	}

	var internalRouteProject4 InternalRouteProject4 = InternalRouteProject4{}
	if err := utils.UnmarshalJSON(data, &internalRouteProject4, "", true, nil); err == nil {
		u.InternalRouteProject4 = &internalRouteProject4
		u.Type = ProjectInternalRouteUnion2TypeInternalRouteProject4
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectInternalRouteUnion2", string(data))
}

func (u ProjectInternalRouteUnion2) MarshalJSON() ([]byte, error) {
	if u.InternalRouteProject3 != nil {
		return utils.MarshalJSON(u.InternalRouteProject3, "", true)
	}

	if u.InternalRouteProject4 != nil {
		return utils.MarshalJSON(u.InternalRouteProject4, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectInternalRouteUnion2: all fields are null")
}

type ProjectDismissedToastAction string

const (
	ProjectDismissedToastActionDelete ProjectDismissedToastAction = "delete"
	ProjectDismissedToastActionCancel ProjectDismissedToastAction = "cancel"
	ProjectDismissedToastActionAccept ProjectDismissedToastAction = "accept"
)

func (e ProjectDismissedToastAction) ToPointer() *ProjectDismissedToastAction {
	return &e
}
func (e *ProjectDismissedToastAction) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "delete":
		fallthrough
	case "cancel":
		fallthrough
	case "accept":
		*e = ProjectDismissedToastAction(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectDismissedToastAction: %v", v)
	}
}

type GetProjectsPreviousValueType string

const (
	GetProjectsPreviousValueTypeStr     GetProjectsPreviousValueType = "str"
	GetProjectsPreviousValueTypeNumber  GetProjectsPreviousValueType = "number"
	GetProjectsPreviousValueTypeBoolean GetProjectsPreviousValueType = "boolean"
)

type GetProjectsPreviousValue struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type GetProjectsPreviousValueType
}

func CreateGetProjectsPreviousValueStr(str string) GetProjectsPreviousValue {
	typ := GetProjectsPreviousValueTypeStr

	return GetProjectsPreviousValue{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetProjectsPreviousValueNumber(number float64) GetProjectsPreviousValue {
	typ := GetProjectsPreviousValueTypeNumber

	return GetProjectsPreviousValue{
		Number: &number,
		Type:   typ,
	}
}

func CreateGetProjectsPreviousValueBoolean(boolean bool) GetProjectsPreviousValue {
	typ := GetProjectsPreviousValueTypeBoolean

	return GetProjectsPreviousValue{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *GetProjectsPreviousValue) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetProjectsPreviousValueTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetProjectsPreviousValueTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = GetProjectsPreviousValueTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsPreviousValue", string(data))
}

func (u GetProjectsPreviousValue) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsPreviousValue: all fields are null")
}

type GetProjectsCurrentValueType string

const (
	GetProjectsCurrentValueTypeStr     GetProjectsCurrentValueType = "str"
	GetProjectsCurrentValueTypeNumber  GetProjectsCurrentValueType = "number"
	GetProjectsCurrentValueTypeBoolean GetProjectsCurrentValueType = "boolean"
)

type GetProjectsCurrentValue struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type GetProjectsCurrentValueType
}

func CreateGetProjectsCurrentValueStr(str string) GetProjectsCurrentValue {
	typ := GetProjectsCurrentValueTypeStr

	return GetProjectsCurrentValue{
		Str:  &str,
		Type: typ,
	}
}

func CreateGetProjectsCurrentValueNumber(number float64) GetProjectsCurrentValue {
	typ := GetProjectsCurrentValueTypeNumber

	return GetProjectsCurrentValue{
		Number: &number,
		Type:   typ,
	}
}

func CreateGetProjectsCurrentValueBoolean(boolean bool) GetProjectsCurrentValue {
	typ := GetProjectsCurrentValueTypeBoolean

	return GetProjectsCurrentValue{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *GetProjectsCurrentValue) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = GetProjectsCurrentValueTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = GetProjectsCurrentValueTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = GetProjectsCurrentValueTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for GetProjectsCurrentValue", string(data))
}

func (u GetProjectsCurrentValue) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type GetProjectsCurrentValue: all fields are null")
}

type ValueProjectDismissedToast struct {
	PreviousValue GetProjectsPreviousValue `json:"previousValue"`
	CurrentValue  GetProjectsCurrentValue  `json:"currentValue"`
}

func (v ValueProjectDismissedToast) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(v, "", false)
}

func (v *ValueProjectDismissedToast) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &v, "", false, []string{"previousValue", "currentValue"}); err != nil {
		return err
	}
	return nil
}

func (o *ValueProjectDismissedToast) GetPreviousValue() GetProjectsPreviousValue {
	if o == nil {
		return GetProjectsPreviousValue{}
	}
	return o.PreviousValue
}

func (o *ValueProjectDismissedToast) GetCurrentValue() GetProjectsCurrentValue {
	if o == nil {
		return GetProjectsCurrentValue{}
	}
	return o.CurrentValue
}

type ProjectDismissedToastValueUnionType string

const (
	ProjectDismissedToastValueUnionTypeStr                        ProjectDismissedToastValueUnionType = "str"
	ProjectDismissedToastValueUnionTypeNumber                     ProjectDismissedToastValueUnionType = "number"
	ProjectDismissedToastValueUnionTypeValueProjectDismissedToast ProjectDismissedToastValueUnionType = "value_project_dismissedToast"
	ProjectDismissedToastValueUnionTypeBoolean                    ProjectDismissedToastValueUnionType = "boolean"
)

type ProjectDismissedToastValueUnion struct {
	Str                        *string                     `queryParam:"inline"`
	Number                     *float64                    `queryParam:"inline"`
	ValueProjectDismissedToast *ValueProjectDismissedToast `queryParam:"inline"`
	Boolean                    *bool                       `queryParam:"inline"`

	Type ProjectDismissedToastValueUnionType
}

func CreateProjectDismissedToastValueUnionStr(str string) ProjectDismissedToastValueUnion {
	typ := ProjectDismissedToastValueUnionTypeStr

	return ProjectDismissedToastValueUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateProjectDismissedToastValueUnionNumber(number float64) ProjectDismissedToastValueUnion {
	typ := ProjectDismissedToastValueUnionTypeNumber

	return ProjectDismissedToastValueUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectDismissedToastValueUnionValueProjectDismissedToast(valueProjectDismissedToast ValueProjectDismissedToast) ProjectDismissedToastValueUnion {
	typ := ProjectDismissedToastValueUnionTypeValueProjectDismissedToast

	return ProjectDismissedToastValueUnion{
		ValueProjectDismissedToast: &valueProjectDismissedToast,
		Type:                       typ,
	}
}

func CreateProjectDismissedToastValueUnionBoolean(boolean bool) ProjectDismissedToastValueUnion {
	typ := ProjectDismissedToastValueUnionTypeBoolean

	return ProjectDismissedToastValueUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ProjectDismissedToastValueUnion) UnmarshalJSON(data []byte) error {

	var valueProjectDismissedToast ValueProjectDismissedToast = ValueProjectDismissedToast{}
	if err := utils.UnmarshalJSON(data, &valueProjectDismissedToast, "", true, nil); err == nil {
		u.ValueProjectDismissedToast = &valueProjectDismissedToast
		u.Type = ProjectDismissedToastValueUnionTypeValueProjectDismissedToast
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ProjectDismissedToastValueUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ProjectDismissedToastValueUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ProjectDismissedToastValueUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectDismissedToastValueUnion", string(data))
}

func (u ProjectDismissedToastValueUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.ValueProjectDismissedToast != nil {
		return utils.MarshalJSON(u.ValueProjectDismissedToast, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectDismissedToastValueUnion: all fields are null")
}

type GetProjectsDismissedToast struct {
	Key         string                           `json:"key"`
	DismissedAt float64                          `json:"dismissedAt"`
	Action      ProjectDismissedToastAction      `json:"action"`
	Value       *ProjectDismissedToastValueUnion `json:"value"`
}

func (g GetProjectsDismissedToast) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsDismissedToast) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"key", "dismissedAt", "action", "value"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsDismissedToast) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *GetProjectsDismissedToast) GetDismissedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.DismissedAt
}

func (o *GetProjectsDismissedToast) GetAction() ProjectDismissedToastAction {
	if o == nil {
		return ProjectDismissedToastAction("")
	}
	return o.Action
}

func (o *GetProjectsDismissedToast) GetValue() *ProjectDismissedToastValueUnion {
	if o == nil {
		return nil
	}
	return o.Value
}

type GetProjectsProject2 struct {
	AccountID                        string                            `json:"accountId"`
	Analytics                        *ProjectAnalytics2                `json:"analytics,omitempty"`
	AppliedCve55182Migration         *bool                             `json:"appliedCve55182Migration,omitempty"`
	SpeedInsights                    *ProjectSpeedInsights2            `json:"speedInsights,omitempty"`
	AutoExposeSystemEnvs             *bool                             `json:"autoExposeSystemEnvs,omitempty"`
	AutoAssignCustomDomains          *bool                             `json:"autoAssignCustomDomains,omitempty"`
	AutoAssignCustomDomainsUpdatedBy *string                           `json:"autoAssignCustomDomainsUpdatedBy,omitempty"`
	BuildCommand                     *string                           `json:"buildCommand,omitempty"`
	CommandForIgnoringBuildStep      *string                           `json:"commandForIgnoringBuildStep,omitempty"`
	ConnectConfigurations            []GetProjectsConnectConfiguration `json:"connectConfigurations,omitempty"`
	ConnectConfigurationID           *string                           `json:"connectConfigurationId,omitempty"`
	ConnectBuildsEnabled             *bool                             `json:"connectBuildsEnabled,omitempty"`
	PassiveConnectConfigurationID    *string                           `json:"passiveConnectConfigurationId,omitempty"`
	CreatedAt                        *float64                          `json:"createdAt,omitempty"`
	CustomerSupportCodeVisibility    *bool                             `json:"customerSupportCodeVisibility,omitempty"`
	Crons                            *GetProjectsCrons                 `json:"crons,omitempty"`
	DataCache                        *GetProjectsDataCache             `json:"dataCache,omitempty"`
	// Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
	DeploymentExpiration          ProjectDeploymentExpiration2    `json:"deploymentExpiration"`
	DevCommand                    *string                         `json:"devCommand,omitempty"`
	DirectoryListing              bool                            `json:"directoryListing"`
	InstallCommand                *string                         `json:"installCommand,omitempty"`
	Env                           []ProjectEnv2                   `json:"env,omitempty"`
	CustomEnvironments            []GetProjectsCustomEnvironment  `json:"customEnvironments,omitempty"`
	Framework                     *ProjectFramework2              `json:"framework,omitempty"`
	GitForkProtection             *bool                           `json:"gitForkProtection,omitempty"`
	GitLFS                        *bool                           `json:"gitLFS,omitempty"`
	ID                            string                          `json:"id"`
	IPBuckets                     []ProjectIPBucket2              `json:"ipBuckets,omitempty"`
	LatestDeployments             []ProjectLatestDeployment2      `json:"latestDeployments,omitempty"`
	Link                          *ProjectLinkUnion2              `json:"link,omitempty"`
	Microfrontends                *GetProjectsMicrofrontendsUnion `json:"microfrontends,omitempty"`
	Name                          string                          `json:"name"`
	NodeVersion                   ProjectNodeVersion2             `json:"nodeVersion"`
	OptionsAllowlist              *GetProjectsOptionsAllowlist    `json:"optionsAllowlist,omitempty"`
	OutputDirectory               *string                         `json:"outputDirectory,omitempty"`
	PasswordProtection            *ProjectPasswordProtection2     `json:"passwordProtection,omitempty"`
	ProductionDeploymentsFastLane *bool                           `json:"productionDeploymentsFastLane,omitempty"`
	PublicSource                  *bool                           `json:"publicSource,omitempty"`
	ResourceConfig                ProjectResourceConfig2          `json:"resourceConfig"`
	// Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.
	RollbackDescription *GetProjectsRollbackDescription `json:"rollbackDescription,omitempty"`
	// Project-level rolling release configuration that defines how deployments should be gradually rolled out
	RollingRelease                       *ProjectRollingRelease2                     `json:"rollingRelease,omitempty"`
	DefaultResourceConfig                GetProjectsDefaultResourceConfig            `json:"defaultResourceConfig"`
	RootDirectory                        *string                                     `json:"rootDirectory,omitempty"`
	ServerlessFunctionZeroConfigFailover *bool                                       `json:"serverlessFunctionZeroConfigFailover,omitempty"`
	SkewProtectionBoundaryAt             *float64                                    `json:"skewProtectionBoundaryAt,omitempty"`
	SkewProtectionMaxAge                 *float64                                    `json:"skewProtectionMaxAge,omitempty"`
	SkewProtectionAllowedDomains         []string                                    `json:"skewProtectionAllowedDomains,omitempty"`
	SkipGitConnectDuringLink             *bool                                       `json:"skipGitConnectDuringLink,omitempty"`
	StaticIps                            *GetProjectsStaticIps                       `json:"staticIps,omitempty"`
	SourceFilesOutsideRootDirectory      *bool                                       `json:"sourceFilesOutsideRootDirectory,omitempty"`
	EnableAffectedProjectsDeployments    *bool                                       `json:"enableAffectedProjectsDeployments,omitempty"`
	SsoProtection                        *ProjectSsoProtection2                      `json:"ssoProtection,omitempty"`
	Targets                              map[string]*ProjectTargets2                 `json:"targets,omitempty"`
	TransferCompletedAt                  *float64                                    `json:"transferCompletedAt,omitempty"`
	TransferStartedAt                    *float64                                    `json:"transferStartedAt,omitempty"`
	TransferToAccountID                  *string                                     `json:"transferToAccountId,omitempty"`
	TransferredFromAccountID             *string                                     `json:"transferredFromAccountId,omitempty"`
	UpdatedAt                            *float64                                    `json:"updatedAt,omitempty"`
	Live                                 *bool                                       `json:"live,omitempty"`
	EnablePreviewFeedback                *bool                                       `json:"enablePreviewFeedback,omitempty"`
	EnableProductionFeedback             *bool                                       `json:"enableProductionFeedback,omitempty"`
	Permissions                          *GetProjectsPermissions                     `json:"permissions,omitempty"`
	LastRollbackTarget                   *GetProjectsLastRollbackTarget              `json:"lastRollbackTarget,omitempty"`
	LastAliasRequest                     *GetProjectsLastAliasRequest                `json:"lastAliasRequest,omitempty"`
	ProtectionBypass                     map[string]GetProjectsProtectionBypassUnion `json:"protectionBypass,omitempty"`
	HasActiveBranches                    *bool                                       `json:"hasActiveBranches,omitempty"`
	TrustedIps                           *GetProjectsTrustedIpsUnion                 `json:"trustedIps,omitempty"`
	GitComments                          *ProjectGitComments2                        `json:"gitComments,omitempty"`
	GitProviderOptions                   *ProjectGitProviderOptions2                 `json:"gitProviderOptions,omitempty"`
	Paused                               *bool                                       `json:"paused,omitempty"`
	ConcurrencyBucketName                *string                                     `json:"concurrencyBucketName,omitempty"`
	WebAnalytics                         *ProjectWebAnalytics2                       `json:"webAnalytics,omitempty"`
	Security                             *ProjectSecurity2                           `json:"security,omitempty"`
	OidcTokenConfig                      *ProjectOidcTokenConfig2                    `json:"oidcTokenConfig,omitempty"`
	Tier                                 *ProjectTier2                               `json:"tier,omitempty"`
	Features                             *GetProjectsFeatures                        `json:"features,omitempty"`
	V0                                   *bool                                       `json:"v0,omitempty"`
	Abuse                                *ProjectAbuse2                              `json:"abuse,omitempty"`
	InternalRoutes                       []ProjectInternalRouteUnion2                `json:"internalRoutes,omitempty"`
	HasDeployments                       *bool                                       `json:"hasDeployments,omitempty"`
	DismissedToasts                      []GetProjectsDismissedToast                 `json:"dismissedToasts,omitempty"`
	ProtectedSourcemaps                  *bool                                       `json:"protectedSourcemaps,omitempty"`
}

func (g GetProjectsProject2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsProject2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"accountId", "deploymentExpiration", "directoryListing", "id", "name", "nodeVersion", "resourceConfig", "defaultResourceConfig"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsProject2) GetAccountID() string {
	if o == nil {
		return ""
	}
	return o.AccountID
}

func (o *GetProjectsProject2) GetAnalytics() *ProjectAnalytics2 {
	if o == nil {
		return nil
	}
	return o.Analytics
}

func (o *GetProjectsProject2) GetAppliedCve55182Migration() *bool {
	if o == nil {
		return nil
	}
	return o.AppliedCve55182Migration
}

func (o *GetProjectsProject2) GetSpeedInsights() *ProjectSpeedInsights2 {
	if o == nil {
		return nil
	}
	return o.SpeedInsights
}

func (o *GetProjectsProject2) GetAutoExposeSystemEnvs() *bool {
	if o == nil {
		return nil
	}
	return o.AutoExposeSystemEnvs
}

func (o *GetProjectsProject2) GetAutoAssignCustomDomains() *bool {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomains
}

func (o *GetProjectsProject2) GetAutoAssignCustomDomainsUpdatedBy() *string {
	if o == nil {
		return nil
	}
	return o.AutoAssignCustomDomainsUpdatedBy
}

func (o *GetProjectsProject2) GetBuildCommand() *string {
	if o == nil {
		return nil
	}
	return o.BuildCommand
}

func (o *GetProjectsProject2) GetCommandForIgnoringBuildStep() *string {
	if o == nil {
		return nil
	}
	return o.CommandForIgnoringBuildStep
}

func (o *GetProjectsProject2) GetConnectConfigurations() []GetProjectsConnectConfiguration {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurations
}

func (o *GetProjectsProject2) GetConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConnectConfigurationID
}

func (o *GetProjectsProject2) GetConnectBuildsEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ConnectBuildsEnabled
}

func (o *GetProjectsProject2) GetPassiveConnectConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.PassiveConnectConfigurationID
}

func (o *GetProjectsProject2) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *GetProjectsProject2) GetCustomerSupportCodeVisibility() *bool {
	if o == nil {
		return nil
	}
	return o.CustomerSupportCodeVisibility
}

func (o *GetProjectsProject2) GetCrons() *GetProjectsCrons {
	if o == nil {
		return nil
	}
	return o.Crons
}

func (o *GetProjectsProject2) GetDataCache() *GetProjectsDataCache {
	if o == nil {
		return nil
	}
	return o.DataCache
}

func (o *GetProjectsProject2) GetDeploymentExpiration() ProjectDeploymentExpiration2 {
	if o == nil {
		return ProjectDeploymentExpiration2{}
	}
	return o.DeploymentExpiration
}

func (o *GetProjectsProject2) GetDevCommand() *string {
	if o == nil {
		return nil
	}
	return o.DevCommand
}

func (o *GetProjectsProject2) GetDirectoryListing() bool {
	if o == nil {
		return false
	}
	return o.DirectoryListing
}

func (o *GetProjectsProject2) GetInstallCommand() *string {
	if o == nil {
		return nil
	}
	return o.InstallCommand
}

func (o *GetProjectsProject2) GetEnv() []ProjectEnv2 {
	if o == nil {
		return nil
	}
	return o.Env
}

func (o *GetProjectsProject2) GetCustomEnvironments() []GetProjectsCustomEnvironment {
	if o == nil {
		return nil
	}
	return o.CustomEnvironments
}

func (o *GetProjectsProject2) GetFramework() *ProjectFramework2 {
	if o == nil {
		return nil
	}
	return o.Framework
}

func (o *GetProjectsProject2) GetGitForkProtection() *bool {
	if o == nil {
		return nil
	}
	return o.GitForkProtection
}

func (o *GetProjectsProject2) GetGitLFS() *bool {
	if o == nil {
		return nil
	}
	return o.GitLFS
}

func (o *GetProjectsProject2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *GetProjectsProject2) GetIPBuckets() []ProjectIPBucket2 {
	if o == nil {
		return nil
	}
	return o.IPBuckets
}

func (o *GetProjectsProject2) GetLatestDeployments() []ProjectLatestDeployment2 {
	if o == nil {
		return nil
	}
	return o.LatestDeployments
}

func (o *GetProjectsProject2) GetLink() *ProjectLinkUnion2 {
	if o == nil {
		return nil
	}
	return o.Link
}

func (o *GetProjectsProject2) GetLinkGithub() *LinkProjectGithub2 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithub2
	}
	return nil
}

func (o *GetProjectsProject2) GetLinkGithubLimited() *LinkProjectGithubLimited2 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithubLimited2
	}
	return nil
}

func (o *GetProjectsProject2) GetLinkGithubCustomHost() *LinkProjectGithubCustomHost2 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGithubCustomHost2
	}
	return nil
}

func (o *GetProjectsProject2) GetLinkGitlab() *LinkProjectGitlab2 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectGitlab2
	}
	return nil
}

func (o *GetProjectsProject2) GetLinkBitbucket() *LinkProjectBitbucket2 {
	if v := o.GetLink(); v != nil {
		return v.LinkProjectBitbucket2
	}
	return nil
}

func (o *GetProjectsProject2) GetMicrofrontends() *GetProjectsMicrofrontendsUnion {
	if o == nil {
		return nil
	}
	return o.Microfrontends
}

func (o *GetProjectsProject2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *GetProjectsProject2) GetNodeVersion() ProjectNodeVersion2 {
	if o == nil {
		return ProjectNodeVersion2("")
	}
	return o.NodeVersion
}

func (o *GetProjectsProject2) GetOptionsAllowlist() *GetProjectsOptionsAllowlist {
	if o == nil {
		return nil
	}
	return o.OptionsAllowlist
}

func (o *GetProjectsProject2) GetOutputDirectory() *string {
	if o == nil {
		return nil
	}
	return o.OutputDirectory
}

func (o *GetProjectsProject2) GetPasswordProtection() *ProjectPasswordProtection2 {
	if o == nil {
		return nil
	}
	return o.PasswordProtection
}

func (o *GetProjectsProject2) GetProductionDeploymentsFastLane() *bool {
	if o == nil {
		return nil
	}
	return o.ProductionDeploymentsFastLane
}

func (o *GetProjectsProject2) GetPublicSource() *bool {
	if o == nil {
		return nil
	}
	return o.PublicSource
}

func (o *GetProjectsProject2) GetResourceConfig() ProjectResourceConfig2 {
	if o == nil {
		return ProjectResourceConfig2{}
	}
	return o.ResourceConfig
}

func (o *GetProjectsProject2) GetRollbackDescription() *GetProjectsRollbackDescription {
	if o == nil {
		return nil
	}
	return o.RollbackDescription
}

func (o *GetProjectsProject2) GetRollingRelease() *ProjectRollingRelease2 {
	if o == nil {
		return nil
	}
	return o.RollingRelease
}

func (o *GetProjectsProject2) GetDefaultResourceConfig() GetProjectsDefaultResourceConfig {
	if o == nil {
		return GetProjectsDefaultResourceConfig{}
	}
	return o.DefaultResourceConfig
}

func (o *GetProjectsProject2) GetRootDirectory() *string {
	if o == nil {
		return nil
	}
	return o.RootDirectory
}

func (o *GetProjectsProject2) GetServerlessFunctionZeroConfigFailover() *bool {
	if o == nil {
		return nil
	}
	return o.ServerlessFunctionZeroConfigFailover
}

func (o *GetProjectsProject2) GetSkewProtectionBoundaryAt() *float64 {
	if o == nil {
		return nil
	}
	return o.SkewProtectionBoundaryAt
}

func (o *GetProjectsProject2) GetSkewProtectionMaxAge() *float64 {
	if o == nil {
		return nil
	}
	return o.SkewProtectionMaxAge
}

func (o *GetProjectsProject2) GetSkewProtectionAllowedDomains() []string {
	if o == nil {
		return nil
	}
	return o.SkewProtectionAllowedDomains
}

func (o *GetProjectsProject2) GetSkipGitConnectDuringLink() *bool {
	if o == nil {
		return nil
	}
	return o.SkipGitConnectDuringLink
}

func (o *GetProjectsProject2) GetStaticIps() *GetProjectsStaticIps {
	if o == nil {
		return nil
	}
	return o.StaticIps
}

func (o *GetProjectsProject2) GetSourceFilesOutsideRootDirectory() *bool {
	if o == nil {
		return nil
	}
	return o.SourceFilesOutsideRootDirectory
}

func (o *GetProjectsProject2) GetEnableAffectedProjectsDeployments() *bool {
	if o == nil {
		return nil
	}
	return o.EnableAffectedProjectsDeployments
}

func (o *GetProjectsProject2) GetSsoProtection() *ProjectSsoProtection2 {
	if o == nil {
		return nil
	}
	return o.SsoProtection
}

func (o *GetProjectsProject2) GetTargets() map[string]*ProjectTargets2 {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *GetProjectsProject2) GetTransferCompletedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferCompletedAt
}

func (o *GetProjectsProject2) GetTransferStartedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.TransferStartedAt
}

func (o *GetProjectsProject2) GetTransferToAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferToAccountID
}

func (o *GetProjectsProject2) GetTransferredFromAccountID() *string {
	if o == nil {
		return nil
	}
	return o.TransferredFromAccountID
}

func (o *GetProjectsProject2) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *GetProjectsProject2) GetLive() *bool {
	if o == nil {
		return nil
	}
	return o.Live
}

func (o *GetProjectsProject2) GetEnablePreviewFeedback() *bool {
	if o == nil {
		return nil
	}
	return o.EnablePreviewFeedback
}

func (o *GetProjectsProject2) GetEnableProductionFeedback() *bool {
	if o == nil {
		return nil
	}
	return o.EnableProductionFeedback
}

func (o *GetProjectsProject2) GetPermissions() *GetProjectsPermissions {
	if o == nil {
		return nil
	}
	return o.Permissions
}

func (o *GetProjectsProject2) GetLastRollbackTarget() *GetProjectsLastRollbackTarget {
	if o == nil {
		return nil
	}
	return o.LastRollbackTarget
}

func (o *GetProjectsProject2) GetLastAliasRequest() *GetProjectsLastAliasRequest {
	if o == nil {
		return nil
	}
	return o.LastAliasRequest
}

func (o *GetProjectsProject2) GetProtectionBypass() map[string]GetProjectsProtectionBypassUnion {
	if o == nil {
		return nil
	}
	return o.ProtectionBypass
}

func (o *GetProjectsProject2) GetHasActiveBranches() *bool {
	if o == nil {
		return nil
	}
	return o.HasActiveBranches
}

func (o *GetProjectsProject2) GetTrustedIps() *GetProjectsTrustedIpsUnion {
	if o == nil {
		return nil
	}
	return o.TrustedIps
}

func (o *GetProjectsProject2) GetGitComments() *ProjectGitComments2 {
	if o == nil {
		return nil
	}
	return o.GitComments
}

func (o *GetProjectsProject2) GetGitProviderOptions() *ProjectGitProviderOptions2 {
	if o == nil {
		return nil
	}
	return o.GitProviderOptions
}

func (o *GetProjectsProject2) GetPaused() *bool {
	if o == nil {
		return nil
	}
	return o.Paused
}

func (o *GetProjectsProject2) GetConcurrencyBucketName() *string {
	if o == nil {
		return nil
	}
	return o.ConcurrencyBucketName
}

func (o *GetProjectsProject2) GetWebAnalytics() *ProjectWebAnalytics2 {
	if o == nil {
		return nil
	}
	return o.WebAnalytics
}

func (o *GetProjectsProject2) GetSecurity() *ProjectSecurity2 {
	if o == nil {
		return nil
	}
	return o.Security
}

func (o *GetProjectsProject2) GetOidcTokenConfig() *ProjectOidcTokenConfig2 {
	if o == nil {
		return nil
	}
	return o.OidcTokenConfig
}

func (o *GetProjectsProject2) GetTier() *ProjectTier2 {
	if o == nil {
		return nil
	}
	return o.Tier
}

func (o *GetProjectsProject2) GetFeatures() *GetProjectsFeatures {
	if o == nil {
		return nil
	}
	return o.Features
}

func (o *GetProjectsProject2) GetV0() *bool {
	if o == nil {
		return nil
	}
	return o.V0
}

func (o *GetProjectsProject2) GetAbuse() *ProjectAbuse2 {
	if o == nil {
		return nil
	}
	return o.Abuse
}

func (o *GetProjectsProject2) GetInternalRoutes() []ProjectInternalRouteUnion2 {
	if o == nil {
		return nil
	}
	return o.InternalRoutes
}

func (o *GetProjectsProject2) GetHasDeployments() *bool {
	if o == nil {
		return nil
	}
	return o.HasDeployments
}

func (o *GetProjectsProject2) GetDismissedToasts() []GetProjectsDismissedToast {
	if o == nil {
		return nil
	}
	return o.DismissedToasts
}

func (o *GetProjectsProject2) GetProtectedSourcemaps() *bool {
	if o == nil {
		return nil
	}
	return o.ProtectedSourcemaps
}

// GetProjectsPagination2 - This object contains information related to the pagination of the current request using continuation tokens. Since CosmosDB doesn't support going to previous pages, only count and next are provided.
type GetProjectsPagination2 struct {
	// Amount of items in the current page.
	Count float64 `json:"count"`
	// Continuation token that must be used to request the next page. Base32 encoded for safe URL transmission.
	Next *string `json:"next"`
}

func (g GetProjectsPagination2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsPagination2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"count", "next"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsPagination2) GetCount() float64 {
	if o == nil {
		return 0.0
	}
	return o.Count
}

func (o *GetProjectsPagination2) GetNext() *string {
	if o == nil {
		return nil
	}
	return o.Next
}

type PaginationUnion2Type string

const (
	PaginationUnion2TypeGetProjectsPagination2 PaginationUnion2Type = "getProjects_pagination_2"
	PaginationUnion2TypePagination             PaginationUnion2Type = "Pagination"
)

type PaginationUnion2 struct {
	GetProjectsPagination2 *GetProjectsPagination2 `queryParam:"inline"`
	Pagination             *components.Pagination  `queryParam:"inline"`

	Type PaginationUnion2Type
}

func CreatePaginationUnion2GetProjectsPagination2(getProjectsPagination2 GetProjectsPagination2) PaginationUnion2 {
	typ := PaginationUnion2TypeGetProjectsPagination2

	return PaginationUnion2{
		GetProjectsPagination2: &getProjectsPagination2,
		Type:                   typ,
	}
}

func CreatePaginationUnion2Pagination(pagination components.Pagination) PaginationUnion2 {
	typ := PaginationUnion2TypePagination

	return PaginationUnion2{
		Pagination: &pagination,
		Type:       typ,
	}
}

func (u *PaginationUnion2) UnmarshalJSON(data []byte) error {

	var pagination components.Pagination = components.Pagination{}
	if err := utils.UnmarshalJSON(data, &pagination, "", true, nil); err == nil {
		u.Pagination = &pagination
		u.Type = PaginationUnion2TypePagination
		return nil
	}

	var getProjectsPagination2 GetProjectsPagination2 = GetProjectsPagination2{}
	if err := utils.UnmarshalJSON(data, &getProjectsPagination2, "", true, nil); err == nil {
		u.GetProjectsPagination2 = &getProjectsPagination2
		u.Type = PaginationUnion2TypeGetProjectsPagination2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for PaginationUnion2", string(data))
}

func (u PaginationUnion2) MarshalJSON() ([]byte, error) {
	if u.GetProjectsPagination2 != nil {
		return utils.MarshalJSON(u.GetProjectsPagination2, "", true)
	}

	if u.Pagination != nil {
		return utils.MarshalJSON(u.Pagination, "", true)
	}

	return nil, errors.New("could not marshal union type PaginationUnion2: all fields are null")
}

type GetProjectsResponseBody3 struct {
	Projects   []GetProjectsProject2 `json:"projects"`
	Pagination PaginationUnion2      `json:"pagination"`
}

func (g GetProjectsResponseBody3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetProjectsResponseBody3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"projects", "pagination"}); err != nil {
		return err
	}
	return nil
}

func (o *GetProjectsResponseBody3) GetProjects() []GetProjectsProject2 {
	if o == nil {
		return []GetProjectsProject2{}
	}
	return o.Projects
}

func (o *GetProjectsResponseBody3) GetPagination() PaginationUnion2 {
	if o == nil {
		return PaginationUnion2{}
	}
	return o.Pagination
}

type ProjectConfiguredBy string

const (
	ProjectConfiguredByA     ProjectConfiguredBy = "A"
	ProjectConfiguredByCname ProjectConfiguredBy = "CNAME"
	ProjectConfiguredByHTTP  ProjectConfiguredBy = "http"
	ProjectConfiguredByDns01 ProjectConfiguredBy = "dns-01"
)

func (e ProjectConfiguredBy) ToPointer() *ProjectConfiguredBy {
	return &e
}
func (e *ProjectConfiguredBy) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "A":
		fallthrough
	case "CNAME":
		fallthrough
	case "http":
		fallthrough
	case "dns-01":
		*e = ProjectConfiguredBy(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectConfiguredBy: %v", v)
	}
}

type ProjectDeploymentAliasAssignedType string

const (
	ProjectDeploymentAliasAssignedTypeNumber  ProjectDeploymentAliasAssignedType = "number"
	ProjectDeploymentAliasAssignedTypeBoolean ProjectDeploymentAliasAssignedType = "boolean"
)

type ProjectDeploymentAliasAssigned struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ProjectDeploymentAliasAssignedType
}

func CreateProjectDeploymentAliasAssignedNumber(number float64) ProjectDeploymentAliasAssigned {
	typ := ProjectDeploymentAliasAssignedTypeNumber

	return ProjectDeploymentAliasAssigned{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectDeploymentAliasAssignedBoolean(boolean bool) ProjectDeploymentAliasAssigned {
	typ := ProjectDeploymentAliasAssignedTypeBoolean

	return ProjectDeploymentAliasAssigned{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ProjectDeploymentAliasAssigned) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ProjectDeploymentAliasAssignedTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ProjectDeploymentAliasAssignedTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectDeploymentAliasAssigned", string(data))
}

func (u ProjectDeploymentAliasAssigned) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectDeploymentAliasAssigned: all fields are null")
}

type ProjectDeploymentBuild struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (p ProjectDeploymentBuild) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeploymentBuild) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeploymentBuild) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *ProjectDeploymentBuild) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *ProjectDeploymentBuild) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type ProjectDeploymentCreator struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (p ProjectDeploymentCreator) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeploymentCreator) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeploymentCreator) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *ProjectDeploymentCreator) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *ProjectDeploymentCreator) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *ProjectDeploymentCreator) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *ProjectDeploymentCreator) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type ProjectDeployment struct {
	Alias              []string                        `json:"alias,omitempty"`
	AliasAssigned      *ProjectDeploymentAliasAssigned `json:"aliasAssigned,omitempty"`
	Builds             []ProjectDeploymentBuild        `json:"builds,omitempty"`
	CreatedAt          float64                         `json:"createdAt"`
	CreatedIn          string                          `json:"createdIn"`
	Creator            *ProjectDeploymentCreator       `json:"creator"`
	DeploymentHostname string                          `json:"deploymentHostname"`
	Name               string                          `json:"name"`
	Forced             *bool                           `json:"forced,omitempty"`
	ID                 string                          `json:"id"`
	Meta               map[string]string               `json:"meta,omitempty"`
	Plan               string                          `json:"plan"`
	Private            bool                            `json:"private"`
	ReadyState         string                          `json:"readyState"`
	RequestedAt        *float64                        `json:"requestedAt,omitempty"`
	Target             *string                         `json:"target,omitempty"`
	TeamID             *string                         `json:"teamId,omitempty"`
	Type               string                          `json:"type"`
	URL                string                          `json:"url"`
	UserID             string                          `json:"userId"`
	WithCache          *bool                           `json:"withCache,omitempty"`
}

func (p ProjectDeployment) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployment) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployment) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *ProjectDeployment) GetAliasAssigned() *ProjectDeploymentAliasAssigned {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *ProjectDeployment) GetBuilds() []ProjectDeploymentBuild {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *ProjectDeployment) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ProjectDeployment) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *ProjectDeployment) GetCreator() *ProjectDeploymentCreator {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *ProjectDeployment) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *ProjectDeployment) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployment) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *ProjectDeployment) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployment) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *ProjectDeployment) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *ProjectDeployment) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *ProjectDeployment) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *ProjectDeployment) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *ProjectDeployment) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *ProjectDeployment) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ProjectDeployment) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *ProjectDeployment) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *ProjectDeployment) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *ProjectDeployment) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type ProjectEnvironment string

const (
	ProjectEnvironmentProduction ProjectEnvironment = "production"
	ProjectEnvironmentPreview    ProjectEnvironment = "preview"
)

func (e ProjectEnvironment) ToPointer() *ProjectEnvironment {
	return &e
}
func (e *ProjectEnvironment) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		*e = ProjectEnvironment(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectEnvironment: %v", v)
	}
}

type ProjectAliasTarget string

const (
	ProjectAliasTargetProduction ProjectAliasTarget = "PRODUCTION"
	ProjectAliasTargetStaging    ProjectAliasTarget = "STAGING"
	ProjectAliasTargetPreview    ProjectAliasTarget = "PREVIEW"
)

func (e ProjectAliasTarget) ToPointer() *ProjectAliasTarget {
	return &e
}
func (e *ProjectAliasTarget) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "PRODUCTION":
		fallthrough
	case "STAGING":
		fallthrough
	case "PREVIEW":
		*e = ProjectAliasTarget(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectAliasTarget: %v", v)
	}
}

type ProjectAlias struct {
	ConfiguredBy        *ProjectConfiguredBy `json:"configuredBy,omitempty"`
	ConfiguredChangedAt *float64             `json:"configuredChangedAt,omitempty"`
	CreatedAt           *float64             `json:"createdAt,omitempty"`
	Deployment          *ProjectDeployment   `json:"deployment"`
	Domain              string               `json:"domain"`
	Environment         ProjectEnvironment   `json:"environment"`
	GitBranch           *string              `json:"gitBranch,omitempty"`
	Redirect            *string              `json:"redirect,omitempty"`
	RedirectStatusCode  *float64             `json:"redirectStatusCode,omitempty"`
	Target              ProjectAliasTarget   `json:"target"`
}

func (p ProjectAlias) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectAlias) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"deployment", "domain", "environment", "target"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectAlias) GetConfiguredBy() *ProjectConfiguredBy {
	if o == nil {
		return nil
	}
	return o.ConfiguredBy
}

func (o *ProjectAlias) GetConfiguredChangedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.ConfiguredChangedAt
}

func (o *ProjectAlias) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectAlias) GetDeployment() *ProjectDeployment {
	if o == nil {
		return nil
	}
	return o.Deployment
}

func (o *ProjectAlias) GetDomain() string {
	if o == nil {
		return ""
	}
	return o.Domain
}

func (o *ProjectAlias) GetEnvironment() ProjectEnvironment {
	if o == nil {
		return ProjectEnvironment("")
	}
	return o.Environment
}

func (o *ProjectAlias) GetGitBranch() *string {
	if o == nil {
		return nil
	}
	return o.GitBranch
}

func (o *ProjectAlias) GetRedirect() *string {
	if o == nil {
		return nil
	}
	return o.Redirect
}

func (o *ProjectAlias) GetRedirectStatusCode() *float64 {
	if o == nil {
		return nil
	}
	return o.RedirectStatusCode
}

func (o *ProjectAlias) GetTarget() ProjectAliasTarget {
	if o == nil {
		return ProjectAliasTarget("")
	}
	return o.Target
}

type ProjectAnalytics1 struct {
	ID                  string   `json:"id"`
	CanceledAt          *float64 `json:"canceledAt,omitempty"`
	DisabledAt          float64  `json:"disabledAt"`
	EnabledAt           float64  `json:"enabledAt"`
	PaidAt              *float64 `json:"paidAt,omitempty"`
	SampleRatePercent   *float64 `json:"sampleRatePercent,omitempty"`
	SpendLimitInDollars *float64 `json:"spendLimitInDollars,omitempty"`
}

func (p ProjectAnalytics1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectAnalytics1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "disabledAt", "enabledAt"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectAnalytics1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectAnalytics1) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *ProjectAnalytics1) GetDisabledAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.DisabledAt
}

func (o *ProjectAnalytics1) GetEnabledAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.EnabledAt
}

func (o *ProjectAnalytics1) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

func (o *ProjectAnalytics1) GetSampleRatePercent() *float64 {
	if o == nil {
		return nil
	}
	return o.SampleRatePercent
}

func (o *ProjectAnalytics1) GetSpendLimitInDollars() *float64 {
	if o == nil {
		return nil
	}
	return o.SpendLimitInDollars
}

// ProjectDeploymentExpiration1 - Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
type ProjectDeploymentExpiration1 struct {
	// Number of days to keep non-production deployments (mostly preview deployments) before soft deletion.
	ExpirationDays *float64 `json:"expirationDays,omitempty"`
	// Number of days to keep production deployments before soft deletion.
	ExpirationDaysProduction *float64 `json:"expirationDaysProduction,omitempty"`
	// Number of days to keep canceled deployments before soft deletion.
	ExpirationDaysCanceled *float64 `json:"expirationDaysCanceled,omitempty"`
	// Number of days to keep errored deployments before soft deletion.
	ExpirationDaysErrored *float64 `json:"expirationDaysErrored,omitempty"`
	// Minimum number of production deployments to keep for this project, even if they are over the production expiration limit.
	DeploymentsToKeep *float64 `json:"deploymentsToKeep,omitempty"`
}

func (p ProjectDeploymentExpiration1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeploymentExpiration1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeploymentExpiration1) GetExpirationDays() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDays
}

func (o *ProjectDeploymentExpiration1) GetExpirationDaysProduction() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysProduction
}

func (o *ProjectDeploymentExpiration1) GetExpirationDaysCanceled() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysCanceled
}

func (o *ProjectDeploymentExpiration1) GetExpirationDaysErrored() *float64 {
	if o == nil {
		return nil
	}
	return o.ExpirationDaysErrored
}

func (o *ProjectDeploymentExpiration1) GetDeploymentsToKeep() *float64 {
	if o == nil {
		return nil
	}
	return o.DeploymentsToKeep
}

type ProjectIPBucket1 struct {
	Bucket       string   `json:"bucket"`
	SupportUntil *float64 `json:"supportUntil,omitempty"`
}

func (p ProjectIPBucket1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectIPBucket1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"bucket"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectIPBucket1) GetBucket() string {
	if o == nil {
		return ""
	}
	return o.Bucket
}

func (o *ProjectIPBucket1) GetSupportUntil() *float64 {
	if o == nil {
		return nil
	}
	return o.SupportUntil
}

type TargetProjectEnvEnum2 string

const (
	TargetProjectEnvEnum2Production  TargetProjectEnvEnum2 = "production"
	TargetProjectEnvEnum2Preview     TargetProjectEnvEnum2 = "preview"
	TargetProjectEnvEnum2Development TargetProjectEnvEnum2 = "development"
)

func (e TargetProjectEnvEnum2) ToPointer() *TargetProjectEnvEnum2 {
	return &e
}
func (e *TargetProjectEnvEnum2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		fallthrough
	case "development":
		*e = TargetProjectEnvEnum2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TargetProjectEnvEnum2: %v", v)
	}
}

type TargetProjectEnvEnum1 string

const (
	TargetProjectEnvEnum1Production  TargetProjectEnvEnum1 = "production"
	TargetProjectEnvEnum1Preview     TargetProjectEnvEnum1 = "preview"
	TargetProjectEnvEnum1Development TargetProjectEnvEnum1 = "development"
)

func (e TargetProjectEnvEnum1) ToPointer() *TargetProjectEnvEnum1 {
	return &e
}
func (e *TargetProjectEnvEnum1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "production":
		fallthrough
	case "preview":
		fallthrough
	case "development":
		*e = TargetProjectEnvEnum1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TargetProjectEnvEnum1: %v", v)
	}
}

type ProjectTargetUnion1Type string

const (
	ProjectTargetUnion1TypeArrayOfTargetProjectEnvEnum1 ProjectTargetUnion1Type = "arrayOfTargetProjectEnvEnum1"
	ProjectTargetUnion1TypeTargetProjectEnvEnum2        ProjectTargetUnion1Type = "target_project_env_enum_2"
)

type ProjectTargetUnion1 struct {
	ArrayOfTargetProjectEnvEnum1 []TargetProjectEnvEnum1 `queryParam:"inline"`
	TargetProjectEnvEnum2        *TargetProjectEnvEnum2  `queryParam:"inline"`

	Type ProjectTargetUnion1Type
}

func CreateProjectTargetUnion1ArrayOfTargetProjectEnvEnum1(arrayOfTargetProjectEnvEnum1 []TargetProjectEnvEnum1) ProjectTargetUnion1 {
	typ := ProjectTargetUnion1TypeArrayOfTargetProjectEnvEnum1

	return ProjectTargetUnion1{
		ArrayOfTargetProjectEnvEnum1: arrayOfTargetProjectEnvEnum1,
		Type:                         typ,
	}
}

func CreateProjectTargetUnion1TargetProjectEnvEnum2(targetProjectEnvEnum2 TargetProjectEnvEnum2) ProjectTargetUnion1 {
	typ := ProjectTargetUnion1TypeTargetProjectEnvEnum2

	return ProjectTargetUnion1{
		TargetProjectEnvEnum2: &targetProjectEnvEnum2,
		Type:                  typ,
	}
}

func (u *ProjectTargetUnion1) UnmarshalJSON(data []byte) error {

	var arrayOfTargetProjectEnvEnum1 []TargetProjectEnvEnum1 = []TargetProjectEnvEnum1{}
	if err := utils.UnmarshalJSON(data, &arrayOfTargetProjectEnvEnum1, "", true, nil); err == nil {
		u.ArrayOfTargetProjectEnvEnum1 = arrayOfTargetProjectEnvEnum1
		u.Type = ProjectTargetUnion1TypeArrayOfTargetProjectEnvEnum1
		return nil
	}

	var targetProjectEnvEnum2 TargetProjectEnvEnum2 = TargetProjectEnvEnum2("")
	if err := utils.UnmarshalJSON(data, &targetProjectEnvEnum2, "", true, nil); err == nil {
		u.TargetProjectEnvEnum2 = &targetProjectEnvEnum2
		u.Type = ProjectTargetUnion1TypeTargetProjectEnvEnum2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectTargetUnion1", string(data))
}

func (u ProjectTargetUnion1) MarshalJSON() ([]byte, error) {
	if u.ArrayOfTargetProjectEnvEnum1 != nil {
		return utils.MarshalJSON(u.ArrayOfTargetProjectEnvEnum1, "", true)
	}

	if u.TargetProjectEnvEnum2 != nil {
		return utils.MarshalJSON(u.TargetProjectEnvEnum2, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectTargetUnion1: all fields are null")
}

type ProjectEnvType1 string

const (
	ProjectEnvType1Secret    ProjectEnvType1 = "secret"
	ProjectEnvType1System    ProjectEnvType1 = "system"
	ProjectEnvType1Encrypted ProjectEnvType1 = "encrypted"
	ProjectEnvType1Plain     ProjectEnvType1 = "plain"
	ProjectEnvType1Sensitive ProjectEnvType1 = "sensitive"
)

func (e ProjectEnvType1) ToPointer() *ProjectEnvType1 {
	return &e
}
func (e *ProjectEnvType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "secret":
		fallthrough
	case "system":
		fallthrough
	case "encrypted":
		fallthrough
	case "plain":
		fallthrough
	case "sensitive":
		*e = ProjectEnvType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectEnvType1: %v", v)
	}
}

type ProjectTypeFlagsConnectionString1 string

const (
	ProjectTypeFlagsConnectionString1FlagsConnectionString ProjectTypeFlagsConnectionString1 = "flags-connection-string"
)

func (e ProjectTypeFlagsConnectionString1) ToPointer() *ProjectTypeFlagsConnectionString1 {
	return &e
}
func (e *ProjectTypeFlagsConnectionString1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flags-connection-string":
		*e = ProjectTypeFlagsConnectionString1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeFlagsConnectionString1: %v", v)
	}
}

type ContentHintProjectFlagsConnectionString1 struct {
	Type      ProjectTypeFlagsConnectionString1 `json:"type"`
	ProjectID string                            `json:"projectId"`
}

func (c ContentHintProjectFlagsConnectionString1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectFlagsConnectionString1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "projectId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectFlagsConnectionString1) GetType() ProjectTypeFlagsConnectionString1 {
	if o == nil {
		return ProjectTypeFlagsConnectionString1("")
	}
	return o.Type
}

func (o *ContentHintProjectFlagsConnectionString1) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

type ProjectTypeIntegrationStoreSecret1 string

const (
	ProjectTypeIntegrationStoreSecret1IntegrationStoreSecret ProjectTypeIntegrationStoreSecret1 = "integration-store-secret"
)

func (e ProjectTypeIntegrationStoreSecret1) ToPointer() *ProjectTypeIntegrationStoreSecret1 {
	return &e
}
func (e *ProjectTypeIntegrationStoreSecret1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-store-secret":
		*e = ProjectTypeIntegrationStoreSecret1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeIntegrationStoreSecret1: %v", v)
	}
}

type ContentHintProjectIntegrationStoreSecret1 struct {
	Type                       ProjectTypeIntegrationStoreSecret1 `json:"type"`
	StoreID                    string                             `json:"storeId"`
	IntegrationID              string                             `json:"integrationId"`
	IntegrationProductID       string                             `json:"integrationProductId"`
	IntegrationConfigurationID string                             `json:"integrationConfigurationId"`
}

func (c ContentHintProjectIntegrationStoreSecret1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectIntegrationStoreSecret1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId", "integrationId", "integrationProductId", "integrationConfigurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectIntegrationStoreSecret1) GetType() ProjectTypeIntegrationStoreSecret1 {
	if o == nil {
		return ProjectTypeIntegrationStoreSecret1("")
	}
	return o.Type
}

func (o *ContentHintProjectIntegrationStoreSecret1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

func (o *ContentHintProjectIntegrationStoreSecret1) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *ContentHintProjectIntegrationStoreSecret1) GetIntegrationProductID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationProductID
}

func (o *ContentHintProjectIntegrationStoreSecret1) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

type ProjectTypePostgresURLNoSsl1 string

const (
	ProjectTypePostgresURLNoSsl1PostgresURLNoSsl ProjectTypePostgresURLNoSsl1 = "postgres-url-no-ssl"
)

func (e ProjectTypePostgresURLNoSsl1) ToPointer() *ProjectTypePostgresURLNoSsl1 {
	return &e
}
func (e *ProjectTypePostgresURLNoSsl1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url-no-ssl":
		*e = ProjectTypePostgresURLNoSsl1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresURLNoSsl1: %v", v)
	}
}

type ContentHintProjectPostgresURLNoSsl1 struct {
	Type    ProjectTypePostgresURLNoSsl1 `json:"type"`
	StoreID string                       `json:"storeId"`
}

func (c ContentHintProjectPostgresURLNoSsl1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresURLNoSsl1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresURLNoSsl1) GetType() ProjectTypePostgresURLNoSsl1 {
	if o == nil {
		return ProjectTypePostgresURLNoSsl1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresURLNoSsl1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresDatabase1 string

const (
	ProjectTypePostgresDatabase1PostgresDatabase ProjectTypePostgresDatabase1 = "postgres-database"
)

func (e ProjectTypePostgresDatabase1) ToPointer() *ProjectTypePostgresDatabase1 {
	return &e
}
func (e *ProjectTypePostgresDatabase1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-database":
		*e = ProjectTypePostgresDatabase1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresDatabase1: %v", v)
	}
}

type ContentHintProjectPostgresDatabase1 struct {
	Type    ProjectTypePostgresDatabase1 `json:"type"`
	StoreID string                       `json:"storeId"`
}

func (c ContentHintProjectPostgresDatabase1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresDatabase1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresDatabase1) GetType() ProjectTypePostgresDatabase1 {
	if o == nil {
		return ProjectTypePostgresDatabase1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresDatabase1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresPassword1 string

const (
	ProjectTypePostgresPassword1PostgresPassword ProjectTypePostgresPassword1 = "postgres-password"
)

func (e ProjectTypePostgresPassword1) ToPointer() *ProjectTypePostgresPassword1 {
	return &e
}
func (e *ProjectTypePostgresPassword1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-password":
		*e = ProjectTypePostgresPassword1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresPassword1: %v", v)
	}
}

type ContentHintProjectPostgresPassword1 struct {
	Type    ProjectTypePostgresPassword1 `json:"type"`
	StoreID string                       `json:"storeId"`
}

func (c ContentHintProjectPostgresPassword1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresPassword1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresPassword1) GetType() ProjectTypePostgresPassword1 {
	if o == nil {
		return ProjectTypePostgresPassword1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresPassword1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresHost1 string

const (
	ProjectTypePostgresHost1PostgresHost ProjectTypePostgresHost1 = "postgres-host"
)

func (e ProjectTypePostgresHost1) ToPointer() *ProjectTypePostgresHost1 {
	return &e
}
func (e *ProjectTypePostgresHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-host":
		*e = ProjectTypePostgresHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresHost1: %v", v)
	}
}

type ContentHintProjectPostgresHost1 struct {
	Type    ProjectTypePostgresHost1 `json:"type"`
	StoreID string                   `json:"storeId"`
}

func (c ContentHintProjectPostgresHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresHost1) GetType() ProjectTypePostgresHost1 {
	if o == nil {
		return ProjectTypePostgresHost1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresHost1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresUser1 string

const (
	ProjectTypePostgresUser1PostgresUser ProjectTypePostgresUser1 = "postgres-user"
)

func (e ProjectTypePostgresUser1) ToPointer() *ProjectTypePostgresUser1 {
	return &e
}
func (e *ProjectTypePostgresUser1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-user":
		*e = ProjectTypePostgresUser1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresUser1: %v", v)
	}
}

type ContentHintProjectPostgresUser1 struct {
	Type    ProjectTypePostgresUser1 `json:"type"`
	StoreID string                   `json:"storeId"`
}

func (c ContentHintProjectPostgresUser1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresUser1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresUser1) GetType() ProjectTypePostgresUser1 {
	if o == nil {
		return ProjectTypePostgresUser1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresUser1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresPrismaURL1 string

const (
	ProjectTypePostgresPrismaURL1PostgresPrismaURL ProjectTypePostgresPrismaURL1 = "postgres-prisma-url"
)

func (e ProjectTypePostgresPrismaURL1) ToPointer() *ProjectTypePostgresPrismaURL1 {
	return &e
}
func (e *ProjectTypePostgresPrismaURL1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-prisma-url":
		*e = ProjectTypePostgresPrismaURL1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresPrismaURL1: %v", v)
	}
}

type ContentHintProjectPostgresPrismaURL1 struct {
	Type    ProjectTypePostgresPrismaURL1 `json:"type"`
	StoreID string                        `json:"storeId"`
}

func (c ContentHintProjectPostgresPrismaURL1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresPrismaURL1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresPrismaURL1) GetType() ProjectTypePostgresPrismaURL1 {
	if o == nil {
		return ProjectTypePostgresPrismaURL1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresPrismaURL1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresURLNonPooling1 string

const (
	ProjectTypePostgresURLNonPooling1PostgresURLNonPooling ProjectTypePostgresURLNonPooling1 = "postgres-url-non-pooling"
)

func (e ProjectTypePostgresURLNonPooling1) ToPointer() *ProjectTypePostgresURLNonPooling1 {
	return &e
}
func (e *ProjectTypePostgresURLNonPooling1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url-non-pooling":
		*e = ProjectTypePostgresURLNonPooling1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresURLNonPooling1: %v", v)
	}
}

type ContentHintProjectPostgresURLNonPooling1 struct {
	Type    ProjectTypePostgresURLNonPooling1 `json:"type"`
	StoreID string                            `json:"storeId"`
}

func (c ContentHintProjectPostgresURLNonPooling1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresURLNonPooling1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresURLNonPooling1) GetType() ProjectTypePostgresURLNonPooling1 {
	if o == nil {
		return ProjectTypePostgresURLNonPooling1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresURLNonPooling1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypePostgresURL1 string

const (
	ProjectTypePostgresURL1PostgresURL ProjectTypePostgresURL1 = "postgres-url"
)

func (e ProjectTypePostgresURL1) ToPointer() *ProjectTypePostgresURL1 {
	return &e
}
func (e *ProjectTypePostgresURL1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "postgres-url":
		*e = ProjectTypePostgresURL1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypePostgresURL1: %v", v)
	}
}

type ContentHintProjectPostgresURL1 struct {
	Type    ProjectTypePostgresURL1 `json:"type"`
	StoreID string                  `json:"storeId"`
}

func (c ContentHintProjectPostgresURL1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectPostgresURL1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectPostgresURL1) GetType() ProjectTypePostgresURL1 {
	if o == nil {
		return ProjectTypePostgresURL1("")
	}
	return o.Type
}

func (o *ContentHintProjectPostgresURL1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypeBlobReadWriteToken1 string

const (
	ProjectTypeBlobReadWriteToken1BlobReadWriteToken ProjectTypeBlobReadWriteToken1 = "blob-read-write-token"
)

func (e ProjectTypeBlobReadWriteToken1) ToPointer() *ProjectTypeBlobReadWriteToken1 {
	return &e
}
func (e *ProjectTypeBlobReadWriteToken1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "blob-read-write-token":
		*e = ProjectTypeBlobReadWriteToken1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeBlobReadWriteToken1: %v", v)
	}
}

type ContentHintProjectBlobReadWriteToken1 struct {
	Type    ProjectTypeBlobReadWriteToken1 `json:"type"`
	StoreID string                         `json:"storeId"`
}

func (c ContentHintProjectBlobReadWriteToken1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectBlobReadWriteToken1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectBlobReadWriteToken1) GetType() ProjectTypeBlobReadWriteToken1 {
	if o == nil {
		return ProjectTypeBlobReadWriteToken1("")
	}
	return o.Type
}

func (o *ContentHintProjectBlobReadWriteToken1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypeRedisRestAPIReadOnlyToken1 string

const (
	ProjectTypeRedisRestAPIReadOnlyToken1RedisRestAPIReadOnlyToken ProjectTypeRedisRestAPIReadOnlyToken1 = "redis-rest-api-read-only-token"
)

func (e ProjectTypeRedisRestAPIReadOnlyToken1) ToPointer() *ProjectTypeRedisRestAPIReadOnlyToken1 {
	return &e
}
func (e *ProjectTypeRedisRestAPIReadOnlyToken1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-read-only-token":
		*e = ProjectTypeRedisRestAPIReadOnlyToken1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeRedisRestAPIReadOnlyToken1: %v", v)
	}
}

type ContentHintProjectRedisRestAPIReadOnlyToken1 struct {
	Type    ProjectTypeRedisRestAPIReadOnlyToken1 `json:"type"`
	StoreID string                                `json:"storeId"`
}

func (c ContentHintProjectRedisRestAPIReadOnlyToken1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectRedisRestAPIReadOnlyToken1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectRedisRestAPIReadOnlyToken1) GetType() ProjectTypeRedisRestAPIReadOnlyToken1 {
	if o == nil {
		return ProjectTypeRedisRestAPIReadOnlyToken1("")
	}
	return o.Type
}

func (o *ContentHintProjectRedisRestAPIReadOnlyToken1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypeRedisRestAPIToken1 string

const (
	ProjectTypeRedisRestAPIToken1RedisRestAPIToken ProjectTypeRedisRestAPIToken1 = "redis-rest-api-token"
)

func (e ProjectTypeRedisRestAPIToken1) ToPointer() *ProjectTypeRedisRestAPIToken1 {
	return &e
}
func (e *ProjectTypeRedisRestAPIToken1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-token":
		*e = ProjectTypeRedisRestAPIToken1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeRedisRestAPIToken1: %v", v)
	}
}

type ContentHintProjectRedisRestAPIToken1 struct {
	Type    ProjectTypeRedisRestAPIToken1 `json:"type"`
	StoreID string                        `json:"storeId"`
}

func (c ContentHintProjectRedisRestAPIToken1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectRedisRestAPIToken1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectRedisRestAPIToken1) GetType() ProjectTypeRedisRestAPIToken1 {
	if o == nil {
		return ProjectTypeRedisRestAPIToken1("")
	}
	return o.Type
}

func (o *ContentHintProjectRedisRestAPIToken1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypeRedisRestAPIURL1 string

const (
	ProjectTypeRedisRestAPIURL1RedisRestAPIURL ProjectTypeRedisRestAPIURL1 = "redis-rest-api-url"
)

func (e ProjectTypeRedisRestAPIURL1) ToPointer() *ProjectTypeRedisRestAPIURL1 {
	return &e
}
func (e *ProjectTypeRedisRestAPIURL1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-rest-api-url":
		*e = ProjectTypeRedisRestAPIURL1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeRedisRestAPIURL1: %v", v)
	}
}

type ContentHintProjectRedisRestAPIURL1 struct {
	Type    ProjectTypeRedisRestAPIURL1 `json:"type"`
	StoreID string                      `json:"storeId"`
}

func (c ContentHintProjectRedisRestAPIURL1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectRedisRestAPIURL1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectRedisRestAPIURL1) GetType() ProjectTypeRedisRestAPIURL1 {
	if o == nil {
		return ProjectTypeRedisRestAPIURL1("")
	}
	return o.Type
}

func (o *ContentHintProjectRedisRestAPIURL1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectTypeRedisURL1 string

const (
	ProjectTypeRedisURL1RedisURL ProjectTypeRedisURL1 = "redis-url"
)

func (e ProjectTypeRedisURL1) ToPointer() *ProjectTypeRedisURL1 {
	return &e
}
func (e *ProjectTypeRedisURL1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "redis-url":
		*e = ProjectTypeRedisURL1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeRedisURL1: %v", v)
	}
}

type ContentHintProjectRedisURL1 struct {
	Type    ProjectTypeRedisURL1 `json:"type"`
	StoreID string               `json:"storeId"`
}

func (c ContentHintProjectRedisURL1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(c, "", false)
}

func (c *ContentHintProjectRedisURL1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &c, "", false, []string{"type", "storeId"}); err != nil {
		return err
	}
	return nil
}

func (o *ContentHintProjectRedisURL1) GetType() ProjectTypeRedisURL1 {
	if o == nil {
		return ProjectTypeRedisURL1("")
	}
	return o.Type
}

func (o *ContentHintProjectRedisURL1) GetStoreID() string {
	if o == nil {
		return ""
	}
	return o.StoreID
}

type ProjectContentHintUnion1Type string

const (
	ProjectContentHintUnion1TypeRedisURL                  ProjectContentHintUnion1Type = "redis-url"
	ProjectContentHintUnion1TypeRedisRestAPIURL           ProjectContentHintUnion1Type = "redis-rest-api-url"
	ProjectContentHintUnion1TypeRedisRestAPIToken         ProjectContentHintUnion1Type = "redis-rest-api-token"
	ProjectContentHintUnion1TypeRedisRestAPIReadOnlyToken ProjectContentHintUnion1Type = "redis-rest-api-read-only-token"
	ProjectContentHintUnion1TypeBlobReadWriteToken        ProjectContentHintUnion1Type = "blob-read-write-token"
	ProjectContentHintUnion1TypePostgresURL               ProjectContentHintUnion1Type = "postgres-url"
	ProjectContentHintUnion1TypePostgresURLNonPooling     ProjectContentHintUnion1Type = "postgres-url-non-pooling"
	ProjectContentHintUnion1TypePostgresPrismaURL         ProjectContentHintUnion1Type = "postgres-prisma-url"
	ProjectContentHintUnion1TypePostgresUser              ProjectContentHintUnion1Type = "postgres-user"
	ProjectContentHintUnion1TypePostgresHost              ProjectContentHintUnion1Type = "postgres-host"
	ProjectContentHintUnion1TypePostgresPassword          ProjectContentHintUnion1Type = "postgres-password"
	ProjectContentHintUnion1TypePostgresDatabase          ProjectContentHintUnion1Type = "postgres-database"
	ProjectContentHintUnion1TypePostgresURLNoSsl          ProjectContentHintUnion1Type = "postgres-url-no-ssl"
	ProjectContentHintUnion1TypeIntegrationStoreSecret    ProjectContentHintUnion1Type = "integration-store-secret"
	ProjectContentHintUnion1TypeFlagsConnectionString     ProjectContentHintUnion1Type = "flags-connection-string"
)

type ProjectContentHintUnion1 struct {
	ContentHintProjectRedisURL1                  *ContentHintProjectRedisURL1                  `queryParam:"inline"`
	ContentHintProjectRedisRestAPIURL1           *ContentHintProjectRedisRestAPIURL1           `queryParam:"inline"`
	ContentHintProjectRedisRestAPIToken1         *ContentHintProjectRedisRestAPIToken1         `queryParam:"inline"`
	ContentHintProjectRedisRestAPIReadOnlyToken1 *ContentHintProjectRedisRestAPIReadOnlyToken1 `queryParam:"inline"`
	ContentHintProjectBlobReadWriteToken1        *ContentHintProjectBlobReadWriteToken1        `queryParam:"inline"`
	ContentHintProjectPostgresURL1               *ContentHintProjectPostgresURL1               `queryParam:"inline"`
	ContentHintProjectPostgresURLNonPooling1     *ContentHintProjectPostgresURLNonPooling1     `queryParam:"inline"`
	ContentHintProjectPostgresPrismaURL1         *ContentHintProjectPostgresPrismaURL1         `queryParam:"inline"`
	ContentHintProjectPostgresUser1              *ContentHintProjectPostgresUser1              `queryParam:"inline"`
	ContentHintProjectPostgresHost1              *ContentHintProjectPostgresHost1              `queryParam:"inline"`
	ContentHintProjectPostgresPassword1          *ContentHintProjectPostgresPassword1          `queryParam:"inline"`
	ContentHintProjectPostgresDatabase1          *ContentHintProjectPostgresDatabase1          `queryParam:"inline"`
	ContentHintProjectPostgresURLNoSsl1          *ContentHintProjectPostgresURLNoSsl1          `queryParam:"inline"`
	ContentHintProjectIntegrationStoreSecret1    *ContentHintProjectIntegrationStoreSecret1    `queryParam:"inline"`
	ContentHintProjectFlagsConnectionString1     *ContentHintProjectFlagsConnectionString1     `queryParam:"inline"`

	Type ProjectContentHintUnion1Type
}

func CreateProjectContentHintUnion1RedisURL(redisURL ContentHintProjectRedisURL1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeRedisURL

	typStr := ProjectTypeRedisURL1(typ)
	redisURL.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectRedisURL1: &redisURL,
		Type:                        typ,
	}
}

func CreateProjectContentHintUnion1RedisRestAPIURL(redisRestAPIURL ContentHintProjectRedisRestAPIURL1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeRedisRestAPIURL

	typStr := ProjectTypeRedisRestAPIURL1(typ)
	redisRestAPIURL.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectRedisRestAPIURL1: &redisRestAPIURL,
		Type:                               typ,
	}
}

func CreateProjectContentHintUnion1RedisRestAPIToken(redisRestAPIToken ContentHintProjectRedisRestAPIToken1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeRedisRestAPIToken

	typStr := ProjectTypeRedisRestAPIToken1(typ)
	redisRestAPIToken.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectRedisRestAPIToken1: &redisRestAPIToken,
		Type:                                 typ,
	}
}

func CreateProjectContentHintUnion1RedisRestAPIReadOnlyToken(redisRestAPIReadOnlyToken ContentHintProjectRedisRestAPIReadOnlyToken1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeRedisRestAPIReadOnlyToken

	typStr := ProjectTypeRedisRestAPIReadOnlyToken1(typ)
	redisRestAPIReadOnlyToken.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectRedisRestAPIReadOnlyToken1: &redisRestAPIReadOnlyToken,
		Type: typ,
	}
}

func CreateProjectContentHintUnion1BlobReadWriteToken(blobReadWriteToken ContentHintProjectBlobReadWriteToken1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeBlobReadWriteToken

	typStr := ProjectTypeBlobReadWriteToken1(typ)
	blobReadWriteToken.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectBlobReadWriteToken1: &blobReadWriteToken,
		Type:                                  typ,
	}
}

func CreateProjectContentHintUnion1PostgresURL(postgresURL ContentHintProjectPostgresURL1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresURL

	typStr := ProjectTypePostgresURL1(typ)
	postgresURL.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresURL1: &postgresURL,
		Type:                           typ,
	}
}

func CreateProjectContentHintUnion1PostgresURLNonPooling(postgresURLNonPooling ContentHintProjectPostgresURLNonPooling1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresURLNonPooling

	typStr := ProjectTypePostgresURLNonPooling1(typ)
	postgresURLNonPooling.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresURLNonPooling1: &postgresURLNonPooling,
		Type:                                     typ,
	}
}

func CreateProjectContentHintUnion1PostgresPrismaURL(postgresPrismaURL ContentHintProjectPostgresPrismaURL1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresPrismaURL

	typStr := ProjectTypePostgresPrismaURL1(typ)
	postgresPrismaURL.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresPrismaURL1: &postgresPrismaURL,
		Type:                                 typ,
	}
}

func CreateProjectContentHintUnion1PostgresUser(postgresUser ContentHintProjectPostgresUser1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresUser

	typStr := ProjectTypePostgresUser1(typ)
	postgresUser.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresUser1: &postgresUser,
		Type:                            typ,
	}
}

func CreateProjectContentHintUnion1PostgresHost(postgresHost ContentHintProjectPostgresHost1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresHost

	typStr := ProjectTypePostgresHost1(typ)
	postgresHost.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresHost1: &postgresHost,
		Type:                            typ,
	}
}

func CreateProjectContentHintUnion1PostgresPassword(postgresPassword ContentHintProjectPostgresPassword1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresPassword

	typStr := ProjectTypePostgresPassword1(typ)
	postgresPassword.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresPassword1: &postgresPassword,
		Type:                                typ,
	}
}

func CreateProjectContentHintUnion1PostgresDatabase(postgresDatabase ContentHintProjectPostgresDatabase1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresDatabase

	typStr := ProjectTypePostgresDatabase1(typ)
	postgresDatabase.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresDatabase1: &postgresDatabase,
		Type:                                typ,
	}
}

func CreateProjectContentHintUnion1PostgresURLNoSsl(postgresURLNoSsl ContentHintProjectPostgresURLNoSsl1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypePostgresURLNoSsl

	typStr := ProjectTypePostgresURLNoSsl1(typ)
	postgresURLNoSsl.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectPostgresURLNoSsl1: &postgresURLNoSsl,
		Type:                                typ,
	}
}

func CreateProjectContentHintUnion1IntegrationStoreSecret(integrationStoreSecret ContentHintProjectIntegrationStoreSecret1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeIntegrationStoreSecret

	typStr := ProjectTypeIntegrationStoreSecret1(typ)
	integrationStoreSecret.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectIntegrationStoreSecret1: &integrationStoreSecret,
		Type: typ,
	}
}

func CreateProjectContentHintUnion1FlagsConnectionString(flagsConnectionString ContentHintProjectFlagsConnectionString1) ProjectContentHintUnion1 {
	typ := ProjectContentHintUnion1TypeFlagsConnectionString

	typStr := ProjectTypeFlagsConnectionString1(typ)
	flagsConnectionString.Type = typStr

	return ProjectContentHintUnion1{
		ContentHintProjectFlagsConnectionString1: &flagsConnectionString,
		Type:                                     typ,
	}
}

func (u *ProjectContentHintUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "redis-url":
		contentHintProjectRedisURL1 := new(ContentHintProjectRedisURL1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectRedisURL1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-url) type ContentHintProjectRedisURL1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectRedisURL1 = contentHintProjectRedisURL1
		u.Type = ProjectContentHintUnion1TypeRedisURL
		return nil
	case "redis-rest-api-url":
		contentHintProjectRedisRestAPIURL1 := new(ContentHintProjectRedisRestAPIURL1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectRedisRestAPIURL1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-url) type ContentHintProjectRedisRestAPIURL1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectRedisRestAPIURL1 = contentHintProjectRedisRestAPIURL1
		u.Type = ProjectContentHintUnion1TypeRedisRestAPIURL
		return nil
	case "redis-rest-api-token":
		contentHintProjectRedisRestAPIToken1 := new(ContentHintProjectRedisRestAPIToken1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectRedisRestAPIToken1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-token) type ContentHintProjectRedisRestAPIToken1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectRedisRestAPIToken1 = contentHintProjectRedisRestAPIToken1
		u.Type = ProjectContentHintUnion1TypeRedisRestAPIToken
		return nil
	case "redis-rest-api-read-only-token":
		contentHintProjectRedisRestAPIReadOnlyToken1 := new(ContentHintProjectRedisRestAPIReadOnlyToken1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectRedisRestAPIReadOnlyToken1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == redis-rest-api-read-only-token) type ContentHintProjectRedisRestAPIReadOnlyToken1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectRedisRestAPIReadOnlyToken1 = contentHintProjectRedisRestAPIReadOnlyToken1
		u.Type = ProjectContentHintUnion1TypeRedisRestAPIReadOnlyToken
		return nil
	case "blob-read-write-token":
		contentHintProjectBlobReadWriteToken1 := new(ContentHintProjectBlobReadWriteToken1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectBlobReadWriteToken1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == blob-read-write-token) type ContentHintProjectBlobReadWriteToken1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectBlobReadWriteToken1 = contentHintProjectBlobReadWriteToken1
		u.Type = ProjectContentHintUnion1TypeBlobReadWriteToken
		return nil
	case "postgres-url":
		contentHintProjectPostgresURL1 := new(ContentHintProjectPostgresURL1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresURL1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url) type ContentHintProjectPostgresURL1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresURL1 = contentHintProjectPostgresURL1
		u.Type = ProjectContentHintUnion1TypePostgresURL
		return nil
	case "postgres-url-non-pooling":
		contentHintProjectPostgresURLNonPooling1 := new(ContentHintProjectPostgresURLNonPooling1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresURLNonPooling1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url-non-pooling) type ContentHintProjectPostgresURLNonPooling1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresURLNonPooling1 = contentHintProjectPostgresURLNonPooling1
		u.Type = ProjectContentHintUnion1TypePostgresURLNonPooling
		return nil
	case "postgres-prisma-url":
		contentHintProjectPostgresPrismaURL1 := new(ContentHintProjectPostgresPrismaURL1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresPrismaURL1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-prisma-url) type ContentHintProjectPostgresPrismaURL1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresPrismaURL1 = contentHintProjectPostgresPrismaURL1
		u.Type = ProjectContentHintUnion1TypePostgresPrismaURL
		return nil
	case "postgres-user":
		contentHintProjectPostgresUser1 := new(ContentHintProjectPostgresUser1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresUser1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-user) type ContentHintProjectPostgresUser1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresUser1 = contentHintProjectPostgresUser1
		u.Type = ProjectContentHintUnion1TypePostgresUser
		return nil
	case "postgres-host":
		contentHintProjectPostgresHost1 := new(ContentHintProjectPostgresHost1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresHost1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-host) type ContentHintProjectPostgresHost1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresHost1 = contentHintProjectPostgresHost1
		u.Type = ProjectContentHintUnion1TypePostgresHost
		return nil
	case "postgres-password":
		contentHintProjectPostgresPassword1 := new(ContentHintProjectPostgresPassword1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresPassword1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-password) type ContentHintProjectPostgresPassword1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresPassword1 = contentHintProjectPostgresPassword1
		u.Type = ProjectContentHintUnion1TypePostgresPassword
		return nil
	case "postgres-database":
		contentHintProjectPostgresDatabase1 := new(ContentHintProjectPostgresDatabase1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresDatabase1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-database) type ContentHintProjectPostgresDatabase1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresDatabase1 = contentHintProjectPostgresDatabase1
		u.Type = ProjectContentHintUnion1TypePostgresDatabase
		return nil
	case "postgres-url-no-ssl":
		contentHintProjectPostgresURLNoSsl1 := new(ContentHintProjectPostgresURLNoSsl1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectPostgresURLNoSsl1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == postgres-url-no-ssl) type ContentHintProjectPostgresURLNoSsl1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectPostgresURLNoSsl1 = contentHintProjectPostgresURLNoSsl1
		u.Type = ProjectContentHintUnion1TypePostgresURLNoSsl
		return nil
	case "integration-store-secret":
		contentHintProjectIntegrationStoreSecret1 := new(ContentHintProjectIntegrationStoreSecret1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectIntegrationStoreSecret1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == integration-store-secret) type ContentHintProjectIntegrationStoreSecret1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectIntegrationStoreSecret1 = contentHintProjectIntegrationStoreSecret1
		u.Type = ProjectContentHintUnion1TypeIntegrationStoreSecret
		return nil
	case "flags-connection-string":
		contentHintProjectFlagsConnectionString1 := new(ContentHintProjectFlagsConnectionString1)
		if err := utils.UnmarshalJSON(data, &contentHintProjectFlagsConnectionString1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == flags-connection-string) type ContentHintProjectFlagsConnectionString1 within ProjectContentHintUnion1: %w", string(data), err)
		}

		u.ContentHintProjectFlagsConnectionString1 = contentHintProjectFlagsConnectionString1
		u.Type = ProjectContentHintUnion1TypeFlagsConnectionString
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectContentHintUnion1", string(data))
}

func (u ProjectContentHintUnion1) MarshalJSON() ([]byte, error) {
	if u.ContentHintProjectRedisURL1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectRedisURL1, "", true)
	}

	if u.ContentHintProjectRedisRestAPIURL1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectRedisRestAPIURL1, "", true)
	}

	if u.ContentHintProjectRedisRestAPIToken1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectRedisRestAPIToken1, "", true)
	}

	if u.ContentHintProjectRedisRestAPIReadOnlyToken1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectRedisRestAPIReadOnlyToken1, "", true)
	}

	if u.ContentHintProjectBlobReadWriteToken1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectBlobReadWriteToken1, "", true)
	}

	if u.ContentHintProjectPostgresURL1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresURL1, "", true)
	}

	if u.ContentHintProjectPostgresURLNonPooling1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresURLNonPooling1, "", true)
	}

	if u.ContentHintProjectPostgresPrismaURL1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresPrismaURL1, "", true)
	}

	if u.ContentHintProjectPostgresUser1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresUser1, "", true)
	}

	if u.ContentHintProjectPostgresHost1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresHost1, "", true)
	}

	if u.ContentHintProjectPostgresPassword1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresPassword1, "", true)
	}

	if u.ContentHintProjectPostgresDatabase1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresDatabase1, "", true)
	}

	if u.ContentHintProjectPostgresURLNoSsl1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectPostgresURLNoSsl1, "", true)
	}

	if u.ContentHintProjectIntegrationStoreSecret1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectIntegrationStoreSecret1, "", true)
	}

	if u.ContentHintProjectFlagsConnectionString1 != nil {
		return utils.MarshalJSON(u.ContentHintProjectFlagsConnectionString1, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectContentHintUnion1: all fields are null")
}

type ProjectTypeFlagsSecret1 string

const (
	ProjectTypeFlagsSecret1FlagsSecret ProjectTypeFlagsSecret1 = "flags-secret"
)

func (e ProjectTypeFlagsSecret1) ToPointer() *ProjectTypeFlagsSecret1 {
	return &e
}
func (e *ProjectTypeFlagsSecret1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "flags-secret":
		*e = ProjectTypeFlagsSecret1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeFlagsSecret1: %v", v)
	}
}

// ProjectInternalContentHint1 - Similar to `contentHints`, but should not be exposed to the user.
type ProjectInternalContentHint1 struct {
	Type ProjectTypeFlagsSecret1 `json:"type"`
	// Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
	EncryptedValue string `json:"encryptedValue"`
}

func (p ProjectInternalContentHint1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectInternalContentHint1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"type", "encryptedValue"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectInternalContentHint1) GetType() ProjectTypeFlagsSecret1 {
	if o == nil {
		return ProjectTypeFlagsSecret1("")
	}
	return o.Type
}

func (o *ProjectInternalContentHint1) GetEncryptedValue() string {
	if o == nil {
		return ""
	}
	return o.EncryptedValue
}

type ProjectEnv1 struct {
	Target *ProjectTargetUnion1 `json:"target,omitempty"`
	Type   ProjectEnvType1      `json:"type"`
	// This is used to identify variables that have been migrated from type secret to sensitive.
	SunsetSecretID *string `json:"sunsetSecretId,omitempty"`
	// Legacy now-encryption ciphertext, present after migration swaps value/vsmValue
	LegacyValue       *string                   `json:"legacyValue,omitempty"`
	Decrypted         *bool                     `json:"decrypted,omitempty"`
	Value             string                    `json:"value"`
	VsmValue          *string                   `json:"vsmValue,omitempty"`
	ID                *string                   `json:"id,omitempty"`
	Key               string                    `json:"key"`
	ConfigurationID   *string                   `json:"configurationId,omitempty"`
	CreatedAt         *float64                  `json:"createdAt,omitempty"`
	UpdatedAt         *float64                  `json:"updatedAt,omitempty"`
	CreatedBy         *string                   `json:"createdBy,omitempty"`
	UpdatedBy         *string                   `json:"updatedBy,omitempty"`
	GitBranch         *string                   `json:"gitBranch,omitempty"`
	EdgeConfigID      *string                   `json:"edgeConfigId,omitempty"`
	EdgeConfigTokenID *string                   `json:"edgeConfigTokenId,omitempty"`
	ContentHint       *ProjectContentHintUnion1 `json:"contentHint,omitempty"`
	// Similar to `contentHints`, but should not be exposed to the user.
	InternalContentHint  *ProjectInternalContentHint1 `json:"internalContentHint,omitempty"`
	Comment              *string                      `json:"comment,omitempty"`
	CustomEnvironmentIds []string                     `json:"customEnvironmentIds,omitempty"`
}

func (p ProjectEnv1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectEnv1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"type", "value", "key"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectEnv1) GetTarget() *ProjectTargetUnion1 {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *ProjectEnv1) GetType() ProjectEnvType1 {
	if o == nil {
		return ProjectEnvType1("")
	}
	return o.Type
}

func (o *ProjectEnv1) GetSunsetSecretID() *string {
	if o == nil {
		return nil
	}
	return o.SunsetSecretID
}

func (o *ProjectEnv1) GetLegacyValue() *string {
	if o == nil {
		return nil
	}
	return o.LegacyValue
}

func (o *ProjectEnv1) GetDecrypted() *bool {
	if o == nil {
		return nil
	}
	return o.Decrypted
}

func (o *ProjectEnv1) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

func (o *ProjectEnv1) GetVsmValue() *string {
	if o == nil {
		return nil
	}
	return o.VsmValue
}

func (o *ProjectEnv1) GetID() *string {
	if o == nil {
		return nil
	}
	return o.ID
}

func (o *ProjectEnv1) GetKey() string {
	if o == nil {
		return ""
	}
	return o.Key
}

func (o *ProjectEnv1) GetConfigurationID() *string {
	if o == nil {
		return nil
	}
	return o.ConfigurationID
}

func (o *ProjectEnv1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectEnv1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *ProjectEnv1) GetCreatedBy() *string {
	if o == nil {
		return nil
	}
	return o.CreatedBy
}

func (o *ProjectEnv1) GetUpdatedBy() *string {
	if o == nil {
		return nil
	}
	return o.UpdatedBy
}

func (o *ProjectEnv1) GetGitBranch() *string {
	if o == nil {
		return nil
	}
	return o.GitBranch
}

func (o *ProjectEnv1) GetEdgeConfigID() *string {
	if o == nil {
		return nil
	}
	return o.EdgeConfigID
}

func (o *ProjectEnv1) GetEdgeConfigTokenID() *string {
	if o == nil {
		return nil
	}
	return o.EdgeConfigTokenID
}

func (o *ProjectEnv1) GetContentHint() *ProjectContentHintUnion1 {
	if o == nil {
		return nil
	}
	return o.ContentHint
}

func (o *ProjectEnv1) GetContentHintRedisURL() *ContentHintProjectRedisURL1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectRedisURL1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintRedisRestAPIURL() *ContentHintProjectRedisRestAPIURL1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectRedisRestAPIURL1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintRedisRestAPIToken() *ContentHintProjectRedisRestAPIToken1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectRedisRestAPIToken1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintRedisRestAPIReadOnlyToken() *ContentHintProjectRedisRestAPIReadOnlyToken1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectRedisRestAPIReadOnlyToken1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintBlobReadWriteToken() *ContentHintProjectBlobReadWriteToken1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectBlobReadWriteToken1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresURL() *ContentHintProjectPostgresURL1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresURL1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresURLNonPooling() *ContentHintProjectPostgresURLNonPooling1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresURLNonPooling1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresPrismaURL() *ContentHintProjectPostgresPrismaURL1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresPrismaURL1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresUser() *ContentHintProjectPostgresUser1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresUser1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresHost() *ContentHintProjectPostgresHost1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresHost1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresPassword() *ContentHintProjectPostgresPassword1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresPassword1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresDatabase() *ContentHintProjectPostgresDatabase1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresDatabase1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintPostgresURLNoSsl() *ContentHintProjectPostgresURLNoSsl1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectPostgresURLNoSsl1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintIntegrationStoreSecret() *ContentHintProjectIntegrationStoreSecret1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectIntegrationStoreSecret1
	}
	return nil
}

func (o *ProjectEnv1) GetContentHintFlagsConnectionString() *ContentHintProjectFlagsConnectionString1 {
	if v := o.GetContentHint(); v != nil {
		return v.ContentHintProjectFlagsConnectionString1
	}
	return nil
}

func (o *ProjectEnv1) GetInternalContentHint() *ProjectInternalContentHint1 {
	if o == nil {
		return nil
	}
	return o.InternalContentHint
}

func (o *ProjectEnv1) GetComment() *string {
	if o == nil {
		return nil
	}
	return o.Comment
}

func (o *ProjectEnv1) GetCustomEnvironmentIds() []string {
	if o == nil {
		return nil
	}
	return o.CustomEnvironmentIds
}

type ProjectFramework1 string

const (
	ProjectFramework1Services       ProjectFramework1 = "services"
	ProjectFramework1Blitzjs        ProjectFramework1 = "blitzjs"
	ProjectFramework1Nextjs         ProjectFramework1 = "nextjs"
	ProjectFramework1Gatsby         ProjectFramework1 = "gatsby"
	ProjectFramework1Remix          ProjectFramework1 = "remix"
	ProjectFramework1ReactRouter    ProjectFramework1 = "react-router"
	ProjectFramework1Astro          ProjectFramework1 = "astro"
	ProjectFramework1Hexo           ProjectFramework1 = "hexo"
	ProjectFramework1Eleventy       ProjectFramework1 = "eleventy"
	ProjectFramework1Docusaurus2    ProjectFramework1 = "docusaurus-2"
	ProjectFramework1Docusaurus     ProjectFramework1 = "docusaurus"
	ProjectFramework1Preact         ProjectFramework1 = "preact"
	ProjectFramework1Solidstart1    ProjectFramework1 = "solidstart-1"
	ProjectFramework1Solidstart     ProjectFramework1 = "solidstart"
	ProjectFramework1Dojo           ProjectFramework1 = "dojo"
	ProjectFramework1Ember          ProjectFramework1 = "ember"
	ProjectFramework1Vue            ProjectFramework1 = "vue"
	ProjectFramework1Scully         ProjectFramework1 = "scully"
	ProjectFramework1IonicAngular   ProjectFramework1 = "ionic-angular"
	ProjectFramework1Angular        ProjectFramework1 = "angular"
	ProjectFramework1Polymer        ProjectFramework1 = "polymer"
	ProjectFramework1Svelte         ProjectFramework1 = "svelte"
	ProjectFramework1Sveltekit      ProjectFramework1 = "sveltekit"
	ProjectFramework1Sveltekit1     ProjectFramework1 = "sveltekit-1"
	ProjectFramework1IonicReact     ProjectFramework1 = "ionic-react"
	ProjectFramework1CreateReactApp ProjectFramework1 = "create-react-app"
	ProjectFramework1Gridsome       ProjectFramework1 = "gridsome"
	ProjectFramework1Umijs          ProjectFramework1 = "umijs"
	ProjectFramework1Sapper         ProjectFramework1 = "sapper"
	ProjectFramework1Saber          ProjectFramework1 = "saber"
	ProjectFramework1Stencil        ProjectFramework1 = "stencil"
	ProjectFramework1Nuxtjs         ProjectFramework1 = "nuxtjs"
	ProjectFramework1Redwoodjs      ProjectFramework1 = "redwoodjs"
	ProjectFramework1Hugo           ProjectFramework1 = "hugo"
	ProjectFramework1Jekyll         ProjectFramework1 = "jekyll"
	ProjectFramework1Brunch         ProjectFramework1 = "brunch"
	ProjectFramework1Middleman      ProjectFramework1 = "middleman"
	ProjectFramework1Zola           ProjectFramework1 = "zola"
	ProjectFramework1Hydrogen       ProjectFramework1 = "hydrogen"
	ProjectFramework1Vite           ProjectFramework1 = "vite"
	ProjectFramework1TanstackStart  ProjectFramework1 = "tanstack-start"
	ProjectFramework1Vitepress      ProjectFramework1 = "vitepress"
	ProjectFramework1Vuepress       ProjectFramework1 = "vuepress"
	ProjectFramework1Parcel         ProjectFramework1 = "parcel"
	ProjectFramework1Fastapi        ProjectFramework1 = "fastapi"
	ProjectFramework1Flask          ProjectFramework1 = "flask"
	ProjectFramework1Fasthtml       ProjectFramework1 = "fasthtml"
	ProjectFramework1SanityV3       ProjectFramework1 = "sanity-v3"
	ProjectFramework1Sanity         ProjectFramework1 = "sanity"
	ProjectFramework1Storybook      ProjectFramework1 = "storybook"
	ProjectFramework1Nitro          ProjectFramework1 = "nitro"
	ProjectFramework1Hono           ProjectFramework1 = "hono"
	ProjectFramework1Express        ProjectFramework1 = "express"
	ProjectFramework1H3             ProjectFramework1 = "h3"
	ProjectFramework1Koa            ProjectFramework1 = "koa"
	ProjectFramework1Nestjs         ProjectFramework1 = "nestjs"
	ProjectFramework1Elysia         ProjectFramework1 = "elysia"
	ProjectFramework1Fastify        ProjectFramework1 = "fastify"
	ProjectFramework1Xmcp           ProjectFramework1 = "xmcp"
	ProjectFramework1Python         ProjectFramework1 = "python"
	ProjectFramework1Ruby           ProjectFramework1 = "ruby"
	ProjectFramework1Rust           ProjectFramework1 = "rust"
	ProjectFramework1Node           ProjectFramework1 = "node"
	ProjectFramework1Go             ProjectFramework1 = "go"
)

func (e ProjectFramework1) ToPointer() *ProjectFramework1 {
	return &e
}
func (e *ProjectFramework1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "services":
		fallthrough
	case "blitzjs":
		fallthrough
	case "nextjs":
		fallthrough
	case "gatsby":
		fallthrough
	case "remix":
		fallthrough
	case "react-router":
		fallthrough
	case "astro":
		fallthrough
	case "hexo":
		fallthrough
	case "eleventy":
		fallthrough
	case "docusaurus-2":
		fallthrough
	case "docusaurus":
		fallthrough
	case "preact":
		fallthrough
	case "solidstart-1":
		fallthrough
	case "solidstart":
		fallthrough
	case "dojo":
		fallthrough
	case "ember":
		fallthrough
	case "vue":
		fallthrough
	case "scully":
		fallthrough
	case "ionic-angular":
		fallthrough
	case "angular":
		fallthrough
	case "polymer":
		fallthrough
	case "svelte":
		fallthrough
	case "sveltekit":
		fallthrough
	case "sveltekit-1":
		fallthrough
	case "ionic-react":
		fallthrough
	case "create-react-app":
		fallthrough
	case "gridsome":
		fallthrough
	case "umijs":
		fallthrough
	case "sapper":
		fallthrough
	case "saber":
		fallthrough
	case "stencil":
		fallthrough
	case "nuxtjs":
		fallthrough
	case "redwoodjs":
		fallthrough
	case "hugo":
		fallthrough
	case "jekyll":
		fallthrough
	case "brunch":
		fallthrough
	case "middleman":
		fallthrough
	case "zola":
		fallthrough
	case "hydrogen":
		fallthrough
	case "vite":
		fallthrough
	case "tanstack-start":
		fallthrough
	case "vitepress":
		fallthrough
	case "vuepress":
		fallthrough
	case "parcel":
		fallthrough
	case "fastapi":
		fallthrough
	case "flask":
		fallthrough
	case "fasthtml":
		fallthrough
	case "sanity-v3":
		fallthrough
	case "sanity":
		fallthrough
	case "storybook":
		fallthrough
	case "nitro":
		fallthrough
	case "hono":
		fallthrough
	case "express":
		fallthrough
	case "h3":
		fallthrough
	case "koa":
		fallthrough
	case "nestjs":
		fallthrough
	case "elysia":
		fallthrough
	case "fastify":
		fallthrough
	case "xmcp":
		fallthrough
	case "python":
		fallthrough
	case "ruby":
		fallthrough
	case "rust":
		fallthrough
	case "node":
		fallthrough
	case "go":
		*e = ProjectFramework1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectFramework1: %v", v)
	}
}

type ProjectLatestDeploymentAliasAssigned1Type string

const (
	ProjectLatestDeploymentAliasAssigned1TypeNumber  ProjectLatestDeploymentAliasAssigned1Type = "number"
	ProjectLatestDeploymentAliasAssigned1TypeBoolean ProjectLatestDeploymentAliasAssigned1Type = "boolean"
)

type ProjectLatestDeploymentAliasAssigned1 struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ProjectLatestDeploymentAliasAssigned1Type
}

func CreateProjectLatestDeploymentAliasAssigned1Number(number float64) ProjectLatestDeploymentAliasAssigned1 {
	typ := ProjectLatestDeploymentAliasAssigned1TypeNumber

	return ProjectLatestDeploymentAliasAssigned1{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectLatestDeploymentAliasAssigned1Boolean(boolean bool) ProjectLatestDeploymentAliasAssigned1 {
	typ := ProjectLatestDeploymentAliasAssigned1TypeBoolean

	return ProjectLatestDeploymentAliasAssigned1{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ProjectLatestDeploymentAliasAssigned1) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ProjectLatestDeploymentAliasAssigned1TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ProjectLatestDeploymentAliasAssigned1TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectLatestDeploymentAliasAssigned1", string(data))
}

func (u ProjectLatestDeploymentAliasAssigned1) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectLatestDeploymentAliasAssigned1: all fields are null")
}

type ProjectLatestDeploymentBuild1 struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (p ProjectLatestDeploymentBuild1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectLatestDeploymentBuild1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectLatestDeploymentBuild1) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *ProjectLatestDeploymentBuild1) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *ProjectLatestDeploymentBuild1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type ProjectLatestDeploymentCreator1 struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (p ProjectLatestDeploymentCreator1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectLatestDeploymentCreator1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectLatestDeploymentCreator1) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *ProjectLatestDeploymentCreator1) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *ProjectLatestDeploymentCreator1) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *ProjectLatestDeploymentCreator1) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *ProjectLatestDeploymentCreator1) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type ProjectLatestDeployment1 struct {
	Alias              []string                               `json:"alias,omitempty"`
	AliasAssigned      *ProjectLatestDeploymentAliasAssigned1 `json:"aliasAssigned,omitempty"`
	Builds             []ProjectLatestDeploymentBuild1        `json:"builds,omitempty"`
	CreatedAt          float64                                `json:"createdAt"`
	CreatedIn          string                                 `json:"createdIn"`
	Creator            *ProjectLatestDeploymentCreator1       `json:"creator"`
	DeploymentHostname string                                 `json:"deploymentHostname"`
	Name               string                                 `json:"name"`
	Forced             *bool                                  `json:"forced,omitempty"`
	ID                 string                                 `json:"id"`
	Meta               map[string]string                      `json:"meta,omitempty"`
	Plan               string                                 `json:"plan"`
	Private            bool                                   `json:"private"`
	ReadyState         string                                 `json:"readyState"`
	RequestedAt        *float64                               `json:"requestedAt,omitempty"`
	Target             *string                                `json:"target,omitempty"`
	TeamID             *string                                `json:"teamId,omitempty"`
	Type               string                                 `json:"type"`
	URL                string                                 `json:"url"`
	UserID             string                                 `json:"userId"`
	WithCache          *bool                                  `json:"withCache,omitempty"`
}

func (p ProjectLatestDeployment1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectLatestDeployment1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectLatestDeployment1) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *ProjectLatestDeployment1) GetAliasAssigned() *ProjectLatestDeploymentAliasAssigned1 {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *ProjectLatestDeployment1) GetBuilds() []ProjectLatestDeploymentBuild1 {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *ProjectLatestDeployment1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ProjectLatestDeployment1) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *ProjectLatestDeployment1) GetCreator() *ProjectLatestDeploymentCreator1 {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *ProjectLatestDeployment1) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *ProjectLatestDeployment1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectLatestDeployment1) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *ProjectLatestDeployment1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectLatestDeployment1) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *ProjectLatestDeployment1) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *ProjectLatestDeployment1) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *ProjectLatestDeployment1) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *ProjectLatestDeployment1) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *ProjectLatestDeployment1) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *ProjectLatestDeployment1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ProjectLatestDeployment1) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *ProjectLatestDeployment1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *ProjectLatestDeployment1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *ProjectLatestDeployment1) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type ProjectTypeBitbucket1 string

const (
	ProjectTypeBitbucket1Bitbucket ProjectTypeBitbucket1 = "bitbucket"
)

func (e ProjectTypeBitbucket1) ToPointer() *ProjectTypeBitbucket1 {
	return &e
}
func (e *ProjectTypeBitbucket1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "bitbucket":
		*e = ProjectTypeBitbucket1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeBitbucket1: %v", v)
	}
}

type ProjectDeployHook5 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (p ProjectDeployHook5) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployHook5) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployHook5) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectDeployHook5) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployHook5) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployHook5) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *ProjectDeployHook5) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type LinkProjectBitbucket1 struct {
	Name             string                `json:"name"`
	Slug             string                `json:"slug"`
	Owner            string                `json:"owner"`
	Type             ProjectTypeBitbucket1 `json:"type"`
	UUID             string                `json:"uuid"`
	WorkspaceUUID    string                `json:"workspaceUuid"`
	CreatedAt        *float64              `json:"createdAt,omitempty"`
	DeployHooks      []ProjectDeployHook5  `json:"deployHooks"`
	GitCredentialID  string                `json:"gitCredentialId"`
	UpdatedAt        *float64              `json:"updatedAt,omitempty"`
	Sourceless       *bool                 `json:"sourceless,omitempty"`
	ProductionBranch string                `json:"productionBranch"`
}

func (l LinkProjectBitbucket1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LinkProjectBitbucket1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"name", "slug", "owner", "type", "uuid", "workspaceUuid", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *LinkProjectBitbucket1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *LinkProjectBitbucket1) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *LinkProjectBitbucket1) GetOwner() string {
	if o == nil {
		return ""
	}
	return o.Owner
}

func (o *LinkProjectBitbucket1) GetType() ProjectTypeBitbucket1 {
	if o == nil {
		return ProjectTypeBitbucket1("")
	}
	return o.Type
}

func (o *LinkProjectBitbucket1) GetUUID() string {
	if o == nil {
		return ""
	}
	return o.UUID
}

func (o *LinkProjectBitbucket1) GetWorkspaceUUID() string {
	if o == nil {
		return ""
	}
	return o.WorkspaceUUID
}

func (o *LinkProjectBitbucket1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *LinkProjectBitbucket1) GetDeployHooks() []ProjectDeployHook5 {
	if o == nil {
		return []ProjectDeployHook5{}
	}
	return o.DeployHooks
}

func (o *LinkProjectBitbucket1) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *LinkProjectBitbucket1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *LinkProjectBitbucket1) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *LinkProjectBitbucket1) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type ProjectTypeGitlab1 string

const (
	ProjectTypeGitlab1Gitlab ProjectTypeGitlab1 = "gitlab"
)

func (e ProjectTypeGitlab1) ToPointer() *ProjectTypeGitlab1 {
	return &e
}
func (e *ProjectTypeGitlab1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gitlab":
		*e = ProjectTypeGitlab1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeGitlab1: %v", v)
	}
}

type ProjectDeployHook4 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (p ProjectDeployHook4) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployHook4) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployHook4) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectDeployHook4) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployHook4) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployHook4) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *ProjectDeployHook4) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type LinkProjectGitlab1 struct {
	ProjectID                string `json:"projectId"`
	ProjectName              string `json:"projectName"`
	ProjectNameWithNamespace string `json:"projectNameWithNamespace"`
	ProjectNamespace         string `json:"projectNamespace"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).
	ProjectOwnerID   *float64             `json:"projectOwnerId,omitempty"`
	ProjectURL       string               `json:"projectUrl"`
	Type             ProjectTypeGitlab1   `json:"type"`
	CreatedAt        *float64             `json:"createdAt,omitempty"`
	DeployHooks      []ProjectDeployHook4 `json:"deployHooks"`
	GitCredentialID  string               `json:"gitCredentialId"`
	UpdatedAt        *float64             `json:"updatedAt,omitempty"`
	Sourceless       *bool                `json:"sourceless,omitempty"`
	ProductionBranch string               `json:"productionBranch"`
}

func (l LinkProjectGitlab1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LinkProjectGitlab1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"projectId", "projectName", "projectNameWithNamespace", "projectNamespace", "projectUrl", "type", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *LinkProjectGitlab1) GetProjectID() string {
	if o == nil {
		return ""
	}
	return o.ProjectID
}

func (o *LinkProjectGitlab1) GetProjectName() string {
	if o == nil {
		return ""
	}
	return o.ProjectName
}

func (o *LinkProjectGitlab1) GetProjectNameWithNamespace() string {
	if o == nil {
		return ""
	}
	return o.ProjectNameWithNamespace
}

func (o *LinkProjectGitlab1) GetProjectNamespace() string {
	if o == nil {
		return ""
	}
	return o.ProjectNamespace
}

func (o *LinkProjectGitlab1) GetProjectOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.ProjectOwnerID
}

func (o *LinkProjectGitlab1) GetProjectURL() string {
	if o == nil {
		return ""
	}
	return o.ProjectURL
}

func (o *LinkProjectGitlab1) GetType() ProjectTypeGitlab1 {
	if o == nil {
		return ProjectTypeGitlab1("")
	}
	return o.Type
}

func (o *LinkProjectGitlab1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *LinkProjectGitlab1) GetDeployHooks() []ProjectDeployHook4 {
	if o == nil {
		return []ProjectDeployHook4{}
	}
	return o.DeployHooks
}

func (o *LinkProjectGitlab1) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *LinkProjectGitlab1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *LinkProjectGitlab1) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *LinkProjectGitlab1) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type ProjectTypeGithubCustomHost1 string

const (
	ProjectTypeGithubCustomHost1GithubCustomHost ProjectTypeGithubCustomHost1 = "github-custom-host"
)

func (e ProjectTypeGithubCustomHost1) ToPointer() *ProjectTypeGithubCustomHost1 {
	return &e
}
func (e *ProjectTypeGithubCustomHost1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-custom-host":
		*e = ProjectTypeGithubCustomHost1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeGithubCustomHost1: %v", v)
	}
}

type ProjectDeployHook3 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (p ProjectDeployHook3) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployHook3) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployHook3) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectDeployHook3) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployHook3) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployHook3) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *ProjectDeployHook3) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type LinkProjectGithubCustomHost1 struct {
	Org string `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64                     `json:"repoOwnerId,omitempty"`
	Repo             *string                      `json:"repo,omitempty"`
	RepoID           *float64                     `json:"repoId,omitempty"`
	Type             ProjectTypeGithubCustomHost1 `json:"type"`
	Host             string                       `json:"host"`
	CreatedAt        *float64                     `json:"createdAt,omitempty"`
	DeployHooks      []ProjectDeployHook3         `json:"deployHooks"`
	GitCredentialID  string                       `json:"gitCredentialId"`
	UpdatedAt        *float64                     `json:"updatedAt,omitempty"`
	Sourceless       *bool                        `json:"sourceless,omitempty"`
	ProductionBranch string                       `json:"productionBranch"`
}

func (l LinkProjectGithubCustomHost1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LinkProjectGithubCustomHost1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"org", "type", "host", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *LinkProjectGithubCustomHost1) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *LinkProjectGithubCustomHost1) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *LinkProjectGithubCustomHost1) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *LinkProjectGithubCustomHost1) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *LinkProjectGithubCustomHost1) GetType() ProjectTypeGithubCustomHost1 {
	if o == nil {
		return ProjectTypeGithubCustomHost1("")
	}
	return o.Type
}

func (o *LinkProjectGithubCustomHost1) GetHost() string {
	if o == nil {
		return ""
	}
	return o.Host
}

func (o *LinkProjectGithubCustomHost1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *LinkProjectGithubCustomHost1) GetDeployHooks() []ProjectDeployHook3 {
	if o == nil {
		return []ProjectDeployHook3{}
	}
	return o.DeployHooks
}

func (o *LinkProjectGithubCustomHost1) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *LinkProjectGithubCustomHost1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *LinkProjectGithubCustomHost1) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *LinkProjectGithubCustomHost1) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type ProjectTypeGithubLimited1 string

const (
	ProjectTypeGithubLimited1GithubLimited ProjectTypeGithubLimited1 = "github-limited"
)

func (e ProjectTypeGithubLimited1) ToPointer() *ProjectTypeGithubLimited1 {
	return &e
}
func (e *ProjectTypeGithubLimited1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github-limited":
		*e = ProjectTypeGithubLimited1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeGithubLimited1: %v", v)
	}
}

type ProjectDeployHook2 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (p ProjectDeployHook2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployHook2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployHook2) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectDeployHook2) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployHook2) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployHook2) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *ProjectDeployHook2) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type LinkProjectGithubLimited1 struct {
	Type      ProjectTypeGithubLimited1 `json:"type"`
	Repo      *string                   `json:"repo,omitempty"`
	RepoID    *float64                  `json:"repoId,omitempty"`
	CreatedAt *float64                  `json:"createdAt,omitempty"`
	UpdatedAt *float64                  `json:"updatedAt,omitempty"`
	Org       string                    `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64             `json:"repoOwnerId,omitempty"`
	DeployHooks      []ProjectDeployHook2 `json:"deployHooks"`
	GitCredentialID  string               `json:"gitCredentialId"`
	Sourceless       *bool                `json:"sourceless,omitempty"`
	ProductionBranch string               `json:"productionBranch"`
}

func (l LinkProjectGithubLimited1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LinkProjectGithubLimited1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"type", "org", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *LinkProjectGithubLimited1) GetType() ProjectTypeGithubLimited1 {
	if o == nil {
		return ProjectTypeGithubLimited1("")
	}
	return o.Type
}

func (o *LinkProjectGithubLimited1) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *LinkProjectGithubLimited1) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *LinkProjectGithubLimited1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *LinkProjectGithubLimited1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *LinkProjectGithubLimited1) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *LinkProjectGithubLimited1) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *LinkProjectGithubLimited1) GetDeployHooks() []ProjectDeployHook2 {
	if o == nil {
		return []ProjectDeployHook2{}
	}
	return o.DeployHooks
}

func (o *LinkProjectGithubLimited1) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *LinkProjectGithubLimited1) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *LinkProjectGithubLimited1) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type ProjectTypeGithub1 string

const (
	ProjectTypeGithub1Github ProjectTypeGithub1 = "github"
)

func (e ProjectTypeGithub1) ToPointer() *ProjectTypeGithub1 {
	return &e
}
func (e *ProjectTypeGithub1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		*e = ProjectTypeGithub1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectTypeGithub1: %v", v)
	}
}

type ProjectDeployHook1 struct {
	CreatedAt *float64 `json:"createdAt,omitempty"`
	ID        string   `json:"id"`
	Name      string   `json:"name"`
	Ref       string   `json:"ref"`
	URL       string   `json:"url"`
}

func (p ProjectDeployHook1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectDeployHook1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id", "name", "ref", "url"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectDeployHook1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *ProjectDeployHook1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectDeployHook1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectDeployHook1) GetRef() string {
	if o == nil {
		return ""
	}
	return o.Ref
}

func (o *ProjectDeployHook1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

type LinkProjectGithub1 struct {
	Org string `json:"org"`
	// A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
	RepoOwnerID      *float64             `json:"repoOwnerId,omitempty"`
	Repo             *string              `json:"repo,omitempty"`
	RepoID           *float64             `json:"repoId,omitempty"`
	Type             ProjectTypeGithub1   `json:"type"`
	CreatedAt        *float64             `json:"createdAt,omitempty"`
	DeployHooks      []ProjectDeployHook1 `json:"deployHooks"`
	GitCredentialID  string               `json:"gitCredentialId"`
	UpdatedAt        *float64             `json:"updatedAt,omitempty"`
	Sourceless       *bool                `json:"sourceless,omitempty"`
	ProductionBranch string               `json:"productionBranch"`
}

func (l LinkProjectGithub1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(l, "", false)
}

func (l *LinkProjectGithub1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &l, "", false, []string{"org", "type", "deployHooks", "gitCredentialId", "productionBranch"}); err != nil {
		return err
	}
	return nil
}

func (o *LinkProjectGithub1) GetOrg() string {
	if o == nil {
		return ""
	}
	return o.Org
}

func (o *LinkProjectGithub1) GetRepoOwnerID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoOwnerID
}

func (o *LinkProjectGithub1) GetRepo() *string {
	if o == nil {
		return nil
	}
	return o.Repo
}

func (o *LinkProjectGithub1) GetRepoID() *float64 {
	if o == nil {
		return nil
	}
	return o.RepoID
}

func (o *LinkProjectGithub1) GetType() ProjectTypeGithub1 {
	if o == nil {
		return ProjectTypeGithub1("")
	}
	return o.Type
}

func (o *LinkProjectGithub1) GetCreatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CreatedAt
}

func (o *LinkProjectGithub1) GetDeployHooks() []ProjectDeployHook1 {
	if o == nil {
		return []ProjectDeployHook1{}
	}
	return o.DeployHooks
}

func (o *LinkProjectGithub1) GetGitCredentialID() string {
	if o == nil {
		return ""
	}
	return o.GitCredentialID
}

func (o *LinkProjectGithub1) GetUpdatedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.UpdatedAt
}

func (o *LinkProjectGithub1) GetSourceless() *bool {
	if o == nil {
		return nil
	}
	return o.Sourceless
}

func (o *LinkProjectGithub1) GetProductionBranch() string {
	if o == nil {
		return ""
	}
	return o.ProductionBranch
}

type ProjectLinkUnion1Type string

const (
	ProjectLinkUnion1TypeGithub           ProjectLinkUnion1Type = "github"
	ProjectLinkUnion1TypeGithubLimited    ProjectLinkUnion1Type = "github-limited"
	ProjectLinkUnion1TypeGithubCustomHost ProjectLinkUnion1Type = "github-custom-host"
	ProjectLinkUnion1TypeGitlab           ProjectLinkUnion1Type = "gitlab"
	ProjectLinkUnion1TypeBitbucket        ProjectLinkUnion1Type = "bitbucket"
)

type ProjectLinkUnion1 struct {
	LinkProjectGithub1           *LinkProjectGithub1           `queryParam:"inline"`
	LinkProjectGithubLimited1    *LinkProjectGithubLimited1    `queryParam:"inline"`
	LinkProjectGithubCustomHost1 *LinkProjectGithubCustomHost1 `queryParam:"inline"`
	LinkProjectGitlab1           *LinkProjectGitlab1           `queryParam:"inline"`
	LinkProjectBitbucket1        *LinkProjectBitbucket1        `queryParam:"inline"`

	Type ProjectLinkUnion1Type
}

func CreateProjectLinkUnion1Github(github LinkProjectGithub1) ProjectLinkUnion1 {
	typ := ProjectLinkUnion1TypeGithub

	typStr := ProjectTypeGithub1(typ)
	github.Type = typStr

	return ProjectLinkUnion1{
		LinkProjectGithub1: &github,
		Type:               typ,
	}
}

func CreateProjectLinkUnion1GithubLimited(githubLimited LinkProjectGithubLimited1) ProjectLinkUnion1 {
	typ := ProjectLinkUnion1TypeGithubLimited

	typStr := ProjectTypeGithubLimited1(typ)
	githubLimited.Type = typStr

	return ProjectLinkUnion1{
		LinkProjectGithubLimited1: &githubLimited,
		Type:                      typ,
	}
}

func CreateProjectLinkUnion1GithubCustomHost(githubCustomHost LinkProjectGithubCustomHost1) ProjectLinkUnion1 {
	typ := ProjectLinkUnion1TypeGithubCustomHost

	typStr := ProjectTypeGithubCustomHost1(typ)
	githubCustomHost.Type = typStr

	return ProjectLinkUnion1{
		LinkProjectGithubCustomHost1: &githubCustomHost,
		Type:                         typ,
	}
}

func CreateProjectLinkUnion1Gitlab(gitlab LinkProjectGitlab1) ProjectLinkUnion1 {
	typ := ProjectLinkUnion1TypeGitlab

	typStr := ProjectTypeGitlab1(typ)
	gitlab.Type = typStr

	return ProjectLinkUnion1{
		LinkProjectGitlab1: &gitlab,
		Type:               typ,
	}
}

func CreateProjectLinkUnion1Bitbucket(bitbucket LinkProjectBitbucket1) ProjectLinkUnion1 {
	typ := ProjectLinkUnion1TypeBitbucket

	typStr := ProjectTypeBitbucket1(typ)
	bitbucket.Type = typStr

	return ProjectLinkUnion1{
		LinkProjectBitbucket1: &bitbucket,
		Type:                  typ,
	}
}

func (u *ProjectLinkUnion1) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Type string `json:"type"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Type {
	case "github":
		linkProjectGithub1 := new(LinkProjectGithub1)
		if err := utils.UnmarshalJSON(data, &linkProjectGithub1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github) type LinkProjectGithub1 within ProjectLinkUnion1: %w", string(data), err)
		}

		u.LinkProjectGithub1 = linkProjectGithub1
		u.Type = ProjectLinkUnion1TypeGithub
		return nil
	case "github-limited":
		linkProjectGithubLimited1 := new(LinkProjectGithubLimited1)
		if err := utils.UnmarshalJSON(data, &linkProjectGithubLimited1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github-limited) type LinkProjectGithubLimited1 within ProjectLinkUnion1: %w", string(data), err)
		}

		u.LinkProjectGithubLimited1 = linkProjectGithubLimited1
		u.Type = ProjectLinkUnion1TypeGithubLimited
		return nil
	case "github-custom-host":
		linkProjectGithubCustomHost1 := new(LinkProjectGithubCustomHost1)
		if err := utils.UnmarshalJSON(data, &linkProjectGithubCustomHost1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == github-custom-host) type LinkProjectGithubCustomHost1 within ProjectLinkUnion1: %w", string(data), err)
		}

		u.LinkProjectGithubCustomHost1 = linkProjectGithubCustomHost1
		u.Type = ProjectLinkUnion1TypeGithubCustomHost
		return nil
	case "gitlab":
		linkProjectGitlab1 := new(LinkProjectGitlab1)
		if err := utils.UnmarshalJSON(data, &linkProjectGitlab1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == gitlab) type LinkProjectGitlab1 within ProjectLinkUnion1: %w", string(data), err)
		}

		u.LinkProjectGitlab1 = linkProjectGitlab1
		u.Type = ProjectLinkUnion1TypeGitlab
		return nil
	case "bitbucket":
		linkProjectBitbucket1 := new(LinkProjectBitbucket1)
		if err := utils.UnmarshalJSON(data, &linkProjectBitbucket1, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Type == bitbucket) type LinkProjectBitbucket1 within ProjectLinkUnion1: %w", string(data), err)
		}

		u.LinkProjectBitbucket1 = linkProjectBitbucket1
		u.Type = ProjectLinkUnion1TypeBitbucket
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectLinkUnion1", string(data))
}

func (u ProjectLinkUnion1) MarshalJSON() ([]byte, error) {
	if u.LinkProjectGithub1 != nil {
		return utils.MarshalJSON(u.LinkProjectGithub1, "", true)
	}

	if u.LinkProjectGithubLimited1 != nil {
		return utils.MarshalJSON(u.LinkProjectGithubLimited1, "", true)
	}

	if u.LinkProjectGithubCustomHost1 != nil {
		return utils.MarshalJSON(u.LinkProjectGithubCustomHost1, "", true)
	}

	if u.LinkProjectGitlab1 != nil {
		return utils.MarshalJSON(u.LinkProjectGitlab1, "", true)
	}

	if u.LinkProjectBitbucket1 != nil {
		return utils.MarshalJSON(u.LinkProjectBitbucket1, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectLinkUnion1: all fields are null")
}

type ProjectNodeVersion1 string

const (
	ProjectNodeVersion1TwentyFourDotX ProjectNodeVersion1 = "24.x"
	ProjectNodeVersion1TwentyTwoDotX  ProjectNodeVersion1 = "22.x"
	ProjectNodeVersion1TwentyDotX     ProjectNodeVersion1 = "20.x"
	ProjectNodeVersion1EighteenDotX   ProjectNodeVersion1 = "18.x"
	ProjectNodeVersion1SixteenDotX    ProjectNodeVersion1 = "16.x"
	ProjectNodeVersion1FourteenDotX   ProjectNodeVersion1 = "14.x"
	ProjectNodeVersion1TwelveDotX     ProjectNodeVersion1 = "12.x"
	ProjectNodeVersion1TenDotX        ProjectNodeVersion1 = "10.x"
	ProjectNodeVersion1EightDot10DotX ProjectNodeVersion1 = "8.10.x"
)

func (e ProjectNodeVersion1) ToPointer() *ProjectNodeVersion1 {
	return &e
}
func (e *ProjectNodeVersion1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "24.x":
		fallthrough
	case "22.x":
		fallthrough
	case "20.x":
		fallthrough
	case "18.x":
		fallthrough
	case "16.x":
		fallthrough
	case "14.x":
		fallthrough
	case "12.x":
		fallthrough
	case "10.x":
		fallthrough
	case "8.10.x":
		*e = ProjectNodeVersion1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectNodeVersion1: %v", v)
	}
}

type ProjectPasswordProtection1 struct {
}

func (p ProjectPasswordProtection1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectPasswordProtection1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

type ProjectResourceConfigFunctionDefaultMemoryType1 string

const (
	ProjectResourceConfigFunctionDefaultMemoryType1StandardLegacy ProjectResourceConfigFunctionDefaultMemoryType1 = "standard_legacy"
	ProjectResourceConfigFunctionDefaultMemoryType1Standard       ProjectResourceConfigFunctionDefaultMemoryType1 = "standard"
	ProjectResourceConfigFunctionDefaultMemoryType1Performance    ProjectResourceConfigFunctionDefaultMemoryType1 = "performance"
)

func (e ProjectResourceConfigFunctionDefaultMemoryType1) ToPointer() *ProjectResourceConfigFunctionDefaultMemoryType1 {
	return &e
}
func (e *ProjectResourceConfigFunctionDefaultMemoryType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard_legacy":
		fallthrough
	case "standard":
		fallthrough
	case "performance":
		*e = ProjectResourceConfigFunctionDefaultMemoryType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectResourceConfigFunctionDefaultMemoryType1: %v", v)
	}
}

type ProjectResourceConfigBuildMachineType1 string

const (
	ProjectResourceConfigBuildMachineType1Standard ProjectResourceConfigBuildMachineType1 = "standard"
	ProjectResourceConfigBuildMachineType1Enhanced ProjectResourceConfigBuildMachineType1 = "enhanced"
	ProjectResourceConfigBuildMachineType1Turbo    ProjectResourceConfigBuildMachineType1 = "turbo"
	ProjectResourceConfigBuildMachineType1Elastic  ProjectResourceConfigBuildMachineType1 = "elastic"
)

func (e ProjectResourceConfigBuildMachineType1) ToPointer() *ProjectResourceConfigBuildMachineType1 {
	return &e
}
func (e *ProjectResourceConfigBuildMachineType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "standard":
		fallthrough
	case "enhanced":
		fallthrough
	case "turbo":
		fallthrough
	case "elastic":
		*e = ProjectResourceConfigBuildMachineType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectResourceConfigBuildMachineType1: %v", v)
	}
}

type ProjectResourceConfigConfiguration1 string

const (
	ProjectResourceConfigConfiguration1SkipNamespaceQueue    ProjectResourceConfigConfiguration1 = "SKIP_NAMESPACE_QUEUE"
	ProjectResourceConfigConfiguration1WaitForNamespaceQueue ProjectResourceConfigConfiguration1 = "WAIT_FOR_NAMESPACE_QUEUE"
)

func (e ProjectResourceConfigConfiguration1) ToPointer() *ProjectResourceConfigConfiguration1 {
	return &e
}
func (e *ProjectResourceConfigConfiguration1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "SKIP_NAMESPACE_QUEUE":
		fallthrough
	case "WAIT_FOR_NAMESPACE_QUEUE":
		*e = ProjectResourceConfigConfiguration1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectResourceConfigConfiguration1: %v", v)
	}
}

type ProjectResourceConfigBuildQueue1 struct {
	Configuration *ProjectResourceConfigConfiguration1 `json:"configuration,omitempty"`
}

func (p ProjectResourceConfigBuildQueue1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectResourceConfigBuildQueue1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *ProjectResourceConfigBuildQueue1) GetConfiguration() *ProjectResourceConfigConfiguration1 {
	if o == nil {
		return nil
	}
	return o.Configuration
}

type ProjectResourceConfig1 struct {
	ElasticConcurrencyEnabled  *bool                                            `json:"elasticConcurrencyEnabled,omitempty"`
	Fluid                      *bool                                            `json:"fluid,omitempty"`
	FunctionDefaultRegions     []string                                         `json:"functionDefaultRegions"`
	FunctionDefaultTimeout     *float64                                         `json:"functionDefaultTimeout,omitempty"`
	FunctionDefaultMemoryType  *ProjectResourceConfigFunctionDefaultMemoryType1 `json:"functionDefaultMemoryType,omitempty"`
	FunctionZeroConfigFailover *bool                                            `json:"functionZeroConfigFailover,omitempty"`
	BuildMachineType           *ProjectResourceConfigBuildMachineType1          `json:"buildMachineType,omitempty"`
	IsNSNBDisabled             *bool                                            `json:"isNSNBDisabled,omitempty"`
	BuildQueue                 *ProjectResourceConfigBuildQueue1                `json:"buildQueue,omitempty"`
}

func (p ProjectResourceConfig1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectResourceConfig1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"functionDefaultRegions"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectResourceConfig1) GetElasticConcurrencyEnabled() *bool {
	if o == nil {
		return nil
	}
	return o.ElasticConcurrencyEnabled
}

func (o *ProjectResourceConfig1) GetFluid() *bool {
	if o == nil {
		return nil
	}
	return o.Fluid
}

func (o *ProjectResourceConfig1) GetFunctionDefaultRegions() []string {
	if o == nil {
		return []string{}
	}
	return o.FunctionDefaultRegions
}

func (o *ProjectResourceConfig1) GetFunctionDefaultTimeout() *float64 {
	if o == nil {
		return nil
	}
	return o.FunctionDefaultTimeout
}

func (o *ProjectResourceConfig1) GetFunctionDefaultMemoryType() *ProjectResourceConfigFunctionDefaultMemoryType1 {
	if o == nil {
		return nil
	}
	return o.FunctionDefaultMemoryType
}

func (o *ProjectResourceConfig1) GetFunctionZeroConfigFailover() *bool {
	if o == nil {
		return nil
	}
	return o.FunctionZeroConfigFailover
}

func (o *ProjectResourceConfig1) GetBuildMachineType() *ProjectResourceConfigBuildMachineType1 {
	if o == nil {
		return nil
	}
	return o.BuildMachineType
}

func (o *ProjectResourceConfig1) GetIsNSNBDisabled() *bool {
	if o == nil {
		return nil
	}
	return o.IsNSNBDisabled
}

func (o *ProjectResourceConfig1) GetBuildQueue() *ProjectResourceConfigBuildQueue1 {
	if o == nil {
		return nil
	}
	return o.BuildQueue
}

// ProjectStage1 - An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
type ProjectStage1 struct {
	// The percentage of traffic to serve to the canary deployment (0-100)
	TargetPercentage float64 `json:"targetPercentage"`
	// Whether or not this stage requires manual approval to proceed
	RequireApproval *bool `json:"requireApproval,omitempty"`
	// Duration in minutes for automatic advancement to the next stage
	Duration *float64 `json:"duration,omitempty"`
	// Whether to linearly shift traffic over the duration of this stage
	LinearShift *bool `json:"linearShift,omitempty"`
}

func (p ProjectStage1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectStage1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"targetPercentage"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectStage1) GetTargetPercentage() float64 {
	if o == nil {
		return 0.0
	}
	return o.TargetPercentage
}

func (o *ProjectStage1) GetRequireApproval() *bool {
	if o == nil {
		return nil
	}
	return o.RequireApproval
}

func (o *ProjectStage1) GetDuration() *float64 {
	if o == nil {
		return nil
	}
	return o.Duration
}

func (o *ProjectStage1) GetLinearShift() *bool {
	if o == nil {
		return nil
	}
	return o.LinearShift
}

// ProjectRollingRelease1 - Project-level rolling release configuration that defines how deployments should be gradually rolled out
type ProjectRollingRelease1 struct {
	// The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.
	Target string `json:"target"`
	// An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
	Stages []ProjectStage1 `json:"stages,omitempty"`
	// Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.
	CanaryResponseHeader *bool `json:"canaryResponseHeader,omitempty"`
}

func (p ProjectRollingRelease1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectRollingRelease1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"target"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectRollingRelease1) GetTarget() string {
	if o == nil {
		return ""
	}
	return o.Target
}

func (o *ProjectRollingRelease1) GetStages() []ProjectStage1 {
	if o == nil {
		return nil
	}
	return o.Stages
}

func (o *ProjectRollingRelease1) GetCanaryResponseHeader() *bool {
	if o == nil {
		return nil
	}
	return o.CanaryResponseHeader
}

type ProjectSpeedInsights1 struct {
	ID         string   `json:"id"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
	PaidAt     *float64 `json:"paidAt,omitempty"`
}

func (p ProjectSpeedInsights1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectSpeedInsights1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectSpeedInsights1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectSpeedInsights1) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *ProjectSpeedInsights1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *ProjectSpeedInsights1) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *ProjectSpeedInsights1) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

func (o *ProjectSpeedInsights1) GetPaidAt() *float64 {
	if o == nil {
		return nil
	}
	return o.PaidAt
}

type ProjectSsoProtectionDeploymentType1 string

const (
	ProjectSsoProtectionDeploymentType1Preview                          ProjectSsoProtectionDeploymentType1 = "preview"
	ProjectSsoProtectionDeploymentType1All                              ProjectSsoProtectionDeploymentType1 = "all"
	ProjectSsoProtectionDeploymentType1ProdDeploymentUrlsAndAllPreviews ProjectSsoProtectionDeploymentType1 = "prod_deployment_urls_and_all_previews"
	ProjectSsoProtectionDeploymentType1AllExceptCustomDomains           ProjectSsoProtectionDeploymentType1 = "all_except_custom_domains"
)

func (e ProjectSsoProtectionDeploymentType1) ToPointer() *ProjectSsoProtectionDeploymentType1 {
	return &e
}
func (e *ProjectSsoProtectionDeploymentType1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preview":
		fallthrough
	case "all":
		fallthrough
	case "prod_deployment_urls_and_all_previews":
		fallthrough
	case "all_except_custom_domains":
		*e = ProjectSsoProtectionDeploymentType1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectSsoProtectionDeploymentType1: %v", v)
	}
}

type ProjectCve55182MigrationAppliedFrom1 string

const (
	ProjectCve55182MigrationAppliedFrom1Preview                          ProjectCve55182MigrationAppliedFrom1 = "preview"
	ProjectCve55182MigrationAppliedFrom1All                              ProjectCve55182MigrationAppliedFrom1 = "all"
	ProjectCve55182MigrationAppliedFrom1ProdDeploymentUrlsAndAllPreviews ProjectCve55182MigrationAppliedFrom1 = "prod_deployment_urls_and_all_previews"
	ProjectCve55182MigrationAppliedFrom1AllExceptCustomDomains           ProjectCve55182MigrationAppliedFrom1 = "all_except_custom_domains"
)

func (e ProjectCve55182MigrationAppliedFrom1) ToPointer() *ProjectCve55182MigrationAppliedFrom1 {
	return &e
}
func (e *ProjectCve55182MigrationAppliedFrom1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "preview":
		fallthrough
	case "all":
		fallthrough
	case "prod_deployment_urls_and_all_previews":
		fallthrough
	case "all_except_custom_domains":
		*e = ProjectCve55182MigrationAppliedFrom1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectCve55182MigrationAppliedFrom1: %v", v)
	}
}

type ProjectSsoProtection1 struct {
	DeploymentType               ProjectSsoProtectionDeploymentType1   `json:"deploymentType"`
	Cve55182MigrationAppliedFrom *ProjectCve55182MigrationAppliedFrom1 `json:"cve55182MigrationAppliedFrom,omitempty"`
}

func (p ProjectSsoProtection1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectSsoProtection1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"deploymentType"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectSsoProtection1) GetDeploymentType() ProjectSsoProtectionDeploymentType1 {
	if o == nil {
		return ProjectSsoProtectionDeploymentType1("")
	}
	return o.DeploymentType
}

func (o *ProjectSsoProtection1) GetCve55182MigrationAppliedFrom() *ProjectCve55182MigrationAppliedFrom1 {
	if o == nil {
		return nil
	}
	return o.Cve55182MigrationAppliedFrom
}

type ProjectTargetsAliasAssigned1Type string

const (
	ProjectTargetsAliasAssigned1TypeNumber  ProjectTargetsAliasAssigned1Type = "number"
	ProjectTargetsAliasAssigned1TypeBoolean ProjectTargetsAliasAssigned1Type = "boolean"
)

type ProjectTargetsAliasAssigned1 struct {
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type ProjectTargetsAliasAssigned1Type
}

func CreateProjectTargetsAliasAssigned1Number(number float64) ProjectTargetsAliasAssigned1 {
	typ := ProjectTargetsAliasAssigned1TypeNumber

	return ProjectTargetsAliasAssigned1{
		Number: &number,
		Type:   typ,
	}
}

func CreateProjectTargetsAliasAssigned1Boolean(boolean bool) ProjectTargetsAliasAssigned1 {
	typ := ProjectTargetsAliasAssigned1TypeBoolean

	return ProjectTargetsAliasAssigned1{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *ProjectTargetsAliasAssigned1) UnmarshalJSON(data []byte) error {

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = ProjectTargetsAliasAssigned1TypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = ProjectTargetsAliasAssigned1TypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectTargetsAliasAssigned1", string(data))
}

func (u ProjectTargetsAliasAssigned1) MarshalJSON() ([]byte, error) {
	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectTargetsAliasAssigned1: all fields are null")
}

type ProjectTargetsBuild1 struct {
	Use  string  `json:"use"`
	Src  *string `json:"src,omitempty"`
	Dest *string `json:"dest,omitempty"`
}

func (p ProjectTargetsBuild1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectTargetsBuild1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"use"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectTargetsBuild1) GetUse() string {
	if o == nil {
		return ""
	}
	return o.Use
}

func (o *ProjectTargetsBuild1) GetSrc() *string {
	if o == nil {
		return nil
	}
	return o.Src
}

func (o *ProjectTargetsBuild1) GetDest() *string {
	if o == nil {
		return nil
	}
	return o.Dest
}

type ProjectTargetsCreator1 struct {
	Email       string  `json:"email"`
	GithubLogin *string `json:"githubLogin,omitempty"`
	GitlabLogin *string `json:"gitlabLogin,omitempty"`
	UID         string  `json:"uid"`
	Username    string  `json:"username"`
}

func (p ProjectTargetsCreator1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectTargetsCreator1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"email", "uid", "username"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectTargetsCreator1) GetEmail() string {
	if o == nil {
		return ""
	}
	return o.Email
}

func (o *ProjectTargetsCreator1) GetGithubLogin() *string {
	if o == nil {
		return nil
	}
	return o.GithubLogin
}

func (o *ProjectTargetsCreator1) GetGitlabLogin() *string {
	if o == nil {
		return nil
	}
	return o.GitlabLogin
}

func (o *ProjectTargetsCreator1) GetUID() string {
	if o == nil {
		return ""
	}
	return o.UID
}

func (o *ProjectTargetsCreator1) GetUsername() string {
	if o == nil {
		return ""
	}
	return o.Username
}

type ProjectTargets1 struct {
	Alias              []string                      `json:"alias,omitempty"`
	AliasAssigned      *ProjectTargetsAliasAssigned1 `json:"aliasAssigned,omitempty"`
	Builds             []ProjectTargetsBuild1        `json:"builds,omitempty"`
	CreatedAt          float64                       `json:"createdAt"`
	CreatedIn          string                        `json:"createdIn"`
	Creator            *ProjectTargetsCreator1       `json:"creator"`
	DeploymentHostname string                        `json:"deploymentHostname"`
	Name               string                        `json:"name"`
	Forced             *bool                         `json:"forced,omitempty"`
	ID                 string                        `json:"id"`
	Meta               map[string]string             `json:"meta,omitempty"`
	Plan               string                        `json:"plan"`
	Private            bool                          `json:"private"`
	ReadyState         string                        `json:"readyState"`
	RequestedAt        *float64                      `json:"requestedAt,omitempty"`
	Target             *string                       `json:"target,omitempty"`
	TeamID             *string                       `json:"teamId,omitempty"`
	Type               string                        `json:"type"`
	URL                string                        `json:"url"`
	UserID             string                        `json:"userId"`
	WithCache          *bool                         `json:"withCache,omitempty"`
}

func (p ProjectTargets1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectTargets1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"createdAt", "createdIn", "creator", "deploymentHostname", "name", "id", "plan", "private", "readyState", "type", "url", "userId"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectTargets1) GetAlias() []string {
	if o == nil {
		return nil
	}
	return o.Alias
}

func (o *ProjectTargets1) GetAliasAssigned() *ProjectTargetsAliasAssigned1 {
	if o == nil {
		return nil
	}
	return o.AliasAssigned
}

func (o *ProjectTargets1) GetBuilds() []ProjectTargetsBuild1 {
	if o == nil {
		return nil
	}
	return o.Builds
}

func (o *ProjectTargets1) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *ProjectTargets1) GetCreatedIn() string {
	if o == nil {
		return ""
	}
	return o.CreatedIn
}

func (o *ProjectTargets1) GetCreator() *ProjectTargetsCreator1 {
	if o == nil {
		return nil
	}
	return o.Creator
}

func (o *ProjectTargets1) GetDeploymentHostname() string {
	if o == nil {
		return ""
	}
	return o.DeploymentHostname
}

func (o *ProjectTargets1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *ProjectTargets1) GetForced() *bool {
	if o == nil {
		return nil
	}
	return o.Forced
}

func (o *ProjectTargets1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectTargets1) GetMeta() map[string]string {
	if o == nil {
		return nil
	}
	return o.Meta
}

func (o *ProjectTargets1) GetPlan() string {
	if o == nil {
		return ""
	}
	return o.Plan
}

func (o *ProjectTargets1) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *ProjectTargets1) GetReadyState() string {
	if o == nil {
		return ""
	}
	return o.ReadyState
}

func (o *ProjectTargets1) GetRequestedAt() *float64 {
	if o == nil {
		return nil
	}
	return o.RequestedAt
}

func (o *ProjectTargets1) GetTarget() *string {
	if o == nil {
		return nil
	}
	return o.Target
}

func (o *ProjectTargets1) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *ProjectTargets1) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *ProjectTargets1) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *ProjectTargets1) GetUserID() string {
	if o == nil {
		return ""
	}
	return o.UserID
}

func (o *ProjectTargets1) GetWithCache() *bool {
	if o == nil {
		return nil
	}
	return o.WithCache
}

type ProjectGitComments1 struct {
	// Whether the Vercel bot should comment on PRs
	OnPullRequest bool `json:"onPullRequest"`
	// Whether the Vercel bot should comment on commits
	OnCommit bool `json:"onCommit"`
}

func (p ProjectGitComments1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectGitComments1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"onPullRequest", "onCommit"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectGitComments1) GetOnPullRequest() bool {
	if o == nil {
		return false
	}
	return o.OnPullRequest
}

func (o *ProjectGitComments1) GetOnCommit() bool {
	if o == nil {
		return false
	}
	return o.OnCommit
}

// ProjectCreateDeployments1 - Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
type ProjectCreateDeployments1 string

const (
	ProjectCreateDeployments1Enabled  ProjectCreateDeployments1 = "enabled"
	ProjectCreateDeployments1Disabled ProjectCreateDeployments1 = "disabled"
)

func (e ProjectCreateDeployments1) ToPointer() *ProjectCreateDeployments1 {
	return &e
}
func (e *ProjectCreateDeployments1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "enabled":
		fallthrough
	case "disabled":
		*e = ProjectCreateDeployments1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for ProjectCreateDeployments1: %v", v)
	}
}

type ProjectGitProviderOptions1 struct {
	// Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
	CreateDeployments ProjectCreateDeployments1 `json:"createDeployments"`
	// Whether the Vercel bot should not automatically create GitHub repository-dispatch events on deployment events. https://vercel.com/docs/git/vercel-for-github#repository-dispatch-events
	DisableRepositoryDispatchEvents *bool `json:"disableRepositoryDispatchEvents,omitempty"`
	// Whether the project requires commits to be signed before deployments will be created.
	RequireVerifiedCommits *bool `json:"requireVerifiedCommits,omitempty"`
}

func (p ProjectGitProviderOptions1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectGitProviderOptions1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"createDeployments"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectGitProviderOptions1) GetCreateDeployments() ProjectCreateDeployments1 {
	if o == nil {
		return ProjectCreateDeployments1("")
	}
	return o.CreateDeployments
}

func (o *ProjectGitProviderOptions1) GetDisableRepositoryDispatchEvents() *bool {
	if o == nil {
		return nil
	}
	return o.DisableRepositoryDispatchEvents
}

func (o *ProjectGitProviderOptions1) GetRequireVerifiedCommits() *bool {
	if o == nil {
		return nil
	}
	return o.RequireVerifiedCommits
}

type ProjectWebAnalytics1 struct {
	ID         string   `json:"id"`
	DisabledAt *float64 `json:"disabledAt,omitempty"`
	CanceledAt *float64 `json:"canceledAt,omitempty"`
	EnabledAt  *float64 `json:"enabledAt,omitempty"`
	HasData    *bool    `json:"hasData,omitempty"`
}

func (p ProjectWebAnalytics1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(p, "", false)
}

func (p *ProjectWebAnalytics1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &p, "", false, []string{"id"}); err != nil {
		return err
	}
	return nil
}

func (o *ProjectWebAnalytics1) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *ProjectWebAnalytics1) GetDisabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.DisabledAt
}

func (o *ProjectWebAnalytics1) GetCanceledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.CanceledAt
}

func (o *ProjectWebAnalytics1) GetEnabledAt() *float64 {
	if o == nil {
		return nil
	}
	return o.EnabledAt
}

func (o *ProjectWebAnalytics1) GetHasData() *bool {
	if o == nil {
		return nil
	}
	return o.HasData
}

type SrcProject struct {
	Re   *string  `json:"re,omitempty"`
	Eq   *string  `json:"eq,omitempty"`
	Neq  *string  `json:"neq,omitempty"`
	Inc  []string `json:"inc,omitempty"`
	Ninc []string `json:"ninc,omitempty"`
	Pre  *string  `json:"pre,omitempty"`
	Suf  *string  `json:"suf,omitempty"`
	Gt   *float64 `json:"gt,omitempty"`
	Gte  *float64 `json:"gte,omitempty"`
	Lt   *float64 `json:"lt,omitempty"`
	Lte  *float64 `json:"lte,omitempty"`
}

func (s SrcProject) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SrcProject) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *SrcProject) GetRe() *string {
	if o == nil {
		return nil
	}
	return o.Re
}

func (o *SrcProject) GetEq() *string {
	if o == nil {
		return nil
	}
	return o.Eq
}

func (o *SrcProject) GetNeq() *string {
	if o == nil {
		return nil
	}
	return o.Neq
}

func (o *SrcProject) GetInc() []string {
	if o == nil {
		return nil
	}
	return o.Inc
}

func (o *SrcProject) GetNinc() []string {
	if o == nil {
		return nil
	}
	return o.Ninc
}

func (o *SrcProject) GetPre() *string {
	if o == nil {
		return nil
	}
	return o.Pre
}

func (o *SrcProject) GetSuf() *string {
	if o == nil {
		return nil
	}
	return o.Suf
}

func (o *SrcProject) GetGt() *float64 {
	if o == nil {
		return nil
	}
	return o.Gt
}

func (o *SrcProject) GetGte() *float64 {
	if o == nil {
		return nil
	}
	return o.Gte
}

func (o *SrcProject) GetLt() *float64 {
	if o == nil {
		return nil
	}
	return o.Lt
}

func (o *SrcProject) GetLte() *float64 {
	if o == nil {
		return nil
	}
	return o.Lte
}

type ProjectSrcUnionType string

const (
	ProjectSrcUnionTypeStr        ProjectSrcUnionType = "str"
	ProjectSrcUnionTypeSrcProject ProjectSrcUnionType = "src_project"
)

type ProjectSrcUnion struct {
	Str        *string     `queryParam:"inline"`
	SrcProject *SrcProject `queryParam:"inline"`

	Type ProjectSrcUnionType
}

func CreateProjectSrcUnionStr(str string) ProjectSrcUnion {
	typ := ProjectSrcUnionTypeStr

	return ProjectSrcUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateProjectSrcUnionSrcProject(srcProject SrcProject) ProjectSrcUnion {
	typ := ProjectSrcUnionTypeSrcProject

	return ProjectSrcUnion{
		SrcProject: &srcProject,
		Type:       typ,
	}
}

func (u *ProjectSrcUnion) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = ProjectSrcUnionTypeStr
		return nil
	}

	var srcProject SrcProject = SrcProject{}
	if err := utils.UnmarshalJSON(data, &srcProject, "", true, nil); err == nil {
		u.SrcProject = &srcProject
		u.Type = ProjectSrcUnionTypeSrcProject
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for ProjectSrcUnion", string(data))
}

func (u ProjectSrcUnion) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.SrcProject != nil {
		return utils.MarshalJSON(u.SrcProject, "", true)
	}

	return nil, errors.New("could not marshal union type ProjectSrcUnion: all fields are null")
}
