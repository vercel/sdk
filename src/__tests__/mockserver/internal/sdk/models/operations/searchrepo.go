// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type QueryParamNamespaceIDType string

const (
	QueryParamNamespaceIDTypeStr    QueryParamNamespaceIDType = "str"
	QueryParamNamespaceIDTypeNumber QueryParamNamespaceIDType = "number"
)

type QueryParamNamespaceID struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type QueryParamNamespaceIDType
}

func CreateQueryParamNamespaceIDStr(str string) QueryParamNamespaceID {
	typ := QueryParamNamespaceIDTypeStr

	return QueryParamNamespaceID{
		Str:  &str,
		Type: typ,
	}
}

func CreateQueryParamNamespaceIDNumber(number float64) QueryParamNamespaceID {
	typ := QueryParamNamespaceIDTypeNumber

	return QueryParamNamespaceID{
		Number: &number,
		Type:   typ,
	}
}

func (u *QueryParamNamespaceID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = QueryParamNamespaceIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = QueryParamNamespaceIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for QueryParamNamespaceID", string(data))
}

func (u QueryParamNamespaceID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type QueryParamNamespaceID: all fields are null")
}

type SearchRepoQueryParamProvider string

const (
	SearchRepoQueryParamProviderGithub           SearchRepoQueryParamProvider = "github"
	SearchRepoQueryParamProviderGithubLimited    SearchRepoQueryParamProvider = "github-limited"
	SearchRepoQueryParamProviderGithubCustomHost SearchRepoQueryParamProvider = "github-custom-host"
	SearchRepoQueryParamProviderGitlab           SearchRepoQueryParamProvider = "gitlab"
	SearchRepoQueryParamProviderBitbucket        SearchRepoQueryParamProvider = "bitbucket"
)

func (e SearchRepoQueryParamProvider) ToPointer() *SearchRepoQueryParamProvider {
	return &e
}
func (e *SearchRepoQueryParamProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		fallthrough
	case "github-limited":
		fallthrough
	case "github-custom-host":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		*e = SearchRepoQueryParamProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchRepoQueryParamProvider: %v", v)
	}
}

type SearchRepoRequest struct {
	Query          *string                       `queryParam:"style=form,explode=true,name=query"`
	NamespaceID    *QueryParamNamespaceID        `queryParam:"style=form,explode=true,name=namespaceId"`
	Provider       *SearchRepoQueryParamProvider `queryParam:"style=form,explode=true,name=provider"`
	InstallationID *string                       `queryParam:"style=form,explode=true,name=installationId"`
	// The custom Git host if using a custom Git provider, like GitHub Enterprise Server
	Host *string `queryParam:"style=form,explode=true,name=host"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string `queryParam:"style=form,explode=true,name=slug"`
}

func (o *SearchRepoRequest) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *SearchRepoRequest) GetNamespaceID() *QueryParamNamespaceID {
	if o == nil {
		return nil
	}
	return o.NamespaceID
}

func (o *SearchRepoRequest) GetProvider() *SearchRepoQueryParamProvider {
	if o == nil {
		return nil
	}
	return o.Provider
}

func (o *SearchRepoRequest) GetInstallationID() *string {
	if o == nil {
		return nil
	}
	return o.InstallationID
}

func (o *SearchRepoRequest) GetHost() *string {
	if o == nil {
		return nil
	}
	return o.Host
}

func (o *SearchRepoRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *SearchRepoRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

type GitAccountProvider string

const (
	GitAccountProviderGithub           GitAccountProvider = "github"
	GitAccountProviderGithubLimited    GitAccountProvider = "github-limited"
	GitAccountProviderGithubCustomHost GitAccountProvider = "github-custom-host"
	GitAccountProviderGitlab           GitAccountProvider = "gitlab"
	GitAccountProviderBitbucket        GitAccountProvider = "bitbucket"
)

func (e GitAccountProvider) ToPointer() *GitAccountProvider {
	return &e
}
func (e *GitAccountProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		fallthrough
	case "github-limited":
		fallthrough
	case "github-custom-host":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		*e = GitAccountProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for GitAccountProvider: %v", v)
	}
}

type NamespaceIDResponseType string

const (
	NamespaceIDResponseTypeStr    NamespaceIDResponseType = "str"
	NamespaceIDResponseTypeNumber NamespaceIDResponseType = "number"
)

type NamespaceIDResponse struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type NamespaceIDResponseType
}

func CreateNamespaceIDResponseStr(str string) NamespaceIDResponse {
	typ := NamespaceIDResponseTypeStr

	return NamespaceIDResponse{
		Str:  &str,
		Type: typ,
	}
}

func CreateNamespaceIDResponseNumber(number float64) NamespaceIDResponse {
	typ := NamespaceIDResponseTypeNumber

	return NamespaceIDResponse{
		Number: &number,
		Type:   typ,
	}
}

func (u *NamespaceIDResponse) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = NamespaceIDResponseTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = NamespaceIDResponseTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for NamespaceIDResponse", string(data))
}

func (u NamespaceIDResponse) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type NamespaceIDResponse: all fields are null")
}

type GitAccount struct {
	Provider    GitAccountProvider   `json:"provider"`
	NamespaceID *NamespaceIDResponse `json:"namespaceId"`
}

func (g GitAccount) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GitAccount) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"provider", "namespaceId"}); err != nil {
		return err
	}
	return nil
}

func (o *GitAccount) GetProvider() GitAccountProvider {
	if o == nil {
		return GitAccountProvider("")
	}
	return o.Provider
}

func (o *GitAccount) GetNamespaceID() *NamespaceIDResponse {
	if o == nil {
		return nil
	}
	return o.NamespaceID
}

type SearchRepoIDType string

const (
	SearchRepoIDTypeStr    SearchRepoIDType = "str"
	SearchRepoIDTypeNumber SearchRepoIDType = "number"
)

type SearchRepoID struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type SearchRepoIDType
}

func CreateSearchRepoIDStr(str string) SearchRepoID {
	typ := SearchRepoIDTypeStr

	return SearchRepoID{
		Str:  &str,
		Type: typ,
	}
}

func CreateSearchRepoIDNumber(number float64) SearchRepoID {
	typ := SearchRepoIDTypeNumber

	return SearchRepoID{
		Number: &number,
		Type:   typ,
	}
}

func (u *SearchRepoID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SearchRepoIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = SearchRepoIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchRepoID", string(data))
}

func (u SearchRepoID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type SearchRepoID: all fields are null")
}

type RepoProvider string

const (
	RepoProviderGithub           RepoProvider = "github"
	RepoProviderGithubLimited    RepoProvider = "github-limited"
	RepoProviderGithubCustomHost RepoProvider = "github-custom-host"
	RepoProviderGitlab           RepoProvider = "gitlab"
	RepoProviderBitbucket        RepoProvider = "bitbucket"
)

func (e RepoProvider) ToPointer() *RepoProvider {
	return &e
}
func (e *RepoProvider) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "github":
		fallthrough
	case "github-limited":
		fallthrough
	case "github-custom-host":
		fallthrough
	case "gitlab":
		fallthrough
	case "bitbucket":
		*e = RepoProvider(v)
		return nil
	default:
		return fmt.Errorf("invalid value for RepoProvider: %v", v)
	}
}

type OwnerIDType string

const (
	OwnerIDTypeStr    OwnerIDType = "str"
	OwnerIDTypeNumber OwnerIDType = "number"
)

type OwnerID struct {
	Str    *string  `queryParam:"inline"`
	Number *float64 `queryParam:"inline"`

	Type OwnerIDType
}

func CreateOwnerIDStr(str string) OwnerID {
	typ := OwnerIDTypeStr

	return OwnerID{
		Str:  &str,
		Type: typ,
	}
}

func CreateOwnerIDNumber(number float64) OwnerID {
	typ := OwnerIDTypeNumber

	return OwnerID{
		Number: &number,
		Type:   typ,
	}
}

func (u *OwnerID) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = OwnerIDTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = OwnerIDTypeNumber
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for OwnerID", string(data))
}

func (u OwnerID) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	return nil, errors.New("could not marshal union type OwnerID: all fields are null")
}

type Owner struct {
	ID   OwnerID `json:"id"`
	Name string  `json:"name"`
}

func (o Owner) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(o, "", false)
}

func (o *Owner) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &o, "", false, []string{"id", "name"}); err != nil {
		return err
	}
	return nil
}

func (o *Owner) GetID() OwnerID {
	if o == nil {
		return OwnerID{}
	}
	return o.ID
}

func (o *Owner) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

type SearchRepoOwnerType string

const (
	SearchRepoOwnerTypeUser SearchRepoOwnerType = "user"
	SearchRepoOwnerTypeTeam SearchRepoOwnerType = "team"
)

func (e SearchRepoOwnerType) ToPointer() *SearchRepoOwnerType {
	return &e
}
func (e *SearchRepoOwnerType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "user":
		fallthrough
	case "team":
		*e = SearchRepoOwnerType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SearchRepoOwnerType: %v", v)
	}
}

type Repo struct {
	ID            SearchRepoID        `json:"id"`
	Provider      RepoProvider        `json:"provider"`
	URL           string              `json:"url"`
	Name          string              `json:"name"`
	Slug          string              `json:"slug"`
	Namespace     string              `json:"namespace"`
	Owner         Owner               `json:"owner"`
	OwnerType     SearchRepoOwnerType `json:"ownerType"`
	Private       bool                `json:"private"`
	DefaultBranch string              `json:"defaultBranch"`
	UpdatedAt     float64             `json:"updatedAt"`
}

func (r Repo) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(r, "", false)
}

func (r *Repo) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &r, "", false, []string{"id", "provider", "url", "name", "slug", "namespace", "owner", "ownerType", "private", "defaultBranch", "updatedAt"}); err != nil {
		return err
	}
	return nil
}

func (o *Repo) GetID() SearchRepoID {
	if o == nil {
		return SearchRepoID{}
	}
	return o.ID
}

func (o *Repo) GetProvider() RepoProvider {
	if o == nil {
		return RepoProvider("")
	}
	return o.Provider
}

func (o *Repo) GetURL() string {
	if o == nil {
		return ""
	}
	return o.URL
}

func (o *Repo) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Repo) GetSlug() string {
	if o == nil {
		return ""
	}
	return o.Slug
}

func (o *Repo) GetNamespace() string {
	if o == nil {
		return ""
	}
	return o.Namespace
}

func (o *Repo) GetOwner() Owner {
	if o == nil {
		return Owner{}
	}
	return o.Owner
}

func (o *Repo) GetOwnerType() SearchRepoOwnerType {
	if o == nil {
		return SearchRepoOwnerType("")
	}
	return o.OwnerType
}

func (o *Repo) GetPrivate() bool {
	if o == nil {
		return false
	}
	return o.Private
}

func (o *Repo) GetDefaultBranch() string {
	if o == nil {
		return ""
	}
	return o.DefaultBranch
}

func (o *Repo) GetUpdatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.UpdatedAt
}

type SearchRepoResponseBody2 struct {
	GitAccount GitAccount `json:"gitAccount"`
	Repos      []Repo     `json:"repos"`
}

func (s SearchRepoResponseBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SearchRepoResponseBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"gitAccount", "repos"}); err != nil {
		return err
	}
	return nil
}

func (o *SearchRepoResponseBody2) GetGitAccount() GitAccount {
	if o == nil {
		return GitAccount{}
	}
	return o.GitAccount
}

func (o *SearchRepoResponseBody2) GetRepos() []Repo {
	if o == nil {
		return []Repo{}
	}
	return o.Repos
}

type SearchRepoResponseBody1 struct {
}

func (s SearchRepoResponseBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SearchRepoResponseBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, nil); err != nil {
		return err
	}
	return nil
}

type SearchRepoResponseBodyType string

const (
	SearchRepoResponseBodyTypeSearchRepoResponseBody1 SearchRepoResponseBodyType = "searchRepo_ResponseBody_1"
	SearchRepoResponseBodyTypeSearchRepoResponseBody2 SearchRepoResponseBodyType = "searchRepo_ResponseBody_2"
)

type SearchRepoResponseBody struct {
	SearchRepoResponseBody1 *SearchRepoResponseBody1 `queryParam:"inline"`
	SearchRepoResponseBody2 *SearchRepoResponseBody2 `queryParam:"inline"`

	Type SearchRepoResponseBodyType
}

func CreateSearchRepoResponseBodySearchRepoResponseBody1(searchRepoResponseBody1 SearchRepoResponseBody1) SearchRepoResponseBody {
	typ := SearchRepoResponseBodyTypeSearchRepoResponseBody1

	return SearchRepoResponseBody{
		SearchRepoResponseBody1: &searchRepoResponseBody1,
		Type:                    typ,
	}
}

func CreateSearchRepoResponseBodySearchRepoResponseBody2(searchRepoResponseBody2 SearchRepoResponseBody2) SearchRepoResponseBody {
	typ := SearchRepoResponseBodyTypeSearchRepoResponseBody2

	return SearchRepoResponseBody{
		SearchRepoResponseBody2: &searchRepoResponseBody2,
		Type:                    typ,
	}
}

func (u *SearchRepoResponseBody) UnmarshalJSON(data []byte) error {

	var searchRepoResponseBody2 SearchRepoResponseBody2 = SearchRepoResponseBody2{}
	if err := utils.UnmarshalJSON(data, &searchRepoResponseBody2, "", true, nil); err == nil {
		u.SearchRepoResponseBody2 = &searchRepoResponseBody2
		u.Type = SearchRepoResponseBodyTypeSearchRepoResponseBody2
		return nil
	}

	var searchRepoResponseBody1 SearchRepoResponseBody1 = SearchRepoResponseBody1{}
	if err := utils.UnmarshalJSON(data, &searchRepoResponseBody1, "", true, nil); err == nil {
		u.SearchRepoResponseBody1 = &searchRepoResponseBody1
		u.Type = SearchRepoResponseBodyTypeSearchRepoResponseBody1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for SearchRepoResponseBody", string(data))
}

func (u SearchRepoResponseBody) MarshalJSON() ([]byte, error) {
	if u.SearchRepoResponseBody1 != nil {
		return utils.MarshalJSON(u.SearchRepoResponseBody1, "", true)
	}

	if u.SearchRepoResponseBody2 != nil {
		return utils.MarshalJSON(u.SearchRepoResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type SearchRepoResponseBody: all fields are null")
}

type SearchRepoResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *SearchRepoResponseBody
}

func (o *SearchRepoResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *SearchRepoResponse) GetOneOf() *SearchRepoResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
