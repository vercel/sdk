// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
	"time"
)

// SubmitBillingDataPeriod - Period for the billing cycle. The period end date cannot be older than 24 hours earlier than our current server's time.
type SubmitBillingDataPeriod struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

func (s SubmitBillingDataPeriod) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SubmitBillingDataPeriod) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"start", "end"}); err != nil {
		return err
	}
	return nil
}

func (o *SubmitBillingDataPeriod) GetStart() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Start
}

func (o *SubmitBillingDataPeriod) GetEnd() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.End
}

type SubmitBillingDataItem struct {
	// Partner's billing plan ID.
	BillingPlanID string `json:"billingPlanId"`
	// Partner's resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	Start *time.Time `json:"start,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	End *time.Time `json:"end,omitempty"`
	// Line item name.
	Name string `json:"name"`
	// Line item details.
	Details *string `json:"details,omitempty"`
	// Price per unit.
	Price string `json:"price"`
	// Quantity of units.
	Quantity float64 `json:"quantity"`
	// Units of the quantity.
	Units string `json:"units"`
	// Total amount.
	Total string `json:"total"`
}

func (s SubmitBillingDataItem) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SubmitBillingDataItem) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"billingPlanId", "name", "price", "quantity", "units", "total"}); err != nil {
		return err
	}
	return nil
}

func (o *SubmitBillingDataItem) GetBillingPlanID() string {
	if o == nil {
		return ""
	}
	return o.BillingPlanID
}

func (o *SubmitBillingDataItem) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *SubmitBillingDataItem) GetStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.Start
}

func (o *SubmitBillingDataItem) GetEnd() *time.Time {
	if o == nil {
		return nil
	}
	return o.End
}

func (o *SubmitBillingDataItem) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *SubmitBillingDataItem) GetDetails() *string {
	if o == nil {
		return nil
	}
	return o.Details
}

func (o *SubmitBillingDataItem) GetPrice() string {
	if o == nil {
		return ""
	}
	return o.Price
}

func (o *SubmitBillingDataItem) GetQuantity() float64 {
	if o == nil {
		return 0.0
	}
	return o.Quantity
}

func (o *SubmitBillingDataItem) GetUnits() string {
	if o == nil {
		return ""
	}
	return o.Units
}

func (o *SubmitBillingDataItem) GetTotal() string {
	if o == nil {
		return ""
	}
	return o.Total
}

type SubmitBillingDataDiscount struct {
	// Partner's billing plan ID.
	BillingPlanID string `json:"billingPlanId"`
	// Partner's resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	Start *time.Time `json:"start,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	End *time.Time `json:"end,omitempty"`
	// Discount name.
	Name string `json:"name"`
	// Discount details.
	Details *string `json:"details,omitempty"`
	// Discount amount.
	Amount string `json:"amount"`
}

func (s SubmitBillingDataDiscount) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SubmitBillingDataDiscount) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"billingPlanId", "name", "amount"}); err != nil {
		return err
	}
	return nil
}

func (o *SubmitBillingDataDiscount) GetBillingPlanID() string {
	if o == nil {
		return ""
	}
	return o.BillingPlanID
}

func (o *SubmitBillingDataDiscount) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *SubmitBillingDataDiscount) GetStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.Start
}

func (o *SubmitBillingDataDiscount) GetEnd() *time.Time {
	if o == nil {
		return nil
	}
	return o.End
}

func (o *SubmitBillingDataDiscount) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *SubmitBillingDataDiscount) GetDetails() *string {
	if o == nil {
		return nil
	}
	return o.Details
}

func (o *SubmitBillingDataDiscount) GetAmount() string {
	if o == nil {
		return ""
	}
	return o.Amount
}

type Billing2 struct {
	Items     []SubmitBillingDataItem     `json:"items"`
	Discounts []SubmitBillingDataDiscount `json:"discounts,omitempty"`
}

func (b Billing2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *Billing2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"items"}); err != nil {
		return err
	}
	return nil
}

func (o *Billing2) GetItems() []SubmitBillingDataItem {
	if o == nil {
		return []SubmitBillingDataItem{}
	}
	return o.Items
}

func (o *Billing2) GetDiscounts() []SubmitBillingDataDiscount {
	if o == nil {
		return nil
	}
	return o.Discounts
}

type Billing1 struct {
	// Partner's billing plan ID.
	BillingPlanID string `json:"billingPlanId"`
	// Partner's resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	Start *time.Time `json:"start,omitempty"`
	// Start and end are only needed if different from the period's start/end.
	End *time.Time `json:"end,omitempty"`
	// Line item name.
	Name string `json:"name"`
	// Line item details.
	Details *string `json:"details,omitempty"`
	// Price per unit.
	Price string `json:"price"`
	// Quantity of units.
	Quantity float64 `json:"quantity"`
	// Units of the quantity.
	Units string `json:"units"`
	// Total amount.
	Total string `json:"total"`
}

func (b Billing1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(b, "", false)
}

func (b *Billing1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &b, "", false, []string{"billingPlanId", "name", "price", "quantity", "units", "total"}); err != nil {
		return err
	}
	return nil
}

func (o *Billing1) GetBillingPlanID() string {
	if o == nil {
		return ""
	}
	return o.BillingPlanID
}

func (o *Billing1) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *Billing1) GetStart() *time.Time {
	if o == nil {
		return nil
	}
	return o.Start
}

func (o *Billing1) GetEnd() *time.Time {
	if o == nil {
		return nil
	}
	return o.End
}

func (o *Billing1) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Billing1) GetDetails() *string {
	if o == nil {
		return nil
	}
	return o.Details
}

func (o *Billing1) GetPrice() string {
	if o == nil {
		return ""
	}
	return o.Price
}

func (o *Billing1) GetQuantity() float64 {
	if o == nil {
		return 0.0
	}
	return o.Quantity
}

func (o *Billing1) GetUnits() string {
	if o == nil {
		return ""
	}
	return o.Units
}

func (o *Billing1) GetTotal() string {
	if o == nil {
		return ""
	}
	return o.Total
}

type BillingUnionType string

const (
	BillingUnionTypeArrayOfBilling1 BillingUnionType = "arrayOfBilling1"
	BillingUnionTypeBilling2        BillingUnionType = "billing_2"
)

// BillingUnion - Billing data (interim invoicing data).
type BillingUnion struct {
	ArrayOfBilling1 []Billing1 `queryParam:"inline"`
	Billing2        *Billing2  `queryParam:"inline"`

	Type BillingUnionType
}

func CreateBillingUnionArrayOfBilling1(arrayOfBilling1 []Billing1) BillingUnion {
	typ := BillingUnionTypeArrayOfBilling1

	return BillingUnion{
		ArrayOfBilling1: arrayOfBilling1,
		Type:            typ,
	}
}

func CreateBillingUnionBilling2(billing2 Billing2) BillingUnion {
	typ := BillingUnionTypeBilling2

	return BillingUnion{
		Billing2: &billing2,
		Type:     typ,
	}
}

func (u *BillingUnion) UnmarshalJSON(data []byte) error {

	var billing2 Billing2 = Billing2{}
	if err := utils.UnmarshalJSON(data, &billing2, "", true, nil); err == nil {
		u.Billing2 = &billing2
		u.Type = BillingUnionTypeBilling2
		return nil
	}

	var arrayOfBilling1 []Billing1 = []Billing1{}
	if err := utils.UnmarshalJSON(data, &arrayOfBilling1, "", true, nil); err == nil {
		u.ArrayOfBilling1 = arrayOfBilling1
		u.Type = BillingUnionTypeArrayOfBilling1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BillingUnion", string(data))
}

func (u BillingUnion) MarshalJSON() ([]byte, error) {
	if u.ArrayOfBilling1 != nil {
		return utils.MarshalJSON(u.ArrayOfBilling1, "", true)
	}

	if u.Billing2 != nil {
		return utils.MarshalJSON(u.Billing2, "", true)
	}

	return nil, errors.New("could not marshal union type BillingUnion: all fields are null")
}

// SubmitBillingDataType - \n              Type of the metric.\n              - total: measured total value, such as Database size\n              - interval: usage during the period, such as i/o or number of queries.\n              - rate: rate of usage, such as queries per second.\n
type SubmitBillingDataType string

const (
	SubmitBillingDataTypeTotal    SubmitBillingDataType = "total"
	SubmitBillingDataTypeInterval SubmitBillingDataType = "interval"
	SubmitBillingDataTypeRate     SubmitBillingDataType = "rate"
)

func (e SubmitBillingDataType) ToPointer() *SubmitBillingDataType {
	return &e
}
func (e *SubmitBillingDataType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "total":
		fallthrough
	case "interval":
		fallthrough
	case "rate":
		*e = SubmitBillingDataType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for SubmitBillingDataType: %v", v)
	}
}

type Usage struct {
	// Partner's resource ID.
	ResourceID *string `json:"resourceId,omitempty"`
	// Metric name.
	Name string `json:"name"`
	// \n              Type of the metric.\n              - total: measured total value, such as Database size\n              - interval: usage during the period, such as i/o or number of queries.\n              - rate: rate of usage, such as queries per second.\n
	Type SubmitBillingDataType `json:"type"`
	// Metric units. Example: \"GB\"
	Units string `json:"units"`
	// Metric value for the day. Could be a final or an interim value for the day.
	DayValue float64 `json:"dayValue"`
	// Metric value for the billing period. Could be a final or an interim value for the period.
	PeriodValue float64 `json:"periodValue"`
	// The limit value of the metric for a billing period, if a limit is defined by the plan.
	PlanValue *float64 `json:"planValue,omitempty"`
}

func (o *Usage) GetResourceID() *string {
	if o == nil {
		return nil
	}
	return o.ResourceID
}

func (o *Usage) GetName() string {
	if o == nil {
		return ""
	}
	return o.Name
}

func (o *Usage) GetType() SubmitBillingDataType {
	if o == nil {
		return SubmitBillingDataType("")
	}
	return o.Type
}

func (o *Usage) GetUnits() string {
	if o == nil {
		return ""
	}
	return o.Units
}

func (o *Usage) GetDayValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.DayValue
}

func (o *Usage) GetPeriodValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.PeriodValue
}

func (o *Usage) GetPlanValue() *float64 {
	if o == nil {
		return nil
	}
	return o.PlanValue
}

type SubmitBillingDataRequestBody struct {
	// Server time of your integration, used to determine the most recent data for race conditions & updates. Only the latest usage data for a given day, week, and month will be kept.
	Timestamp time.Time `json:"timestamp"`
	// End of Day, the UTC datetime for when the end of the billing/usage day is in UTC time. This tells us which day the usage data is for, and also allows for your \"end of day\" to be different from UTC 00:00:00. eod must be within the period dates, and cannot be older than 24h earlier from our server's current time.
	Eod time.Time `json:"eod"`
	// Period for the billing cycle. The period end date cannot be older than 24 hours earlier than our current server's time.
	Period SubmitBillingDataPeriod `json:"period"`
	// Billing data (interim invoicing data).
	Billing BillingUnion `json:"billing"`
	Usage   []Usage      `json:"usage"`
}

func (s SubmitBillingDataRequestBody) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(s, "", false)
}

func (s *SubmitBillingDataRequestBody) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &s, "", false, []string{"timestamp", "eod", "period", "billing", "usage"}); err != nil {
		return err
	}
	return nil
}

func (o *SubmitBillingDataRequestBody) GetTimestamp() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Timestamp
}

func (o *SubmitBillingDataRequestBody) GetEod() time.Time {
	if o == nil {
		return time.Time{}
	}
	return o.Eod
}

func (o *SubmitBillingDataRequestBody) GetPeriod() SubmitBillingDataPeriod {
	if o == nil {
		return SubmitBillingDataPeriod{}
	}
	return o.Period
}

func (o *SubmitBillingDataRequestBody) GetBilling() BillingUnion {
	if o == nil {
		return BillingUnion{}
	}
	return o.Billing
}

func (o *SubmitBillingDataRequestBody) GetUsage() []Usage {
	if o == nil {
		return []Usage{}
	}
	return o.Usage
}

type SubmitBillingDataRequest struct {
	IntegrationConfigurationID string                       `pathParam:"style=simple,explode=false,name=integrationConfigurationId"`
	Body                       SubmitBillingDataRequestBody `request:"mediaType=application/json"`
}

func (o *SubmitBillingDataRequest) GetIntegrationConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationConfigurationID
}

func (o *SubmitBillingDataRequest) GetBody() SubmitBillingDataRequestBody {
	if o == nil {
		return SubmitBillingDataRequestBody{}
	}
	return o.Body
}

type SubmitBillingDataResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
}

func (o *SubmitBillingDataResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}
