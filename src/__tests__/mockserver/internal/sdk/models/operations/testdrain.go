// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type TestDrainSchemas struct {
	Version string `json:"version"`
}

func (o *TestDrainSchemas) GetVersion() string {
	if o == nil {
		return ""
	}
	return o.Version
}

type TestDrainEndpoint struct {
	Traces string `json:"traces"`
}

func (t TestDrainEndpoint) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TestDrainEndpoint) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"traces"}); err != nil {
		return err
	}
	return nil
}

func (o *TestDrainEndpoint) GetTraces() string {
	if o == nil {
		return ""
	}
	return o.Traces
}

type TestDrainEndpointUnionType string

const (
	TestDrainEndpointUnionTypeTestDrainEndpoint TestDrainEndpointUnionType = "testDrain_endpoint"
)

type TestDrainEndpointUnion struct {
	TestDrainEndpoint *TestDrainEndpoint `queryParam:"inline"`

	Type TestDrainEndpointUnionType
}

func CreateTestDrainEndpointUnionTestDrainEndpoint(testDrainEndpoint TestDrainEndpoint) TestDrainEndpointUnion {
	typ := TestDrainEndpointUnionTypeTestDrainEndpoint

	return TestDrainEndpointUnion{
		TestDrainEndpoint: &testDrainEndpoint,
		Type:              typ,
	}
}

func (u *TestDrainEndpointUnion) UnmarshalJSON(data []byte) error {

	var testDrainEndpoint TestDrainEndpoint = TestDrainEndpoint{}
	if err := utils.UnmarshalJSON(data, &testDrainEndpoint, "", true, nil); err == nil {
		u.TestDrainEndpoint = &testDrainEndpoint
		u.Type = TestDrainEndpointUnionTypeTestDrainEndpoint
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TestDrainEndpointUnion", string(data))
}

func (u TestDrainEndpointUnion) MarshalJSON() ([]byte, error) {
	if u.TestDrainEndpoint != nil {
		return utils.MarshalJSON(u.TestDrainEndpoint, "", true)
	}

	return nil, errors.New("could not marshal union type TestDrainEndpointUnion: all fields are null")
}

type TestDrainEncoding2 string

const (
	TestDrainEncoding2Proto TestDrainEncoding2 = "proto"
	TestDrainEncoding2JSON  TestDrainEncoding2 = "json"
)

func (e TestDrainEncoding2) ToPointer() *TestDrainEncoding2 {
	return &e
}
func (e *TestDrainEncoding2) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "proto":
		fallthrough
	case "json":
		*e = TestDrainEncoding2(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TestDrainEncoding2: %v", v)
	}
}

type TestDrainDelivery2 struct {
	Type     string                 `json:"type"`
	Endpoint TestDrainEndpointUnion `json:"endpoint"`
	Encoding TestDrainEncoding2     `json:"encoding"`
	Headers  map[string]string      `json:"headers"`
	Secret   *string                `json:"secret,omitempty"`
}

func (t TestDrainDelivery2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TestDrainDelivery2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *TestDrainDelivery2) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TestDrainDelivery2) GetEndpoint() TestDrainEndpointUnion {
	if o == nil {
		return TestDrainEndpointUnion{}
	}
	return o.Endpoint
}

func (o *TestDrainDelivery2) GetEncoding() TestDrainEncoding2 {
	if o == nil {
		return TestDrainEncoding2("")
	}
	return o.Encoding
}

func (o *TestDrainDelivery2) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *TestDrainDelivery2) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type TestDrainCompression string

const (
	TestDrainCompressionGzip TestDrainCompression = "gzip"
	TestDrainCompressionNone TestDrainCompression = "none"
)

func (e TestDrainCompression) ToPointer() *TestDrainCompression {
	return &e
}
func (e *TestDrainCompression) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "gzip":
		fallthrough
	case "none":
		*e = TestDrainCompression(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TestDrainCompression: %v", v)
	}
}

type TestDrainEncoding1 string

const (
	TestDrainEncoding1JSON   TestDrainEncoding1 = "json"
	TestDrainEncoding1Ndjson TestDrainEncoding1 = "ndjson"
)

func (e TestDrainEncoding1) ToPointer() *TestDrainEncoding1 {
	return &e
}
func (e *TestDrainEncoding1) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "json":
		fallthrough
	case "ndjson":
		*e = TestDrainEncoding1(v)
		return nil
	default:
		return fmt.Errorf("invalid value for TestDrainEncoding1: %v", v)
	}
}

type TestDrainDelivery1 struct {
	Type        string                `json:"type"`
	Endpoint    string                `json:"endpoint"`
	Compression *TestDrainCompression `json:"compression,omitempty"`
	Encoding    TestDrainEncoding1    `json:"encoding"`
	Headers     map[string]string     `json:"headers"`
	Secret      *string               `json:"secret,omitempty"`
}

func (t TestDrainDelivery1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TestDrainDelivery1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"type", "endpoint", "encoding", "headers"}); err != nil {
		return err
	}
	return nil
}

func (o *TestDrainDelivery1) GetType() string {
	if o == nil {
		return ""
	}
	return o.Type
}

func (o *TestDrainDelivery1) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

func (o *TestDrainDelivery1) GetCompression() *TestDrainCompression {
	if o == nil {
		return nil
	}
	return o.Compression
}

func (o *TestDrainDelivery1) GetEncoding() TestDrainEncoding1 {
	if o == nil {
		return TestDrainEncoding1("")
	}
	return o.Encoding
}

func (o *TestDrainDelivery1) GetHeaders() map[string]string {
	if o == nil {
		return map[string]string{}
	}
	return o.Headers
}

func (o *TestDrainDelivery1) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

type TestDrainDeliveryUnionType string

const (
	TestDrainDeliveryUnionTypeTestDrainDelivery1 TestDrainDeliveryUnionType = "testDrain_delivery_1"
	TestDrainDeliveryUnionTypeTestDrainDelivery2 TestDrainDeliveryUnionType = "testDrain_delivery_2"
)

type TestDrainDeliveryUnion struct {
	TestDrainDelivery1 *TestDrainDelivery1 `queryParam:"inline"`
	TestDrainDelivery2 *TestDrainDelivery2 `queryParam:"inline"`

	Type TestDrainDeliveryUnionType
}

func CreateTestDrainDeliveryUnionTestDrainDelivery1(testDrainDelivery1 TestDrainDelivery1) TestDrainDeliveryUnion {
	typ := TestDrainDeliveryUnionTypeTestDrainDelivery1

	return TestDrainDeliveryUnion{
		TestDrainDelivery1: &testDrainDelivery1,
		Type:               typ,
	}
}

func CreateTestDrainDeliveryUnionTestDrainDelivery2(testDrainDelivery2 TestDrainDelivery2) TestDrainDeliveryUnion {
	typ := TestDrainDeliveryUnionTypeTestDrainDelivery2

	return TestDrainDeliveryUnion{
		TestDrainDelivery2: &testDrainDelivery2,
		Type:               typ,
	}
}

func (u *TestDrainDeliveryUnion) UnmarshalJSON(data []byte) error {

	var testDrainDelivery1 TestDrainDelivery1 = TestDrainDelivery1{}
	if err := utils.UnmarshalJSON(data, &testDrainDelivery1, "", true, nil); err == nil {
		u.TestDrainDelivery1 = &testDrainDelivery1
		u.Type = TestDrainDeliveryUnionTypeTestDrainDelivery1
		return nil
	}

	var testDrainDelivery2 TestDrainDelivery2 = TestDrainDelivery2{}
	if err := utils.UnmarshalJSON(data, &testDrainDelivery2, "", true, nil); err == nil {
		u.TestDrainDelivery2 = &testDrainDelivery2
		u.Type = TestDrainDeliveryUnionTypeTestDrainDelivery2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TestDrainDeliveryUnion", string(data))
}

func (u TestDrainDeliveryUnion) MarshalJSON() ([]byte, error) {
	if u.TestDrainDelivery1 != nil {
		return utils.MarshalJSON(u.TestDrainDelivery1, "", true)
	}

	if u.TestDrainDelivery2 != nil {
		return utils.MarshalJSON(u.TestDrainDelivery2, "", true)
	}

	return nil, errors.New("could not marshal union type TestDrainDeliveryUnion: all fields are null")
}

type TestDrainRequestBody struct {
	Schemas  map[string]TestDrainSchemas `json:"schemas"`
	Delivery TestDrainDeliveryUnion      `json:"delivery"`
}

func (o *TestDrainRequestBody) GetSchemas() map[string]TestDrainSchemas {
	if o == nil {
		return map[string]TestDrainSchemas{}
	}
	return o.Schemas
}

func (o *TestDrainRequestBody) GetDelivery() TestDrainDeliveryUnion {
	if o == nil {
		return TestDrainDeliveryUnion{}
	}
	return o.Delivery
}

type TestDrainRequest struct {
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string               `queryParam:"style=form,explode=true,name=slug"`
	Body *TestDrainRequestBody `request:"mediaType=application/json"`
}

func (o *TestDrainRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *TestDrainRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *TestDrainRequest) GetBody() *TestDrainRequestBody {
	if o == nil {
		return nil
	}
	return o.Body
}

type TestDrainResponseBody2 struct {
	Status   string `json:"status"`
	Error    string `json:"error"`
	Endpoint string `json:"endpoint"`
}

func (t TestDrainResponseBody2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TestDrainResponseBody2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, []string{"status", "error", "endpoint"}); err != nil {
		return err
	}
	return nil
}

func (o *TestDrainResponseBody2) GetStatus() string {
	if o == nil {
		return ""
	}
	return o.Status
}

func (o *TestDrainResponseBody2) GetError() string {
	if o == nil {
		return ""
	}
	return o.Error
}

func (o *TestDrainResponseBody2) GetEndpoint() string {
	if o == nil {
		return ""
	}
	return o.Endpoint
}

type TestDrainResponseBody1 struct {
}

func (t TestDrainResponseBody1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(t, "", false)
}

func (t *TestDrainResponseBody1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &t, "", false, nil); err != nil {
		return err
	}
	return nil
}

type TestDrainResponseBodyType string

const (
	TestDrainResponseBodyTypeTestDrainResponseBody1 TestDrainResponseBodyType = "testDrain_ResponseBody_1"
	TestDrainResponseBodyTypeTestDrainResponseBody2 TestDrainResponseBodyType = "testDrain_ResponseBody_2"
)

type TestDrainResponseBody struct {
	TestDrainResponseBody1 *TestDrainResponseBody1 `queryParam:"inline"`
	TestDrainResponseBody2 *TestDrainResponseBody2 `queryParam:"inline"`

	Type TestDrainResponseBodyType
}

func CreateTestDrainResponseBodyTestDrainResponseBody1(testDrainResponseBody1 TestDrainResponseBody1) TestDrainResponseBody {
	typ := TestDrainResponseBodyTypeTestDrainResponseBody1

	return TestDrainResponseBody{
		TestDrainResponseBody1: &testDrainResponseBody1,
		Type:                   typ,
	}
}

func CreateTestDrainResponseBodyTestDrainResponseBody2(testDrainResponseBody2 TestDrainResponseBody2) TestDrainResponseBody {
	typ := TestDrainResponseBodyTypeTestDrainResponseBody2

	return TestDrainResponseBody{
		TestDrainResponseBody2: &testDrainResponseBody2,
		Type:                   typ,
	}
}

func (u *TestDrainResponseBody) UnmarshalJSON(data []byte) error {

	var testDrainResponseBody2 TestDrainResponseBody2 = TestDrainResponseBody2{}
	if err := utils.UnmarshalJSON(data, &testDrainResponseBody2, "", true, nil); err == nil {
		u.TestDrainResponseBody2 = &testDrainResponseBody2
		u.Type = TestDrainResponseBodyTypeTestDrainResponseBody2
		return nil
	}

	var testDrainResponseBody1 TestDrainResponseBody1 = TestDrainResponseBody1{}
	if err := utils.UnmarshalJSON(data, &testDrainResponseBody1, "", true, nil); err == nil {
		u.TestDrainResponseBody1 = &testDrainResponseBody1
		u.Type = TestDrainResponseBodyTypeTestDrainResponseBody1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for TestDrainResponseBody", string(data))
}

func (u TestDrainResponseBody) MarshalJSON() ([]byte, error) {
	if u.TestDrainResponseBody1 != nil {
		return utils.MarshalJSON(u.TestDrainResponseBody1, "", true)
	}

	if u.TestDrainResponseBody2 != nil {
		return utils.MarshalJSON(u.TestDrainResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type TestDrainResponseBody: all fields are null")
}

type TestDrainResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	OneOf    *TestDrainResponseBody
}

func (o *TestDrainResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *TestDrainResponse) GetOneOf() *TestDrainResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
