// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type UpdateFlagValueType string

const (
	UpdateFlagValueTypeStr     UpdateFlagValueType = "str"
	UpdateFlagValueTypeNumber  UpdateFlagValueType = "number"
	UpdateFlagValueTypeBoolean UpdateFlagValueType = "boolean"
)

type UpdateFlagValue struct {
	Str     *string  `queryParam:"inline"`
	Number  *float64 `queryParam:"inline"`
	Boolean *bool    `queryParam:"inline"`

	Type UpdateFlagValueType
}

func CreateUpdateFlagValueStr(str string) UpdateFlagValue {
	typ := UpdateFlagValueTypeStr

	return UpdateFlagValue{
		Str:  &str,
		Type: typ,
	}
}

func CreateUpdateFlagValueNumber(number float64) UpdateFlagValue {
	typ := UpdateFlagValueTypeNumber

	return UpdateFlagValue{
		Number: &number,
		Type:   typ,
	}
}

func CreateUpdateFlagValueBoolean(boolean bool) UpdateFlagValue {
	typ := UpdateFlagValueTypeBoolean

	return UpdateFlagValue{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *UpdateFlagValue) UnmarshalJSON(data []byte) error {

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = UpdateFlagValueTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = UpdateFlagValueTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = UpdateFlagValueTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagValue", string(data))
}

func (u UpdateFlagValue) MarshalJSON() ([]byte, error) {
	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagValue: all fields are null")
}

type UpdateFlagVariant struct {
	// The id of the variant
	ID string `json:"id"`
	// A label for the variant
	Label *string `json:"label,omitempty"`
	// A description of the variant
	Description *string         `json:"description,omitempty"`
	Value       UpdateFlagValue `json:"value"`
}

func (o *UpdateFlagVariant) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *UpdateFlagVariant) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *UpdateFlagVariant) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *UpdateFlagVariant) GetValue() UpdateFlagValue {
	if o == nil {
		return UpdateFlagValue{}
	}
	return o.Value
}

// UpdateFlagReuse - Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
type UpdateFlagReuse struct {
	// Whether the reuse is active or not
	Active bool `json:"active"`
	// The environment to link to
	Environment string `json:"environment"`
}

func (o *UpdateFlagReuse) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *UpdateFlagReuse) GetEnvironment() string {
	if o == nil {
		return ""
	}
	return o.Environment
}

type UpdateFlagTarget struct {
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (o *UpdateFlagTarget) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *UpdateFlagTarget) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type UpdateFlagPausedOutcome struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (o *UpdateFlagPausedOutcome) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagPausedOutcome) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type UpdateFlagLHS2 struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (u UpdateFlagLHS2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagLHS2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagLHS2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagLHS2) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *UpdateFlagLHS2) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type UpdateFlagLHS1 struct {
	Type any `json:"type"`
}

func (u UpdateFlagLHS1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagLHS1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagLHS1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

type UpdateFlagLHSUnionType string

const (
	UpdateFlagLHSUnionTypeUpdateFlagLHS1 UpdateFlagLHSUnionType = "updateFlag_lhs_1"
	UpdateFlagLHSUnionTypeUpdateFlagLHS2 UpdateFlagLHSUnionType = "updateFlag_lhs_2"
)

type UpdateFlagLHSUnion struct {
	UpdateFlagLHS1 *UpdateFlagLHS1 `queryParam:"inline"`
	UpdateFlagLHS2 *UpdateFlagLHS2 `queryParam:"inline"`

	Type UpdateFlagLHSUnionType
}

func CreateUpdateFlagLHSUnionUpdateFlagLHS1(updateFlagLHS1 UpdateFlagLHS1) UpdateFlagLHSUnion {
	typ := UpdateFlagLHSUnionTypeUpdateFlagLHS1

	return UpdateFlagLHSUnion{
		UpdateFlagLHS1: &updateFlagLHS1,
		Type:           typ,
	}
}

func CreateUpdateFlagLHSUnionUpdateFlagLHS2(updateFlagLHS2 UpdateFlagLHS2) UpdateFlagLHSUnion {
	typ := UpdateFlagLHSUnionTypeUpdateFlagLHS2

	return UpdateFlagLHSUnion{
		UpdateFlagLHS2: &updateFlagLHS2,
		Type:           typ,
	}
}

func (u *UpdateFlagLHSUnion) UnmarshalJSON(data []byte) error {

	var updateFlagLHS2 UpdateFlagLHS2 = UpdateFlagLHS2{}
	if err := utils.UnmarshalJSON(data, &updateFlagLHS2, "", true, nil); err == nil {
		u.UpdateFlagLHS2 = &updateFlagLHS2
		u.Type = UpdateFlagLHSUnionTypeUpdateFlagLHS2
		return nil
	}

	var updateFlagLHS1 UpdateFlagLHS1 = UpdateFlagLHS1{}
	if err := utils.UnmarshalJSON(data, &updateFlagLHS1, "", true, nil); err == nil {
		u.UpdateFlagLHS1 = &updateFlagLHS1
		u.Type = UpdateFlagLHSUnionTypeUpdateFlagLHS1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagLHSUnion", string(data))
}

func (u UpdateFlagLHSUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateFlagLHS1 != nil {
		return utils.MarshalJSON(u.UpdateFlagLHS1, "", true)
	}

	if u.UpdateFlagLHS2 != nil {
		return utils.MarshalJSON(u.UpdateFlagLHS2, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagLHSUnion: all fields are null")
}

type UpdateFlagCmp string

const (
	UpdateFlagCmpEq             UpdateFlagCmp = "eq"
	UpdateFlagCmpNotEq          UpdateFlagCmp = "!eq"
	UpdateFlagCmpOneOf          UpdateFlagCmp = "oneOf"
	UpdateFlagCmpNotOneOf       UpdateFlagCmp = "!oneOf"
	UpdateFlagCmpContainsAllOf  UpdateFlagCmp = "containsAllOf"
	UpdateFlagCmpContainsAnyOf  UpdateFlagCmp = "containsAnyOf"
	UpdateFlagCmpContainsNoneOf UpdateFlagCmp = "containsNoneOf"
	UpdateFlagCmpStartsWith     UpdateFlagCmp = "startsWith"
	UpdateFlagCmpNotStartsWith  UpdateFlagCmp = "!startsWith"
	UpdateFlagCmpEndsWith       UpdateFlagCmp = "endsWith"
	UpdateFlagCmpNotEndsWith    UpdateFlagCmp = "!endsWith"
	UpdateFlagCmpEx             UpdateFlagCmp = "ex"
	UpdateFlagCmpNotEx          UpdateFlagCmp = "!ex"
	UpdateFlagCmpGt             UpdateFlagCmp = "gt"
	UpdateFlagCmpGte            UpdateFlagCmp = "gte"
	UpdateFlagCmpLt             UpdateFlagCmp = "lt"
	UpdateFlagCmpLte            UpdateFlagCmp = "lte"
	UpdateFlagCmpRegex          UpdateFlagCmp = "regex"
	UpdateFlagCmpNotRegex       UpdateFlagCmp = "!regex"
	UpdateFlagCmpBefore         UpdateFlagCmp = "before"
	UpdateFlagCmpAfter          UpdateFlagCmp = "after"
)

func (e UpdateFlagCmp) ToPointer() *UpdateFlagCmp {
	return &e
}
func (e *UpdateFlagCmp) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "eq":
		fallthrough
	case "!eq":
		fallthrough
	case "oneOf":
		fallthrough
	case "!oneOf":
		fallthrough
	case "containsAllOf":
		fallthrough
	case "containsAnyOf":
		fallthrough
	case "containsNoneOf":
		fallthrough
	case "startsWith":
		fallthrough
	case "!startsWith":
		fallthrough
	case "endsWith":
		fallthrough
	case "!endsWith":
		fallthrough
	case "ex":
		fallthrough
	case "!ex":
		fallthrough
	case "gt":
		fallthrough
	case "gte":
		fallthrough
	case "lt":
		fallthrough
	case "lte":
		fallthrough
	case "regex":
		fallthrough
	case "!regex":
		fallthrough
	case "before":
		fallthrough
	case "after":
		*e = UpdateFlagCmp(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateFlagCmp: %v", v)
	}
}

type UpdateFlagRHS2 struct {
	Type    any    `json:"type"`
	Pattern string `json:"pattern"`
	Flags   string `json:"flags"`
}

func (u UpdateFlagRHS2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagRHS2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "pattern", "flags"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagRHS2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagRHS2) GetPattern() string {
	if o == nil {
		return ""
	}
	return o.Pattern
}

func (o *UpdateFlagRHS2) GetFlags() string {
	if o == nil {
		return ""
	}
	return o.Flags
}

type UpdateFlagType string

const (
	UpdateFlagTypeListInline UpdateFlagType = "list/inline"
	UpdateFlagTypeList       UpdateFlagType = "list"
)

func (e UpdateFlagType) ToPointer() *UpdateFlagType {
	return &e
}
func (e *UpdateFlagType) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "list/inline":
		fallthrough
	case "list":
		*e = UpdateFlagType(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateFlagType: %v", v)
	}
}

type UpdateFlagItem2 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value string  `json:"value"`
}

func (u UpdateFlagItem2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagItem2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagItem2) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *UpdateFlagItem2) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *UpdateFlagItem2) GetValue() string {
	if o == nil {
		return ""
	}
	return o.Value
}

type UpdateFlagItem1 struct {
	Label *string `json:"label,omitempty"`
	Note  *string `json:"note,omitempty"`
	Value float64 `json:"value"`
}

func (u UpdateFlagItem1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagItem1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"value"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagItem1) GetLabel() *string {
	if o == nil {
		return nil
	}
	return o.Label
}

func (o *UpdateFlagItem1) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

func (o *UpdateFlagItem1) GetValue() float64 {
	if o == nil {
		return 0.0
	}
	return o.Value
}

type UpdateFlagItemUnionType string

const (
	UpdateFlagItemUnionTypeUpdateFlagItem1 UpdateFlagItemUnionType = "updateFlag_item_1"
	UpdateFlagItemUnionTypeUpdateFlagItem2 UpdateFlagItemUnionType = "updateFlag_item_2"
)

type UpdateFlagItemUnion struct {
	UpdateFlagItem1 *UpdateFlagItem1 `queryParam:"inline"`
	UpdateFlagItem2 *UpdateFlagItem2 `queryParam:"inline"`

	Type UpdateFlagItemUnionType
}

func CreateUpdateFlagItemUnionUpdateFlagItem1(updateFlagItem1 UpdateFlagItem1) UpdateFlagItemUnion {
	typ := UpdateFlagItemUnionTypeUpdateFlagItem1

	return UpdateFlagItemUnion{
		UpdateFlagItem1: &updateFlagItem1,
		Type:            typ,
	}
}

func CreateUpdateFlagItemUnionUpdateFlagItem2(updateFlagItem2 UpdateFlagItem2) UpdateFlagItemUnion {
	typ := UpdateFlagItemUnionTypeUpdateFlagItem2

	return UpdateFlagItemUnion{
		UpdateFlagItem2: &updateFlagItem2,
		Type:            typ,
	}
}

func (u *UpdateFlagItemUnion) UnmarshalJSON(data []byte) error {

	var updateFlagItem1 UpdateFlagItem1 = UpdateFlagItem1{}
	if err := utils.UnmarshalJSON(data, &updateFlagItem1, "", true, nil); err == nil {
		u.UpdateFlagItem1 = &updateFlagItem1
		u.Type = UpdateFlagItemUnionTypeUpdateFlagItem1
		return nil
	}

	var updateFlagItem2 UpdateFlagItem2 = UpdateFlagItem2{}
	if err := utils.UnmarshalJSON(data, &updateFlagItem2, "", true, nil); err == nil {
		u.UpdateFlagItem2 = &updateFlagItem2
		u.Type = UpdateFlagItemUnionTypeUpdateFlagItem2
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagItemUnion", string(data))
}

func (u UpdateFlagItemUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateFlagItem1 != nil {
		return utils.MarshalJSON(u.UpdateFlagItem1, "", true)
	}

	if u.UpdateFlagItem2 != nil {
		return utils.MarshalJSON(u.UpdateFlagItem2, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagItemUnion: all fields are null")
}

type UpdateFlagRHS1 struct {
	Type  UpdateFlagType        `json:"type"`
	Items []UpdateFlagItemUnion `json:"items"`
}

func (u UpdateFlagRHS1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagRHS1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "items"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagRHS1) GetType() UpdateFlagType {
	if o == nil {
		return UpdateFlagType("")
	}
	return o.Type
}

func (o *UpdateFlagRHS1) GetItems() []UpdateFlagItemUnion {
	if o == nil {
		return []UpdateFlagItemUnion{}
	}
	return o.Items
}

type UpdateFlagRHSUnionType string

const (
	UpdateFlagRHSUnionTypeUpdateFlagRHS1 UpdateFlagRHSUnionType = "updateFlag_rhs_1"
	UpdateFlagRHSUnionTypeUpdateFlagRHS2 UpdateFlagRHSUnionType = "updateFlag_rhs_2"
	UpdateFlagRHSUnionTypeStr            UpdateFlagRHSUnionType = "str"
	UpdateFlagRHSUnionTypeNumber         UpdateFlagRHSUnionType = "number"
	UpdateFlagRHSUnionTypeBoolean        UpdateFlagRHSUnionType = "boolean"
)

type UpdateFlagRHSUnion struct {
	UpdateFlagRHS1 *UpdateFlagRHS1 `queryParam:"inline"`
	UpdateFlagRHS2 *UpdateFlagRHS2 `queryParam:"inline"`
	Str            *string         `queryParam:"inline"`
	Number         *float64        `queryParam:"inline"`
	Boolean        *bool           `queryParam:"inline"`

	Type UpdateFlagRHSUnionType
}

func CreateUpdateFlagRHSUnionUpdateFlagRHS1(updateFlagRHS1 UpdateFlagRHS1) UpdateFlagRHSUnion {
	typ := UpdateFlagRHSUnionTypeUpdateFlagRHS1

	return UpdateFlagRHSUnion{
		UpdateFlagRHS1: &updateFlagRHS1,
		Type:           typ,
	}
}

func CreateUpdateFlagRHSUnionUpdateFlagRHS2(updateFlagRHS2 UpdateFlagRHS2) UpdateFlagRHSUnion {
	typ := UpdateFlagRHSUnionTypeUpdateFlagRHS2

	return UpdateFlagRHSUnion{
		UpdateFlagRHS2: &updateFlagRHS2,
		Type:           typ,
	}
}

func CreateUpdateFlagRHSUnionStr(str string) UpdateFlagRHSUnion {
	typ := UpdateFlagRHSUnionTypeStr

	return UpdateFlagRHSUnion{
		Str:  &str,
		Type: typ,
	}
}

func CreateUpdateFlagRHSUnionNumber(number float64) UpdateFlagRHSUnion {
	typ := UpdateFlagRHSUnionTypeNumber

	return UpdateFlagRHSUnion{
		Number: &number,
		Type:   typ,
	}
}

func CreateUpdateFlagRHSUnionBoolean(boolean bool) UpdateFlagRHSUnion {
	typ := UpdateFlagRHSUnionTypeBoolean

	return UpdateFlagRHSUnion{
		Boolean: &boolean,
		Type:    typ,
	}
}

func (u *UpdateFlagRHSUnion) UnmarshalJSON(data []byte) error {

	var updateFlagRHS2 UpdateFlagRHS2 = UpdateFlagRHS2{}
	if err := utils.UnmarshalJSON(data, &updateFlagRHS2, "", true, nil); err == nil {
		u.UpdateFlagRHS2 = &updateFlagRHS2
		u.Type = UpdateFlagRHSUnionTypeUpdateFlagRHS2
		return nil
	}

	var updateFlagRHS1 UpdateFlagRHS1 = UpdateFlagRHS1{}
	if err := utils.UnmarshalJSON(data, &updateFlagRHS1, "", true, nil); err == nil {
		u.UpdateFlagRHS1 = &updateFlagRHS1
		u.Type = UpdateFlagRHSUnionTypeUpdateFlagRHS1
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = UpdateFlagRHSUnionTypeStr
		return nil
	}

	var number float64 = float64(0)
	if err := utils.UnmarshalJSON(data, &number, "", true, nil); err == nil {
		u.Number = &number
		u.Type = UpdateFlagRHSUnionTypeNumber
		return nil
	}

	var boolean bool = false
	if err := utils.UnmarshalJSON(data, &boolean, "", true, nil); err == nil {
		u.Boolean = &boolean
		u.Type = UpdateFlagRHSUnionTypeBoolean
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagRHSUnion", string(data))
}

func (u UpdateFlagRHSUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateFlagRHS1 != nil {
		return utils.MarshalJSON(u.UpdateFlagRHS1, "", true)
	}

	if u.UpdateFlagRHS2 != nil {
		return utils.MarshalJSON(u.UpdateFlagRHS2, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	if u.Number != nil {
		return utils.MarshalJSON(u.Number, "", true)
	}

	if u.Boolean != nil {
		return utils.MarshalJSON(u.Boolean, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagRHSUnion: all fields are null")
}

type UpdateFlagCondition struct {
	LHS UpdateFlagLHSUnion  `json:"lhs"`
	Cmp UpdateFlagCmp       `json:"cmp"`
	RHS *UpdateFlagRHSUnion `json:"rhs,omitempty"`
}

func (o *UpdateFlagCondition) GetLHS() UpdateFlagLHSUnion {
	if o == nil {
		return UpdateFlagLHSUnion{}
	}
	return o.LHS
}

func (o *UpdateFlagCondition) GetCmp() UpdateFlagCmp {
	if o == nil {
		return UpdateFlagCmp("")
	}
	return o.Cmp
}

func (o *UpdateFlagCondition) GetRHS() *UpdateFlagRHSUnion {
	if o == nil {
		return nil
	}
	return o.RHS
}

type UpdateFlagOutcomeBase struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (u UpdateFlagOutcomeBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagOutcomeBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagOutcomeBase) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagOutcomeBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *UpdateFlagOutcomeBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type UpdateFlagOutcome2 struct {
	Type any                   `json:"type"`
	Base UpdateFlagOutcomeBase `json:"base"`
	// The distribution for each variant
	Weights map[string]float64 `json:"weights"`
	// This variant will be used when the base attribute does not exist
	DefaultVariantID string `json:"defaultVariantId"`
}

func (u UpdateFlagOutcome2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagOutcome2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagOutcome2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagOutcome2) GetBase() UpdateFlagOutcomeBase {
	if o == nil {
		return UpdateFlagOutcomeBase{}
	}
	return o.Base
}

func (o *UpdateFlagOutcome2) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *UpdateFlagOutcome2) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type UpdateFlagOutcome1 struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (u UpdateFlagOutcome1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagOutcome1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagOutcome1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagOutcome1) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type UpdateFlagOutcomeUnionType string

const (
	UpdateFlagOutcomeUnionTypeUpdateFlagOutcome1 UpdateFlagOutcomeUnionType = "updateFlag_outcome_1"
	UpdateFlagOutcomeUnionTypeUpdateFlagOutcome2 UpdateFlagOutcomeUnionType = "updateFlag_outcome_2"
)

type UpdateFlagOutcomeUnion struct {
	UpdateFlagOutcome1 *UpdateFlagOutcome1 `queryParam:"inline"`
	UpdateFlagOutcome2 *UpdateFlagOutcome2 `queryParam:"inline"`

	Type UpdateFlagOutcomeUnionType
}

func CreateUpdateFlagOutcomeUnionUpdateFlagOutcome1(updateFlagOutcome1 UpdateFlagOutcome1) UpdateFlagOutcomeUnion {
	typ := UpdateFlagOutcomeUnionTypeUpdateFlagOutcome1

	return UpdateFlagOutcomeUnion{
		UpdateFlagOutcome1: &updateFlagOutcome1,
		Type:               typ,
	}
}

func CreateUpdateFlagOutcomeUnionUpdateFlagOutcome2(updateFlagOutcome2 UpdateFlagOutcome2) UpdateFlagOutcomeUnion {
	typ := UpdateFlagOutcomeUnionTypeUpdateFlagOutcome2

	return UpdateFlagOutcomeUnion{
		UpdateFlagOutcome2: &updateFlagOutcome2,
		Type:               typ,
	}
}

func (u *UpdateFlagOutcomeUnion) UnmarshalJSON(data []byte) error {

	var updateFlagOutcome2 UpdateFlagOutcome2 = UpdateFlagOutcome2{}
	if err := utils.UnmarshalJSON(data, &updateFlagOutcome2, "", true, nil); err == nil {
		u.UpdateFlagOutcome2 = &updateFlagOutcome2
		u.Type = UpdateFlagOutcomeUnionTypeUpdateFlagOutcome2
		return nil
	}

	var updateFlagOutcome1 UpdateFlagOutcome1 = UpdateFlagOutcome1{}
	if err := utils.UnmarshalJSON(data, &updateFlagOutcome1, "", true, nil); err == nil {
		u.UpdateFlagOutcome1 = &updateFlagOutcome1
		u.Type = UpdateFlagOutcomeUnionTypeUpdateFlagOutcome1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagOutcomeUnion", string(data))
}

func (u UpdateFlagOutcomeUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateFlagOutcome1 != nil {
		return utils.MarshalJSON(u.UpdateFlagOutcome1, "", true)
	}

	if u.UpdateFlagOutcome2 != nil {
		return utils.MarshalJSON(u.UpdateFlagOutcome2, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagOutcomeUnion: all fields are null")
}

type UpdateFlagRule struct {
	ID         string                 `json:"id"`
	Conditions []UpdateFlagCondition  `json:"conditions"`
	Outcome    UpdateFlagOutcomeUnion `json:"outcome"`
}

func (o *UpdateFlagRule) GetID() string {
	if o == nil {
		return ""
	}
	return o.ID
}

func (o *UpdateFlagRule) GetConditions() []UpdateFlagCondition {
	if o == nil {
		return []UpdateFlagCondition{}
	}
	return o.Conditions
}

func (o *UpdateFlagRule) GetOutcome() UpdateFlagOutcomeUnion {
	if o == nil {
		return UpdateFlagOutcomeUnion{}
	}
	return o.Outcome
}

type UpdateFlagFallthroughBase struct {
	Type      any    `json:"type"`
	Kind      string `json:"kind"`
	Attribute string `json:"attribute"`
}

func (u UpdateFlagFallthroughBase) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagFallthroughBase) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "kind", "attribute"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagFallthroughBase) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagFallthroughBase) GetKind() string {
	if o == nil {
		return ""
	}
	return o.Kind
}

func (o *UpdateFlagFallthroughBase) GetAttribute() string {
	if o == nil {
		return ""
	}
	return o.Attribute
}

type UpdateFlagFallthrough2 struct {
	Type any                       `json:"type"`
	Base UpdateFlagFallthroughBase `json:"base"`
	// The distribution for each variant
	Weights map[string]float64 `json:"weights"`
	// This variant will be used when the base attribute does not exist
	DefaultVariantID string `json:"defaultVariantId"`
}

func (u UpdateFlagFallthrough2) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagFallthrough2) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "base", "weights", "defaultVariantId"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagFallthrough2) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagFallthrough2) GetBase() UpdateFlagFallthroughBase {
	if o == nil {
		return UpdateFlagFallthroughBase{}
	}
	return o.Base
}

func (o *UpdateFlagFallthrough2) GetWeights() map[string]float64 {
	if o == nil {
		return map[string]float64{}
	}
	return o.Weights
}

func (o *UpdateFlagFallthrough2) GetDefaultVariantID() string {
	if o == nil {
		return ""
	}
	return o.DefaultVariantID
}

type UpdateFlagFallthrough1 struct {
	Type      any    `json:"type"`
	VariantID string `json:"variantId"`
}

func (u UpdateFlagFallthrough1) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateFlagFallthrough1) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"type", "variantId"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateFlagFallthrough1) GetType() any {
	if o == nil {
		return nil
	}
	return o.Type
}

func (o *UpdateFlagFallthrough1) GetVariantID() string {
	if o == nil {
		return ""
	}
	return o.VariantID
}

type UpdateFlagFallthroughUnionType string

const (
	UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough1 UpdateFlagFallthroughUnionType = "updateFlag_fallthrough_1"
	UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough2 UpdateFlagFallthroughUnionType = "updateFlag_fallthrough_2"
)

type UpdateFlagFallthroughUnion struct {
	UpdateFlagFallthrough1 *UpdateFlagFallthrough1 `queryParam:"inline"`
	UpdateFlagFallthrough2 *UpdateFlagFallthrough2 `queryParam:"inline"`

	Type UpdateFlagFallthroughUnionType
}

func CreateUpdateFlagFallthroughUnionUpdateFlagFallthrough1(updateFlagFallthrough1 UpdateFlagFallthrough1) UpdateFlagFallthroughUnion {
	typ := UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough1

	return UpdateFlagFallthroughUnion{
		UpdateFlagFallthrough1: &updateFlagFallthrough1,
		Type:                   typ,
	}
}

func CreateUpdateFlagFallthroughUnionUpdateFlagFallthrough2(updateFlagFallthrough2 UpdateFlagFallthrough2) UpdateFlagFallthroughUnion {
	typ := UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough2

	return UpdateFlagFallthroughUnion{
		UpdateFlagFallthrough2: &updateFlagFallthrough2,
		Type:                   typ,
	}
}

func (u *UpdateFlagFallthroughUnion) UnmarshalJSON(data []byte) error {

	var updateFlagFallthrough2 UpdateFlagFallthrough2 = UpdateFlagFallthrough2{}
	if err := utils.UnmarshalJSON(data, &updateFlagFallthrough2, "", true, nil); err == nil {
		u.UpdateFlagFallthrough2 = &updateFlagFallthrough2
		u.Type = UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough2
		return nil
	}

	var updateFlagFallthrough1 UpdateFlagFallthrough1 = UpdateFlagFallthrough1{}
	if err := utils.UnmarshalJSON(data, &updateFlagFallthrough1, "", true, nil); err == nil {
		u.UpdateFlagFallthrough1 = &updateFlagFallthrough1
		u.Type = UpdateFlagFallthroughUnionTypeUpdateFlagFallthrough1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateFlagFallthroughUnion", string(data))
}

func (u UpdateFlagFallthroughUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateFlagFallthrough1 != nil {
		return utils.MarshalJSON(u.UpdateFlagFallthrough1, "", true)
	}

	if u.UpdateFlagFallthrough2 != nil {
		return utils.MarshalJSON(u.UpdateFlagFallthrough2, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateFlagFallthroughUnion: all fields are null")
}

type UpdateFlagEnvironments struct {
	Active bool `json:"active"`
	// Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
	Reuse *UpdateFlagReuse `json:"reuse,omitempty"`
	// Allows assigning targets to variants while bypassing the flag's rules
	Targets       map[string]map[string]map[string][]UpdateFlagTarget `json:"targets,omitempty"`
	PausedOutcome UpdateFlagPausedOutcome                             `json:"pausedOutcome"`
	Rules         []UpdateFlagRule                                    `json:"rules"`
	Fallthrough   UpdateFlagFallthroughUnion                          `json:"fallthrough"`
	// The revision of the environment config
	Revision *float64 `json:"revision,omitempty"`
}

func (o *UpdateFlagEnvironments) GetActive() bool {
	if o == nil {
		return false
	}
	return o.Active
}

func (o *UpdateFlagEnvironments) GetReuse() *UpdateFlagReuse {
	if o == nil {
		return nil
	}
	return o.Reuse
}

func (o *UpdateFlagEnvironments) GetTargets() map[string]map[string]map[string][]UpdateFlagTarget {
	if o == nil {
		return nil
	}
	return o.Targets
}

func (o *UpdateFlagEnvironments) GetPausedOutcome() UpdateFlagPausedOutcome {
	if o == nil {
		return UpdateFlagPausedOutcome{}
	}
	return o.PausedOutcome
}

func (o *UpdateFlagEnvironments) GetRules() []UpdateFlagRule {
	if o == nil {
		return []UpdateFlagRule{}
	}
	return o.Rules
}

func (o *UpdateFlagEnvironments) GetFallthrough() UpdateFlagFallthroughUnion {
	if o == nil {
		return UpdateFlagFallthroughUnion{}
	}
	return o.Fallthrough
}

func (o *UpdateFlagEnvironments) GetRevision() *float64 {
	if o == nil {
		return nil
	}
	return o.Revision
}

type UpdateFlagState string

const (
	UpdateFlagStateActive   UpdateFlagState = "active"
	UpdateFlagStateArchived UpdateFlagState = "archived"
)

func (e UpdateFlagState) ToPointer() *UpdateFlagState {
	return &e
}
func (e *UpdateFlagState) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "active":
		fallthrough
	case "archived":
		*e = UpdateFlagState(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateFlagState: %v", v)
	}
}

type UpdateFlagRequestBody struct {
	// The user who created this patch
	CreatedBy *string `json:"createdBy,omitempty"`
	// Additional message for this version
	Message *string `json:"message,omitempty"`
	// The variants of the flag
	Variants []UpdateFlagVariant `json:"variants,omitempty"`
	// The configuration for the flag in different environments
	Environments map[string]UpdateFlagEnvironments `json:"environments,omitempty"`
	// A random seed to prevent split points in different flags from having the same targets
	Seed *float64 `json:"seed,omitempty"`
	// A description of the flag
	Description *string          `json:"description,omitempty"`
	State       *UpdateFlagState `json:"state,omitempty"`
}

func (o *UpdateFlagRequestBody) GetCreatedBy() *string {
	if o == nil {
		return nil
	}
	return o.CreatedBy
}

func (o *UpdateFlagRequestBody) GetMessage() *string {
	if o == nil {
		return nil
	}
	return o.Message
}

func (o *UpdateFlagRequestBody) GetVariants() []UpdateFlagVariant {
	if o == nil {
		return nil
	}
	return o.Variants
}

func (o *UpdateFlagRequestBody) GetEnvironments() map[string]UpdateFlagEnvironments {
	if o == nil {
		return nil
	}
	return o.Environments
}

func (o *UpdateFlagRequestBody) GetSeed() *float64 {
	if o == nil {
		return nil
	}
	return o.Seed
}

func (o *UpdateFlagRequestBody) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *UpdateFlagRequestBody) GetState() *UpdateFlagState {
	if o == nil {
		return nil
	}
	return o.State
}

type UpdateFlagRequest struct {
	// The project id or name
	ProjectIDOrName string `pathParam:"style=simple,explode=false,name=projectIdOrName"`
	// The flag id or name
	FlagIDOrSlug string `pathParam:"style=simple,explode=false,name=flagIdOrSlug"`
	// Etag to match, can be used interchangeably with the `if-match` header
	IfMatch *string `queryParam:"style=form,explode=true,name=ifMatch"`
	// Whether to include metadata in the response
	WithMetadata *bool `queryParam:"style=form,explode=true,name=withMetadata"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string                `queryParam:"style=form,explode=true,name=slug"`
	Body *UpdateFlagRequestBody `request:"mediaType=application/json"`
}

func (o *UpdateFlagRequest) GetProjectIDOrName() string {
	if o == nil {
		return ""
	}
	return o.ProjectIDOrName
}

func (o *UpdateFlagRequest) GetFlagIDOrSlug() string {
	if o == nil {
		return ""
	}
	return o.FlagIDOrSlug
}

func (o *UpdateFlagRequest) GetIfMatch() *string {
	if o == nil {
		return nil
	}
	return o.IfMatch
}

func (o *UpdateFlagRequest) GetWithMetadata() *bool {
	if o == nil {
		return nil
	}
	return o.WithMetadata
}

func (o *UpdateFlagRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *UpdateFlagRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *UpdateFlagRequest) GetBody() *UpdateFlagRequestBody {
	if o == nil {
		return nil
	}
	return o.Body
}

type UpdateFlagResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Flag     *components.Flag
}

func (o *UpdateFlagResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *UpdateFlagResponse) GetFlag() *components.Flag {
	if o == nil {
		return nil
	}
	return o.Flag
}
