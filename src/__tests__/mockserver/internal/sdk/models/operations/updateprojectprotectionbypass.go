// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

// UpdateProjectProtectionBypassRevoke - Optional instructions for revoking and regenerating a automation bypass
type UpdateProjectProtectionBypassRevoke struct {
	// Automation bypass to revoked
	Secret string `json:"secret"`
	// Whether or not a new automation bypass should be created after the provided secret is revoked
	Regenerate bool `json:"regenerate"`
}

func (o *UpdateProjectProtectionBypassRevoke) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

func (o *UpdateProjectProtectionBypassRevoke) GetRegenerate() bool {
	if o == nil {
		return false
	}
	return o.Regenerate
}

// Generate a new secret. If neither generate or revoke are provided, a new random secret will be generated.
type Generate struct {
	// Optional value of the secret to generate, don't send it for oauth2 tokens
	Secret *string `json:"secret,omitempty"`
	// Note to be displayed in the UI for this bypass
	Note *string `json:"note,omitempty"`
}

func (o *Generate) GetSecret() *string {
	if o == nil {
		return nil
	}
	return o.Secret
}

func (o *Generate) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

// Update an existing bypass
type Update struct {
	// Automation bypass to updated
	Secret string `json:"secret"`
	// Whether or not this bypass is set as the VERCEL_AUTOMATION_BYPASS_SECRET environment variable on deployments
	IsEnvVar *bool `json:"isEnvVar,omitempty"`
	// Note to be displayed in the UI for this bypass
	Note *string `json:"note,omitempty"`
}

func (o *Update) GetSecret() string {
	if o == nil {
		return ""
	}
	return o.Secret
}

func (o *Update) GetIsEnvVar() *bool {
	if o == nil {
		return nil
	}
	return o.IsEnvVar
}

func (o *Update) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

type UpdateProjectProtectionBypassRequestBody struct {
	// Optional instructions for revoking and regenerating a automation bypass
	Revoke *UpdateProjectProtectionBypassRevoke `json:"revoke,omitempty"`
	// Generate a new secret. If neither generate or revoke are provided, a new random secret will be generated.
	Generate *Generate `json:"generate,omitempty"`
	// Update an existing bypass
	Update *Update `json:"update,omitempty"`
}

func (o *UpdateProjectProtectionBypassRequestBody) GetRevoke() *UpdateProjectProtectionBypassRevoke {
	if o == nil {
		return nil
	}
	return o.Revoke
}

func (o *UpdateProjectProtectionBypassRequestBody) GetGenerate() *Generate {
	if o == nil {
		return nil
	}
	return o.Generate
}

func (o *UpdateProjectProtectionBypassRequestBody) GetUpdate() *Update {
	if o == nil {
		return nil
	}
	return o.Update
}

type UpdateProjectProtectionBypassRequest struct {
	// The unique project identifier or the project name
	IDOrName string `pathParam:"style=simple,explode=false,name=idOrName"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug *string                                  `queryParam:"style=form,explode=true,name=slug"`
	Body UpdateProjectProtectionBypassRequestBody `request:"mediaType=application/json"`
}

func (o *UpdateProjectProtectionBypassRequest) GetIDOrName() string {
	if o == nil {
		return ""
	}
	return o.IDOrName
}

func (o *UpdateProjectProtectionBypassRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *UpdateProjectProtectionBypassRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *UpdateProjectProtectionBypassRequest) GetBody() UpdateProjectProtectionBypassRequestBody {
	if o == nil {
		return UpdateProjectProtectionBypassRequestBody{}
	}
	return o.Body
}

type UpdateProjectProtectionBypassScopeAutomationBypass string

const (
	UpdateProjectProtectionBypassScopeAutomationBypassAutomationBypass UpdateProjectProtectionBypassScopeAutomationBypass = "automation-bypass"
)

func (e UpdateProjectProtectionBypassScopeAutomationBypass) ToPointer() *UpdateProjectProtectionBypassScopeAutomationBypass {
	return &e
}
func (e *UpdateProjectProtectionBypassScopeAutomationBypass) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "automation-bypass":
		*e = UpdateProjectProtectionBypassScopeAutomationBypass(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateProjectProtectionBypassScopeAutomationBypass: %v", v)
	}
}

type UpdateProjectProtectionBypassProtectionBypassAutomationBypass struct {
	CreatedAt float64                                            `json:"createdAt"`
	CreatedBy string                                             `json:"createdBy"`
	Scope     UpdateProjectProtectionBypassScopeAutomationBypass `json:"scope"`
	// When there was only one bypass, it was automatically set as an env var on deployments. With multiple bypasses, there is always one bypass that is selected as the default, and gets set as an env var on deployments. As this is a new field, undefined means that the bypass is the env var. If there are any automation bypasses, exactly one must be the env var.
	IsEnvVar *bool `json:"isEnvVar,omitempty"`
	// Optional note about the bypass to be displayed in the UI
	Note *string `json:"note,omitempty"`
}

func (u UpdateProjectProtectionBypassProtectionBypassAutomationBypass) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"createdAt", "createdBy", "scope"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) GetScope() UpdateProjectProtectionBypassScopeAutomationBypass {
	if o == nil {
		return UpdateProjectProtectionBypassScopeAutomationBypass("")
	}
	return o.Scope
}

func (o *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) GetIsEnvVar() *bool {
	if o == nil {
		return nil
	}
	return o.IsEnvVar
}

func (o *UpdateProjectProtectionBypassProtectionBypassAutomationBypass) GetNote() *string {
	if o == nil {
		return nil
	}
	return o.Note
}

type UpdateProjectProtectionBypassScopeIntegrationAutomationBypass string

const (
	UpdateProjectProtectionBypassScopeIntegrationAutomationBypassIntegrationAutomationBypass UpdateProjectProtectionBypassScopeIntegrationAutomationBypass = "integration-automation-bypass"
)

func (e UpdateProjectProtectionBypassScopeIntegrationAutomationBypass) ToPointer() *UpdateProjectProtectionBypassScopeIntegrationAutomationBypass {
	return &e
}
func (e *UpdateProjectProtectionBypassScopeIntegrationAutomationBypass) UnmarshalJSON(data []byte) error {
	var v string
	if err := json.Unmarshal(data, &v); err != nil {
		return err
	}
	switch v {
	case "integration-automation-bypass":
		*e = UpdateProjectProtectionBypassScopeIntegrationAutomationBypass(v)
		return nil
	default:
		return fmt.Errorf("invalid value for UpdateProjectProtectionBypassScopeIntegrationAutomationBypass: %v", v)
	}
}

type UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass struct {
	CreatedAt       float64                                                       `json:"createdAt"`
	CreatedBy       string                                                        `json:"createdBy"`
	Scope           UpdateProjectProtectionBypassScopeIntegrationAutomationBypass `json:"scope"`
	IntegrationID   string                                                        `json:"integrationId"`
	ConfigurationID string                                                        `json:"configurationId"`
}

func (u UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(u, "", false)
}

func (u *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &u, "", false, []string{"createdAt", "createdBy", "scope", "integrationId", "configurationId"}); err != nil {
		return err
	}
	return nil
}

func (o *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) GetCreatedAt() float64 {
	if o == nil {
		return 0.0
	}
	return o.CreatedAt
}

func (o *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) GetCreatedBy() string {
	if o == nil {
		return ""
	}
	return o.CreatedBy
}

func (o *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) GetScope() UpdateProjectProtectionBypassScopeIntegrationAutomationBypass {
	if o == nil {
		return UpdateProjectProtectionBypassScopeIntegrationAutomationBypass("")
	}
	return o.Scope
}

func (o *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) GetIntegrationID() string {
	if o == nil {
		return ""
	}
	return o.IntegrationID
}

func (o *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) GetConfigurationID() string {
	if o == nil {
		return ""
	}
	return o.ConfigurationID
}

type UpdateProjectProtectionBypassProtectionBypassUnionType string

const (
	UpdateProjectProtectionBypassProtectionBypassUnionTypeIntegrationAutomationBypass UpdateProjectProtectionBypassProtectionBypassUnionType = "integration-automation-bypass"
	UpdateProjectProtectionBypassProtectionBypassUnionTypeAutomationBypass            UpdateProjectProtectionBypassProtectionBypassUnionType = "automation-bypass"
)

type UpdateProjectProtectionBypassProtectionBypassUnion struct {
	UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass *UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass `queryParam:"inline"`
	UpdateProjectProtectionBypassProtectionBypassAutomationBypass            *UpdateProjectProtectionBypassProtectionBypassAutomationBypass            `queryParam:"inline"`

	Type UpdateProjectProtectionBypassProtectionBypassUnionType
}

func CreateUpdateProjectProtectionBypassProtectionBypassUnionIntegrationAutomationBypass(integrationAutomationBypass UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass) UpdateProjectProtectionBypassProtectionBypassUnion {
	typ := UpdateProjectProtectionBypassProtectionBypassUnionTypeIntegrationAutomationBypass

	typStr := UpdateProjectProtectionBypassScopeIntegrationAutomationBypass(typ)
	integrationAutomationBypass.Scope = typStr

	return UpdateProjectProtectionBypassProtectionBypassUnion{
		UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass: &integrationAutomationBypass,
		Type: typ,
	}
}

func CreateUpdateProjectProtectionBypassProtectionBypassUnionAutomationBypass(automationBypass UpdateProjectProtectionBypassProtectionBypassAutomationBypass) UpdateProjectProtectionBypassProtectionBypassUnion {
	typ := UpdateProjectProtectionBypassProtectionBypassUnionTypeAutomationBypass

	typStr := UpdateProjectProtectionBypassScopeAutomationBypass(typ)
	automationBypass.Scope = typStr

	return UpdateProjectProtectionBypassProtectionBypassUnion{
		UpdateProjectProtectionBypassProtectionBypassAutomationBypass: &automationBypass,
		Type: typ,
	}
}

func (u *UpdateProjectProtectionBypassProtectionBypassUnion) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Scope string `json:"scope"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Scope {
	case "integration-automation-bypass":
		updateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass := new(UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass)
		if err := utils.UnmarshalJSON(data, &updateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Scope == integration-automation-bypass) type UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass within UpdateProjectProtectionBypassProtectionBypassUnion: %w", string(data), err)
		}

		u.UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass = updateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass
		u.Type = UpdateProjectProtectionBypassProtectionBypassUnionTypeIntegrationAutomationBypass
		return nil
	case "automation-bypass":
		updateProjectProtectionBypassProtectionBypassAutomationBypass := new(UpdateProjectProtectionBypassProtectionBypassAutomationBypass)
		if err := utils.UnmarshalJSON(data, &updateProjectProtectionBypassProtectionBypassAutomationBypass, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Scope == automation-bypass) type UpdateProjectProtectionBypassProtectionBypassAutomationBypass within UpdateProjectProtectionBypassProtectionBypassUnion: %w", string(data), err)
		}

		u.UpdateProjectProtectionBypassProtectionBypassAutomationBypass = updateProjectProtectionBypassProtectionBypassAutomationBypass
		u.Type = UpdateProjectProtectionBypassProtectionBypassUnionTypeAutomationBypass
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UpdateProjectProtectionBypassProtectionBypassUnion", string(data))
}

func (u UpdateProjectProtectionBypassProtectionBypassUnion) MarshalJSON() ([]byte, error) {
	if u.UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass != nil {
		return utils.MarshalJSON(u.UpdateProjectProtectionBypassProtectionBypassIntegrationAutomationBypass, "", true)
	}

	if u.UpdateProjectProtectionBypassProtectionBypassAutomationBypass != nil {
		return utils.MarshalJSON(u.UpdateProjectProtectionBypassProtectionBypassAutomationBypass, "", true)
	}

	return nil, errors.New("could not marshal union type UpdateProjectProtectionBypassProtectionBypassUnion: all fields are null")
}

type UpdateProjectProtectionBypassResponseBody struct {
	ProtectionBypass map[string]UpdateProjectProtectionBypassProtectionBypassUnion `json:"protectionBypass,omitempty"`
}

func (o *UpdateProjectProtectionBypassResponseBody) GetProtectionBypass() map[string]UpdateProjectProtectionBypassProtectionBypassUnion {
	if o == nil {
		return nil
	}
	return o.ProtectionBypass
}

type UpdateProjectProtectionBypassResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	Object   *UpdateProjectProtectionBypassResponseBody
}

func (o *UpdateProjectProtectionBypassResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *UpdateProjectProtectionBypassResponse) GetObject() *UpdateProjectProtectionBypassResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
