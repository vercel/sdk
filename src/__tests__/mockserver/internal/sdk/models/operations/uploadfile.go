// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"errors"
	"fmt"
	"io"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type UploadFileRequest struct {
	// The file size in bytes
	ContentLength *float64 `header:"style=simple,explode=false,name=Content-Length"`
	// The file SHA1 used to check the integrity
	XVercelDigest *string `header:"style=simple,explode=false,name=x-vercel-digest"`
	// The file SHA1 used to check the integrity
	XNowDigest *string `header:"style=simple,explode=false,name=x-now-digest"`
	// The file size as an alternative to `Content-Length`
	XNowSize *float64 `header:"style=simple,explode=false,name=x-now-size"`
	// Shared secret token set by v0 deployments. When present and valid, the API applies an extended rate limit.
	XInternalV0Token *string `header:"style=simple,explode=false,name=x-internal-v0-token"`
	// The Team identifier to perform the request on behalf of.
	TeamID *string `queryParam:"style=form,explode=true,name=teamId"`
	// The Team slug to perform the request on behalf of.
	Slug        *string    `queryParam:"style=form,explode=true,name=slug"`
	RequestBody *io.Reader `request:"mediaType=application/octet-stream"`
}

func (o *UploadFileRequest) GetContentLength() *float64 {
	if o == nil {
		return nil
	}
	return o.ContentLength
}

func (o *UploadFileRequest) GetXVercelDigest() *string {
	if o == nil {
		return nil
	}
	return o.XVercelDigest
}

func (o *UploadFileRequest) GetXNowDigest() *string {
	if o == nil {
		return nil
	}
	return o.XNowDigest
}

func (o *UploadFileRequest) GetXNowSize() *float64 {
	if o == nil {
		return nil
	}
	return o.XNowSize
}

func (o *UploadFileRequest) GetXInternalV0Token() *string {
	if o == nil {
		return nil
	}
	return o.XInternalV0Token
}

func (o *UploadFileRequest) GetTeamID() *string {
	if o == nil {
		return nil
	}
	return o.TeamID
}

func (o *UploadFileRequest) GetSlug() *string {
	if o == nil {
		return nil
	}
	return o.Slug
}

func (o *UploadFileRequest) GetRequestBody() *io.Reader {
	if o == nil {
		return nil
	}
	return o.RequestBody
}

type UploadFileResponseBody2 struct {
}

type UploadFileResponseBody1 struct {
	// Array of URLs where the file was updated
	Urls []string `json:"urls"`
}

func (o *UploadFileResponseBody1) GetUrls() []string {
	if o == nil {
		return []string{}
	}
	return o.Urls
}

type UploadFileResponseBodyType string

const (
	UploadFileResponseBodyTypeUploadFileResponseBody1 UploadFileResponseBodyType = "uploadFile_ResponseBody_1"
	UploadFileResponseBodyTypeUploadFileResponseBody2 UploadFileResponseBodyType = "uploadFile_ResponseBody_2"
)

// UploadFileResponseBody - File already uploaded
// File successfully uploaded
type UploadFileResponseBody struct {
	UploadFileResponseBody1 *UploadFileResponseBody1 `queryParam:"inline"`
	UploadFileResponseBody2 *UploadFileResponseBody2 `queryParam:"inline"`

	Type UploadFileResponseBodyType
}

func CreateUploadFileResponseBodyUploadFileResponseBody1(uploadFileResponseBody1 UploadFileResponseBody1) UploadFileResponseBody {
	typ := UploadFileResponseBodyTypeUploadFileResponseBody1

	return UploadFileResponseBody{
		UploadFileResponseBody1: &uploadFileResponseBody1,
		Type:                    typ,
	}
}

func CreateUploadFileResponseBodyUploadFileResponseBody2(uploadFileResponseBody2 UploadFileResponseBody2) UploadFileResponseBody {
	typ := UploadFileResponseBodyTypeUploadFileResponseBody2

	return UploadFileResponseBody{
		UploadFileResponseBody2: &uploadFileResponseBody2,
		Type:                    typ,
	}
}

func (u *UploadFileResponseBody) UnmarshalJSON(data []byte) error {

	var uploadFileResponseBody2 UploadFileResponseBody2 = UploadFileResponseBody2{}
	if err := utils.UnmarshalJSON(data, &uploadFileResponseBody2, "", true, true); err == nil {
		u.UploadFileResponseBody2 = &uploadFileResponseBody2
		u.Type = UploadFileResponseBodyTypeUploadFileResponseBody2
		return nil
	}

	var uploadFileResponseBody1 UploadFileResponseBody1 = UploadFileResponseBody1{}
	if err := utils.UnmarshalJSON(data, &uploadFileResponseBody1, "", true, true); err == nil {
		u.UploadFileResponseBody1 = &uploadFileResponseBody1
		u.Type = UploadFileResponseBodyTypeUploadFileResponseBody1
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for UploadFileResponseBody", string(data))
}

func (u UploadFileResponseBody) MarshalJSON() ([]byte, error) {
	if u.UploadFileResponseBody1 != nil {
		return utils.MarshalJSON(u.UploadFileResponseBody1, "", true)
	}

	if u.UploadFileResponseBody2 != nil {
		return utils.MarshalJSON(u.UploadFileResponseBody2, "", true)
	}

	return nil, errors.New("could not marshal union type UploadFileResponseBody: all fields are null")
}

type UploadFileResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// File already uploaded
	// File successfully uploaded
	OneOf *UploadFileResponseBody
}

func (o *UploadFileResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *UploadFileResponse) GetOneOf() *UploadFileResponseBody {
	if o == nil {
		return nil
	}
	return o.OneOf
}
