// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package sdkerrors

import (
	"encoding/json"
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
)

type BuySingleDomainForbiddenType string

const (
	BuySingleDomainForbiddenTypeNotAuthorizedForScope BuySingleDomainForbiddenType = "not_authorized_for_scope"
	BuySingleDomainForbiddenTypeForbidden             BuySingleDomainForbiddenType = "forbidden"
)

// BuySingleDomainForbidden - NotAuthorizedForScope
type BuySingleDomainForbidden struct {
	NotAuthorizedForScopeError *NotAuthorizedForScopeError `queryParam:"inline"`
	ForbiddenError             *ForbiddenError             `queryParam:"inline"`

	Type BuySingleDomainForbiddenType

	HTTPMeta components.HTTPMetadata `json:"-"`
}

var _ error = &BuySingleDomainForbidden{}

func CreateBuySingleDomainForbiddenNotAuthorizedForScope(notAuthorizedForScope NotAuthorizedForScopeError) BuySingleDomainForbidden {
	typ := BuySingleDomainForbiddenTypeNotAuthorizedForScope

	return BuySingleDomainForbidden{
		NotAuthorizedForScopeError: &notAuthorizedForScope,
		Type:                       typ,
	}
}

func CreateBuySingleDomainForbiddenForbidden(forbidden ForbiddenError) BuySingleDomainForbidden {
	typ := BuySingleDomainForbiddenTypeForbidden

	return BuySingleDomainForbidden{
		ForbiddenError: &forbidden,
		Type:           typ,
	}
}

func (u *BuySingleDomainForbidden) UnmarshalJSON(data []byte) error {

	type discriminator struct {
		Code string `json:"code"`
	}

	dis := new(discriminator)
	if err := json.Unmarshal(data, &dis); err != nil {
		return fmt.Errorf("could not unmarshal discriminator: %w", err)
	}

	switch dis.Code {
	case "not_authorized_for_scope":
		notAuthorizedForScopeError := new(NotAuthorizedForScopeError)
		if err := utils.UnmarshalJSON(data, &notAuthorizedForScopeError, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == not_authorized_for_scope) type NotAuthorizedForScopeError within BuySingleDomainForbidden: %w", string(data), err)
		}

		u.NotAuthorizedForScopeError = notAuthorizedForScopeError
		u.Type = BuySingleDomainForbiddenTypeNotAuthorizedForScope
		return nil
	case "forbidden":
		forbiddenError := new(ForbiddenError)
		if err := utils.UnmarshalJSON(data, &forbiddenError, "", true, nil); err != nil {
			return fmt.Errorf("could not unmarshal `%s` into expected (Code == forbidden) type ForbiddenError within BuySingleDomainForbidden: %w", string(data), err)
		}

		u.ForbiddenError = forbiddenError
		u.Type = BuySingleDomainForbiddenTypeForbidden
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BuySingleDomainForbidden", string(data))
}

func (u BuySingleDomainForbidden) MarshalJSON() ([]byte, error) {
	if u.NotAuthorizedForScopeError != nil {
		return utils.MarshalJSON(u.NotAuthorizedForScopeError, "", true)
	}

	if u.ForbiddenError != nil {
		return utils.MarshalJSON(u.ForbiddenError, "", true)
	}

	return nil, errors.New("could not marshal union type BuySingleDomainForbidden: all fields are null")
}

func (u BuySingleDomainForbidden) Error() string {
	switch u.Type {
	case BuySingleDomainForbiddenTypeNotAuthorizedForScope:
		data, _ := json.Marshal(u.NotAuthorizedForScopeError)
		return string(data)
	case BuySingleDomainForbiddenTypeForbidden:
		data, _ := json.Marshal(u.ForbiddenError)
		return string(data)
	default:
		return "unknown error"
	}
}

type BuySingleDomainBadRequestType string

const (
	BuySingleDomainBadRequestTypeDomainTooShortError                BuySingleDomainBadRequestType = "DomainTooShort_error"
	BuySingleDomainBadRequestTypeOrderTooExpensiveError             BuySingleDomainBadRequestType = "OrderTooExpensive_error"
	BuySingleDomainBadRequestTypeInvalidAdditionalContactInfoError  BuySingleDomainBadRequestType = "InvalidAdditionalContactInfo_error"
	BuySingleDomainBadRequestTypeAdditionalContactInfoRequiredError BuySingleDomainBadRequestType = "AdditionalContactInfoRequired_error"
	BuySingleDomainBadRequestTypeExpectedPriceMismatchError         BuySingleDomainBadRequestType = "ExpectedPriceMismatch_error"
	BuySingleDomainBadRequestTypeDomainNotAvailableError            BuySingleDomainBadRequestType = "DomainNotAvailable_error"
	BuySingleDomainBadRequestTypeLanguageCodeRequiredError          BuySingleDomainBadRequestType = "LanguageCodeRequired_error"
	BuySingleDomainBadRequestTypeTldNotSupportedError               BuySingleDomainBadRequestType = "TldNotSupported_error"
	BuySingleDomainBadRequestTypeHTTPAPIDecodeError                 BuySingleDomainBadRequestType = "HttpApiDecodeError"
)

// BuySingleDomainBadRequest - There was something wrong with the request
type BuySingleDomainBadRequest struct {
	DomainTooShortError                *DomainTooShortError                `queryParam:"inline"`
	OrderTooExpensiveError             *OrderTooExpensiveError             `queryParam:"inline"`
	InvalidAdditionalContactInfoError  *InvalidAdditionalContactInfoError  `queryParam:"inline"`
	AdditionalContactInfoRequiredError *AdditionalContactInfoRequiredError `queryParam:"inline"`
	ExpectedPriceMismatchError         *ExpectedPriceMismatchError         `queryParam:"inline"`
	DomainNotAvailableError            *DomainNotAvailableError            `queryParam:"inline"`
	LanguageCodeRequiredError          *LanguageCodeRequiredError          `queryParam:"inline"`
	TldNotSupportedError               *TldNotSupportedError               `queryParam:"inline"`
	HTTPAPIDecodeError                 *HTTPAPIDecodeError                 `queryParam:"inline"`

	Type BuySingleDomainBadRequestType

	HTTPMeta components.HTTPMetadata `json:"-"`
}

var _ error = &BuySingleDomainBadRequest{}

func CreateBuySingleDomainBadRequestDomainTooShortError(domainTooShortError DomainTooShortError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeDomainTooShortError

	return BuySingleDomainBadRequest{
		DomainTooShortError: &domainTooShortError,
		Type:                typ,
	}
}

func CreateBuySingleDomainBadRequestOrderTooExpensiveError(orderTooExpensiveError OrderTooExpensiveError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeOrderTooExpensiveError

	return BuySingleDomainBadRequest{
		OrderTooExpensiveError: &orderTooExpensiveError,
		Type:                   typ,
	}
}

func CreateBuySingleDomainBadRequestInvalidAdditionalContactInfoError(invalidAdditionalContactInfoError InvalidAdditionalContactInfoError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeInvalidAdditionalContactInfoError

	return BuySingleDomainBadRequest{
		InvalidAdditionalContactInfoError: &invalidAdditionalContactInfoError,
		Type:                              typ,
	}
}

func CreateBuySingleDomainBadRequestAdditionalContactInfoRequiredError(additionalContactInfoRequiredError AdditionalContactInfoRequiredError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeAdditionalContactInfoRequiredError

	return BuySingleDomainBadRequest{
		AdditionalContactInfoRequiredError: &additionalContactInfoRequiredError,
		Type:                               typ,
	}
}

func CreateBuySingleDomainBadRequestExpectedPriceMismatchError(expectedPriceMismatchError ExpectedPriceMismatchError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeExpectedPriceMismatchError

	return BuySingleDomainBadRequest{
		ExpectedPriceMismatchError: &expectedPriceMismatchError,
		Type:                       typ,
	}
}

func CreateBuySingleDomainBadRequestDomainNotAvailableError(domainNotAvailableError DomainNotAvailableError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeDomainNotAvailableError

	return BuySingleDomainBadRequest{
		DomainNotAvailableError: &domainNotAvailableError,
		Type:                    typ,
	}
}

func CreateBuySingleDomainBadRequestLanguageCodeRequiredError(languageCodeRequiredError LanguageCodeRequiredError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeLanguageCodeRequiredError

	return BuySingleDomainBadRequest{
		LanguageCodeRequiredError: &languageCodeRequiredError,
		Type:                      typ,
	}
}

func CreateBuySingleDomainBadRequestTldNotSupportedError(tldNotSupportedError TldNotSupportedError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeTldNotSupportedError

	return BuySingleDomainBadRequest{
		TldNotSupportedError: &tldNotSupportedError,
		Type:                 typ,
	}
}

func CreateBuySingleDomainBadRequestHTTPAPIDecodeError(httpAPIDecodeError HTTPAPIDecodeError) BuySingleDomainBadRequest {
	typ := BuySingleDomainBadRequestTypeHTTPAPIDecodeError

	return BuySingleDomainBadRequest{
		HTTPAPIDecodeError: &httpAPIDecodeError,
		Type:               typ,
	}
}

func (u *BuySingleDomainBadRequest) UnmarshalJSON(data []byte) error {

	var domainTooShortError DomainTooShortError = DomainTooShortError{}
	if err := utils.UnmarshalJSON(data, &domainTooShortError, "", true, nil); err == nil {
		u.DomainTooShortError = &domainTooShortError
		u.Type = BuySingleDomainBadRequestTypeDomainTooShortError
		return nil
	}

	var orderTooExpensiveError OrderTooExpensiveError = OrderTooExpensiveError{}
	if err := utils.UnmarshalJSON(data, &orderTooExpensiveError, "", true, nil); err == nil {
		u.OrderTooExpensiveError = &orderTooExpensiveError
		u.Type = BuySingleDomainBadRequestTypeOrderTooExpensiveError
		return nil
	}

	var invalidAdditionalContactInfoError InvalidAdditionalContactInfoError = InvalidAdditionalContactInfoError{}
	if err := utils.UnmarshalJSON(data, &invalidAdditionalContactInfoError, "", true, nil); err == nil {
		u.InvalidAdditionalContactInfoError = &invalidAdditionalContactInfoError
		u.Type = BuySingleDomainBadRequestTypeInvalidAdditionalContactInfoError
		return nil
	}

	var additionalContactInfoRequiredError AdditionalContactInfoRequiredError = AdditionalContactInfoRequiredError{}
	if err := utils.UnmarshalJSON(data, &additionalContactInfoRequiredError, "", true, nil); err == nil {
		u.AdditionalContactInfoRequiredError = &additionalContactInfoRequiredError
		u.Type = BuySingleDomainBadRequestTypeAdditionalContactInfoRequiredError
		return nil
	}

	var expectedPriceMismatchError ExpectedPriceMismatchError = ExpectedPriceMismatchError{}
	if err := utils.UnmarshalJSON(data, &expectedPriceMismatchError, "", true, nil); err == nil {
		u.ExpectedPriceMismatchError = &expectedPriceMismatchError
		u.Type = BuySingleDomainBadRequestTypeExpectedPriceMismatchError
		return nil
	}

	var domainNotAvailableError DomainNotAvailableError = DomainNotAvailableError{}
	if err := utils.UnmarshalJSON(data, &domainNotAvailableError, "", true, nil); err == nil {
		u.DomainNotAvailableError = &domainNotAvailableError
		u.Type = BuySingleDomainBadRequestTypeDomainNotAvailableError
		return nil
	}

	var languageCodeRequiredError LanguageCodeRequiredError = LanguageCodeRequiredError{}
	if err := utils.UnmarshalJSON(data, &languageCodeRequiredError, "", true, nil); err == nil {
		u.LanguageCodeRequiredError = &languageCodeRequiredError
		u.Type = BuySingleDomainBadRequestTypeLanguageCodeRequiredError
		return nil
	}

	var tldNotSupportedError TldNotSupportedError = TldNotSupportedError{}
	if err := utils.UnmarshalJSON(data, &tldNotSupportedError, "", true, nil); err == nil {
		u.TldNotSupportedError = &tldNotSupportedError
		u.Type = BuySingleDomainBadRequestTypeTldNotSupportedError
		return nil
	}

	var httpAPIDecodeError HTTPAPIDecodeError = HTTPAPIDecodeError{}
	if err := utils.UnmarshalJSON(data, &httpAPIDecodeError, "", true, nil); err == nil {
		u.HTTPAPIDecodeError = &httpAPIDecodeError
		u.Type = BuySingleDomainBadRequestTypeHTTPAPIDecodeError
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for BuySingleDomainBadRequest", string(data))
}

func (u BuySingleDomainBadRequest) MarshalJSON() ([]byte, error) {
	if u.DomainTooShortError != nil {
		return utils.MarshalJSON(u.DomainTooShortError, "", true)
	}

	if u.OrderTooExpensiveError != nil {
		return utils.MarshalJSON(u.OrderTooExpensiveError, "", true)
	}

	if u.InvalidAdditionalContactInfoError != nil {
		return utils.MarshalJSON(u.InvalidAdditionalContactInfoError, "", true)
	}

	if u.AdditionalContactInfoRequiredError != nil {
		return utils.MarshalJSON(u.AdditionalContactInfoRequiredError, "", true)
	}

	if u.ExpectedPriceMismatchError != nil {
		return utils.MarshalJSON(u.ExpectedPriceMismatchError, "", true)
	}

	if u.DomainNotAvailableError != nil {
		return utils.MarshalJSON(u.DomainNotAvailableError, "", true)
	}

	if u.LanguageCodeRequiredError != nil {
		return utils.MarshalJSON(u.LanguageCodeRequiredError, "", true)
	}

	if u.TldNotSupportedError != nil {
		return utils.MarshalJSON(u.TldNotSupportedError, "", true)
	}

	if u.HTTPAPIDecodeError != nil {
		return utils.MarshalJSON(u.HTTPAPIDecodeError, "", true)
	}

	return nil, errors.New("could not marshal union type BuySingleDomainBadRequest: all fields are null")
}

func (u BuySingleDomainBadRequest) Error() string {
	switch u.Type {
	case BuySingleDomainBadRequestTypeDomainTooShortError:
		data, _ := json.Marshal(u.DomainTooShortError)
		return string(data)
	case BuySingleDomainBadRequestTypeOrderTooExpensiveError:
		data, _ := json.Marshal(u.OrderTooExpensiveError)
		return string(data)
	case BuySingleDomainBadRequestTypeInvalidAdditionalContactInfoError:
		data, _ := json.Marshal(u.InvalidAdditionalContactInfoError)
		return string(data)
	case BuySingleDomainBadRequestTypeAdditionalContactInfoRequiredError:
		data, _ := json.Marshal(u.AdditionalContactInfoRequiredError)
		return string(data)
	case BuySingleDomainBadRequestTypeExpectedPriceMismatchError:
		data, _ := json.Marshal(u.ExpectedPriceMismatchError)
		return string(data)
	case BuySingleDomainBadRequestTypeDomainNotAvailableError:
		data, _ := json.Marshal(u.DomainNotAvailableError)
		return string(data)
	case BuySingleDomainBadRequestTypeLanguageCodeRequiredError:
		data, _ := json.Marshal(u.LanguageCodeRequiredError)
		return string(data)
	case BuySingleDomainBadRequestTypeTldNotSupportedError:
		data, _ := json.Marshal(u.TldNotSupportedError)
		return string(data)
	case BuySingleDomainBadRequestTypeHTTPAPIDecodeError:
		data, _ := json.Marshal(u.HTTPAPIDecodeError)
		return string(data)
	default:
		return "unknown error"
	}
}
