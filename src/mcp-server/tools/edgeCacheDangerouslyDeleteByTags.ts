/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { edgeCacheDangerouslyDeleteByTags } from "../../funcs/edgeCacheDangerouslyDeleteByTags.js";
import { DangerouslyDeleteByTagsRequest$inboundSchema } from "../../models/dangerouslydeletebytagsop.js";
import { formatResult, ToolDefinition } from "../tools.js";

const args = {
  request: DangerouslyDeleteByTagsRequest$inboundSchema,
};

export const tool$edgeCacheDangerouslyDeleteByTags: ToolDefinition<
  typeof args
> = {
  name: "edge-cache-dangerously-delete-by-tags",
  description: `Dangerously delete by tag

Marks a cache tag as deleted, causing cache entries associated with that tag to be revalidated in the foreground on the next request. Use this method with caution because one tag can be associated with many paths and deleting the cache can cause many concurrent requests to the origin leading to cache stampede problem. A good use case for deleting the cache is when the origin has also been deleted, for example it returns a 404 or 410 status code.`,
  args,
  tool: async (client, args, ctx) => {
    const [result, apiCall] = await edgeCacheDangerouslyDeleteByTags(
      client,
      args.request,
      { fetchOptions: { signal: ctx.signal } },
    ).$inspect();

    if (!result.ok) {
      return {
        content: [{ type: "text", text: result.error.message }],
        isError: true,
      };
    }

    return formatResult(void 0, apiCall);
  },
};
