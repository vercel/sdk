/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type ApproveRollingReleaseStageRequestBody = {
  /**
   * The index of the stage to transition to
   */
  nextStageIndex: number;
  /**
   * The id of the canary deployment to approve for the next stage
   */
  canaryDeploymentId: string;
};

export type ApproveRollingReleaseStageRequest = {
  /**
   * Project ID or project name (URL-encoded)
   */
  idOrName: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: ApproveRollingReleaseStageRequestBody | undefined;
};

/**
 * The current state of the rolling release
 */
export const ApproveRollingReleaseStageState = {
  Active: "ACTIVE",
  Complete: "COMPLETE",
  Aborted: "ABORTED",
} as const;
/**
 * The current state of the rolling release
 */
export type ApproveRollingReleaseStageState = ClosedEnum<
  typeof ApproveRollingReleaseStageState
>;

/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export const ApproveRollingReleaseStageTarget = {
  Staging: "staging",
  Production: "production",
} as const;
/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export type ApproveRollingReleaseStageTarget = ClosedEnum<
  typeof ApproveRollingReleaseStageTarget
>;

/**
 * Where was the deployment created from
 */
export const ApproveRollingReleaseStageSource = {
  ApiTriggerGitDeploy: "api-trigger-git-deploy",
  Cli: "cli",
  CloneRepo: "clone/repo",
  Git: "git",
  Import: "import",
  ImportRepo: "import/repo",
  Redeploy: "redeploy",
  V0Web: "v0-web",
} as const;
/**
 * Where was the deployment created from
 */
export type ApproveRollingReleaseStageSource = ClosedEnum<
  typeof ApproveRollingReleaseStageSource
>;

/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export const ApproveRollingReleaseStageReadyState = {
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Queued: "QUEUED",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export type ApproveRollingReleaseStageReadyState = ClosedEnum<
  typeof ApproveRollingReleaseStageReadyState
>;

/**
 * The current deployment receiving production traffic
 */
export type ApproveRollingReleaseStageCurrentDeployment = {
  /**
   * A string holding the unique ID of the deployment
   */
  id: string;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   */
  name: string;
  /**
   * A string with the unique URL of the deployment
   */
  url: string;
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
   */
  target?: ApproveRollingReleaseStageTarget | null | undefined;
  /**
   * Where was the deployment created from
   */
  source?: ApproveRollingReleaseStageSource | undefined;
  /**
   * A number containing the date when the deployment was created in milliseconds
   */
  createdAt: number;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   */
  readyState: ApproveRollingReleaseStageReadyState;
  readyStateAt?: number | undefined;
};

/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export const ApproveRollingReleaseStageRollingReleaseTarget = {
  Staging: "staging",
  Production: "production",
} as const;
/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export type ApproveRollingReleaseStageRollingReleaseTarget = ClosedEnum<
  typeof ApproveRollingReleaseStageRollingReleaseTarget
>;

/**
 * Where was the deployment created from
 */
export const ApproveRollingReleaseStageRollingReleaseSource = {
  ApiTriggerGitDeploy: "api-trigger-git-deploy",
  Cli: "cli",
  CloneRepo: "clone/repo",
  Git: "git",
  Import: "import",
  ImportRepo: "import/repo",
  Redeploy: "redeploy",
  V0Web: "v0-web",
} as const;
/**
 * Where was the deployment created from
 */
export type ApproveRollingReleaseStageRollingReleaseSource = ClosedEnum<
  typeof ApproveRollingReleaseStageRollingReleaseSource
>;

/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export const ApproveRollingReleaseStageRollingReleaseReadyState = {
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Queued: "QUEUED",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export type ApproveRollingReleaseStageRollingReleaseReadyState = ClosedEnum<
  typeof ApproveRollingReleaseStageRollingReleaseReadyState
>;

/**
 * The canary deployment being rolled out
 */
export type ApproveRollingReleaseStageCanaryDeployment = {
  /**
   * A string holding the unique ID of the deployment
   */
  id: string;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   */
  name: string;
  /**
   * A string with the unique URL of the deployment
   */
  url: string;
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
   */
  target?: ApproveRollingReleaseStageRollingReleaseTarget | null | undefined;
  /**
   * Where was the deployment created from
   */
  source?: ApproveRollingReleaseStageRollingReleaseSource | undefined;
  /**
   * A number containing the date when the deployment was created in milliseconds
   */
  createdAt: number;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   */
  readyState: ApproveRollingReleaseStageRollingReleaseReadyState;
  readyStateAt?: number | undefined;
};

/**
 * The advancement type of the rolling release
 */
export const ApproveRollingReleaseStageAdvancementType = {
  Automatic: "automatic",
  ManualApproval: "manual-approval",
} as const;
/**
 * The advancement type of the rolling release
 */
export type ApproveRollingReleaseStageAdvancementType = ClosedEnum<
  typeof ApproveRollingReleaseStageAdvancementType
>;

/**
 * All stages configured for this rolling release
 */
export type ApproveRollingReleaseStageStages = {
  /**
   * The zero-based index of the stage
   */
  index: number;
  /**
   * Whether or not this stage is the final stage (targetPercentage === 100)
   */
  isFinalStage: boolean;
  /**
   * The percentage of traffic to serve to the canary deployment (0-100)
   */
  targetPercentage: number;
  /**
   * Whether or not this stage requires manual approval to proceed
   */
  requireApproval: boolean;
  /**
   * Duration in seconds for automatic advancement, null for manual stages or the final stage
   */
  duration: number | null;
  /**
   * Whether to linearly shift traffic over the duration of this stage
   */
  linearShift?: boolean | undefined;
};

/**
 * The currently active stage, null if the rollout is aborted
 */
export type ApproveRollingReleaseStageActiveStage = {
  /**
   * The zero-based index of the stage
   */
  index: number;
  /**
   * Whether or not this stage is the final stage (targetPercentage === 100)
   */
  isFinalStage: boolean;
  /**
   * The percentage of traffic to serve to the canary deployment (0-100)
   */
  targetPercentage: number;
  /**
   * Whether or not this stage requires manual approval to proceed
   */
  requireApproval: boolean;
  /**
   * Duration in seconds for automatic advancement, null for manual stages or the final stage
   */
  duration: number | null;
  /**
   * Whether to linearly shift traffic over the duration of this stage
   */
  linearShift?: boolean | undefined;
};

/**
 * The next stage to be activated, null if not in ACTIVE state
 */
export type ApproveRollingReleaseStageNextStage = {
  /**
   * The zero-based index of the stage
   */
  index: number;
  /**
   * Whether or not this stage is the final stage (targetPercentage === 100)
   */
  isFinalStage: boolean;
  /**
   * The percentage of traffic to serve to the canary deployment (0-100)
   */
  targetPercentage: number;
  /**
   * Whether or not this stage requires manual approval to proceed
   */
  requireApproval: boolean;
  /**
   * Duration in seconds for automatic advancement, null for manual stages or the final stage
   */
  duration: number | null;
  /**
   * Whether to linearly shift traffic over the duration of this stage
   */
  linearShift?: boolean | undefined;
};

/**
 * Rolling release information including configuration and document details, or null if no rolling release exists
 */
export type ApproveRollingReleaseStageRollingRelease = {
  /**
   * The current state of the rolling release
   */
  state: ApproveRollingReleaseStageState;
  /**
   * The current deployment receiving production traffic
   */
  currentDeployment: ApproveRollingReleaseStageCurrentDeployment | null;
  /**
   * The canary deployment being rolled out
   */
  canaryDeployment: ApproveRollingReleaseStageCanaryDeployment | null;
  /**
   * The ID of a deployment queued for the next rolling release
   */
  queuedDeploymentId: string | null;
  /**
   * The advancement type of the rolling release
   */
  advancementType: ApproveRollingReleaseStageAdvancementType;
  /**
   * All stages configured for this rolling release
   */
  stages: Array<ApproveRollingReleaseStageStages>;
  /**
   * The currently active stage, null if the rollout is aborted
   */
  activeStage: ApproveRollingReleaseStageActiveStage | null;
  /**
   * The next stage to be activated, null if not in ACTIVE state
   */
  nextStage: ApproveRollingReleaseStageNextStage | null;
  /**
   * Unix timestamp in milliseconds when the rolling release started
   */
  startedAt: number;
  /**
   * Unix timestamp in milliseconds when the rolling release was last updated
   */
  updatedAt: number;
};

/**
 * The response format for rolling release endpoints that return rolling release information
 */
export type ApproveRollingReleaseStageResponseBody = {
  /**
   * Rolling release information including configuration and document details, or null if no rolling release exists
   */
  rollingRelease: ApproveRollingReleaseStageRollingRelease | null;
};

/** @internal */
export const ApproveRollingReleaseStageRequestBody$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  nextStageIndex: z.number(),
  canaryDeploymentId: z.string(),
});
/** @internal */
export type ApproveRollingReleaseStageRequestBody$Outbound = {
  nextStageIndex: number;
  canaryDeploymentId: string;
};

/** @internal */
export const ApproveRollingReleaseStageRequestBody$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageRequestBody$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageRequestBody
> = z.object({
  nextStageIndex: z.number(),
  canaryDeploymentId: z.string(),
});

export function approveRollingReleaseStageRequestBodyToJSON(
  approveRollingReleaseStageRequestBody: ApproveRollingReleaseStageRequestBody,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageRequestBody$outboundSchema.parse(
      approveRollingReleaseStageRequestBody,
    ),
  );
}
export function approveRollingReleaseStageRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageRequestBody' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageRequest$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  idOrName: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  RequestBody: z.lazy(() => ApproveRollingReleaseStageRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type ApproveRollingReleaseStageRequest$Outbound = {
  idOrName: string;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: ApproveRollingReleaseStageRequestBody$Outbound | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageRequest$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageRequest$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageRequest
> = z.object({
  idOrName: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() =>
    ApproveRollingReleaseStageRequestBody$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function approveRollingReleaseStageRequestToJSON(
  approveRollingReleaseStageRequest: ApproveRollingReleaseStageRequest,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageRequest$outboundSchema.parse(
      approveRollingReleaseStageRequest,
    ),
  );
}
export function approveRollingReleaseStageRequestFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApproveRollingReleaseStageRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageRequest' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageState$inboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageState
> = z.nativeEnum(ApproveRollingReleaseStageState);
/** @internal */
export const ApproveRollingReleaseStageState$outboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageState
> = ApproveRollingReleaseStageState$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageTarget$inboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageTarget
> = z.nativeEnum(ApproveRollingReleaseStageTarget);
/** @internal */
export const ApproveRollingReleaseStageTarget$outboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageTarget
> = ApproveRollingReleaseStageTarget$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageSource$inboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageSource
> = z.nativeEnum(ApproveRollingReleaseStageSource);
/** @internal */
export const ApproveRollingReleaseStageSource$outboundSchema: z.ZodNativeEnum<
  typeof ApproveRollingReleaseStageSource
> = ApproveRollingReleaseStageSource$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageReadyState$inboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageReadyState> = z.nativeEnum(
    ApproveRollingReleaseStageReadyState,
  );
/** @internal */
export const ApproveRollingReleaseStageReadyState$outboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageReadyState> =
    ApproveRollingReleaseStageReadyState$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageCurrentDeployment$inboundSchema:
  z.ZodType<
    ApproveRollingReleaseStageCurrentDeployment,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    name: z.string(),
    url: z.string(),
    target: z.nullable(ApproveRollingReleaseStageTarget$inboundSchema)
      .optional(),
    source: ApproveRollingReleaseStageSource$inboundSchema.optional(),
    createdAt: z.number(),
    readyState: ApproveRollingReleaseStageReadyState$inboundSchema,
    readyStateAt: z.number().optional(),
  });
/** @internal */
export type ApproveRollingReleaseStageCurrentDeployment$Outbound = {
  id: string;
  name: string;
  url: string;
  target?: string | null | undefined;
  source?: string | undefined;
  createdAt: number;
  readyState: string;
  readyStateAt?: number | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageCurrentDeployment$outboundSchema:
  z.ZodType<
    ApproveRollingReleaseStageCurrentDeployment$Outbound,
    z.ZodTypeDef,
    ApproveRollingReleaseStageCurrentDeployment
  > = z.object({
    id: z.string(),
    name: z.string(),
    url: z.string(),
    target: z.nullable(ApproveRollingReleaseStageTarget$outboundSchema)
      .optional(),
    source: ApproveRollingReleaseStageSource$outboundSchema.optional(),
    createdAt: z.number(),
    readyState: ApproveRollingReleaseStageReadyState$outboundSchema,
    readyStateAt: z.number().optional(),
  });

export function approveRollingReleaseStageCurrentDeploymentToJSON(
  approveRollingReleaseStageCurrentDeployment:
    ApproveRollingReleaseStageCurrentDeployment,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageCurrentDeployment$outboundSchema.parse(
      approveRollingReleaseStageCurrentDeployment,
    ),
  );
}
export function approveRollingReleaseStageCurrentDeploymentFromJSON(
  jsonString: string,
): SafeParseResult<
  ApproveRollingReleaseStageCurrentDeployment,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageCurrentDeployment$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ApproveRollingReleaseStageCurrentDeployment' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageRollingReleaseTarget$inboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseTarget> = z
    .nativeEnum(ApproveRollingReleaseStageRollingReleaseTarget);
/** @internal */
export const ApproveRollingReleaseStageRollingReleaseTarget$outboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseTarget> =
    ApproveRollingReleaseStageRollingReleaseTarget$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageRollingReleaseSource$inboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseSource> = z
    .nativeEnum(ApproveRollingReleaseStageRollingReleaseSource);
/** @internal */
export const ApproveRollingReleaseStageRollingReleaseSource$outboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseSource> =
    ApproveRollingReleaseStageRollingReleaseSource$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageRollingReleaseReadyState$inboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseReadyState> = z
    .nativeEnum(ApproveRollingReleaseStageRollingReleaseReadyState);
/** @internal */
export const ApproveRollingReleaseStageRollingReleaseReadyState$outboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageRollingReleaseReadyState> =
    ApproveRollingReleaseStageRollingReleaseReadyState$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageCanaryDeployment$inboundSchema:
  z.ZodType<ApproveRollingReleaseStageCanaryDeployment, z.ZodTypeDef, unknown> =
    z.object({
      id: z.string(),
      name: z.string(),
      url: z.string(),
      target: z.nullable(
        ApproveRollingReleaseStageRollingReleaseTarget$inboundSchema,
      ).optional(),
      source: ApproveRollingReleaseStageRollingReleaseSource$inboundSchema
        .optional(),
      createdAt: z.number(),
      readyState:
        ApproveRollingReleaseStageRollingReleaseReadyState$inboundSchema,
      readyStateAt: z.number().optional(),
    });
/** @internal */
export type ApproveRollingReleaseStageCanaryDeployment$Outbound = {
  id: string;
  name: string;
  url: string;
  target?: string | null | undefined;
  source?: string | undefined;
  createdAt: number;
  readyState: string;
  readyStateAt?: number | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageCanaryDeployment$outboundSchema:
  z.ZodType<
    ApproveRollingReleaseStageCanaryDeployment$Outbound,
    z.ZodTypeDef,
    ApproveRollingReleaseStageCanaryDeployment
  > = z.object({
    id: z.string(),
    name: z.string(),
    url: z.string(),
    target: z.nullable(
      ApproveRollingReleaseStageRollingReleaseTarget$outboundSchema,
    ).optional(),
    source: ApproveRollingReleaseStageRollingReleaseSource$outboundSchema
      .optional(),
    createdAt: z.number(),
    readyState:
      ApproveRollingReleaseStageRollingReleaseReadyState$outboundSchema,
    readyStateAt: z.number().optional(),
  });

export function approveRollingReleaseStageCanaryDeploymentToJSON(
  approveRollingReleaseStageCanaryDeployment:
    ApproveRollingReleaseStageCanaryDeployment,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageCanaryDeployment$outboundSchema.parse(
      approveRollingReleaseStageCanaryDeployment,
    ),
  );
}
export function approveRollingReleaseStageCanaryDeploymentFromJSON(
  jsonString: string,
): SafeParseResult<
  ApproveRollingReleaseStageCanaryDeployment,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageCanaryDeployment$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ApproveRollingReleaseStageCanaryDeployment' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageAdvancementType$inboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageAdvancementType> = z
    .nativeEnum(ApproveRollingReleaseStageAdvancementType);
/** @internal */
export const ApproveRollingReleaseStageAdvancementType$outboundSchema:
  z.ZodNativeEnum<typeof ApproveRollingReleaseStageAdvancementType> =
    ApproveRollingReleaseStageAdvancementType$inboundSchema;

/** @internal */
export const ApproveRollingReleaseStageStages$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageStages,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});
/** @internal */
export type ApproveRollingReleaseStageStages$Outbound = {
  index: number;
  isFinalStage: boolean;
  targetPercentage: number;
  requireApproval: boolean;
  duration: number | null;
  linearShift?: boolean | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageStages$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageStages$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageStages
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});

export function approveRollingReleaseStageStagesToJSON(
  approveRollingReleaseStageStages: ApproveRollingReleaseStageStages,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageStages$outboundSchema.parse(
      approveRollingReleaseStageStages,
    ),
  );
}
export function approveRollingReleaseStageStagesFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageStages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ApproveRollingReleaseStageStages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageStages' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageActiveStage$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageActiveStage,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});
/** @internal */
export type ApproveRollingReleaseStageActiveStage$Outbound = {
  index: number;
  isFinalStage: boolean;
  targetPercentage: number;
  requireApproval: boolean;
  duration: number | null;
  linearShift?: boolean | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageActiveStage$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageActiveStage$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageActiveStage
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});

export function approveRollingReleaseStageActiveStageToJSON(
  approveRollingReleaseStageActiveStage: ApproveRollingReleaseStageActiveStage,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageActiveStage$outboundSchema.parse(
      approveRollingReleaseStageActiveStage,
    ),
  );
}
export function approveRollingReleaseStageActiveStageFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageActiveStage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageActiveStage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageActiveStage' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageNextStage$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageNextStage,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});
/** @internal */
export type ApproveRollingReleaseStageNextStage$Outbound = {
  index: number;
  isFinalStage: boolean;
  targetPercentage: number;
  requireApproval: boolean;
  duration: number | null;
  linearShift?: boolean | undefined;
};

/** @internal */
export const ApproveRollingReleaseStageNextStage$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageNextStage$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageNextStage
> = z.object({
  index: z.number(),
  isFinalStage: z.boolean(),
  targetPercentage: z.number(),
  requireApproval: z.boolean(),
  duration: z.nullable(z.number()),
  linearShift: z.boolean().optional(),
});

export function approveRollingReleaseStageNextStageToJSON(
  approveRollingReleaseStageNextStage: ApproveRollingReleaseStageNextStage,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageNextStage$outboundSchema.parse(
      approveRollingReleaseStageNextStage,
    ),
  );
}
export function approveRollingReleaseStageNextStageFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageNextStage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageNextStage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageNextStage' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageRollingRelease$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageRollingRelease,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: ApproveRollingReleaseStageState$inboundSchema,
  currentDeployment: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageCurrentDeployment$inboundSchema),
  ),
  canaryDeployment: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageCanaryDeployment$inboundSchema),
  ),
  queuedDeploymentId: z.nullable(z.string()),
  advancementType: ApproveRollingReleaseStageAdvancementType$inboundSchema,
  stages: z.array(z.lazy(() => ApproveRollingReleaseStageStages$inboundSchema)),
  activeStage: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageActiveStage$inboundSchema),
  ),
  nextStage: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageNextStage$inboundSchema),
  ),
  startedAt: z.number(),
  updatedAt: z.number(),
});
/** @internal */
export type ApproveRollingReleaseStageRollingRelease$Outbound = {
  state: string;
  currentDeployment:
    | ApproveRollingReleaseStageCurrentDeployment$Outbound
    | null;
  canaryDeployment: ApproveRollingReleaseStageCanaryDeployment$Outbound | null;
  queuedDeploymentId: string | null;
  advancementType: string;
  stages: Array<ApproveRollingReleaseStageStages$Outbound>;
  activeStage: ApproveRollingReleaseStageActiveStage$Outbound | null;
  nextStage: ApproveRollingReleaseStageNextStage$Outbound | null;
  startedAt: number;
  updatedAt: number;
};

/** @internal */
export const ApproveRollingReleaseStageRollingRelease$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageRollingRelease$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageRollingRelease
> = z.object({
  state: ApproveRollingReleaseStageState$outboundSchema,
  currentDeployment: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageCurrentDeployment$outboundSchema),
  ),
  canaryDeployment: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageCanaryDeployment$outboundSchema),
  ),
  queuedDeploymentId: z.nullable(z.string()),
  advancementType: ApproveRollingReleaseStageAdvancementType$outboundSchema,
  stages: z.array(
    z.lazy(() => ApproveRollingReleaseStageStages$outboundSchema),
  ),
  activeStage: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageActiveStage$outboundSchema),
  ),
  nextStage: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageNextStage$outboundSchema),
  ),
  startedAt: z.number(),
  updatedAt: z.number(),
});

export function approveRollingReleaseStageRollingReleaseToJSON(
  approveRollingReleaseStageRollingRelease:
    ApproveRollingReleaseStageRollingRelease,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageRollingRelease$outboundSchema.parse(
      approveRollingReleaseStageRollingRelease,
    ),
  );
}
export function approveRollingReleaseStageRollingReleaseFromJSON(
  jsonString: string,
): SafeParseResult<
  ApproveRollingReleaseStageRollingRelease,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageRollingRelease$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ApproveRollingReleaseStageRollingRelease' from JSON`,
  );
}

/** @internal */
export const ApproveRollingReleaseStageResponseBody$inboundSchema: z.ZodType<
  ApproveRollingReleaseStageResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  rollingRelease: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageRollingRelease$inboundSchema),
  ),
});
/** @internal */
export type ApproveRollingReleaseStageResponseBody$Outbound = {
  rollingRelease: ApproveRollingReleaseStageRollingRelease$Outbound | null;
};

/** @internal */
export const ApproveRollingReleaseStageResponseBody$outboundSchema: z.ZodType<
  ApproveRollingReleaseStageResponseBody$Outbound,
  z.ZodTypeDef,
  ApproveRollingReleaseStageResponseBody
> = z.object({
  rollingRelease: z.nullable(
    z.lazy(() => ApproveRollingReleaseStageRollingRelease$outboundSchema),
  ),
});

export function approveRollingReleaseStageResponseBodyToJSON(
  approveRollingReleaseStageResponseBody:
    ApproveRollingReleaseStageResponseBody,
): string {
  return JSON.stringify(
    ApproveRollingReleaseStageResponseBody$outboundSchema.parse(
      approveRollingReleaseStageResponseBody,
    ),
  );
}
export function approveRollingReleaseStageResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ApproveRollingReleaseStageResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ApproveRollingReleaseStageResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ApproveRollingReleaseStageResponseBody' from JSON`,
  );
}
