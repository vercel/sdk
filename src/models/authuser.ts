/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const Reason = {
  SubscriptionCanceled: "SUBSCRIPTION_CANCELED",
  SubscriptionExpired: "SUBSCRIPTION_EXPIRED",
  UnpaidInvoice: "UNPAID_INVOICE",
  EnterpriseTrialEnded: "ENTERPRISE_TRIAL_ENDED",
  FairUseLimitsExceeded: "FAIR_USE_LIMITS_EXCEEDED",
  BlockedForPlatformAbuse: "BLOCKED_FOR_PLATFORM_ABUSE",
} as const;
export type Reason = ClosedEnum<typeof Reason>;

export const BlockedDueToOverageType = {
  AnalyticsUsage: "analyticsUsage",
  Artifacts: "artifacts",
  Bandwidth: "bandwidth",
  BlobTotalAdvancedRequests: "blobTotalAdvancedRequests",
  BlobTotalAvgSizeInBytes: "blobTotalAvgSizeInBytes",
  BlobTotalGetResponseObjectSizeInBytes:
    "blobTotalGetResponseObjectSizeInBytes",
  BlobTotalSimpleRequests: "blobTotalSimpleRequests",
  ConnectDataTransfer: "connectDataTransfer",
  DataCacheRead: "dataCacheRead",
  DataCacheWrite: "dataCacheWrite",
  EdgeConfigRead: "edgeConfigRead",
  EdgeConfigWrite: "edgeConfigWrite",
  EdgeFunctionExecutionUnits: "edgeFunctionExecutionUnits",
  EdgeMiddlewareInvocations: "edgeMiddlewareInvocations",
  EdgeRequestAdditionalCpuDuration: "edgeRequestAdditionalCpuDuration",
  EdgeRequest: "edgeRequest",
  ElasticConcurrencyBuildSlots: "elasticConcurrencyBuildSlots",
  FastDataTransfer: "fastDataTransfer",
  FastOriginTransfer: "fastOriginTransfer",
  FluidCpuDuration: "fluidCpuDuration",
  FluidDuration: "fluidDuration",
  FunctionDuration: "functionDuration",
  FunctionInvocation: "functionInvocation",
  ImageOptimizationCacheRead: "imageOptimizationCacheRead",
  ImageOptimizationCacheWrite: "imageOptimizationCacheWrite",
  ImageOptimizationTransformation: "imageOptimizationTransformation",
  LogDrainsVolume: "logDrainsVolume",
  MonitoringMetric: "monitoringMetric",
  BlobDataTransfer: "blobDataTransfer",
  ObservabilityEvent: "observabilityEvent",
  OnDemandConcurrencyMinutes: "onDemandConcurrencyMinutes",
  RuntimeCacheRead: "runtimeCacheRead",
  RuntimeCacheWrite: "runtimeCacheWrite",
  ServerlessFunctionExecution: "serverlessFunctionExecution",
  SourceImages: "sourceImages",
  WafOwaspExcessBytes: "wafOwaspExcessBytes",
  WafOwaspRequests: "wafOwaspRequests",
  WafRateLimitRequest: "wafRateLimitRequest",
  WebAnalyticsEvent: "webAnalyticsEvent",
} as const;
export type BlockedDueToOverageType = ClosedEnum<
  typeof BlockedDueToOverageType
>;

/**
 * When the User account has been "soft blocked", this property will contain the date when the restriction was enacted, and the identifier for why.
 */
export type SoftBlock = {
  blockedAt: number;
  reason: Reason;
  blockedDueToOverageType?: BlockedDueToOverageType | undefined;
};

/**
 * An object containing billing infomation associated with the User account.
 */
export type Billing = {};

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type AuthUserBuildEntitlements = {
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  enhancedBuilds?: boolean | undefined;
};

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export const AuthUserConfiguration = {
  SkipNamespaceQueue: "SKIP_NAMESPACE_QUEUE",
  WaitForNamespaceQueue: "WAIT_FOR_NAMESPACE_QUEUE",
} as const;
/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type AuthUserConfiguration = ClosedEnum<typeof AuthUserConfiguration>;

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type BuildQueue = {
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  configuration?: AuthUserConfiguration | undefined;
};

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export const PurchaseType = {
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type PurchaseType = ClosedEnum<typeof PurchaseType>;

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type BuildMachine = {
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  purchaseType?: PurchaseType | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  isDefaultBuildMachine?: boolean | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  cores?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  memory?: number | undefined;
};

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type AuthUserSecurity = {
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  customRules?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  ipBlocks?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  ipBypass?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  rateLimit?: number | undefined;
};

/**
 * An object containing infomation related to the amount of platform resources may be allocated to the User account.
 */
export type AuthUserResourceConfig = {
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  nodeType?: string | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  concurrentBuilds?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  elasticConcurrencyEnabled?: boolean | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  buildEntitlements?: AuthUserBuildEntitlements | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  buildQueue?: BuildQueue | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  awsAccountType?: string | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  awsAccountIds?: Array<string> | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  cfZoneName?: string | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  imageOptimizationType?: string | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  edgeConfigs?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  edgeConfigSize?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  edgeFunctionMaxSizeBytes?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  edgeFunctionExecutionTimeoutMs?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  serverlessFunctionMaxMemorySize?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  kvDatabases?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  postgresDatabases?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  blobStores?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  integrationStores?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  cronJobs?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  cronJobsPerProject?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  microfrontendGroupsPerTeam?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  microfrontendProjectsPerGroup?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  flagsExplorerOverridesThreshold?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  flagsExplorerUnlimitedOverrides?: boolean | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  customEnvironmentsPerProject?: number | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  buildMachine?: BuildMachine | undefined;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  security?: AuthUserSecurity | undefined;
};

export const ViewPreference = {
  List: "list",
  Cards: "cards",
} as const;
export type ViewPreference = ClosedEnum<typeof ViewPreference>;

export const FavoritesViewPreference = {
  Open: "open",
  Closed: "closed",
} as const;
export type FavoritesViewPreference = ClosedEnum<
  typeof FavoritesViewPreference
>;

export const RecentsViewPreference = {
  Open: "open",
  Closed: "closed",
} as const;
export type RecentsViewPreference = ClosedEnum<typeof RecentsViewPreference>;

/**
 * set of dashboard view preferences (cards or list) per scopeId
 */
export type ActiveDashboardViews = {
  scopeId: string;
  viewPreference?: ViewPreference | null | undefined;
  favoritesViewPreference?: FavoritesViewPreference | null | undefined;
  recentsViewPreference?: RecentsViewPreference | null | undefined;
};

export type ImportFlowGitNamespace = string | number;

export type ImportFlowGitNamespaceId = string | number;

export const ImportFlowGitProvider = {
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
} as const;
export type ImportFlowGitProvider = ClosedEnum<typeof ImportFlowGitProvider>;

export type GitNamespaceId = string | number;

export type PreferredScopesAndGitNamespaces = {
  scopeId: string;
  gitNamespaceId: string | number | null;
};

export type Dismissals = {
  scopeId: string;
  createdAt: number;
};

/**
 * A record of when, under a certain scopeId, a toast was dismissed
 */
export type DismissedToasts = {
  name: string;
  dismissals: Array<Dismissals>;
};

/**
 * A list of projects and spaces across teams that a user has marked as a favorite.
 */
export type FavoriteProjectsAndSpaces = {
  teamId: string;
  projectId: string;
};

/**
 * remote caching settings
 */
export type AuthUserRemoteCaching = {
  enabled?: boolean | undefined;
};

/**
 * data cache settings
 */
export type DataCache = {
  excessBillingEnabled?: boolean | undefined;
};

export type WebAnalytics = {
  blockedFrom?: number | undefined;
  blockedUntil?: number | undefined;
  isCurrentlyBlocked: boolean;
};

/**
 * Feature blocks for the user
 */
export type FeatureBlocks = {
  webAnalytics?: WebAnalytics | undefined;
};

/**
 * Data for the currently authenticated User.
 */
export type AuthUser = {
  /**
   * UNIX timestamp (in milliseconds) when the User account was created.
   */
  createdAt: number;
  /**
   * When the User account has been "soft blocked", this property will contain the date when the restriction was enacted, and the identifier for why.
   */
  softBlock: SoftBlock | null;
  /**
   * An object containing billing infomation associated with the User account.
   */
  billing: Billing | null;
  /**
   * An object containing infomation related to the amount of platform resources may be allocated to the User account.
   */
  resourceConfig: AuthUserResourceConfig;
  /**
   * Prefix that will be used in the URL of "Preview" deployments created by the User account.
   */
  stagingPrefix: string;
  /**
   * set of dashboard view preferences (cards or list) per scopeId
   */
  activeDashboardViews?: Array<ActiveDashboardViews> | undefined;
  importFlowGitNamespace?: string | number | null | undefined;
  importFlowGitNamespaceId?: string | number | null | undefined;
  importFlowGitProvider?: ImportFlowGitProvider | null | undefined;
  preferredScopesAndGitNamespaces?:
    | Array<PreferredScopesAndGitNamespaces>
    | undefined;
  /**
   * A record of when, under a certain scopeId, a toast was dismissed
   */
  dismissedToasts?: Array<DismissedToasts> | undefined;
  /**
   * A list of projects and spaces across teams that a user has marked as a favorite.
   */
  favoriteProjectsAndSpaces?: Array<FavoriteProjectsAndSpaces> | undefined;
  /**
   * Whether the user has a trial available for a paid plan subscription.
   */
  hasTrialAvailable: boolean;
  /**
   * remote caching settings
   */
  remoteCaching?: AuthUserRemoteCaching | undefined;
  /**
   * data cache settings
   */
  dataCache?: DataCache | undefined;
  /**
   * Feature blocks for the user
   */
  featureBlocks?: FeatureBlocks | undefined;
  /**
   * The User's unique identifier.
   */
  id: string;
  /**
   * Email address associated with the User account.
   */
  email: string;
  /**
   * Name associated with the User account, or `null` if none has been provided.
   */
  name: string | null;
  /**
   * Unique username associated with the User account.
   */
  username: string;
  /**
   * SHA1 hash of the avatar for the User account. Can be used in conjuction with the ... endpoint to retrieve the avatar image.
   */
  avatar: string | null;
  /**
   * The user's default team.
   */
  defaultTeamId: string | null;
};

/** @internal */
export const Reason$inboundSchema: z.ZodNativeEnum<typeof Reason> = z
  .nativeEnum(Reason);
/** @internal */
export const Reason$outboundSchema: z.ZodNativeEnum<typeof Reason> =
  Reason$inboundSchema;

/** @internal */
export const BlockedDueToOverageType$inboundSchema: z.ZodNativeEnum<
  typeof BlockedDueToOverageType
> = z.nativeEnum(BlockedDueToOverageType);
/** @internal */
export const BlockedDueToOverageType$outboundSchema: z.ZodNativeEnum<
  typeof BlockedDueToOverageType
> = BlockedDueToOverageType$inboundSchema;

/** @internal */
export const SoftBlock$inboundSchema: z.ZodType<
  SoftBlock,
  z.ZodTypeDef,
  unknown
> = z.object({
  blockedAt: z.number(),
  reason: Reason$inboundSchema,
  blockedDueToOverageType: BlockedDueToOverageType$inboundSchema.optional(),
});
/** @internal */
export type SoftBlock$Outbound = {
  blockedAt: number;
  reason: string;
  blockedDueToOverageType?: string | undefined;
};

/** @internal */
export const SoftBlock$outboundSchema: z.ZodType<
  SoftBlock$Outbound,
  z.ZodTypeDef,
  SoftBlock
> = z.object({
  blockedAt: z.number(),
  reason: Reason$outboundSchema,
  blockedDueToOverageType: BlockedDueToOverageType$outboundSchema.optional(),
});

export function softBlockToJSON(softBlock: SoftBlock): string {
  return JSON.stringify(SoftBlock$outboundSchema.parse(softBlock));
}
export function softBlockFromJSON(
  jsonString: string,
): SafeParseResult<SoftBlock, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SoftBlock$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SoftBlock' from JSON`,
  );
}

/** @internal */
export const Billing$inboundSchema: z.ZodType<Billing, z.ZodTypeDef, unknown> =
  z.object({});
/** @internal */
export type Billing$Outbound = {};

/** @internal */
export const Billing$outboundSchema: z.ZodType<
  Billing$Outbound,
  z.ZodTypeDef,
  Billing
> = z.object({});

export function billingToJSON(billing: Billing): string {
  return JSON.stringify(Billing$outboundSchema.parse(billing));
}
export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const AuthUserBuildEntitlements$inboundSchema: z.ZodType<
  AuthUserBuildEntitlements,
  z.ZodTypeDef,
  unknown
> = z.object({
  enhancedBuilds: z.boolean().optional(),
});
/** @internal */
export type AuthUserBuildEntitlements$Outbound = {
  enhancedBuilds?: boolean | undefined;
};

/** @internal */
export const AuthUserBuildEntitlements$outboundSchema: z.ZodType<
  AuthUserBuildEntitlements$Outbound,
  z.ZodTypeDef,
  AuthUserBuildEntitlements
> = z.object({
  enhancedBuilds: z.boolean().optional(),
});

export function authUserBuildEntitlementsToJSON(
  authUserBuildEntitlements: AuthUserBuildEntitlements,
): string {
  return JSON.stringify(
    AuthUserBuildEntitlements$outboundSchema.parse(authUserBuildEntitlements),
  );
}
export function authUserBuildEntitlementsFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserBuildEntitlements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserBuildEntitlements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserBuildEntitlements' from JSON`,
  );
}

/** @internal */
export const AuthUserConfiguration$inboundSchema: z.ZodNativeEnum<
  typeof AuthUserConfiguration
> = z.nativeEnum(AuthUserConfiguration);
/** @internal */
export const AuthUserConfiguration$outboundSchema: z.ZodNativeEnum<
  typeof AuthUserConfiguration
> = AuthUserConfiguration$inboundSchema;

/** @internal */
export const BuildQueue$inboundSchema: z.ZodType<
  BuildQueue,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: AuthUserConfiguration$inboundSchema.optional(),
});
/** @internal */
export type BuildQueue$Outbound = {
  configuration?: string | undefined;
};

/** @internal */
export const BuildQueue$outboundSchema: z.ZodType<
  BuildQueue$Outbound,
  z.ZodTypeDef,
  BuildQueue
> = z.object({
  configuration: AuthUserConfiguration$outboundSchema.optional(),
});

export function buildQueueToJSON(buildQueue: BuildQueue): string {
  return JSON.stringify(BuildQueue$outboundSchema.parse(buildQueue));
}
export function buildQueueFromJSON(
  jsonString: string,
): SafeParseResult<BuildQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BuildQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BuildQueue' from JSON`,
  );
}

/** @internal */
export const PurchaseType$inboundSchema: z.ZodNativeEnum<typeof PurchaseType> =
  z.nativeEnum(PurchaseType);
/** @internal */
export const PurchaseType$outboundSchema: z.ZodNativeEnum<typeof PurchaseType> =
  PurchaseType$inboundSchema;

/** @internal */
export const BuildMachine$inboundSchema: z.ZodType<
  BuildMachine,
  z.ZodTypeDef,
  unknown
> = z.object({
  purchaseType: PurchaseType$inboundSchema.optional(),
  isDefaultBuildMachine: z.boolean().optional(),
  cores: z.number().optional(),
  memory: z.number().optional(),
});
/** @internal */
export type BuildMachine$Outbound = {
  purchaseType?: string | undefined;
  isDefaultBuildMachine?: boolean | undefined;
  cores?: number | undefined;
  memory?: number | undefined;
};

/** @internal */
export const BuildMachine$outboundSchema: z.ZodType<
  BuildMachine$Outbound,
  z.ZodTypeDef,
  BuildMachine
> = z.object({
  purchaseType: PurchaseType$outboundSchema.optional(),
  isDefaultBuildMachine: z.boolean().optional(),
  cores: z.number().optional(),
  memory: z.number().optional(),
});

export function buildMachineToJSON(buildMachine: BuildMachine): string {
  return JSON.stringify(BuildMachine$outboundSchema.parse(buildMachine));
}
export function buildMachineFromJSON(
  jsonString: string,
): SafeParseResult<BuildMachine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BuildMachine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BuildMachine' from JSON`,
  );
}

/** @internal */
export const AuthUserSecurity$inboundSchema: z.ZodType<
  AuthUserSecurity,
  z.ZodTypeDef,
  unknown
> = z.object({
  customRules: z.number().optional(),
  ipBlocks: z.number().optional(),
  ipBypass: z.number().optional(),
  rateLimit: z.number().optional(),
});
/** @internal */
export type AuthUserSecurity$Outbound = {
  customRules?: number | undefined;
  ipBlocks?: number | undefined;
  ipBypass?: number | undefined;
  rateLimit?: number | undefined;
};

/** @internal */
export const AuthUserSecurity$outboundSchema: z.ZodType<
  AuthUserSecurity$Outbound,
  z.ZodTypeDef,
  AuthUserSecurity
> = z.object({
  customRules: z.number().optional(),
  ipBlocks: z.number().optional(),
  ipBypass: z.number().optional(),
  rateLimit: z.number().optional(),
});

export function authUserSecurityToJSON(
  authUserSecurity: AuthUserSecurity,
): string {
  return JSON.stringify(
    AuthUserSecurity$outboundSchema.parse(authUserSecurity),
  );
}
export function authUserSecurityFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserSecurity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserSecurity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserSecurity' from JSON`,
  );
}

/** @internal */
export const AuthUserResourceConfig$inboundSchema: z.ZodType<
  AuthUserResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  nodeType: z.string().optional(),
  concurrentBuilds: z.number().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildEntitlements: z.lazy(() => AuthUserBuildEntitlements$inboundSchema)
    .optional(),
  buildQueue: z.lazy(() => BuildQueue$inboundSchema).optional(),
  awsAccountType: z.string().optional(),
  awsAccountIds: z.array(z.string()).optional(),
  cfZoneName: z.string().optional(),
  imageOptimizationType: z.string().optional(),
  edgeConfigs: z.number().optional(),
  edgeConfigSize: z.number().optional(),
  edgeFunctionMaxSizeBytes: z.number().optional(),
  edgeFunctionExecutionTimeoutMs: z.number().optional(),
  serverlessFunctionMaxMemorySize: z.number().optional(),
  kvDatabases: z.number().optional(),
  postgresDatabases: z.number().optional(),
  blobStores: z.number().optional(),
  integrationStores: z.number().optional(),
  cronJobs: z.number().optional(),
  cronJobsPerProject: z.number().optional(),
  microfrontendGroupsPerTeam: z.number().optional(),
  microfrontendProjectsPerGroup: z.number().optional(),
  flagsExplorerOverridesThreshold: z.number().optional(),
  flagsExplorerUnlimitedOverrides: z.boolean().optional(),
  customEnvironmentsPerProject: z.number().optional(),
  buildMachine: z.lazy(() => BuildMachine$inboundSchema).optional(),
  security: z.lazy(() => AuthUserSecurity$inboundSchema).optional(),
});
/** @internal */
export type AuthUserResourceConfig$Outbound = {
  nodeType?: string | undefined;
  concurrentBuilds?: number | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  buildEntitlements?: AuthUserBuildEntitlements$Outbound | undefined;
  buildQueue?: BuildQueue$Outbound | undefined;
  awsAccountType?: string | undefined;
  awsAccountIds?: Array<string> | undefined;
  cfZoneName?: string | undefined;
  imageOptimizationType?: string | undefined;
  edgeConfigs?: number | undefined;
  edgeConfigSize?: number | undefined;
  edgeFunctionMaxSizeBytes?: number | undefined;
  edgeFunctionExecutionTimeoutMs?: number | undefined;
  serverlessFunctionMaxMemorySize?: number | undefined;
  kvDatabases?: number | undefined;
  postgresDatabases?: number | undefined;
  blobStores?: number | undefined;
  integrationStores?: number | undefined;
  cronJobs?: number | undefined;
  cronJobsPerProject?: number | undefined;
  microfrontendGroupsPerTeam?: number | undefined;
  microfrontendProjectsPerGroup?: number | undefined;
  flagsExplorerOverridesThreshold?: number | undefined;
  flagsExplorerUnlimitedOverrides?: boolean | undefined;
  customEnvironmentsPerProject?: number | undefined;
  buildMachine?: BuildMachine$Outbound | undefined;
  security?: AuthUserSecurity$Outbound | undefined;
};

/** @internal */
export const AuthUserResourceConfig$outboundSchema: z.ZodType<
  AuthUserResourceConfig$Outbound,
  z.ZodTypeDef,
  AuthUserResourceConfig
> = z.object({
  nodeType: z.string().optional(),
  concurrentBuilds: z.number().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildEntitlements: z.lazy(() => AuthUserBuildEntitlements$outboundSchema)
    .optional(),
  buildQueue: z.lazy(() => BuildQueue$outboundSchema).optional(),
  awsAccountType: z.string().optional(),
  awsAccountIds: z.array(z.string()).optional(),
  cfZoneName: z.string().optional(),
  imageOptimizationType: z.string().optional(),
  edgeConfigs: z.number().optional(),
  edgeConfigSize: z.number().optional(),
  edgeFunctionMaxSizeBytes: z.number().optional(),
  edgeFunctionExecutionTimeoutMs: z.number().optional(),
  serverlessFunctionMaxMemorySize: z.number().optional(),
  kvDatabases: z.number().optional(),
  postgresDatabases: z.number().optional(),
  blobStores: z.number().optional(),
  integrationStores: z.number().optional(),
  cronJobs: z.number().optional(),
  cronJobsPerProject: z.number().optional(),
  microfrontendGroupsPerTeam: z.number().optional(),
  microfrontendProjectsPerGroup: z.number().optional(),
  flagsExplorerOverridesThreshold: z.number().optional(),
  flagsExplorerUnlimitedOverrides: z.boolean().optional(),
  customEnvironmentsPerProject: z.number().optional(),
  buildMachine: z.lazy(() => BuildMachine$outboundSchema).optional(),
  security: z.lazy(() => AuthUserSecurity$outboundSchema).optional(),
});

export function authUserResourceConfigToJSON(
  authUserResourceConfig: AuthUserResourceConfig,
): string {
  return JSON.stringify(
    AuthUserResourceConfig$outboundSchema.parse(authUserResourceConfig),
  );
}
export function authUserResourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserResourceConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserResourceConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserResourceConfig' from JSON`,
  );
}

/** @internal */
export const ViewPreference$inboundSchema: z.ZodNativeEnum<
  typeof ViewPreference
> = z.nativeEnum(ViewPreference);
/** @internal */
export const ViewPreference$outboundSchema: z.ZodNativeEnum<
  typeof ViewPreference
> = ViewPreference$inboundSchema;

/** @internal */
export const FavoritesViewPreference$inboundSchema: z.ZodNativeEnum<
  typeof FavoritesViewPreference
> = z.nativeEnum(FavoritesViewPreference);
/** @internal */
export const FavoritesViewPreference$outboundSchema: z.ZodNativeEnum<
  typeof FavoritesViewPreference
> = FavoritesViewPreference$inboundSchema;

/** @internal */
export const RecentsViewPreference$inboundSchema: z.ZodNativeEnum<
  typeof RecentsViewPreference
> = z.nativeEnum(RecentsViewPreference);
/** @internal */
export const RecentsViewPreference$outboundSchema: z.ZodNativeEnum<
  typeof RecentsViewPreference
> = RecentsViewPreference$inboundSchema;

/** @internal */
export const ActiveDashboardViews$inboundSchema: z.ZodType<
  ActiveDashboardViews,
  z.ZodTypeDef,
  unknown
> = z.object({
  scopeId: z.string(),
  viewPreference: z.nullable(ViewPreference$inboundSchema).optional(),
  favoritesViewPreference: z.nullable(FavoritesViewPreference$inboundSchema)
    .optional(),
  recentsViewPreference: z.nullable(RecentsViewPreference$inboundSchema)
    .optional(),
});
/** @internal */
export type ActiveDashboardViews$Outbound = {
  scopeId: string;
  viewPreference?: string | null | undefined;
  favoritesViewPreference?: string | null | undefined;
  recentsViewPreference?: string | null | undefined;
};

/** @internal */
export const ActiveDashboardViews$outboundSchema: z.ZodType<
  ActiveDashboardViews$Outbound,
  z.ZodTypeDef,
  ActiveDashboardViews
> = z.object({
  scopeId: z.string(),
  viewPreference: z.nullable(ViewPreference$outboundSchema).optional(),
  favoritesViewPreference: z.nullable(FavoritesViewPreference$outboundSchema)
    .optional(),
  recentsViewPreference: z.nullable(RecentsViewPreference$outboundSchema)
    .optional(),
});

export function activeDashboardViewsToJSON(
  activeDashboardViews: ActiveDashboardViews,
): string {
  return JSON.stringify(
    ActiveDashboardViews$outboundSchema.parse(activeDashboardViews),
  );
}
export function activeDashboardViewsFromJSON(
  jsonString: string,
): SafeParseResult<ActiveDashboardViews, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ActiveDashboardViews$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActiveDashboardViews' from JSON`,
  );
}

/** @internal */
export const ImportFlowGitNamespace$inboundSchema: z.ZodType<
  ImportFlowGitNamespace,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number()]);
/** @internal */
export type ImportFlowGitNamespace$Outbound = string | number;

/** @internal */
export const ImportFlowGitNamespace$outboundSchema: z.ZodType<
  ImportFlowGitNamespace$Outbound,
  z.ZodTypeDef,
  ImportFlowGitNamespace
> = z.union([z.string(), z.number()]);

export function importFlowGitNamespaceToJSON(
  importFlowGitNamespace: ImportFlowGitNamespace,
): string {
  return JSON.stringify(
    ImportFlowGitNamespace$outboundSchema.parse(importFlowGitNamespace),
  );
}
export function importFlowGitNamespaceFromJSON(
  jsonString: string,
): SafeParseResult<ImportFlowGitNamespace, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImportFlowGitNamespace$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImportFlowGitNamespace' from JSON`,
  );
}

/** @internal */
export const ImportFlowGitNamespaceId$inboundSchema: z.ZodType<
  ImportFlowGitNamespaceId,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number()]);
/** @internal */
export type ImportFlowGitNamespaceId$Outbound = string | number;

/** @internal */
export const ImportFlowGitNamespaceId$outboundSchema: z.ZodType<
  ImportFlowGitNamespaceId$Outbound,
  z.ZodTypeDef,
  ImportFlowGitNamespaceId
> = z.union([z.string(), z.number()]);

export function importFlowGitNamespaceIdToJSON(
  importFlowGitNamespaceId: ImportFlowGitNamespaceId,
): string {
  return JSON.stringify(
    ImportFlowGitNamespaceId$outboundSchema.parse(importFlowGitNamespaceId),
  );
}
export function importFlowGitNamespaceIdFromJSON(
  jsonString: string,
): SafeParseResult<ImportFlowGitNamespaceId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImportFlowGitNamespaceId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImportFlowGitNamespaceId' from JSON`,
  );
}

/** @internal */
export const ImportFlowGitProvider$inboundSchema: z.ZodNativeEnum<
  typeof ImportFlowGitProvider
> = z.nativeEnum(ImportFlowGitProvider);
/** @internal */
export const ImportFlowGitProvider$outboundSchema: z.ZodNativeEnum<
  typeof ImportFlowGitProvider
> = ImportFlowGitProvider$inboundSchema;

/** @internal */
export const GitNamespaceId$inboundSchema: z.ZodType<
  GitNamespaceId,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number()]);
/** @internal */
export type GitNamespaceId$Outbound = string | number;

/** @internal */
export const GitNamespaceId$outboundSchema: z.ZodType<
  GitNamespaceId$Outbound,
  z.ZodTypeDef,
  GitNamespaceId
> = z.union([z.string(), z.number()]);

export function gitNamespaceIdToJSON(gitNamespaceId: GitNamespaceId): string {
  return JSON.stringify(GitNamespaceId$outboundSchema.parse(gitNamespaceId));
}
export function gitNamespaceIdFromJSON(
  jsonString: string,
): SafeParseResult<GitNamespaceId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitNamespaceId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitNamespaceId' from JSON`,
  );
}

/** @internal */
export const PreferredScopesAndGitNamespaces$inboundSchema: z.ZodType<
  PreferredScopesAndGitNamespaces,
  z.ZodTypeDef,
  unknown
> = z.object({
  scopeId: z.string(),
  gitNamespaceId: z.nullable(z.union([z.string(), z.number()])),
});
/** @internal */
export type PreferredScopesAndGitNamespaces$Outbound = {
  scopeId: string;
  gitNamespaceId: string | number | null;
};

/** @internal */
export const PreferredScopesAndGitNamespaces$outboundSchema: z.ZodType<
  PreferredScopesAndGitNamespaces$Outbound,
  z.ZodTypeDef,
  PreferredScopesAndGitNamespaces
> = z.object({
  scopeId: z.string(),
  gitNamespaceId: z.nullable(z.union([z.string(), z.number()])),
});

export function preferredScopesAndGitNamespacesToJSON(
  preferredScopesAndGitNamespaces: PreferredScopesAndGitNamespaces,
): string {
  return JSON.stringify(
    PreferredScopesAndGitNamespaces$outboundSchema.parse(
      preferredScopesAndGitNamespaces,
    ),
  );
}
export function preferredScopesAndGitNamespacesFromJSON(
  jsonString: string,
): SafeParseResult<PreferredScopesAndGitNamespaces, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PreferredScopesAndGitNamespaces$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PreferredScopesAndGitNamespaces' from JSON`,
  );
}

/** @internal */
export const Dismissals$inboundSchema: z.ZodType<
  Dismissals,
  z.ZodTypeDef,
  unknown
> = z.object({
  scopeId: z.string(),
  createdAt: z.number(),
});
/** @internal */
export type Dismissals$Outbound = {
  scopeId: string;
  createdAt: number;
};

/** @internal */
export const Dismissals$outboundSchema: z.ZodType<
  Dismissals$Outbound,
  z.ZodTypeDef,
  Dismissals
> = z.object({
  scopeId: z.string(),
  createdAt: z.number(),
});

export function dismissalsToJSON(dismissals: Dismissals): string {
  return JSON.stringify(Dismissals$outboundSchema.parse(dismissals));
}
export function dismissalsFromJSON(
  jsonString: string,
): SafeParseResult<Dismissals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Dismissals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Dismissals' from JSON`,
  );
}

/** @internal */
export const DismissedToasts$inboundSchema: z.ZodType<
  DismissedToasts,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  dismissals: z.array(z.lazy(() => Dismissals$inboundSchema)),
});
/** @internal */
export type DismissedToasts$Outbound = {
  name: string;
  dismissals: Array<Dismissals$Outbound>;
};

/** @internal */
export const DismissedToasts$outboundSchema: z.ZodType<
  DismissedToasts$Outbound,
  z.ZodTypeDef,
  DismissedToasts
> = z.object({
  name: z.string(),
  dismissals: z.array(z.lazy(() => Dismissals$outboundSchema)),
});

export function dismissedToastsToJSON(
  dismissedToasts: DismissedToasts,
): string {
  return JSON.stringify(DismissedToasts$outboundSchema.parse(dismissedToasts));
}
export function dismissedToastsFromJSON(
  jsonString: string,
): SafeParseResult<DismissedToasts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DismissedToasts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DismissedToasts' from JSON`,
  );
}

/** @internal */
export const FavoriteProjectsAndSpaces$inboundSchema: z.ZodType<
  FavoriteProjectsAndSpaces,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamId: z.string(),
  projectId: z.string(),
});
/** @internal */
export type FavoriteProjectsAndSpaces$Outbound = {
  teamId: string;
  projectId: string;
};

/** @internal */
export const FavoriteProjectsAndSpaces$outboundSchema: z.ZodType<
  FavoriteProjectsAndSpaces$Outbound,
  z.ZodTypeDef,
  FavoriteProjectsAndSpaces
> = z.object({
  teamId: z.string(),
  projectId: z.string(),
});

export function favoriteProjectsAndSpacesToJSON(
  favoriteProjectsAndSpaces: FavoriteProjectsAndSpaces,
): string {
  return JSON.stringify(
    FavoriteProjectsAndSpaces$outboundSchema.parse(favoriteProjectsAndSpaces),
  );
}
export function favoriteProjectsAndSpacesFromJSON(
  jsonString: string,
): SafeParseResult<FavoriteProjectsAndSpaces, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FavoriteProjectsAndSpaces$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FavoriteProjectsAndSpaces' from JSON`,
  );
}

/** @internal */
export const AuthUserRemoteCaching$inboundSchema: z.ZodType<
  AuthUserRemoteCaching,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type AuthUserRemoteCaching$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const AuthUserRemoteCaching$outboundSchema: z.ZodType<
  AuthUserRemoteCaching$Outbound,
  z.ZodTypeDef,
  AuthUserRemoteCaching
> = z.object({
  enabled: z.boolean().optional(),
});

export function authUserRemoteCachingToJSON(
  authUserRemoteCaching: AuthUserRemoteCaching,
): string {
  return JSON.stringify(
    AuthUserRemoteCaching$outboundSchema.parse(authUserRemoteCaching),
  );
}
export function authUserRemoteCachingFromJSON(
  jsonString: string,
): SafeParseResult<AuthUserRemoteCaching, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUserRemoteCaching$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUserRemoteCaching' from JSON`,
  );
}

/** @internal */
export const DataCache$inboundSchema: z.ZodType<
  DataCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  excessBillingEnabled: z.boolean().optional(),
});
/** @internal */
export type DataCache$Outbound = {
  excessBillingEnabled?: boolean | undefined;
};

/** @internal */
export const DataCache$outboundSchema: z.ZodType<
  DataCache$Outbound,
  z.ZodTypeDef,
  DataCache
> = z.object({
  excessBillingEnabled: z.boolean().optional(),
});

export function dataCacheToJSON(dataCache: DataCache): string {
  return JSON.stringify(DataCache$outboundSchema.parse(dataCache));
}
export function dataCacheFromJSON(
  jsonString: string,
): SafeParseResult<DataCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCache' from JSON`,
  );
}

/** @internal */
export const WebAnalytics$inboundSchema: z.ZodType<
  WebAnalytics,
  z.ZodTypeDef,
  unknown
> = z.object({
  blockedFrom: z.number().optional(),
  blockedUntil: z.number().optional(),
  isCurrentlyBlocked: z.boolean(),
});
/** @internal */
export type WebAnalytics$Outbound = {
  blockedFrom?: number | undefined;
  blockedUntil?: number | undefined;
  isCurrentlyBlocked: boolean;
};

/** @internal */
export const WebAnalytics$outboundSchema: z.ZodType<
  WebAnalytics$Outbound,
  z.ZodTypeDef,
  WebAnalytics
> = z.object({
  blockedFrom: z.number().optional(),
  blockedUntil: z.number().optional(),
  isCurrentlyBlocked: z.boolean(),
});

export function webAnalyticsToJSON(webAnalytics: WebAnalytics): string {
  return JSON.stringify(WebAnalytics$outboundSchema.parse(webAnalytics));
}
export function webAnalyticsFromJSON(
  jsonString: string,
): SafeParseResult<WebAnalytics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebAnalytics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebAnalytics' from JSON`,
  );
}

/** @internal */
export const FeatureBlocks$inboundSchema: z.ZodType<
  FeatureBlocks,
  z.ZodTypeDef,
  unknown
> = z.object({
  webAnalytics: z.lazy(() => WebAnalytics$inboundSchema).optional(),
});
/** @internal */
export type FeatureBlocks$Outbound = {
  webAnalytics?: WebAnalytics$Outbound | undefined;
};

/** @internal */
export const FeatureBlocks$outboundSchema: z.ZodType<
  FeatureBlocks$Outbound,
  z.ZodTypeDef,
  FeatureBlocks
> = z.object({
  webAnalytics: z.lazy(() => WebAnalytics$outboundSchema).optional(),
});

export function featureBlocksToJSON(featureBlocks: FeatureBlocks): string {
  return JSON.stringify(FeatureBlocks$outboundSchema.parse(featureBlocks));
}
export function featureBlocksFromJSON(
  jsonString: string,
): SafeParseResult<FeatureBlocks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FeatureBlocks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FeatureBlocks' from JSON`,
  );
}

/** @internal */
export const AuthUser$inboundSchema: z.ZodType<
  AuthUser,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number(),
  softBlock: z.nullable(z.lazy(() => SoftBlock$inboundSchema)),
  billing: z.nullable(z.lazy(() => Billing$inboundSchema)),
  resourceConfig: z.lazy(() => AuthUserResourceConfig$inboundSchema),
  stagingPrefix: z.string(),
  activeDashboardViews: z.array(
    z.lazy(() => ActiveDashboardViews$inboundSchema),
  ).optional(),
  importFlowGitNamespace: z.nullable(z.union([z.string(), z.number()]))
    .optional(),
  importFlowGitNamespaceId: z.nullable(z.union([z.string(), z.number()]))
    .optional(),
  importFlowGitProvider: z.nullable(ImportFlowGitProvider$inboundSchema)
    .optional(),
  preferredScopesAndGitNamespaces: z.array(
    z.lazy(() => PreferredScopesAndGitNamespaces$inboundSchema),
  ).optional(),
  dismissedToasts: z.array(z.lazy(() => DismissedToasts$inboundSchema))
    .optional(),
  favoriteProjectsAndSpaces: z.array(
    z.lazy(() => FavoriteProjectsAndSpaces$inboundSchema),
  ).optional(),
  hasTrialAvailable: z.boolean(),
  remoteCaching: z.lazy(() => AuthUserRemoteCaching$inboundSchema).optional(),
  dataCache: z.lazy(() => DataCache$inboundSchema).optional(),
  featureBlocks: z.lazy(() => FeatureBlocks$inboundSchema).optional(),
  id: z.string(),
  email: z.string(),
  name: z.nullable(z.string()),
  username: z.string(),
  avatar: z.nullable(z.string()),
  defaultTeamId: z.nullable(z.string()),
});
/** @internal */
export type AuthUser$Outbound = {
  createdAt: number;
  softBlock: SoftBlock$Outbound | null;
  billing: Billing$Outbound | null;
  resourceConfig: AuthUserResourceConfig$Outbound;
  stagingPrefix: string;
  activeDashboardViews?: Array<ActiveDashboardViews$Outbound> | undefined;
  importFlowGitNamespace?: string | number | null | undefined;
  importFlowGitNamespaceId?: string | number | null | undefined;
  importFlowGitProvider?: string | null | undefined;
  preferredScopesAndGitNamespaces?:
    | Array<PreferredScopesAndGitNamespaces$Outbound>
    | undefined;
  dismissedToasts?: Array<DismissedToasts$Outbound> | undefined;
  favoriteProjectsAndSpaces?:
    | Array<FavoriteProjectsAndSpaces$Outbound>
    | undefined;
  hasTrialAvailable: boolean;
  remoteCaching?: AuthUserRemoteCaching$Outbound | undefined;
  dataCache?: DataCache$Outbound | undefined;
  featureBlocks?: FeatureBlocks$Outbound | undefined;
  id: string;
  email: string;
  name: string | null;
  username: string;
  avatar: string | null;
  defaultTeamId: string | null;
};

/** @internal */
export const AuthUser$outboundSchema: z.ZodType<
  AuthUser$Outbound,
  z.ZodTypeDef,
  AuthUser
> = z.object({
  createdAt: z.number(),
  softBlock: z.nullable(z.lazy(() => SoftBlock$outboundSchema)),
  billing: z.nullable(z.lazy(() => Billing$outboundSchema)),
  resourceConfig: z.lazy(() => AuthUserResourceConfig$outboundSchema),
  stagingPrefix: z.string(),
  activeDashboardViews: z.array(
    z.lazy(() => ActiveDashboardViews$outboundSchema),
  ).optional(),
  importFlowGitNamespace: z.nullable(z.union([z.string(), z.number()]))
    .optional(),
  importFlowGitNamespaceId: z.nullable(z.union([z.string(), z.number()]))
    .optional(),
  importFlowGitProvider: z.nullable(ImportFlowGitProvider$outboundSchema)
    .optional(),
  preferredScopesAndGitNamespaces: z.array(
    z.lazy(() => PreferredScopesAndGitNamespaces$outboundSchema),
  ).optional(),
  dismissedToasts: z.array(z.lazy(() => DismissedToasts$outboundSchema))
    .optional(),
  favoriteProjectsAndSpaces: z.array(
    z.lazy(() => FavoriteProjectsAndSpaces$outboundSchema),
  ).optional(),
  hasTrialAvailable: z.boolean(),
  remoteCaching: z.lazy(() => AuthUserRemoteCaching$outboundSchema).optional(),
  dataCache: z.lazy(() => DataCache$outboundSchema).optional(),
  featureBlocks: z.lazy(() => FeatureBlocks$outboundSchema).optional(),
  id: z.string(),
  email: z.string(),
  name: z.nullable(z.string()),
  username: z.string(),
  avatar: z.nullable(z.string()),
  defaultTeamId: z.nullable(z.string()),
});

export function authUserToJSON(authUser: AuthUser): string {
  return JSON.stringify(AuthUser$outboundSchema.parse(authUser));
}
export function authUserFromJSON(
  jsonString: string,
): SafeParseResult<AuthUser, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AuthUser$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AuthUser' from JSON`,
  );
}
