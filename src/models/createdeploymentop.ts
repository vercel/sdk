/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  FlagJSONValue,
  FlagJSONValue$inboundSchema,
  FlagJSONValue$Outbound,
  FlagJSONValue$outboundSchema,
} from "./flagjsonvalue.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * Forces a new deployment even if there is a previous similar deployment
 */
export const ForceNew = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Forces a new deployment even if there is a previous similar deployment
 */
export type ForceNew = ClosedEnum<typeof ForceNew>;

/**
 * Allows to skip framework detection so the API would not fail to ask for confirmation
 */
export const SkipAutoDetectionConfirmation = {
  Zero: "0",
  One: "1",
} as const;
/**
 * Allows to skip framework detection so the API would not fail to ask for confirmation
 */
export type SkipAutoDetectionConfirmation = ClosedEnum<
  typeof SkipAutoDetectionConfirmation
>;

/**
 * Used in the case you want to reference a file that was already uploaded
 */
export type UploadedFile = {
  /**
   * The file path relative to the project root
   */
  file: string;
  /**
   * The file contents hashed with SHA1, used to check the integrity
   */
  sha?: string | undefined;
  /**
   * The file size in bytes
   */
  size?: number | undefined;
};

/**
 * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
 */
export const Encoding = {
  Base64: "base64",
  Utf8: "utf-8",
} as const;
/**
 * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
 */
export type Encoding = ClosedEnum<typeof Encoding>;

/**
 * Used in the case you want to inline a file inside the request
 */
export type InlinedFile = {
  /**
   * The file content, it could be either a `base64` (useful for images, etc.) of the files or the plain content for source code
   */
  data: string;
  /**
   * The file content encoding, it could be either a base64 (useful for images, etc.) of the files or the plain text for source code.
   */
  encoding?: Encoding | undefined;
  /**
   * The file name including the whole path
   */
  file: string;
};

export type Files = InlinedFile | UploadedFile;

/**
 * Populates initial git metadata for different git providers.
 */
export type GitMetadata = {
  /**
   * The git repository's remote origin url
   */
  remoteUrl?: string | undefined;
  /**
   * The name of the author of the commit
   */
  commitAuthorName?: string | undefined;
  /**
   * The email of the author of the commit
   */
  commitAuthorEmail?: string | undefined;
  /**
   * The commit message
   */
  commitMessage?: string | undefined;
  /**
   * The branch on which the commit was made
   */
  commitRef?: string | undefined;
  /**
   * The hash of the commit
   */
  commitSha?: string | undefined;
  /**
   * Whether or not there have been modifications to the working tree since the latest commit
   */
  dirty?: boolean | undefined;
  /**
   * True if process.env.CI was set when deploying
   */
  ci?: boolean | undefined;
  /**
   * The type of CI system used
   */
  ciType?: string | undefined;
  /**
   * The username used for the Git Provider (e.g. GitHub) if their CI (e.g. GitHub Actions) was used, if available
   */
  ciGitProviderUsername?: string | undefined;
  /**
   * The visibility of the Git repository if their CI (e.g. GitHub Actions) was used, if available
   */
  ciGitRepoVisibility?: string | undefined;
};

export const CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type = {
  Bitbucket: "bitbucket",
} as const;
export type CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type
  >;

export type GitSource7 = {
  owner: string;
  ref: string;
  sha?: string | undefined;
  slug: string;
  type: CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type;
};

export const CreateDeploymentGitSourceDeploymentsRequestRequestBodyType = {
  Bitbucket: "bitbucket",
} as const;
export type CreateDeploymentGitSourceDeploymentsRequestRequestBodyType =
  ClosedEnum<typeof CreateDeploymentGitSourceDeploymentsRequestRequestBodyType>;

export type GitSource6 = {
  ref: string;
  repoUuid: string;
  sha?: string | undefined;
  type: CreateDeploymentGitSourceDeploymentsRequestRequestBodyType;
  workspaceUuid?: string | undefined;
};

export type ProjectId = number | string;

export const CreateDeploymentGitSourceDeploymentsRequestType = {
  Gitlab: "gitlab",
} as const;
export type CreateDeploymentGitSourceDeploymentsRequestType = ClosedEnum<
  typeof CreateDeploymentGitSourceDeploymentsRequestType
>;

export type GitSource5 = {
  projectId: number | string;
  ref: string;
  sha?: string | undefined;
  type: CreateDeploymentGitSourceDeploymentsRequestType;
};

export const CreateDeploymentGitSourceDeploymentsType = {
  GithubLimited: "github-limited",
} as const;
export type CreateDeploymentGitSourceDeploymentsType = ClosedEnum<
  typeof CreateDeploymentGitSourceDeploymentsType
>;

export type GitSource4 = {
  org: string;
  ref: string;
  repo: string;
  sha?: string | undefined;
  type: CreateDeploymentGitSourceDeploymentsType;
};

export type GitSourceRepoId = number | string;

export const CreateDeploymentGitSourceType = {
  GithubLimited: "github-limited",
} as const;
export type CreateDeploymentGitSourceType = ClosedEnum<
  typeof CreateDeploymentGitSourceType
>;

export type GitSource3 = {
  ref: string;
  repoId: number | string;
  sha?: string | undefined;
  type: CreateDeploymentGitSourceType;
};

export const GitSourceType = {
  Github: "github",
} as const;
export type GitSourceType = ClosedEnum<typeof GitSourceType>;

export type GitSource2 = {
  org: string;
  ref: string;
  repo: string;
  sha?: string | undefined;
  type: GitSourceType;
};

export type RepoId = number | string;

export const CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type = {
  Github: "github",
} as const;
export type CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type
  >;

export type GitSource1 = {
  ref: string;
  repoId: number | string;
  sha?: string | undefined;
  type: CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type;
};

/**
 * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
 */
export type GitSource =
  | GitSource2
  | GitSource4
  | GitSource7
  | GitSource1
  | GitSource3
  | GitSource5
  | GitSource6;

/**
 * The framework that is being used for this project. When `null` is used no framework is selected
 */
export const Framework = {
  Blitzjs: "blitzjs",
  Nextjs: "nextjs",
  Gatsby: "gatsby",
  Remix: "remix",
  ReactRouter: "react-router",
  Astro: "astro",
  Hexo: "hexo",
  Eleventy: "eleventy",
  Docusaurus2: "docusaurus-2",
  Docusaurus: "docusaurus",
  Preact: "preact",
  Solidstart1: "solidstart-1",
  Solidstart: "solidstart",
  Dojo: "dojo",
  Ember: "ember",
  Vue: "vue",
  Scully: "scully",
  IonicAngular: "ionic-angular",
  Angular: "angular",
  Polymer: "polymer",
  Svelte: "svelte",
  Sveltekit: "sveltekit",
  Sveltekit1: "sveltekit-1",
  IonicReact: "ionic-react",
  CreateReactApp: "create-react-app",
  Gridsome: "gridsome",
  Umijs: "umijs",
  Sapper: "sapper",
  Saber: "saber",
  Stencil: "stencil",
  Nuxtjs: "nuxtjs",
  Redwoodjs: "redwoodjs",
  Hugo: "hugo",
  Jekyll: "jekyll",
  Brunch: "brunch",
  Middleman: "middleman",
  Zola: "zola",
  Hydrogen: "hydrogen",
  Vite: "vite",
  TanstackStart: "tanstack-start",
  Vitepress: "vitepress",
  Vuepress: "vuepress",
  Parcel: "parcel",
  Fastapi: "fastapi",
  Flask: "flask",
  Fasthtml: "fasthtml",
  SanityV3: "sanity-v3",
  Sanity: "sanity",
  Storybook: "storybook",
  Nitro: "nitro",
  Hono: "hono",
  Express: "express",
  H3: "h3",
  Koa: "koa",
  Nestjs: "nestjs",
  Elysia: "elysia",
  Fastify: "fastify",
  Xmcp: "xmcp",
  Python: "python",
  Ruby: "ruby",
  Rust: "rust",
  Node: "node",
  Services: "services",
} as const;
/**
 * The framework that is being used for this project. When `null` is used no framework is selected
 */
export type Framework = ClosedEnum<typeof Framework>;

/**
 * Override the Node.js version that should be used for this deployment
 */
export const NodeVersion = {
  TwentyFourDotX: "24.x",
  TwentyTwoDotX: "22.x",
  TwentyDotX: "20.x",
  EighteenDotX: "18.x",
  SixteenDotX: "16.x",
  FourteenDotX: "14.x",
  TwelveDotX: "12.x",
  TenDotX: "10.x",
  EightDot10DotX: "8.10.x",
} as const;
/**
 * Override the Node.js version that should be used for this deployment
 */
export type NodeVersion = ClosedEnum<typeof NodeVersion>;

/**
 * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
 */
export type ProjectSettings = {
  /**
   * The build command for this project. When `null` is used this value will be automatically detected
   */
  buildCommand?: string | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  /**
   * The dev command for this project. When `null` is used this value will be automatically detected
   */
  devCommand?: string | null | undefined;
  /**
   * The framework that is being used for this project. When `null` is used no framework is selected
   */
  framework?: Framework | null | undefined;
  /**
   * The install command for this project. When `null` is used this value will be automatically detected
   */
  installCommand?: string | null | undefined;
  /**
   * Override the Node.js version that should be used for this deployment
   */
  nodeVersion?: NodeVersion | undefined;
  /**
   * The output directory of the project. When `null` is used this value will be automatically detected
   */
  outputDirectory?: string | null | undefined;
  /**
   * The name of a directory or relative path to the source code of your project. When `null` is used it will default to the project root
   */
  rootDirectory?: string | null | undefined;
  /**
   * The region to deploy Serverless Functions in this project
   */
  serverlessFunctionRegion?: string | null | undefined;
  /**
   * Opts-out of the message prompting a CLI user to connect a Git repository in `vercel link`.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  skipGitConnectDuringLink?: boolean | undefined;
  /**
   * Indicates if there are source files outside of the root directory, typically used for monorepos
   */
  sourceFilesOutsideRootDirectory?: boolean | undefined;
};

export type CreateDeploymentRequestBody = {
  /**
   * Deploy to a custom environment, which will override the default environment
   */
  customEnvironmentSlugOrId?: string | undefined;
  /**
   * An deployment id for an existing deployment to redeploy
   */
  deploymentId?: string | undefined;
  /**
   * A list of objects with the files to be deployed
   */
  files?: Array<InlinedFile | UploadedFile> | undefined;
  /**
   * Populates initial git metadata for different git providers.
   */
  gitMetadata?: GitMetadata | undefined;
  /**
   * Defines the Git Repository source to be deployed. This property can not be used in combination with `files`.
   */
  gitSource?:
    | GitSource2
    | GitSource4
    | GitSource7
    | GitSource1
    | GitSource3
    | GitSource5
    | GitSource6
    | undefined;
  /**
   * An object containing the deployment's metadata. Multiple key-value pairs can be attached to a deployment
   */
  meta?: { [k: string]: string } | undefined;
  /**
   * The monorepo manager that is being used for this deployment. When `null` is used no monorepo manager is selected
   */
  monorepoManager?: string | null | undefined;
  /**
   * A string with the project name used in the deployment URL
   */
  name: string;
  /**
   * The target project identifier in which the deployment will be created. When defined, this parameter overrides name
   */
  project?: string | undefined;
  /**
   * Project settings that will be applied to the deployment. It is required for the first deployment of a project and will be saved for any following deployments
   */
  projectSettings?: ProjectSettings | undefined;
  /**
   * Either not defined, `staging`, `production`, or a custom environment identifier. If `staging`, a staging alias in the format `<project>-<team>.vercel.app` will be assigned. If `production`, any aliases defined in `alias` will be assigned. If omitted, the target will be `preview`.
   */
  target?: string | undefined;
  /**
   * When `true` and `deploymentId` is passed in, the sha from the previous deployment's `gitSource` is removed forcing the latest commit to be used.
   */
  withLatestCommit?: boolean | undefined;
};

export type CreateDeploymentRequest = {
  /**
   * Forces a new deployment even if there is a previous similar deployment
   */
  forceNew?: ForceNew | undefined;
  /**
   * Allows to skip framework detection so the API would not fail to ask for confirmation
   */
  skipAutoDetectionConfirmation?: SkipAutoDetectionConfirmation | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody: CreateDeploymentRequestBody;
};

export type AliasAssignedAt = number | boolean;

export type Build = {
  env: Array<string>;
};

export type Builds = {
  use: string;
  src?: string | undefined;
  config?: { [k: string]: any } | undefined;
};

export const CreateDeploymentDeploymentsNodeVersion = {
  TwentyFourDotX: "24.x",
  TwentyTwoDotX: "22.x",
  TwentyDotX: "20.x",
  EighteenDotX: "18.x",
  SixteenDotX: "16.x",
  FourteenDotX: "14.x",
  TwelveDotX: "12.x",
  TenDotX: "10.x",
  EightDot10DotX: "8.10.x",
} as const;
export type CreateDeploymentDeploymentsNodeVersion = ClosedEnum<
  typeof CreateDeploymentDeploymentsNodeVersion
>;

export const CreateDeploymentFramework = {
  Blitzjs: "blitzjs",
  Nextjs: "nextjs",
  Gatsby: "gatsby",
  Remix: "remix",
  ReactRouter: "react-router",
  Astro: "astro",
  Hexo: "hexo",
  Eleventy: "eleventy",
  Docusaurus2: "docusaurus-2",
  Docusaurus: "docusaurus",
  Preact: "preact",
  Solidstart1: "solidstart-1",
  Solidstart: "solidstart",
  Dojo: "dojo",
  Ember: "ember",
  Vue: "vue",
  Scully: "scully",
  IonicAngular: "ionic-angular",
  Angular: "angular",
  Polymer: "polymer",
  Svelte: "svelte",
  Sveltekit: "sveltekit",
  Sveltekit1: "sveltekit-1",
  IonicReact: "ionic-react",
  CreateReactApp: "create-react-app",
  Gridsome: "gridsome",
  Umijs: "umijs",
  Sapper: "sapper",
  Saber: "saber",
  Stencil: "stencil",
  Nuxtjs: "nuxtjs",
  Redwoodjs: "redwoodjs",
  Hugo: "hugo",
  Jekyll: "jekyll",
  Brunch: "brunch",
  Middleman: "middleman",
  Zola: "zola",
  Hydrogen: "hydrogen",
  Vite: "vite",
  TanstackStart: "tanstack-start",
  Vitepress: "vitepress",
  Vuepress: "vuepress",
  Parcel: "parcel",
  Fastapi: "fastapi",
  Flask: "flask",
  Fasthtml: "fasthtml",
  SanityV3: "sanity-v3",
  Sanity: "sanity",
  Storybook: "storybook",
  Nitro: "nitro",
  Hono: "hono",
  Express: "express",
  H3: "h3",
  Koa: "koa",
  Nestjs: "nestjs",
  Elysia: "elysia",
  Fastify: "fastify",
  Xmcp: "xmcp",
  Python: "python",
  Ruby: "ruby",
  Rust: "rust",
  Node: "node",
  Services: "services",
} as const;
export type CreateDeploymentFramework = ClosedEnum<
  typeof CreateDeploymentFramework
>;

export type CreateDeploymentSpeedInsights = {
  id: string;
  enabledAt?: number | undefined;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  hasData?: boolean | undefined;
  paidAt?: number | undefined;
};

export type CreateDeploymentWebAnalytics = {
  id: string;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  enabledAt?: number | undefined;
  hasData?: boolean | undefined;
};

export type CreateDeploymentProjectSettings = {
  nodeVersion?: CreateDeploymentDeploymentsNodeVersion | undefined;
  buildCommand?: string | null | undefined;
  devCommand?: string | null | undefined;
  framework?: CreateDeploymentFramework | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  installCommand?: string | null | undefined;
  outputDirectory?: string | null | undefined;
  speedInsights?: CreateDeploymentSpeedInsights | undefined;
  webAnalytics?: CreateDeploymentWebAnalytics | undefined;
};

export const CreateDeploymentDeploymentsStatus = {
  Skipped: "skipped",
  Pending: "pending",
  Ready: "ready",
  Error: "error",
  Timeout: "timeout",
} as const;
export type CreateDeploymentDeploymentsStatus = ClosedEnum<
  typeof CreateDeploymentDeploymentsStatus
>;

export type Integrations = {
  status: CreateDeploymentDeploymentsStatus;
  startedAt: number;
  completedAt?: number | undefined;
  skippedAt?: number | undefined;
  skippedBy?: string | undefined;
};

/**
 * Must be `http` or `https`.
 */
export const Protocol = {
  Http: "http",
  Https: "https",
} as const;
/**
 * Must be `http` or `https`.
 */
export type Protocol = ClosedEnum<typeof Protocol>;

export type RemotePatterns = {
  /**
   * Must be `http` or `https`.
   */
  protocol?: Protocol | undefined;
  /**
   * Can be literal or wildcard. Single `*` matches a single subdomain. Double `**` matches any number of subdomains.
   */
  hostname: string;
  /**
   * Can be literal port such as `8080` or empty string meaning no port.
   */
  port?: string | undefined;
  /**
   * Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
   */
  pathname?: string | undefined;
  /**
   * Can be literal query string such as `?v=1` or empty string meaning no query string.
   */
  search?: string | undefined;
};

export type LocalPatterns = {
  /**
   * Can be literal or wildcard. Single `*` matches a single path segment. Double `**` matches any number of path segments.
   */
  pathname?: string | undefined;
  /**
   * Can be literal query string such as `?v=1` or empty string meaning no query string.
   */
  search?: string | undefined;
};

export const Formats = {
  ImageAvif: "image/avif",
  ImageWebp: "image/webp",
} as const;
export type Formats = ClosedEnum<typeof Formats>;

export const ContentDispositionType = {
  Inline: "inline",
  Attachment: "attachment",
} as const;
export type ContentDispositionType = ClosedEnum<typeof ContentDispositionType>;

export type Images = {
  sizes?: Array<number> | undefined;
  qualities?: Array<number> | undefined;
  domains?: Array<string> | undefined;
  remotePatterns?: Array<RemotePatterns> | undefined;
  localPatterns?: Array<LocalPatterns> | undefined;
  minimumCacheTTL?: number | undefined;
  formats?: Array<Formats> | undefined;
  dangerouslyAllowSVG?: boolean | undefined;
  contentSecurityPolicy?: string | undefined;
  contentDispositionType?: ContentDispositionType | undefined;
};

/**
 * Information about the deployment creator
 */
export type Creator = {
  /**
   * The ID of the user that created the deployment
   */
  uid: string;
  /**
   * The username of the user that created the deployment
   */
  username?: string | undefined;
  /**
   * The avatar of the user that created the deployment
   */
  avatar?: string | undefined;
};

export const CreateDeploymentReadyState = {
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Ready: "READY",
} as const;
export type CreateDeploymentReadyState = ClosedEnum<
  typeof CreateDeploymentReadyState
>;

export type CreateDeploymentOutput = {
  path: string;
  functionName: string;
};

/**
 * A partial representation of a Build used by the deployment endpoint.
 */
export type Lambdas = {
  id: string;
  createdAt?: number | undefined;
  readyState?: CreateDeploymentReadyState | undefined;
  entrypoint?: string | null | undefined;
  readyStateAt?: number | undefined;
  output: Array<CreateDeploymentOutput>;
};

export const CreateDeploymentStatus = {
  Queued: "QUEUED",
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
export type CreateDeploymentStatus = ClosedEnum<typeof CreateDeploymentStatus>;

/**
 * The team that owns the deployment if any
 */
export type CreateDeploymentTeam = {
  id: string;
  name: string;
  slug: string;
  avatar?: string | undefined;
};

/**
 * If the deployment was created using a Custom Environment, then this property contains information regarding the environment used.
 */
export type CustomEnvironment2 = {
  id: string;
};

/**
 * The type of environment (production, preview, or development)
 */
export const CustomEnvironmentType = {
  Production: "production",
  Preview: "preview",
  Development: "development",
} as const;
/**
 * The type of environment (production, preview, or development)
 */
export type CustomEnvironmentType = ClosedEnum<typeof CustomEnvironmentType>;

/**
 * The type of matching to perform
 */
export const CreateDeploymentCustomEnvironmentType = {
  EndsWith: "endsWith",
  StartsWith: "startsWith",
  Equals: "equals",
} as const;
/**
 * The type of matching to perform
 */
export type CreateDeploymentCustomEnvironmentType = ClosedEnum<
  typeof CreateDeploymentCustomEnvironmentType
>;

/**
 * Configuration for matching git branches to this environment
 */
export type CreateDeploymentCustomEnvironmentBranchMatcher = {
  /**
   * The type of matching to perform
   */
  type: CreateDeploymentCustomEnvironmentType;
  /**
   * The pattern to match against branch names
   */
  pattern: string;
};

/**
 * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
 */
export type CreateDeploymentCustomEnvironmentVerification = {
  type: string;
  domain: string;
  value: string;
  reason: string;
};

/**
 * List of domains associated with this environment
 */
export type CreateDeploymentCustomEnvironmentDomains = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
  gitBranch?: string | null | undefined;
  customEnvironmentId?: string | null | undefined;
  updatedAt?: number | undefined;
  createdAt?: number | undefined;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?:
    | Array<CreateDeploymentCustomEnvironmentVerification>
    | undefined;
};

/**
 * If the deployment was created using a Custom Environment, then this property contains information regarding the environment used.
 */
export type CustomEnvironment1 = {
  /**
   * Unique identifier for the custom environment (format: env_*)
   */
  id: string;
  /**
   * URL-friendly name of the environment
   */
  slug: string;
  /**
   * The type of environment (production, preview, or development)
   */
  type: CustomEnvironmentType;
  /**
   * Optional description of the environment's purpose
   */
  description?: string | undefined;
  /**
   * Configuration for matching git branches to this environment
   */
  branchMatcher?: CreateDeploymentCustomEnvironmentBranchMatcher | undefined;
  /**
   * List of domains associated with this environment
   */
  domains?: Array<CreateDeploymentCustomEnvironmentDomains> | undefined;
  /**
   * List of aliases for the current deployment
   */
  currentDeploymentAliases?: Array<string> | undefined;
  /**
   * Timestamp when the environment was created
   */
  createdAt: number;
  /**
   * Timestamp when the environment was last updated
   */
  updatedAt: number;
};

export type CustomEnvironment = CustomEnvironment1 | CustomEnvironment2;

export const OomReport = {
  OutOfMemory: "out-of-memory",
} as const;
export type OomReport = ClosedEnum<typeof OomReport>;

export type AliasWarning = {
  code: string;
  message: string;
  link?: string | undefined;
  action?: string | undefined;
};

/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export const ReadyState = {
  Queued: "QUEUED",
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
/**
 * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
 */
export type ReadyState = ClosedEnum<typeof ReadyState>;

export const CreateDeploymentType = {
  Lambdas: "LAMBDAS",
} as const;
export type CreateDeploymentType = ClosedEnum<typeof CreateDeploymentType>;

/**
 * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
 */
export type AliasError = {
  code: string;
  message: string;
};

export const ChecksState = {
  Registered: "registered",
  Running: "running",
  Completed: "completed",
} as const;
export type ChecksState = ClosedEnum<typeof ChecksState>;

export const ChecksConclusion = {
  Succeeded: "succeeded",
  Failed: "failed",
  Skipped: "skipped",
  Canceled: "canceled",
} as const;
export type ChecksConclusion = ClosedEnum<typeof ChecksConclusion>;

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type =
  {
    Bitbucket: "bitbucket",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type
  >;

export type CreateDeploymentGitSource15 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type;
  ref: string;
  sha: string;
  owner?: string | undefined;
  slug?: string | undefined;
  workspaceUuid: string;
  repoUuid: string;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type =
  {
    Gitlab: "gitlab",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type
  >;

export type CreateDeploymentGitSource14 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type;
  ref: string;
  sha: string;
  projectId: number;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type =
  {
    GithubLimited: "github-limited",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type
  >;

export type CreateDeploymentGitSource13 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type =
  {
    GithubCustomHost: "github-custom-host",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type
  >;

export type CreateDeploymentGitSource12 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type;
  host: string;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type =
  {
    Github: "github",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type
  >;

export type CreateDeploymentGitSource11 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type =
  {
    Custom: "custom",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type
  >;

/**
 * Allows custom git sources (local folder mounted to the container) in test mode
 */
export type CreateDeploymentGitSource10 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type;
  ref: string;
  sha: string;
  gitUrl: string;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type =
  {
    Bitbucket: "bitbucket",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type
  >;

export type CreateDeploymentGitSource9 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type;
  owner: string;
  slug: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type =
  {
    Bitbucket: "bitbucket",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type
  >;

export type CreateDeploymentGitSource8 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type;
  workspaceUuid?: string | undefined;
  repoUuid: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type =
  {
    Gitlab: "gitlab",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type
  >;

export type GitSourceProjectId = string | number;

export type CreateDeploymentGitSource7 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type;
  projectId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type =
  {
    GithubLimited: "github-limited",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type
  >;

export type CreateDeploymentGitSource6 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type =
  {
    GithubLimited: "github-limited",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type
  >;

export type CreateDeploymentGitSourceDeploymentsResponseRepoId =
  | string
  | number;

export type CreateDeploymentGitSource5 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType =
  {
    GithubCustomHost: "github-custom-host",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType
  >;

export type CreateDeploymentGitSource4 = {
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType;
  host: string;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType =
  {
    GithubCustomHost: "github-custom-host",
  } as const;
export type CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType
  >;

export type CreateDeploymentGitSourceDeploymentsRepoId = string | number;

export type CreateDeploymentGitSource3 = {
  type: CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType;
  host: string;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponse200Type = {
  Github: "github",
} as const;
export type CreateDeploymentGitSourceDeploymentsResponse200Type = ClosedEnum<
  typeof CreateDeploymentGitSourceDeploymentsResponse200Type
>;

export type CreateDeploymentGitSource2 = {
  type: CreateDeploymentGitSourceDeploymentsResponse200Type;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export const CreateDeploymentGitSourceDeploymentsResponseType = {
  Github: "github",
} as const;
export type CreateDeploymentGitSourceDeploymentsResponseType = ClosedEnum<
  typeof CreateDeploymentGitSourceDeploymentsResponseType
>;

export type CreateDeploymentGitSourceRepoId = string | number;

export type CreateDeploymentGitSource1 = {
  type: CreateDeploymentGitSourceDeploymentsResponseType;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

export type CreateDeploymentGitSource =
  | CreateDeploymentGitSource12
  | CreateDeploymentGitSource15
  | CreateDeploymentGitSource4
  | CreateDeploymentGitSource10
  | CreateDeploymentGitSource11
  | CreateDeploymentGitSource13
  | CreateDeploymentGitSource14
  | CreateDeploymentGitSource2
  | CreateDeploymentGitSource3
  | CreateDeploymentGitSource6
  | CreateDeploymentGitSource9
  | CreateDeploymentGitSource1
  | CreateDeploymentGitSource5
  | CreateDeploymentGitSource7
  | CreateDeploymentGitSource8;

/**
 * Current provisioning state
 */
export const CreateDeploymentState = {
  Pending: "PENDING",
  Complete: "COMPLETE",
  Timeout: "TIMEOUT",
} as const;
/**
 * Current provisioning state
 */
export type CreateDeploymentState = ClosedEnum<typeof CreateDeploymentState>;

/**
 * Present when deployment was created with VERCEL_MANUAL_PROVISIONING=true. The deployment stays in INITIALIZING until /continue is called.
 */
export type ManualProvisioning = {
  /**
   * Current provisioning state
   */
  state: CreateDeploymentState;
  /**
   * Timestamp when manual provisioning completed
   */
  completedAt?: number | undefined;
};

/**
 * If set it overrides the `projectSettings.nodeVersion` for this deployment.
 */
export const CreateDeploymentNodeVersion = {
  TwentyFourDotX: "24.x",
  TwentyTwoDotX: "22.x",
  TwentyDotX: "20.x",
  EighteenDotX: "18.x",
  SixteenDotX: "16.x",
  FourteenDotX: "14.x",
  TwelveDotX: "12.x",
  TenDotX: "10.x",
  EightDot10DotX: "8.10.x",
} as const;
/**
 * If set it overrides the `projectSettings.nodeVersion` for this deployment.
 */
export type CreateDeploymentNodeVersion = ClosedEnum<
  typeof CreateDeploymentNodeVersion
>;

/**
 * The public project information associated with the deployment.
 */
export type CreateDeploymentProject = {
  id: string;
  name: string;
  framework?: string | null | undefined;
};

/**
 * Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
 */
export const ReadySubstate = {
  Staged: "STAGED",
  Rolling: "ROLLING",
  Promoted: "PROMOTED",
} as const;
/**
 * Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
 */
export type ReadySubstate = ClosedEnum<typeof ReadySubstate>;

/**
 * Where was the deployment created from
 */
export const CreateDeploymentSource = {
  ApiTriggerGitDeploy: "api-trigger-git-deploy",
  Cli: "cli",
  CloneRepo: "clone/repo",
  Git: "git",
  Import: "import",
  ImportRepo: "import/repo",
  Redeploy: "redeploy",
  V0Web: "v0-web",
} as const;
/**
 * Where was the deployment created from
 */
export type CreateDeploymentSource = ClosedEnum<typeof CreateDeploymentSource>;

/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export const CreateDeploymentTarget = {
  Staging: "staging",
  Production: "production",
} as const;
/**
 * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
 */
export type CreateDeploymentTarget = ClosedEnum<typeof CreateDeploymentTarget>;

export type OidcTokenClaims = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  ownerId: string;
  project: string;
  projectId: string;
  environment: string;
  plan?: string | undefined;
};

export const CreateDeploymentPlan = {
  Pro: "pro",
  Enterprise: "enterprise",
  Hobby: "hobby",
} as const;
export type CreateDeploymentPlan = ClosedEnum<typeof CreateDeploymentPlan>;

export type Crons = {
  schedule: string;
  path: string;
};

export const Architecture = {
  X8664: "x86_64",
  Arm64: "arm64",
} as const;
export type Architecture = ClosedEnum<typeof Architecture>;

/**
 * Event type - must be "queue/v1beta" (REQUIRED)
 */
export const CreateDeploymentDeploymentsType = {
  QueueV1beta: "queue/v1beta",
} as const;
/**
 * Event type - must be "queue/v1beta" (REQUIRED)
 */
export type CreateDeploymentDeploymentsType = ClosedEnum<
  typeof CreateDeploymentDeploymentsType
>;

/**
 * Queue trigger event for Vercel's queue system. Handles "queue/v1beta" events with queue-specific configuration.
 */
export type ExperimentalTriggers = {
  /**
   * Event type - must be "queue/v1beta" (REQUIRED)
   */
  type: CreateDeploymentDeploymentsType;
  /**
   * Name of the queue topic to consume from (REQUIRED)
   */
  topic: string;
  /**
   * Name of the consumer group for this trigger (REQUIRED)
   */
  consumer: string;
  /**
   * Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxDeliveries?: number | undefined;
  /**
   * Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
   */
  retryAfterSeconds?: number | undefined;
  /**
   * Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
   */
  initialDelaySeconds?: number | undefined;
  /**
   * Maximum number of concurrent executions for this consumer (OPTIONAL) Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxConcurrency?: number | undefined;
};

export type Functions = {
  architecture?: Architecture | undefined;
  memory?: number | undefined;
  maxDuration?: number | undefined;
  runtime?: string | undefined;
  includeFiles?: string | undefined;
  excludeFiles?: string | undefined;
  experimentalTriggers?: Array<ExperimentalTriggers> | undefined;
  supportsCancellation?: boolean | undefined;
};

export type Routes3 = {
  src: string;
  continue: boolean;
  middleware: number;
};

export const Handle = {
  Error: "error",
  Filesystem: "filesystem",
  Hit: "hit",
  Miss: "miss",
  Rewrite: "rewrite",
  Resource: "resource",
} as const;
export type Handle = ClosedEnum<typeof Handle>;

export type Routes2 = {
  handle: Handle;
  src?: string | undefined;
  dest?: string | undefined;
  status?: number | undefined;
};

export const CreateDeploymentHasType = {
  Header: "header",
  Cookie: "cookie",
  Query: "query",
} as const;
export type CreateDeploymentHasType = ClosedEnum<
  typeof CreateDeploymentHasType
>;

export type ValueEq = string | number;

export type CreateDeploymentValue2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type HasValue = string | CreateDeploymentValue2;

export type Has2 = {
  type: CreateDeploymentHasType;
  key: string;
  value?: string | CreateDeploymentValue2 | undefined;
};

export type Eq = string | number;

export type CreateDeploymentValueDeploymentsResponse2002 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type CreateDeploymentHasValue =
  | string
  | CreateDeploymentValueDeploymentsResponse2002;

export type Has1 = {
  type: "host";
  value: string | CreateDeploymentValueDeploymentsResponse2002;
};

export type Has =
  | Has1
  | (Has2 & { type: "header" })
  | (Has2 & { type: "cookie" })
  | (Has2 & { type: "query" });

export const CreateDeploymentMissingType = {
  Header: "header",
  Cookie: "cookie",
  Query: "query",
} as const;
export type CreateDeploymentMissingType = ClosedEnum<
  typeof CreateDeploymentMissingType
>;

export type CreateDeploymentValueDeploymentsEq = string | number;

export type CreateDeploymentValueDeploymentsResponse2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type CreateDeploymentMissingValue =
  | string
  | CreateDeploymentValueDeploymentsResponse2;

export type Missing2 = {
  type: CreateDeploymentMissingType;
  key: string;
  value?: string | CreateDeploymentValueDeploymentsResponse2 | undefined;
};

export type CreateDeploymentValueEq = string | number;

export type CreateDeploymentValueDeployments2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type MissingValue = string | CreateDeploymentValueDeployments2;

export type Missing1 = {
  type: "host";
  value: string | CreateDeploymentValueDeployments2;
};

export type Missing =
  | Missing1
  | (Missing2 & { type: "header" })
  | (Missing2 & { type: "cookie" })
  | (Missing2 & { type: "query" });

export const RoutesAction = {
  Challenge: "challenge",
  Deny: "deny",
} as const;
export type RoutesAction = ClosedEnum<typeof RoutesAction>;

export type CreateDeploymentRoutesMitigate = {
  action: RoutesAction;
};

export const RoutesType = {
  RequestHeaders: "request.headers",
  RequestQuery: "request.query",
  ResponseHeaders: "response.headers",
} as const;
export type RoutesType = ClosedEnum<typeof RoutesType>;

export const CreateDeploymentRoutesOp = {
  Append: "append",
  Set: "set",
  Delete: "delete",
} as const;
export type CreateDeploymentRoutesOp = ClosedEnum<
  typeof CreateDeploymentRoutesOp
>;

export type KeyEq = string | number;

export type Key2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type Key = string | Key2;

export type RoutesTarget = {
  key: string | Key2;
};

export type Args = string | Array<string>;

export type CreateDeploymentRoutesTransforms = {
  type: RoutesType;
  op: CreateDeploymentRoutesOp;
  target: RoutesTarget;
  args?: string | Array<string> | undefined;
  env?: Array<string> | undefined;
};

export type Locale = {
  redirect?: { [k: string]: string } | undefined;
  cookie?: string | undefined;
};

export type Routes1 = {
  src: string;
  dest?: string | undefined;
  headers?: { [k: string]: string } | undefined;
  methods?: Array<string> | undefined;
  continue?: boolean | undefined;
  override?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  check?: boolean | undefined;
  important?: boolean | undefined;
  status?: number | undefined;
  has?:
    | Array<
      | Has1
      | (Has2 & { type: "header" })
      | (Has2 & { type: "cookie" })
      | (Has2 & { type: "query" })
    >
    | undefined;
  missing?:
    | Array<
      | Missing1
      | (Missing2 & { type: "header" })
      | (Missing2 & { type: "cookie" })
      | (Missing2 & { type: "query" })
    >
    | undefined;
  mitigate?: CreateDeploymentRoutesMitigate | undefined;
  transforms?: Array<CreateDeploymentRoutesTransforms> | undefined;
  env?: Array<string> | undefined;
  locale?: Locale | undefined;
  /**
   * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
   */
  middlewarePath?: string | undefined;
  /**
   * The original middleware matchers.
   */
  middlewareRawSrc?: Array<string> | undefined;
  /**
   * A middleware index in the `middleware` key under the build result
   */
  middleware?: number | undefined;
  respectOriginCacheControl?: boolean | undefined;
};

export type Routes = Routes3 | Routes1 | Routes2;

export const CreateDeploymentGitRepoOwnerType = {
  Team: "team",
  User: "user",
} as const;
export type CreateDeploymentGitRepoOwnerType = ClosedEnum<
  typeof CreateDeploymentGitRepoOwnerType
>;

export type GitRepo3 = {
  owner: string;
  repoUuid: string;
  slug: string;
  type: "bitbucket";
  workspaceUuid: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: CreateDeploymentGitRepoOwnerType;
};

export const GitRepoOwnerType = {
  Team: "team",
  User: "user",
} as const;
export type GitRepoOwnerType = ClosedEnum<typeof GitRepoOwnerType>;

export type GitRepo2 = {
  org: string;
  repo: string;
  repoId: number;
  type: "github";
  repoOwnerId: number;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: GitRepoOwnerType;
};

export const OwnerType = {
  Team: "team",
  User: "user",
} as const;
export type OwnerType = ClosedEnum<typeof OwnerType>;

export type GitRepo1 = {
  namespace: string;
  projectId: number;
  type: "gitlab";
  url: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: OwnerType;
};

export type GitRepo = GitRepo1 | GitRepo2 | GitRepo3;

/**
 * Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
 */
export type Flags2 = {};

export type Options = {
  value: FlagJSONValue | null;
  label?: string | undefined;
};

export type CreateDeploymentFlagsDefinitions = {
  options?: Array<Options> | undefined;
  url?: string | undefined;
  description?: string | undefined;
};

/**
 * Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
 */
export type Flags1 = {
  definitions: { [k: string]: CreateDeploymentFlagsDefinitions };
};

export type Flags = Flags1 | Array<Flags2>;

/**
 * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
 */
export const MfeConfigUploadState = {
  Success: "success",
  WaitingOnBuild: "waiting_on_build",
  NoConfig: "no_config",
} as const;
/**
 * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
 */
export type MfeConfigUploadState = ClosedEnum<typeof MfeConfigUploadState>;

export type CreateDeploymentMicrofrontends2 = {
  isDefaultApp: boolean;
  /**
   * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
   */
  mfeConfigUploadState?: MfeConfigUploadState | undefined;
  /**
   * The project name of the default app of this deployment's microfrontends group.
   */
  defaultAppProjectName: string;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
   */
  defaultRoute?: string | undefined;
  /**
   * The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
};

export type CreateDeploymentMicrofrontends1 = {
  isDefaultApp?: boolean | undefined;
  /**
   * The project name of the default app of this deployment's microfrontends group.
   */
  defaultAppProjectName: string;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
   */
  defaultRoute?: string | undefined;
  /**
   * The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
};

export type CreateDeploymentMicrofrontends =
  | CreateDeploymentMicrofrontends2
  | CreateDeploymentMicrofrontends1;

export const FunctionType = {
  Fluid: "fluid",
  Standard: "standard",
} as const;
export type FunctionType = ClosedEnum<typeof FunctionType>;

export const FunctionMemoryType = {
  Standard: "standard",
  StandardLegacy: "standard_legacy",
  Performance: "performance",
} as const;
export type FunctionMemoryType = ClosedEnum<typeof FunctionMemoryType>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export const CreateDeploymentConfiguration = {
  SkipNamespaceQueue: "SKIP_NAMESPACE_QUEUE",
  WaitForNamespaceQueue: "WAIT_FOR_NAMESPACE_QUEUE",
} as const;
/**
 * Build resource configuration snapshot for this deployment.
 */
export type CreateDeploymentConfiguration = ClosedEnum<
  typeof CreateDeploymentConfiguration
>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export type CreateDeploymentBuildQueue = {
  /**
   * Build resource configuration snapshot for this deployment.
   */
  configuration?: CreateDeploymentConfiguration | undefined;
};

/**
 * Build resource configuration snapshot for this deployment.
 */
export const CreateDeploymentPurchaseType = {
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
/**
 * Build resource configuration snapshot for this deployment.
 */
export type CreateDeploymentPurchaseType = ClosedEnum<
  typeof CreateDeploymentPurchaseType
>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export type CreateDeploymentBuildMachine = {
  /**
   * Build resource configuration snapshot for this deployment.
   */
  purchaseType?: CreateDeploymentPurchaseType | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  isDefaultBuildMachine?: boolean | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  cores?: number | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  memory?: number | undefined;
};

/**
 * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
 */
export const ElasticConcurrency = {
  TeamSetting: "TEAM_SETTING",
  ProjectSetting: "PROJECT_SETTING",
  SkipQueue: "SKIP_QUEUE",
} as const;
/**
 * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
 */
export type ElasticConcurrency = ClosedEnum<typeof ElasticConcurrency>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export type CreateDeploymentResourceConfig = {
  /**
   * Build resource configuration snapshot for this deployment.
   */
  buildQueue?: CreateDeploymentBuildQueue | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  buildMachine?: CreateDeploymentBuildMachine | undefined;
  /**
   * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
   */
  elasticConcurrency?: ElasticConcurrency | undefined;
};

/**
 * Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
 */
export type Config = {
  version?: number | undefined;
  functionType: FunctionType;
  functionMemoryType: FunctionMemoryType;
  functionTimeout: number | null;
  secureComputePrimaryRegion: string | null;
  secureComputeFallbackRegion: string | null;
  isUsingActiveCPU?: boolean | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  resourceConfig?: CreateDeploymentResourceConfig | undefined;
};

export const CreateDeploymentDeploymentsState = {
  Succeeded: "succeeded",
  Failed: "failed",
  Pending: "pending",
} as const;
export type CreateDeploymentDeploymentsState = ClosedEnum<
  typeof CreateDeploymentDeploymentsState
>;

/**
 * Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
 */
export type DeploymentAlias = {
  state: CreateDeploymentDeploymentsState;
  startedAt: number;
  completedAt?: number | undefined;
};

export type CreateDeploymentChecks = {
  /**
   * Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
   */
  deploymentAlias: DeploymentAlias;
};

/**
 * The successfully created deployment
 */
export type CreateDeploymentResponseBody = {
  aliasAssignedAt?: number | boolean | null | undefined;
  alwaysRefuseToBuild?: boolean | undefined;
  build: Build;
  buildArtifactUrls?: Array<string> | undefined;
  builds?: Array<Builds> | undefined;
  env: Array<string>;
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  isInSystemBuildsQueue: boolean;
  projectSettings: CreateDeploymentProjectSettings;
  readyStateReason?: string | undefined;
  integrations?: Integrations | undefined;
  images?: Images | undefined;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias?: Array<string> | undefined;
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   */
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  /**
   * Since April 2025 it necessary for On-Demand Concurrency Minutes calculation
   */
  buildContainerFinishedAt?: number | undefined;
  buildSkipped: boolean;
  /**
   * Information about the deployment creator
   */
  creator: Creator;
  initReadyAt?: number | undefined;
  isFirstBranchDeployment?: boolean | undefined;
  lambdas?: Array<Lambdas> | undefined;
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   */
  public: boolean;
  ready?: number | undefined;
  status: CreateDeploymentStatus;
  /**
   * The team that owns the deployment if any
   */
  team?: CreateDeploymentTeam | undefined;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   */
  userAliases?: Array<string> | undefined;
  /**
   * Whether or not preview comments are enabled for the deployment
   */
  previewCommentsEnabled?: boolean | undefined;
  ttyBuildLogs?: boolean | undefined;
  customEnvironment?: CustomEnvironment1 | CustomEnvironment2 | undefined;
  oomReport?: OomReport | undefined;
  aliasWarning?: AliasWarning | null | undefined;
  /**
   * A string holding the unique ID of the deployment
   */
  id: string;
  /**
   * A number containing the date when the deployment was created in milliseconds
   */
  createdAt: number;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   */
  readyState: ReadyState;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   */
  name: string;
  type: CreateDeploymentType;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   */
  aliasError?: AliasError | null | undefined;
  aliasFinal?: string | null | undefined;
  /**
   * applies to custom domains only, defaults to `true`
   */
  autoAssignCustomDomains?: boolean | undefined;
  automaticAliases?: Array<string> | undefined;
  buildErrorAt?: number | undefined;
  checksState?: ChecksState | undefined;
  checksConclusion?: ChecksConclusion | undefined;
  /**
   * A number containing the date when the deployment was deleted at milliseconds
   */
  deletedAt?: number | null | undefined;
  /**
   * Computed field that is only available for deployments with a microfrontend configuration.
   */
  defaultRoute?: string | undefined;
  canceledAt?: number | undefined;
  errorCode?: string | undefined;
  errorLink?: string | undefined;
  errorMessage?: string | null | undefined;
  errorStep?: string | undefined;
  /**
   * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
   */
  passiveRegions?: Array<string> | undefined;
  gitSource?:
    | CreateDeploymentGitSource12
    | CreateDeploymentGitSource15
    | CreateDeploymentGitSource4
    | CreateDeploymentGitSource10
    | CreateDeploymentGitSource11
    | CreateDeploymentGitSource13
    | CreateDeploymentGitSource14
    | CreateDeploymentGitSource2
    | CreateDeploymentGitSource3
    | CreateDeploymentGitSource6
    | CreateDeploymentGitSource9
    | CreateDeploymentGitSource1
    | CreateDeploymentGitSource5
    | CreateDeploymentGitSource7
    | CreateDeploymentGitSource8
    | undefined;
  /**
   * Present when deployment was created with VERCEL_MANUAL_PROVISIONING=true. The deployment stays in INITIALIZING until /continue is called.
   */
  manualProvisioning?: ManualProvisioning | undefined;
  meta: { [k: string]: string };
  originCacheRegion?: string | undefined;
  /**
   * If set it overrides the `projectSettings.nodeVersion` for this deployment.
   */
  nodeVersion?: CreateDeploymentNodeVersion | undefined;
  /**
   * The public project information associated with the deployment.
   */
  project?: CreateDeploymentProject | undefined;
  prebuilt?: boolean | undefined;
  /**
   * Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
   */
  readySubstate?: ReadySubstate | undefined;
  /**
   * The regions the deployment exists in
   */
  regions: Array<string>;
  /**
   * flag to indicate if the deployment was deleted by retention policy
   */
  softDeletedByRetention?: boolean | undefined;
  /**
   * Where was the deployment created from
   */
  source?: CreateDeploymentSource | undefined;
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
   */
  target?: CreateDeploymentTarget | null | undefined;
  /**
   * A number containing the date when the deployment was undeleted at milliseconds
   */
  undeletedAt?: number | undefined;
  /**
   * A string with the unique URL of the deployment
   */
  url: string;
  /**
   * Since January 2025 User-configured deployment ID for skew protection with pre-built deployments. This is set when users configure a custom deploymentId in their next.config.js file. This allows Next.js to use skew protection even when deployments are pre-built outside of Vercel's build system.
   */
  userConfiguredDeploymentId?: string | undefined;
  /**
   * The platform version that was used to create the deployment.
   */
  version: number;
  oidcTokenClaims?: OidcTokenClaims | undefined;
  projectId: string;
  plan: CreateDeploymentPlan;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdIn: string;
  crons?: Array<Crons> | undefined;
  functions?: { [k: string]: Functions } | null | undefined;
  monorepoManager?: string | null | undefined;
  ownerId: string;
  /**
   * Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)
   */
  passiveConnectConfigurationId?: string | undefined;
  routes: Array<Routes3 | Routes1 | Routes2> | null;
  gitRepo?: GitRepo1 | GitRepo2 | GitRepo3 | null | undefined;
  flags?: Flags1 | Array<Flags2> | undefined;
  microfrontends?:
    | CreateDeploymentMicrofrontends2
    | CreateDeploymentMicrofrontends1
    | undefined;
  /**
   * Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
   */
  config?: Config | undefined;
  checks?: CreateDeploymentChecks | undefined;
};

/** @internal */
export const ForceNew$inboundSchema: z.ZodNativeEnum<typeof ForceNew> = z
  .nativeEnum(ForceNew);
/** @internal */
export const ForceNew$outboundSchema: z.ZodNativeEnum<typeof ForceNew> =
  ForceNew$inboundSchema;

/** @internal */
export const SkipAutoDetectionConfirmation$inboundSchema: z.ZodNativeEnum<
  typeof SkipAutoDetectionConfirmation
> = z.nativeEnum(SkipAutoDetectionConfirmation);
/** @internal */
export const SkipAutoDetectionConfirmation$outboundSchema: z.ZodNativeEnum<
  typeof SkipAutoDetectionConfirmation
> = SkipAutoDetectionConfirmation$inboundSchema;

/** @internal */
export const UploadedFile$inboundSchema: z.ZodType<
  UploadedFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  file: types.string(),
  sha: types.optional(types.string()),
  size: types.optional(types.number()),
});
/** @internal */
export type UploadedFile$Outbound = {
  file: string;
  sha?: string | undefined;
  size?: number | undefined;
};

/** @internal */
export const UploadedFile$outboundSchema: z.ZodType<
  UploadedFile$Outbound,
  z.ZodTypeDef,
  UploadedFile
> = z.object({
  file: z.string(),
  sha: z.string().optional(),
  size: z.number().int().optional(),
});

export function uploadedFileToJSON(uploadedFile: UploadedFile): string {
  return JSON.stringify(UploadedFile$outboundSchema.parse(uploadedFile));
}
export function uploadedFileFromJSON(
  jsonString: string,
): SafeParseResult<UploadedFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UploadedFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UploadedFile' from JSON`,
  );
}

/** @internal */
export const Encoding$inboundSchema: z.ZodNativeEnum<typeof Encoding> = z
  .nativeEnum(Encoding);
/** @internal */
export const Encoding$outboundSchema: z.ZodNativeEnum<typeof Encoding> =
  Encoding$inboundSchema;

/** @internal */
export const InlinedFile$inboundSchema: z.ZodType<
  InlinedFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: types.string(),
  encoding: types.optional(Encoding$inboundSchema),
  file: types.string(),
});
/** @internal */
export type InlinedFile$Outbound = {
  data: string;
  encoding?: string | undefined;
  file: string;
};

/** @internal */
export const InlinedFile$outboundSchema: z.ZodType<
  InlinedFile$Outbound,
  z.ZodTypeDef,
  InlinedFile
> = z.object({
  data: z.string(),
  encoding: Encoding$outboundSchema.optional(),
  file: z.string(),
});

export function inlinedFileToJSON(inlinedFile: InlinedFile): string {
  return JSON.stringify(InlinedFile$outboundSchema.parse(inlinedFile));
}
export function inlinedFileFromJSON(
  jsonString: string,
): SafeParseResult<InlinedFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InlinedFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InlinedFile' from JSON`,
  );
}

/** @internal */
export const Files$inboundSchema: z.ZodType<Files, z.ZodTypeDef, unknown> =
  smartUnion([
    z.lazy(() => InlinedFile$inboundSchema),
    z.lazy(() => UploadedFile$inboundSchema),
  ]);
/** @internal */
export type Files$Outbound = InlinedFile$Outbound | UploadedFile$Outbound;

/** @internal */
export const Files$outboundSchema: z.ZodType<
  Files$Outbound,
  z.ZodTypeDef,
  Files
> = smartUnion([
  z.lazy(() => InlinedFile$outboundSchema),
  z.lazy(() => UploadedFile$outboundSchema),
]);

export function filesToJSON(files: Files): string {
  return JSON.stringify(Files$outboundSchema.parse(files));
}
export function filesFromJSON(
  jsonString: string,
): SafeParseResult<Files, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Files$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Files' from JSON`,
  );
}

/** @internal */
export const GitMetadata$inboundSchema: z.ZodType<
  GitMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  remoteUrl: types.optional(types.string()),
  commitAuthorName: types.optional(types.string()),
  commitAuthorEmail: types.optional(types.string()),
  commitMessage: types.optional(types.string()),
  commitRef: types.optional(types.string()),
  commitSha: types.optional(types.string()),
  dirty: types.optional(types.boolean()),
  ci: types.optional(types.boolean()),
  ciType: types.optional(types.string()),
  ciGitProviderUsername: types.optional(types.string()),
  ciGitRepoVisibility: types.optional(types.string()),
});
/** @internal */
export type GitMetadata$Outbound = {
  remoteUrl?: string | undefined;
  commitAuthorName?: string | undefined;
  commitAuthorEmail?: string | undefined;
  commitMessage?: string | undefined;
  commitRef?: string | undefined;
  commitSha?: string | undefined;
  dirty?: boolean | undefined;
  ci?: boolean | undefined;
  ciType?: string | undefined;
  ciGitProviderUsername?: string | undefined;
  ciGitRepoVisibility?: string | undefined;
};

/** @internal */
export const GitMetadata$outboundSchema: z.ZodType<
  GitMetadata$Outbound,
  z.ZodTypeDef,
  GitMetadata
> = z.object({
  remoteUrl: z.string().optional(),
  commitAuthorName: z.string().optional(),
  commitAuthorEmail: z.string().optional(),
  commitMessage: z.string().optional(),
  commitRef: z.string().optional(),
  commitSha: z.string().optional(),
  dirty: z.boolean().optional(),
  ci: z.boolean().optional(),
  ciType: z.string().optional(),
  ciGitProviderUsername: z.string().optional(),
  ciGitRepoVisibility: z.string().optional(),
});

export function gitMetadataToJSON(gitMetadata: GitMetadata): string {
  return JSON.stringify(GitMetadata$outboundSchema.parse(gitMetadata));
}
export function gitMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GitMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitMetadata' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type
  > = z.nativeEnum(CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type
  > = CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type$inboundSchema;

/** @internal */
export const GitSource7$inboundSchema: z.ZodType<
  GitSource7,
  z.ZodTypeDef,
  unknown
> = z.object({
  owner: types.string(),
  ref: types.string(),
  sha: types.optional(types.string()),
  slug: types.string(),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type$inboundSchema,
});
/** @internal */
export type GitSource7$Outbound = {
  owner: string;
  ref: string;
  sha?: string | undefined;
  slug: string;
  type: string;
};

/** @internal */
export const GitSource7$outboundSchema: z.ZodType<
  GitSource7$Outbound,
  z.ZodTypeDef,
  GitSource7
> = z.object({
  owner: z.string(),
  ref: z.string(),
  sha: z.string().optional(),
  slug: z.string(),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBody7Type$outboundSchema,
});

export function gitSource7ToJSON(gitSource7: GitSource7): string {
  return JSON.stringify(GitSource7$outboundSchema.parse(gitSource7));
}
export function gitSource7FromJSON(
  jsonString: string,
): SafeParseResult<GitSource7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource7' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBodyType
  > = z.nativeEnum(CreateDeploymentGitSourceDeploymentsRequestRequestBodyType);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBodyType
  > = CreateDeploymentGitSourceDeploymentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const GitSource6$inboundSchema: z.ZodType<
  GitSource6,
  z.ZodTypeDef,
  unknown
> = z.object({
  ref: types.string(),
  repoUuid: types.string(),
  sha: types.optional(types.string()),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBodyType$inboundSchema,
  workspaceUuid: types.optional(types.string()),
});
/** @internal */
export type GitSource6$Outbound = {
  ref: string;
  repoUuid: string;
  sha?: string | undefined;
  type: string;
  workspaceUuid?: string | undefined;
};

/** @internal */
export const GitSource6$outboundSchema: z.ZodType<
  GitSource6$Outbound,
  z.ZodTypeDef,
  GitSource6
> = z.object({
  ref: z.string(),
  repoUuid: z.string(),
  sha: z.string().optional(),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBodyType$outboundSchema,
  workspaceUuid: z.string().optional(),
});

export function gitSource6ToJSON(gitSource6: GitSource6): string {
  return JSON.stringify(GitSource6$outboundSchema.parse(gitSource6));
}
export function gitSource6FromJSON(
  jsonString: string,
): SafeParseResult<GitSource6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource6' from JSON`,
  );
}

/** @internal */
export const ProjectId$inboundSchema: z.ZodType<
  ProjectId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.number(), types.string()]);
/** @internal */
export type ProjectId$Outbound = number | string;

/** @internal */
export const ProjectId$outboundSchema: z.ZodType<
  ProjectId$Outbound,
  z.ZodTypeDef,
  ProjectId
> = smartUnion([z.number(), z.string()]);

export function projectIdToJSON(projectId: ProjectId): string {
  return JSON.stringify(ProjectId$outboundSchema.parse(projectId));
}
export function projectIdFromJSON(
  jsonString: string,
): SafeParseResult<ProjectId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProjectId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProjectId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsRequestType> = z
    .nativeEnum(CreateDeploymentGitSourceDeploymentsRequestType);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsRequestType> =
    CreateDeploymentGitSourceDeploymentsRequestType$inboundSchema;

/** @internal */
export const GitSource5$inboundSchema: z.ZodType<
  GitSource5,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: smartUnion([types.number(), types.string()]),
  ref: types.string(),
  sha: types.optional(types.string()),
  type: CreateDeploymentGitSourceDeploymentsRequestType$inboundSchema,
});
/** @internal */
export type GitSource5$Outbound = {
  projectId: number | string;
  ref: string;
  sha?: string | undefined;
  type: string;
};

/** @internal */
export const GitSource5$outboundSchema: z.ZodType<
  GitSource5$Outbound,
  z.ZodTypeDef,
  GitSource5
> = z.object({
  projectId: smartUnion([z.number(), z.string()]),
  ref: z.string(),
  sha: z.string().optional(),
  type: CreateDeploymentGitSourceDeploymentsRequestType$outboundSchema,
});

export function gitSource5ToJSON(gitSource5: GitSource5): string {
  return JSON.stringify(GitSource5$outboundSchema.parse(gitSource5));
}
export function gitSource5FromJSON(
  jsonString: string,
): SafeParseResult<GitSource5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource5' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsType> = z
    .nativeEnum(CreateDeploymentGitSourceDeploymentsType);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsType> =
    CreateDeploymentGitSourceDeploymentsType$inboundSchema;

/** @internal */
export const GitSource4$inboundSchema: z.ZodType<
  GitSource4,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  ref: types.string(),
  repo: types.string(),
  sha: types.optional(types.string()),
  type: CreateDeploymentGitSourceDeploymentsType$inboundSchema,
});
/** @internal */
export type GitSource4$Outbound = {
  org: string;
  ref: string;
  repo: string;
  sha?: string | undefined;
  type: string;
};

/** @internal */
export const GitSource4$outboundSchema: z.ZodType<
  GitSource4$Outbound,
  z.ZodTypeDef,
  GitSource4
> = z.object({
  org: z.string(),
  ref: z.string(),
  repo: z.string(),
  sha: z.string().optional(),
  type: CreateDeploymentGitSourceDeploymentsType$outboundSchema,
});

export function gitSource4ToJSON(gitSource4: GitSource4): string {
  return JSON.stringify(GitSource4$outboundSchema.parse(gitSource4));
}
export function gitSource4FromJSON(
  jsonString: string,
): SafeParseResult<GitSource4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource4' from JSON`,
  );
}

/** @internal */
export const GitSourceRepoId$inboundSchema: z.ZodType<
  GitSourceRepoId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.number(), types.string()]);
/** @internal */
export type GitSourceRepoId$Outbound = number | string;

/** @internal */
export const GitSourceRepoId$outboundSchema: z.ZodType<
  GitSourceRepoId$Outbound,
  z.ZodTypeDef,
  GitSourceRepoId
> = smartUnion([z.number(), z.string()]);

export function gitSourceRepoIdToJSON(
  gitSourceRepoId: GitSourceRepoId,
): string {
  return JSON.stringify(GitSourceRepoId$outboundSchema.parse(gitSourceRepoId));
}
export function gitSourceRepoIdFromJSON(
  jsonString: string,
): SafeParseResult<GitSourceRepoId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSourceRepoId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSourceRepoId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentGitSourceType
> = z.nativeEnum(CreateDeploymentGitSourceType);
/** @internal */
export const CreateDeploymentGitSourceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentGitSourceType
> = CreateDeploymentGitSourceType$inboundSchema;

/** @internal */
export const GitSource3$inboundSchema: z.ZodType<
  GitSource3,
  z.ZodTypeDef,
  unknown
> = z.object({
  ref: types.string(),
  repoId: smartUnion([types.number(), types.string()]),
  sha: types.optional(types.string()),
  type: CreateDeploymentGitSourceType$inboundSchema,
});
/** @internal */
export type GitSource3$Outbound = {
  ref: string;
  repoId: number | string;
  sha?: string | undefined;
  type: string;
};

/** @internal */
export const GitSource3$outboundSchema: z.ZodType<
  GitSource3$Outbound,
  z.ZodTypeDef,
  GitSource3
> = z.object({
  ref: z.string(),
  repoId: smartUnion([z.number(), z.string()]),
  sha: z.string().optional(),
  type: CreateDeploymentGitSourceType$outboundSchema,
});

export function gitSource3ToJSON(gitSource3: GitSource3): string {
  return JSON.stringify(GitSource3$outboundSchema.parse(gitSource3));
}
export function gitSource3FromJSON(
  jsonString: string,
): SafeParseResult<GitSource3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource3' from JSON`,
  );
}

/** @internal */
export const GitSourceType$inboundSchema: z.ZodNativeEnum<
  typeof GitSourceType
> = z.nativeEnum(GitSourceType);
/** @internal */
export const GitSourceType$outboundSchema: z.ZodNativeEnum<
  typeof GitSourceType
> = GitSourceType$inboundSchema;

/** @internal */
export const GitSource2$inboundSchema: z.ZodType<
  GitSource2,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  ref: types.string(),
  repo: types.string(),
  sha: types.optional(types.string()),
  type: GitSourceType$inboundSchema,
});
/** @internal */
export type GitSource2$Outbound = {
  org: string;
  ref: string;
  repo: string;
  sha?: string | undefined;
  type: string;
};

/** @internal */
export const GitSource2$outboundSchema: z.ZodType<
  GitSource2$Outbound,
  z.ZodTypeDef,
  GitSource2
> = z.object({
  org: z.string(),
  ref: z.string(),
  repo: z.string(),
  sha: z.string().optional(),
  type: GitSourceType$outboundSchema,
});

export function gitSource2ToJSON(gitSource2: GitSource2): string {
  return JSON.stringify(GitSource2$outboundSchema.parse(gitSource2));
}
export function gitSource2FromJSON(
  jsonString: string,
): SafeParseResult<GitSource2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource2' from JSON`,
  );
}

/** @internal */
export const RepoId$inboundSchema: z.ZodType<RepoId, z.ZodTypeDef, unknown> =
  smartUnion([types.number(), types.string()]);
/** @internal */
export type RepoId$Outbound = number | string;

/** @internal */
export const RepoId$outboundSchema: z.ZodType<
  RepoId$Outbound,
  z.ZodTypeDef,
  RepoId
> = smartUnion([z.number(), z.string()]);

export function repoIdToJSON(repoId: RepoId): string {
  return JSON.stringify(RepoId$outboundSchema.parse(repoId));
}
export function repoIdFromJSON(
  jsonString: string,
): SafeParseResult<RepoId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RepoId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RepoId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type
  > = z.nativeEnum(CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type
  > = CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type$inboundSchema;

/** @internal */
export const GitSource1$inboundSchema: z.ZodType<
  GitSource1,
  z.ZodTypeDef,
  unknown
> = z.object({
  ref: types.string(),
  repoId: smartUnion([types.number(), types.string()]),
  sha: types.optional(types.string()),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type$inboundSchema,
});
/** @internal */
export type GitSource1$Outbound = {
  ref: string;
  repoId: number | string;
  sha?: string | undefined;
  type: string;
};

/** @internal */
export const GitSource1$outboundSchema: z.ZodType<
  GitSource1$Outbound,
  z.ZodTypeDef,
  GitSource1
> = z.object({
  ref: z.string(),
  repoId: smartUnion([z.number(), z.string()]),
  sha: z.string().optional(),
  type:
    CreateDeploymentGitSourceDeploymentsRequestRequestBody1Type$outboundSchema,
});

export function gitSource1ToJSON(gitSource1: GitSource1): string {
  return JSON.stringify(GitSource1$outboundSchema.parse(gitSource1));
}
export function gitSource1FromJSON(
  jsonString: string,
): SafeParseResult<GitSource1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource1' from JSON`,
  );
}

/** @internal */
export const GitSource$inboundSchema: z.ZodType<
  GitSource,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GitSource2$inboundSchema),
  z.lazy(() => GitSource4$inboundSchema),
  z.lazy(() => GitSource7$inboundSchema),
  z.lazy(() => GitSource1$inboundSchema),
  z.lazy(() => GitSource3$inboundSchema),
  z.lazy(() => GitSource5$inboundSchema),
  z.lazy(() => GitSource6$inboundSchema),
]);
/** @internal */
export type GitSource$Outbound =
  | GitSource2$Outbound
  | GitSource4$Outbound
  | GitSource7$Outbound
  | GitSource1$Outbound
  | GitSource3$Outbound
  | GitSource5$Outbound
  | GitSource6$Outbound;

/** @internal */
export const GitSource$outboundSchema: z.ZodType<
  GitSource$Outbound,
  z.ZodTypeDef,
  GitSource
> = smartUnion([
  z.lazy(() => GitSource2$outboundSchema),
  z.lazy(() => GitSource4$outboundSchema),
  z.lazy(() => GitSource7$outboundSchema),
  z.lazy(() => GitSource1$outboundSchema),
  z.lazy(() => GitSource3$outboundSchema),
  z.lazy(() => GitSource5$outboundSchema),
  z.lazy(() => GitSource6$outboundSchema),
]);

export function gitSourceToJSON(gitSource: GitSource): string {
  return JSON.stringify(GitSource$outboundSchema.parse(gitSource));
}
export function gitSourceFromJSON(
  jsonString: string,
): SafeParseResult<GitSource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSource' from JSON`,
  );
}

/** @internal */
export const Framework$inboundSchema: z.ZodNativeEnum<typeof Framework> = z
  .nativeEnum(Framework);
/** @internal */
export const Framework$outboundSchema: z.ZodNativeEnum<typeof Framework> =
  Framework$inboundSchema;

/** @internal */
export const NodeVersion$inboundSchema: z.ZodNativeEnum<typeof NodeVersion> = z
  .nativeEnum(NodeVersion);
/** @internal */
export const NodeVersion$outboundSchema: z.ZodNativeEnum<typeof NodeVersion> =
  NodeVersion$inboundSchema;

/** @internal */
export const ProjectSettings$inboundSchema: z.ZodType<
  ProjectSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  buildCommand: z.nullable(types.string()).optional(),
  commandForIgnoringBuildStep: z.nullable(types.string()).optional(),
  devCommand: z.nullable(types.string()).optional(),
  framework: z.nullable(Framework$inboundSchema).optional(),
  installCommand: z.nullable(types.string()).optional(),
  nodeVersion: types.optional(NodeVersion$inboundSchema),
  outputDirectory: z.nullable(types.string()).optional(),
  rootDirectory: z.nullable(types.string()).optional(),
  serverlessFunctionRegion: z.nullable(types.string()).optional(),
  skipGitConnectDuringLink: types.optional(types.boolean()),
  sourceFilesOutsideRootDirectory: types.optional(types.boolean()),
});
/** @internal */
export type ProjectSettings$Outbound = {
  buildCommand?: string | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  devCommand?: string | null | undefined;
  framework?: string | null | undefined;
  installCommand?: string | null | undefined;
  nodeVersion?: string | undefined;
  outputDirectory?: string | null | undefined;
  rootDirectory?: string | null | undefined;
  serverlessFunctionRegion?: string | null | undefined;
  skipGitConnectDuringLink?: boolean | undefined;
  sourceFilesOutsideRootDirectory?: boolean | undefined;
};

/** @internal */
export const ProjectSettings$outboundSchema: z.ZodType<
  ProjectSettings$Outbound,
  z.ZodTypeDef,
  ProjectSettings
> = z.object({
  buildCommand: z.nullable(z.string()).optional(),
  commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
  devCommand: z.nullable(z.string()).optional(),
  framework: z.nullable(Framework$outboundSchema).optional(),
  installCommand: z.nullable(z.string()).optional(),
  nodeVersion: NodeVersion$outboundSchema.optional(),
  outputDirectory: z.nullable(z.string()).optional(),
  rootDirectory: z.nullable(z.string()).optional(),
  serverlessFunctionRegion: z.nullable(z.string()).optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
});

export function projectSettingsToJSON(
  projectSettings: ProjectSettings,
): string {
  return JSON.stringify(ProjectSettings$outboundSchema.parse(projectSettings));
}
export function projectSettingsFromJSON(
  jsonString: string,
): SafeParseResult<ProjectSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProjectSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProjectSettings' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentRequestBody$inboundSchema: z.ZodType<
  CreateDeploymentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  customEnvironmentSlugOrId: types.optional(types.string()),
  deploymentId: types.optional(types.string()),
  files: types.optional(
    z.array(smartUnion([
      z.lazy(() => InlinedFile$inboundSchema),
      z.lazy(() =>
        UploadedFile$inboundSchema
      ),
    ])),
  ),
  gitMetadata: types.optional(z.lazy(() => GitMetadata$inboundSchema)),
  gitSource: types.optional(
    smartUnion([
      z.lazy(() => GitSource2$inboundSchema),
      z.lazy(() => GitSource4$inboundSchema),
      z.lazy(() => GitSource7$inboundSchema),
      z.lazy(() => GitSource1$inboundSchema),
      z.lazy(() => GitSource3$inboundSchema),
      z.lazy(() => GitSource5$inboundSchema),
      z.lazy(() => GitSource6$inboundSchema),
    ]),
  ),
  meta: types.optional(z.record(types.string())),
  monorepoManager: z.nullable(types.string()).optional(),
  name: types.string(),
  project: types.optional(types.string()),
  projectSettings: types.optional(z.lazy(() => ProjectSettings$inboundSchema)),
  target: types.optional(types.string()),
  withLatestCommit: types.optional(types.boolean()),
});
/** @internal */
export type CreateDeploymentRequestBody$Outbound = {
  customEnvironmentSlugOrId?: string | undefined;
  deploymentId?: string | undefined;
  files?: Array<InlinedFile$Outbound | UploadedFile$Outbound> | undefined;
  gitMetadata?: GitMetadata$Outbound | undefined;
  gitSource?:
    | GitSource2$Outbound
    | GitSource4$Outbound
    | GitSource7$Outbound
    | GitSource1$Outbound
    | GitSource3$Outbound
    | GitSource5$Outbound
    | GitSource6$Outbound
    | undefined;
  meta?: { [k: string]: string } | undefined;
  monorepoManager?: string | null | undefined;
  name: string;
  project?: string | undefined;
  projectSettings?: ProjectSettings$Outbound | undefined;
  target?: string | undefined;
  withLatestCommit?: boolean | undefined;
};

/** @internal */
export const CreateDeploymentRequestBody$outboundSchema: z.ZodType<
  CreateDeploymentRequestBody$Outbound,
  z.ZodTypeDef,
  CreateDeploymentRequestBody
> = z.object({
  customEnvironmentSlugOrId: z.string().optional(),
  deploymentId: z.string().optional(),
  files: z.array(
    smartUnion([
      z.lazy(() => InlinedFile$outboundSchema),
      z.lazy(() => UploadedFile$outboundSchema),
    ]),
  ).optional(),
  gitMetadata: z.lazy(() => GitMetadata$outboundSchema).optional(),
  gitSource: smartUnion([
    z.lazy(() => GitSource2$outboundSchema),
    z.lazy(() => GitSource4$outboundSchema),
    z.lazy(() => GitSource7$outboundSchema),
    z.lazy(() => GitSource1$outboundSchema),
    z.lazy(() => GitSource3$outboundSchema),
    z.lazy(() => GitSource5$outboundSchema),
    z.lazy(() => GitSource6$outboundSchema),
  ]).optional(),
  meta: z.record(z.string()).optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  name: z.string(),
  project: z.string().optional(),
  projectSettings: z.lazy(() => ProjectSettings$outboundSchema).optional(),
  target: z.string().optional(),
  withLatestCommit: z.boolean().optional(),
});

export function createDeploymentRequestBodyToJSON(
  createDeploymentRequestBody: CreateDeploymentRequestBody,
): string {
  return JSON.stringify(
    CreateDeploymentRequestBody$outboundSchema.parse(
      createDeploymentRequestBody,
    ),
  );
}
export function createDeploymentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentRequest$inboundSchema: z.ZodType<
  CreateDeploymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  forceNew: types.optional(ForceNew$inboundSchema),
  skipAutoDetectionConfirmation: types.optional(
    SkipAutoDetectionConfirmation$inboundSchema,
  ),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: z.lazy(() => CreateDeploymentRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateDeploymentRequest$Outbound = {
  forceNew?: string | undefined;
  skipAutoDetectionConfirmation?: string | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody: CreateDeploymentRequestBody$Outbound;
};

/** @internal */
export const CreateDeploymentRequest$outboundSchema: z.ZodType<
  CreateDeploymentRequest$Outbound,
  z.ZodTypeDef,
  CreateDeploymentRequest
> = z.object({
  forceNew: ForceNew$outboundSchema.optional(),
  skipAutoDetectionConfirmation: SkipAutoDetectionConfirmation$outboundSchema
    .optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => CreateDeploymentRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function createDeploymentRequestToJSON(
  createDeploymentRequest: CreateDeploymentRequest,
): string {
  return JSON.stringify(
    CreateDeploymentRequest$outboundSchema.parse(createDeploymentRequest),
  );
}
export function createDeploymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentRequest' from JSON`,
  );
}

/** @internal */
export const AliasAssignedAt$inboundSchema: z.ZodType<
  AliasAssignedAt,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.number(), types.boolean()]);
/** @internal */
export type AliasAssignedAt$Outbound = number | boolean;

/** @internal */
export const AliasAssignedAt$outboundSchema: z.ZodType<
  AliasAssignedAt$Outbound,
  z.ZodTypeDef,
  AliasAssignedAt
> = smartUnion([z.number(), z.boolean()]);

export function aliasAssignedAtToJSON(
  aliasAssignedAt: AliasAssignedAt,
): string {
  return JSON.stringify(AliasAssignedAt$outboundSchema.parse(aliasAssignedAt));
}
export function aliasAssignedAtFromJSON(
  jsonString: string,
): SafeParseResult<AliasAssignedAt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AliasAssignedAt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AliasAssignedAt' from JSON`,
  );
}

/** @internal */
export const Build$inboundSchema: z.ZodType<Build, z.ZodTypeDef, unknown> = z
  .object({
    env: z.array(types.string()),
  });
/** @internal */
export type Build$Outbound = {
  env: Array<string>;
};

/** @internal */
export const Build$outboundSchema: z.ZodType<
  Build$Outbound,
  z.ZodTypeDef,
  Build
> = z.object({
  env: z.array(z.string()),
});

export function buildToJSON(build: Build): string {
  return JSON.stringify(Build$outboundSchema.parse(build));
}
export function buildFromJSON(
  jsonString: string,
): SafeParseResult<Build, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Build$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Build' from JSON`,
  );
}

/** @internal */
export const Builds$inboundSchema: z.ZodType<Builds, z.ZodTypeDef, unknown> = z
  .object({
    use: types.string(),
    src: types.optional(types.string()),
    config: types.optional(z.record(z.any())),
  });
/** @internal */
export type Builds$Outbound = {
  use: string;
  src?: string | undefined;
  config?: { [k: string]: any } | undefined;
};

/** @internal */
export const Builds$outboundSchema: z.ZodType<
  Builds$Outbound,
  z.ZodTypeDef,
  Builds
> = z.object({
  use: z.string(),
  src: z.string().optional(),
  config: z.record(z.any()).optional(),
});

export function buildsToJSON(builds: Builds): string {
  return JSON.stringify(Builds$outboundSchema.parse(builds));
}
export function buildsFromJSON(
  jsonString: string,
): SafeParseResult<Builds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Builds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Builds' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentDeploymentsNodeVersion$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentDeploymentsNodeVersion> = z.nativeEnum(
    CreateDeploymentDeploymentsNodeVersion,
  );
/** @internal */
export const CreateDeploymentDeploymentsNodeVersion$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentDeploymentsNodeVersion> =
    CreateDeploymentDeploymentsNodeVersion$inboundSchema;

/** @internal */
export const CreateDeploymentFramework$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentFramework
> = z.nativeEnum(CreateDeploymentFramework);
/** @internal */
export const CreateDeploymentFramework$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentFramework
> = CreateDeploymentFramework$inboundSchema;

/** @internal */
export const CreateDeploymentSpeedInsights$inboundSchema: z.ZodType<
  CreateDeploymentSpeedInsights,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  enabledAt: types.optional(types.number()),
  disabledAt: types.optional(types.number()),
  canceledAt: types.optional(types.number()),
  hasData: types.optional(types.boolean()),
  paidAt: types.optional(types.number()),
});
/** @internal */
export type CreateDeploymentSpeedInsights$Outbound = {
  id: string;
  enabledAt?: number | undefined;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  hasData?: boolean | undefined;
  paidAt?: number | undefined;
};

/** @internal */
export const CreateDeploymentSpeedInsights$outboundSchema: z.ZodType<
  CreateDeploymentSpeedInsights$Outbound,
  z.ZodTypeDef,
  CreateDeploymentSpeedInsights
> = z.object({
  id: z.string(),
  enabledAt: z.number().optional(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  hasData: z.boolean().optional(),
  paidAt: z.number().optional(),
});

export function createDeploymentSpeedInsightsToJSON(
  createDeploymentSpeedInsights: CreateDeploymentSpeedInsights,
): string {
  return JSON.stringify(
    CreateDeploymentSpeedInsights$outboundSchema.parse(
      createDeploymentSpeedInsights,
    ),
  );
}
export function createDeploymentSpeedInsightsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentSpeedInsights, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentSpeedInsights$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentSpeedInsights' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentWebAnalytics$inboundSchema: z.ZodType<
  CreateDeploymentWebAnalytics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  disabledAt: types.optional(types.number()),
  canceledAt: types.optional(types.number()),
  enabledAt: types.optional(types.number()),
  hasData: types.optional(types.boolean()),
});
/** @internal */
export type CreateDeploymentWebAnalytics$Outbound = {
  id: string;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  enabledAt?: number | undefined;
  hasData?: boolean | undefined;
};

/** @internal */
export const CreateDeploymentWebAnalytics$outboundSchema: z.ZodType<
  CreateDeploymentWebAnalytics$Outbound,
  z.ZodTypeDef,
  CreateDeploymentWebAnalytics
> = z.object({
  id: z.string(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  enabledAt: z.number().optional(),
  hasData: z.boolean().optional(),
});

export function createDeploymentWebAnalyticsToJSON(
  createDeploymentWebAnalytics: CreateDeploymentWebAnalytics,
): string {
  return JSON.stringify(
    CreateDeploymentWebAnalytics$outboundSchema.parse(
      createDeploymentWebAnalytics,
    ),
  );
}
export function createDeploymentWebAnalyticsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentWebAnalytics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentWebAnalytics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentWebAnalytics' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentProjectSettings$inboundSchema: z.ZodType<
  CreateDeploymentProjectSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  nodeVersion: types.optional(
    CreateDeploymentDeploymentsNodeVersion$inboundSchema,
  ),
  buildCommand: z.nullable(types.string()).optional(),
  devCommand: z.nullable(types.string()).optional(),
  framework: z.nullable(CreateDeploymentFramework$inboundSchema).optional(),
  commandForIgnoringBuildStep: z.nullable(types.string()).optional(),
  installCommand: z.nullable(types.string()).optional(),
  outputDirectory: z.nullable(types.string()).optional(),
  speedInsights: types.optional(
    z.lazy(() => CreateDeploymentSpeedInsights$inboundSchema),
  ),
  webAnalytics: types.optional(
    z.lazy(() => CreateDeploymentWebAnalytics$inboundSchema),
  ),
});
/** @internal */
export type CreateDeploymentProjectSettings$Outbound = {
  nodeVersion?: string | undefined;
  buildCommand?: string | null | undefined;
  devCommand?: string | null | undefined;
  framework?: string | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  installCommand?: string | null | undefined;
  outputDirectory?: string | null | undefined;
  speedInsights?: CreateDeploymentSpeedInsights$Outbound | undefined;
  webAnalytics?: CreateDeploymentWebAnalytics$Outbound | undefined;
};

/** @internal */
export const CreateDeploymentProjectSettings$outboundSchema: z.ZodType<
  CreateDeploymentProjectSettings$Outbound,
  z.ZodTypeDef,
  CreateDeploymentProjectSettings
> = z.object({
  nodeVersion: CreateDeploymentDeploymentsNodeVersion$outboundSchema.optional(),
  buildCommand: z.nullable(z.string()).optional(),
  devCommand: z.nullable(z.string()).optional(),
  framework: z.nullable(CreateDeploymentFramework$outboundSchema).optional(),
  commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
  installCommand: z.nullable(z.string()).optional(),
  outputDirectory: z.nullable(z.string()).optional(),
  speedInsights: z.lazy(() => CreateDeploymentSpeedInsights$outboundSchema)
    .optional(),
  webAnalytics: z.lazy(() => CreateDeploymentWebAnalytics$outboundSchema)
    .optional(),
});

export function createDeploymentProjectSettingsToJSON(
  createDeploymentProjectSettings: CreateDeploymentProjectSettings,
): string {
  return JSON.stringify(
    CreateDeploymentProjectSettings$outboundSchema.parse(
      createDeploymentProjectSettings,
    ),
  );
}
export function createDeploymentProjectSettingsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentProjectSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentProjectSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentProjectSettings' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentDeploymentsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsStatus
> = z.nativeEnum(CreateDeploymentDeploymentsStatus);
/** @internal */
export const CreateDeploymentDeploymentsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsStatus
> = CreateDeploymentDeploymentsStatus$inboundSchema;

/** @internal */
export const Integrations$inboundSchema: z.ZodType<
  Integrations,
  z.ZodTypeDef,
  unknown
> = z.object({
  status: CreateDeploymentDeploymentsStatus$inboundSchema,
  startedAt: types.number(),
  completedAt: types.optional(types.number()),
  skippedAt: types.optional(types.number()),
  skippedBy: types.optional(types.string()),
});
/** @internal */
export type Integrations$Outbound = {
  status: string;
  startedAt: number;
  completedAt?: number | undefined;
  skippedAt?: number | undefined;
  skippedBy?: string | undefined;
};

/** @internal */
export const Integrations$outboundSchema: z.ZodType<
  Integrations$Outbound,
  z.ZodTypeDef,
  Integrations
> = z.object({
  status: CreateDeploymentDeploymentsStatus$outboundSchema,
  startedAt: z.number(),
  completedAt: z.number().optional(),
  skippedAt: z.number().optional(),
  skippedBy: z.string().optional(),
});

export function integrationsToJSON(integrations: Integrations): string {
  return JSON.stringify(Integrations$outboundSchema.parse(integrations));
}
export function integrationsFromJSON(
  jsonString: string,
): SafeParseResult<Integrations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Integrations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Integrations' from JSON`,
  );
}

/** @internal */
export const Protocol$inboundSchema: z.ZodNativeEnum<typeof Protocol> = z
  .nativeEnum(Protocol);
/** @internal */
export const Protocol$outboundSchema: z.ZodNativeEnum<typeof Protocol> =
  Protocol$inboundSchema;

/** @internal */
export const RemotePatterns$inboundSchema: z.ZodType<
  RemotePatterns,
  z.ZodTypeDef,
  unknown
> = z.object({
  protocol: types.optional(Protocol$inboundSchema),
  hostname: types.string(),
  port: types.optional(types.string()),
  pathname: types.optional(types.string()),
  search: types.optional(types.string()),
});
/** @internal */
export type RemotePatterns$Outbound = {
  protocol?: string | undefined;
  hostname: string;
  port?: string | undefined;
  pathname?: string | undefined;
  search?: string | undefined;
};

/** @internal */
export const RemotePatterns$outboundSchema: z.ZodType<
  RemotePatterns$Outbound,
  z.ZodTypeDef,
  RemotePatterns
> = z.object({
  protocol: Protocol$outboundSchema.optional(),
  hostname: z.string(),
  port: z.string().optional(),
  pathname: z.string().optional(),
  search: z.string().optional(),
});

export function remotePatternsToJSON(remotePatterns: RemotePatterns): string {
  return JSON.stringify(RemotePatterns$outboundSchema.parse(remotePatterns));
}
export function remotePatternsFromJSON(
  jsonString: string,
): SafeParseResult<RemotePatterns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RemotePatterns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RemotePatterns' from JSON`,
  );
}

/** @internal */
export const LocalPatterns$inboundSchema: z.ZodType<
  LocalPatterns,
  z.ZodTypeDef,
  unknown
> = z.object({
  pathname: types.optional(types.string()),
  search: types.optional(types.string()),
});
/** @internal */
export type LocalPatterns$Outbound = {
  pathname?: string | undefined;
  search?: string | undefined;
};

/** @internal */
export const LocalPatterns$outboundSchema: z.ZodType<
  LocalPatterns$Outbound,
  z.ZodTypeDef,
  LocalPatterns
> = z.object({
  pathname: z.string().optional(),
  search: z.string().optional(),
});

export function localPatternsToJSON(localPatterns: LocalPatterns): string {
  return JSON.stringify(LocalPatterns$outboundSchema.parse(localPatterns));
}
export function localPatternsFromJSON(
  jsonString: string,
): SafeParseResult<LocalPatterns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LocalPatterns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LocalPatterns' from JSON`,
  );
}

/** @internal */
export const Formats$inboundSchema: z.ZodNativeEnum<typeof Formats> = z
  .nativeEnum(Formats);
/** @internal */
export const Formats$outboundSchema: z.ZodNativeEnum<typeof Formats> =
  Formats$inboundSchema;

/** @internal */
export const ContentDispositionType$inboundSchema: z.ZodNativeEnum<
  typeof ContentDispositionType
> = z.nativeEnum(ContentDispositionType);
/** @internal */
export const ContentDispositionType$outboundSchema: z.ZodNativeEnum<
  typeof ContentDispositionType
> = ContentDispositionType$inboundSchema;

/** @internal */
export const Images$inboundSchema: z.ZodType<Images, z.ZodTypeDef, unknown> = z
  .object({
    sizes: types.optional(z.array(types.number())),
    qualities: types.optional(z.array(types.number())),
    domains: types.optional(z.array(types.string())),
    remotePatterns: types.optional(
      z.array(z.lazy(() => RemotePatterns$inboundSchema)),
    ),
    localPatterns: types.optional(
      z.array(z.lazy(() => LocalPatterns$inboundSchema)),
    ),
    minimumCacheTTL: types.optional(types.number()),
    formats: types.optional(z.array(Formats$inboundSchema)),
    dangerouslyAllowSVG: types.optional(types.boolean()),
    contentSecurityPolicy: types.optional(types.string()),
    contentDispositionType: types.optional(
      ContentDispositionType$inboundSchema,
    ),
  });
/** @internal */
export type Images$Outbound = {
  sizes?: Array<number> | undefined;
  qualities?: Array<number> | undefined;
  domains?: Array<string> | undefined;
  remotePatterns?: Array<RemotePatterns$Outbound> | undefined;
  localPatterns?: Array<LocalPatterns$Outbound> | undefined;
  minimumCacheTTL?: number | undefined;
  formats?: Array<string> | undefined;
  dangerouslyAllowSVG?: boolean | undefined;
  contentSecurityPolicy?: string | undefined;
  contentDispositionType?: string | undefined;
};

/** @internal */
export const Images$outboundSchema: z.ZodType<
  Images$Outbound,
  z.ZodTypeDef,
  Images
> = z.object({
  sizes: z.array(z.number()).optional(),
  qualities: z.array(z.number()).optional(),
  domains: z.array(z.string()).optional(),
  remotePatterns: z.array(z.lazy(() => RemotePatterns$outboundSchema))
    .optional(),
  localPatterns: z.array(z.lazy(() => LocalPatterns$outboundSchema)).optional(),
  minimumCacheTTL: z.number().optional(),
  formats: z.array(Formats$outboundSchema).optional(),
  dangerouslyAllowSVG: z.boolean().optional(),
  contentSecurityPolicy: z.string().optional(),
  contentDispositionType: ContentDispositionType$outboundSchema.optional(),
});

export function imagesToJSON(images: Images): string {
  return JSON.stringify(Images$outboundSchema.parse(images));
}
export function imagesFromJSON(
  jsonString: string,
): SafeParseResult<Images, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Images$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Images' from JSON`,
  );
}

/** @internal */
export const Creator$inboundSchema: z.ZodType<Creator, z.ZodTypeDef, unknown> =
  z.object({
    uid: types.string(),
    username: types.optional(types.string()),
    avatar: types.optional(types.string()),
  });
/** @internal */
export type Creator$Outbound = {
  uid: string;
  username?: string | undefined;
  avatar?: string | undefined;
};

/** @internal */
export const Creator$outboundSchema: z.ZodType<
  Creator$Outbound,
  z.ZodTypeDef,
  Creator
> = z.object({
  uid: z.string(),
  username: z.string().optional(),
  avatar: z.string().optional(),
});

export function creatorToJSON(creator: Creator): string {
  return JSON.stringify(Creator$outboundSchema.parse(creator));
}
export function creatorFromJSON(
  jsonString: string,
): SafeParseResult<Creator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Creator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Creator' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentReadyState$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentReadyState
> = z.nativeEnum(CreateDeploymentReadyState);
/** @internal */
export const CreateDeploymentReadyState$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentReadyState
> = CreateDeploymentReadyState$inboundSchema;

/** @internal */
export const CreateDeploymentOutput$inboundSchema: z.ZodType<
  CreateDeploymentOutput,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: types.string(),
  functionName: types.string(),
});
/** @internal */
export type CreateDeploymentOutput$Outbound = {
  path: string;
  functionName: string;
};

/** @internal */
export const CreateDeploymentOutput$outboundSchema: z.ZodType<
  CreateDeploymentOutput$Outbound,
  z.ZodTypeDef,
  CreateDeploymentOutput
> = z.object({
  path: z.string(),
  functionName: z.string(),
});

export function createDeploymentOutputToJSON(
  createDeploymentOutput: CreateDeploymentOutput,
): string {
  return JSON.stringify(
    CreateDeploymentOutput$outboundSchema.parse(createDeploymentOutput),
  );
}
export function createDeploymentOutputFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentOutput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentOutput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentOutput' from JSON`,
  );
}

/** @internal */
export const Lambdas$inboundSchema: z.ZodType<Lambdas, z.ZodTypeDef, unknown> =
  z.object({
    id: types.string(),
    createdAt: types.optional(types.number()),
    readyState: types.optional(CreateDeploymentReadyState$inboundSchema),
    entrypoint: z.nullable(types.string()).optional(),
    readyStateAt: types.optional(types.number()),
    output: z.array(z.lazy(() => CreateDeploymentOutput$inboundSchema)),
  });
/** @internal */
export type Lambdas$Outbound = {
  id: string;
  createdAt?: number | undefined;
  readyState?: string | undefined;
  entrypoint?: string | null | undefined;
  readyStateAt?: number | undefined;
  output: Array<CreateDeploymentOutput$Outbound>;
};

/** @internal */
export const Lambdas$outboundSchema: z.ZodType<
  Lambdas$Outbound,
  z.ZodTypeDef,
  Lambdas
> = z.object({
  id: z.string(),
  createdAt: z.number().optional(),
  readyState: CreateDeploymentReadyState$outboundSchema.optional(),
  entrypoint: z.nullable(z.string()).optional(),
  readyStateAt: z.number().optional(),
  output: z.array(z.lazy(() => CreateDeploymentOutput$outboundSchema)),
});

export function lambdasToJSON(lambdas: Lambdas): string {
  return JSON.stringify(Lambdas$outboundSchema.parse(lambdas));
}
export function lambdasFromJSON(
  jsonString: string,
): SafeParseResult<Lambdas, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lambdas$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lambdas' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentStatus
> = z.nativeEnum(CreateDeploymentStatus);
/** @internal */
export const CreateDeploymentStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentStatus
> = CreateDeploymentStatus$inboundSchema;

/** @internal */
export const CreateDeploymentTeam$inboundSchema: z.ZodType<
  CreateDeploymentTeam,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
  slug: types.string(),
  avatar: types.optional(types.string()),
});
/** @internal */
export type CreateDeploymentTeam$Outbound = {
  id: string;
  name: string;
  slug: string;
  avatar?: string | undefined;
};

/** @internal */
export const CreateDeploymentTeam$outboundSchema: z.ZodType<
  CreateDeploymentTeam$Outbound,
  z.ZodTypeDef,
  CreateDeploymentTeam
> = z.object({
  id: z.string(),
  name: z.string(),
  slug: z.string(),
  avatar: z.string().optional(),
});

export function createDeploymentTeamToJSON(
  createDeploymentTeam: CreateDeploymentTeam,
): string {
  return JSON.stringify(
    CreateDeploymentTeam$outboundSchema.parse(createDeploymentTeam),
  );
}
export function createDeploymentTeamFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentTeam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentTeam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentTeam' from JSON`,
  );
}

/** @internal */
export const CustomEnvironment2$inboundSchema: z.ZodType<
  CustomEnvironment2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
});
/** @internal */
export type CustomEnvironment2$Outbound = {
  id: string;
};

/** @internal */
export const CustomEnvironment2$outboundSchema: z.ZodType<
  CustomEnvironment2$Outbound,
  z.ZodTypeDef,
  CustomEnvironment2
> = z.object({
  id: z.string(),
});

export function customEnvironment2ToJSON(
  customEnvironment2: CustomEnvironment2,
): string {
  return JSON.stringify(
    CustomEnvironment2$outboundSchema.parse(customEnvironment2),
  );
}
export function customEnvironment2FromJSON(
  jsonString: string,
): SafeParseResult<CustomEnvironment2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomEnvironment2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomEnvironment2' from JSON`,
  );
}

/** @internal */
export const CustomEnvironmentType$inboundSchema: z.ZodNativeEnum<
  typeof CustomEnvironmentType
> = z.nativeEnum(CustomEnvironmentType);
/** @internal */
export const CustomEnvironmentType$outboundSchema: z.ZodNativeEnum<
  typeof CustomEnvironmentType
> = CustomEnvironmentType$inboundSchema;

/** @internal */
export const CreateDeploymentCustomEnvironmentType$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentCustomEnvironmentType> = z.nativeEnum(
    CreateDeploymentCustomEnvironmentType,
  );
/** @internal */
export const CreateDeploymentCustomEnvironmentType$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentCustomEnvironmentType> =
    CreateDeploymentCustomEnvironmentType$inboundSchema;

/** @internal */
export const CreateDeploymentCustomEnvironmentBranchMatcher$inboundSchema:
  z.ZodType<
    CreateDeploymentCustomEnvironmentBranchMatcher,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateDeploymentCustomEnvironmentType$inboundSchema,
    pattern: types.string(),
  });
/** @internal */
export type CreateDeploymentCustomEnvironmentBranchMatcher$Outbound = {
  type: string;
  pattern: string;
};

/** @internal */
export const CreateDeploymentCustomEnvironmentBranchMatcher$outboundSchema:
  z.ZodType<
    CreateDeploymentCustomEnvironmentBranchMatcher$Outbound,
    z.ZodTypeDef,
    CreateDeploymentCustomEnvironmentBranchMatcher
  > = z.object({
    type: CreateDeploymentCustomEnvironmentType$outboundSchema,
    pattern: z.string(),
  });

export function createDeploymentCustomEnvironmentBranchMatcherToJSON(
  createDeploymentCustomEnvironmentBranchMatcher:
    CreateDeploymentCustomEnvironmentBranchMatcher,
): string {
  return JSON.stringify(
    CreateDeploymentCustomEnvironmentBranchMatcher$outboundSchema.parse(
      createDeploymentCustomEnvironmentBranchMatcher,
    ),
  );
}
export function createDeploymentCustomEnvironmentBranchMatcherFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentCustomEnvironmentBranchMatcher,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentCustomEnvironmentBranchMatcher$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentCustomEnvironmentBranchMatcher' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentCustomEnvironmentVerification$inboundSchema:
  z.ZodType<
    CreateDeploymentCustomEnvironmentVerification,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: types.string(),
    domain: types.string(),
    value: types.string(),
    reason: types.string(),
  });
/** @internal */
export type CreateDeploymentCustomEnvironmentVerification$Outbound = {
  type: string;
  domain: string;
  value: string;
  reason: string;
};

/** @internal */
export const CreateDeploymentCustomEnvironmentVerification$outboundSchema:
  z.ZodType<
    CreateDeploymentCustomEnvironmentVerification$Outbound,
    z.ZodTypeDef,
    CreateDeploymentCustomEnvironmentVerification
  > = z.object({
    type: z.string(),
    domain: z.string(),
    value: z.string(),
    reason: z.string(),
  });

export function createDeploymentCustomEnvironmentVerificationToJSON(
  createDeploymentCustomEnvironmentVerification:
    CreateDeploymentCustomEnvironmentVerification,
): string {
  return JSON.stringify(
    CreateDeploymentCustomEnvironmentVerification$outboundSchema.parse(
      createDeploymentCustomEnvironmentVerification,
    ),
  );
}
export function createDeploymentCustomEnvironmentVerificationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentCustomEnvironmentVerification,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentCustomEnvironmentVerification$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentCustomEnvironmentVerification' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentCustomEnvironmentDomains$inboundSchema: z.ZodType<
  CreateDeploymentCustomEnvironmentDomains,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.string(),
  apexName: types.string(),
  projectId: types.string(),
  redirect: z.nullable(types.string()).optional(),
  redirectStatusCode: z.nullable(types.number()).optional(),
  gitBranch: z.nullable(types.string()).optional(),
  customEnvironmentId: z.nullable(types.string()).optional(),
  updatedAt: types.optional(types.number()),
  createdAt: types.optional(types.number()),
  verified: types.boolean(),
  verification: types.optional(
    z.array(z.lazy(() =>
      CreateDeploymentCustomEnvironmentVerification$inboundSchema
    )),
  ),
});
/** @internal */
export type CreateDeploymentCustomEnvironmentDomains$Outbound = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
  gitBranch?: string | null | undefined;
  customEnvironmentId?: string | null | undefined;
  updatedAt?: number | undefined;
  createdAt?: number | undefined;
  verified: boolean;
  verification?:
    | Array<CreateDeploymentCustomEnvironmentVerification$Outbound>
    | undefined;
};

/** @internal */
export const CreateDeploymentCustomEnvironmentDomains$outboundSchema: z.ZodType<
  CreateDeploymentCustomEnvironmentDomains$Outbound,
  z.ZodTypeDef,
  CreateDeploymentCustomEnvironmentDomains
> = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.nullable(z.string()).optional(),
  redirectStatusCode: z.nullable(z.number()).optional(),
  gitBranch: z.nullable(z.string()).optional(),
  customEnvironmentId: z.nullable(z.string()).optional(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z.boolean(),
  verification: z.array(
    z.lazy(() => CreateDeploymentCustomEnvironmentVerification$outboundSchema),
  ).optional(),
});

export function createDeploymentCustomEnvironmentDomainsToJSON(
  createDeploymentCustomEnvironmentDomains:
    CreateDeploymentCustomEnvironmentDomains,
): string {
  return JSON.stringify(
    CreateDeploymentCustomEnvironmentDomains$outboundSchema.parse(
      createDeploymentCustomEnvironmentDomains,
    ),
  );
}
export function createDeploymentCustomEnvironmentDomainsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentCustomEnvironmentDomains,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentCustomEnvironmentDomains$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentCustomEnvironmentDomains' from JSON`,
  );
}

/** @internal */
export const CustomEnvironment1$inboundSchema: z.ZodType<
  CustomEnvironment1,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  slug: types.string(),
  type: CustomEnvironmentType$inboundSchema,
  description: types.optional(types.string()),
  branchMatcher: types.optional(
    z.lazy(() => CreateDeploymentCustomEnvironmentBranchMatcher$inboundSchema),
  ),
  domains: types.optional(
    z.array(
      z.lazy(() => CreateDeploymentCustomEnvironmentDomains$inboundSchema),
    ),
  ),
  currentDeploymentAliases: types.optional(z.array(types.string())),
  createdAt: types.number(),
  updatedAt: types.number(),
});
/** @internal */
export type CustomEnvironment1$Outbound = {
  id: string;
  slug: string;
  type: string;
  description?: string | undefined;
  branchMatcher?:
    | CreateDeploymentCustomEnvironmentBranchMatcher$Outbound
    | undefined;
  domains?:
    | Array<CreateDeploymentCustomEnvironmentDomains$Outbound>
    | undefined;
  currentDeploymentAliases?: Array<string> | undefined;
  createdAt: number;
  updatedAt: number;
};

/** @internal */
export const CustomEnvironment1$outboundSchema: z.ZodType<
  CustomEnvironment1$Outbound,
  z.ZodTypeDef,
  CustomEnvironment1
> = z.object({
  id: z.string(),
  slug: z.string(),
  type: CustomEnvironmentType$outboundSchema,
  description: z.string().optional(),
  branchMatcher: z.lazy(() =>
    CreateDeploymentCustomEnvironmentBranchMatcher$outboundSchema
  ).optional(),
  domains: z.array(
    z.lazy(() => CreateDeploymentCustomEnvironmentDomains$outboundSchema),
  ).optional(),
  currentDeploymentAliases: z.array(z.string()).optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
});

export function customEnvironment1ToJSON(
  customEnvironment1: CustomEnvironment1,
): string {
  return JSON.stringify(
    CustomEnvironment1$outboundSchema.parse(customEnvironment1),
  );
}
export function customEnvironment1FromJSON(
  jsonString: string,
): SafeParseResult<CustomEnvironment1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomEnvironment1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomEnvironment1' from JSON`,
  );
}

/** @internal */
export const CustomEnvironment$inboundSchema: z.ZodType<
  CustomEnvironment,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => CustomEnvironment1$inboundSchema),
  z.lazy(() => CustomEnvironment2$inboundSchema),
]);
/** @internal */
export type CustomEnvironment$Outbound =
  | CustomEnvironment1$Outbound
  | CustomEnvironment2$Outbound;

/** @internal */
export const CustomEnvironment$outboundSchema: z.ZodType<
  CustomEnvironment$Outbound,
  z.ZodTypeDef,
  CustomEnvironment
> = smartUnion([
  z.lazy(() => CustomEnvironment1$outboundSchema),
  z.lazy(() => CustomEnvironment2$outboundSchema),
]);

export function customEnvironmentToJSON(
  customEnvironment: CustomEnvironment,
): string {
  return JSON.stringify(
    CustomEnvironment$outboundSchema.parse(customEnvironment),
  );
}
export function customEnvironmentFromJSON(
  jsonString: string,
): SafeParseResult<CustomEnvironment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomEnvironment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomEnvironment' from JSON`,
  );
}

/** @internal */
export const OomReport$inboundSchema: z.ZodNativeEnum<typeof OomReport> = z
  .nativeEnum(OomReport);
/** @internal */
export const OomReport$outboundSchema: z.ZodNativeEnum<typeof OomReport> =
  OomReport$inboundSchema;

/** @internal */
export const AliasWarning$inboundSchema: z.ZodType<
  AliasWarning,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: types.string(),
  message: types.string(),
  link: types.optional(types.string()),
  action: types.optional(types.string()),
});
/** @internal */
export type AliasWarning$Outbound = {
  code: string;
  message: string;
  link?: string | undefined;
  action?: string | undefined;
};

/** @internal */
export const AliasWarning$outboundSchema: z.ZodType<
  AliasWarning$Outbound,
  z.ZodTypeDef,
  AliasWarning
> = z.object({
  code: z.string(),
  message: z.string(),
  link: z.string().optional(),
  action: z.string().optional(),
});

export function aliasWarningToJSON(aliasWarning: AliasWarning): string {
  return JSON.stringify(AliasWarning$outboundSchema.parse(aliasWarning));
}
export function aliasWarningFromJSON(
  jsonString: string,
): SafeParseResult<AliasWarning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AliasWarning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AliasWarning' from JSON`,
  );
}

/** @internal */
export const ReadyState$inboundSchema: z.ZodNativeEnum<typeof ReadyState> = z
  .nativeEnum(ReadyState);
/** @internal */
export const ReadyState$outboundSchema: z.ZodNativeEnum<typeof ReadyState> =
  ReadyState$inboundSchema;

/** @internal */
export const CreateDeploymentType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentType
> = z.nativeEnum(CreateDeploymentType);
/** @internal */
export const CreateDeploymentType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentType
> = CreateDeploymentType$inboundSchema;

/** @internal */
export const AliasError$inboundSchema: z.ZodType<
  AliasError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: types.string(),
  message: types.string(),
});
/** @internal */
export type AliasError$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const AliasError$outboundSchema: z.ZodType<
  AliasError$Outbound,
  z.ZodTypeDef,
  AliasError
> = z.object({
  code: z.string(),
  message: z.string(),
});

export function aliasErrorToJSON(aliasError: AliasError): string {
  return JSON.stringify(AliasError$outboundSchema.parse(aliasError));
}
export function aliasErrorFromJSON(
  jsonString: string,
): SafeParseResult<AliasError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AliasError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AliasError' from JSON`,
  );
}

/** @internal */
export const ChecksState$inboundSchema: z.ZodNativeEnum<typeof ChecksState> = z
  .nativeEnum(ChecksState);
/** @internal */
export const ChecksState$outboundSchema: z.ZodNativeEnum<typeof ChecksState> =
  ChecksState$inboundSchema;

/** @internal */
export const ChecksConclusion$inboundSchema: z.ZodNativeEnum<
  typeof ChecksConclusion
> = z.nativeEnum(ChecksConclusion);
/** @internal */
export const ChecksConclusion$outboundSchema: z.ZodNativeEnum<
  typeof ChecksConclusion
> = ChecksConclusion$inboundSchema;

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource15$inboundSchema: z.ZodType<
  CreateDeploymentGitSource15,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type$inboundSchema,
  ref: types.string(),
  sha: types.string(),
  owner: types.optional(types.string()),
  slug: types.optional(types.string()),
  workspaceUuid: types.string(),
  repoUuid: types.string(),
});
/** @internal */
export type CreateDeploymentGitSource15$Outbound = {
  type: string;
  ref: string;
  sha: string;
  owner?: string | undefined;
  slug?: string | undefined;
  workspaceUuid: string;
  repoUuid: string;
};

/** @internal */
export const CreateDeploymentGitSource15$outboundSchema: z.ZodType<
  CreateDeploymentGitSource15$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource15
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody15Type$outboundSchema,
  ref: z.string(),
  sha: z.string(),
  owner: z.string().optional(),
  slug: z.string().optional(),
  workspaceUuid: z.string(),
  repoUuid: z.string(),
});

export function createDeploymentGitSource15ToJSON(
  createDeploymentGitSource15: CreateDeploymentGitSource15,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource15$outboundSchema.parse(
      createDeploymentGitSource15,
    ),
  );
}
export function createDeploymentGitSource15FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource15, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource15$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource15' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource14$inboundSchema: z.ZodType<
  CreateDeploymentGitSource14,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type$inboundSchema,
  ref: types.string(),
  sha: types.string(),
  projectId: types.number(),
});
/** @internal */
export type CreateDeploymentGitSource14$Outbound = {
  type: string;
  ref: string;
  sha: string;
  projectId: number;
};

/** @internal */
export const CreateDeploymentGitSource14$outboundSchema: z.ZodType<
  CreateDeploymentGitSource14$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource14
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody14Type$outboundSchema,
  ref: z.string(),
  sha: z.string(),
  projectId: z.number(),
});

export function createDeploymentGitSource14ToJSON(
  createDeploymentGitSource14: CreateDeploymentGitSource14,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource14$outboundSchema.parse(
      createDeploymentGitSource14,
    ),
  );
}
export function createDeploymentGitSource14FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource14, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource14$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource14' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource13$inboundSchema: z.ZodType<
  CreateDeploymentGitSource13,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type$inboundSchema,
  ref: types.string(),
  sha: types.string(),
  repoId: types.number(),
  org: types.optional(types.string()),
  repo: types.optional(types.string()),
});
/** @internal */
export type CreateDeploymentGitSource13$Outbound = {
  type: string;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

/** @internal */
export const CreateDeploymentGitSource13$outboundSchema: z.ZodType<
  CreateDeploymentGitSource13$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource13
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody13Type$outboundSchema,
  ref: z.string(),
  sha: z.string(),
  repoId: z.number(),
  org: z.string().optional(),
  repo: z.string().optional(),
});

export function createDeploymentGitSource13ToJSON(
  createDeploymentGitSource13: CreateDeploymentGitSource13,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource13$outboundSchema.parse(
      createDeploymentGitSource13,
    ),
  );
}
export function createDeploymentGitSource13FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource13, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource13$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource13' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource12$inboundSchema: z.ZodType<
  CreateDeploymentGitSource12,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type$inboundSchema,
  host: types.string(),
  ref: types.string(),
  sha: types.string(),
  repoId: types.number(),
  org: types.optional(types.string()),
  repo: types.optional(types.string()),
});
/** @internal */
export type CreateDeploymentGitSource12$Outbound = {
  type: string;
  host: string;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

/** @internal */
export const CreateDeploymentGitSource12$outboundSchema: z.ZodType<
  CreateDeploymentGitSource12$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource12
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody12Type$outboundSchema,
  host: z.string(),
  ref: z.string(),
  sha: z.string(),
  repoId: z.number(),
  org: z.string().optional(),
  repo: z.string().optional(),
});

export function createDeploymentGitSource12ToJSON(
  createDeploymentGitSource12: CreateDeploymentGitSource12,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource12$outboundSchema.parse(
      createDeploymentGitSource12,
    ),
  );
}
export function createDeploymentGitSource12FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource12' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource11$inboundSchema: z.ZodType<
  CreateDeploymentGitSource11,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type$inboundSchema,
  ref: types.string(),
  sha: types.string(),
  repoId: types.number(),
  org: types.optional(types.string()),
  repo: types.optional(types.string()),
});
/** @internal */
export type CreateDeploymentGitSource11$Outbound = {
  type: string;
  ref: string;
  sha: string;
  repoId: number;
  org?: string | undefined;
  repo?: string | undefined;
};

/** @internal */
export const CreateDeploymentGitSource11$outboundSchema: z.ZodType<
  CreateDeploymentGitSource11$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource11
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody11Type$outboundSchema,
  ref: z.string(),
  sha: z.string(),
  repoId: z.number(),
  org: z.string().optional(),
  repo: z.string().optional(),
});

export function createDeploymentGitSource11ToJSON(
  createDeploymentGitSource11: CreateDeploymentGitSource11,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource11$outboundSchema.parse(
      createDeploymentGitSource11,
    ),
  );
}
export function createDeploymentGitSource11FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource11' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource10$inboundSchema: z.ZodType<
  CreateDeploymentGitSource10,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type$inboundSchema,
  ref: types.string(),
  sha: types.string(),
  gitUrl: types.string(),
});
/** @internal */
export type CreateDeploymentGitSource10$Outbound = {
  type: string;
  ref: string;
  sha: string;
  gitUrl: string;
};

/** @internal */
export const CreateDeploymentGitSource10$outboundSchema: z.ZodType<
  CreateDeploymentGitSource10$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource10
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody10Type$outboundSchema,
  ref: z.string(),
  sha: z.string(),
  gitUrl: z.string(),
});

export function createDeploymentGitSource10ToJSON(
  createDeploymentGitSource10: CreateDeploymentGitSource10,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource10$outboundSchema.parse(
      createDeploymentGitSource10,
    ),
  );
}
export function createDeploymentGitSource10FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource10' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource9$inboundSchema: z.ZodType<
  CreateDeploymentGitSource9,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$inboundSchema,
  owner: types.string(),
  slug: types.string(),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource9$Outbound = {
  type: string;
  owner: string;
  slug: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource9$outboundSchema: z.ZodType<
  CreateDeploymentGitSource9$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource9
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody9Type$outboundSchema,
  owner: z.string(),
  slug: z.string(),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource9ToJSON(
  createDeploymentGitSource9: CreateDeploymentGitSource9,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource9$outboundSchema.parse(createDeploymentGitSource9),
  );
}
export function createDeploymentGitSource9FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource9' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource8$inboundSchema: z.ZodType<
  CreateDeploymentGitSource8,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$inboundSchema,
  workspaceUuid: types.optional(types.string()),
  repoUuid: types.string(),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource8$Outbound = {
  type: string;
  workspaceUuid?: string | undefined;
  repoUuid: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource8$outboundSchema: z.ZodType<
  CreateDeploymentGitSource8$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource8
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody8Type$outboundSchema,
  workspaceUuid: z.string().optional(),
  repoUuid: z.string(),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource8ToJSON(
  createDeploymentGitSource8: CreateDeploymentGitSource8,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource8$outboundSchema.parse(createDeploymentGitSource8),
  );
}
export function createDeploymentGitSource8FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource8' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$inboundSchema;

/** @internal */
export const GitSourceProjectId$inboundSchema: z.ZodType<
  GitSourceProjectId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GitSourceProjectId$Outbound = string | number;

/** @internal */
export const GitSourceProjectId$outboundSchema: z.ZodType<
  GitSourceProjectId$Outbound,
  z.ZodTypeDef,
  GitSourceProjectId
> = smartUnion([z.string(), z.number()]);

export function gitSourceProjectIdToJSON(
  gitSourceProjectId: GitSourceProjectId,
): string {
  return JSON.stringify(
    GitSourceProjectId$outboundSchema.parse(gitSourceProjectId),
  );
}
export function gitSourceProjectIdFromJSON(
  jsonString: string,
): SafeParseResult<GitSourceProjectId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitSourceProjectId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitSourceProjectId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSource7$inboundSchema: z.ZodType<
  CreateDeploymentGitSource7,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$inboundSchema,
  projectId: smartUnion([types.string(), types.number()]),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource7$Outbound = {
  type: string;
  projectId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource7$outboundSchema: z.ZodType<
  CreateDeploymentGitSource7$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource7
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody7Type$outboundSchema,
  projectId: smartUnion([z.string(), z.number()]),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource7ToJSON(
  createDeploymentGitSource7: CreateDeploymentGitSource7,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource7$outboundSchema.parse(createDeploymentGitSource7),
  );
}
export function createDeploymentGitSource7FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource7' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource6$inboundSchema: z.ZodType<
  CreateDeploymentGitSource6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$inboundSchema,
  org: types.string(),
  repo: types.string(),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource6$Outbound = {
  type: string;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource6$outboundSchema: z.ZodType<
  CreateDeploymentGitSource6$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource6
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody6Type$outboundSchema,
  org: z.string(),
  repo: z.string(),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource6ToJSON(
  createDeploymentGitSource6: CreateDeploymentGitSource6,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource6$outboundSchema.parse(createDeploymentGitSource6),
  );
}
export function createDeploymentGitSource6FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource6' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponseRepoId$inboundSchema:
  z.ZodType<
    CreateDeploymentGitSourceDeploymentsResponseRepoId,
    z.ZodTypeDef,
    unknown
  > = smartUnion([types.string(), types.number()]);
/** @internal */
export type CreateDeploymentGitSourceDeploymentsResponseRepoId$Outbound =
  | string
  | number;

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponseRepoId$outboundSchema:
  z.ZodType<
    CreateDeploymentGitSourceDeploymentsResponseRepoId$Outbound,
    z.ZodTypeDef,
    CreateDeploymentGitSourceDeploymentsResponseRepoId
  > = smartUnion([z.string(), z.number()]);

export function createDeploymentGitSourceDeploymentsResponseRepoIdToJSON(
  createDeploymentGitSourceDeploymentsResponseRepoId:
    CreateDeploymentGitSourceDeploymentsResponseRepoId,
): string {
  return JSON.stringify(
    CreateDeploymentGitSourceDeploymentsResponseRepoId$outboundSchema.parse(
      createDeploymentGitSourceDeploymentsResponseRepoId,
    ),
  );
}
export function createDeploymentGitSourceDeploymentsResponseRepoIdFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentGitSourceDeploymentsResponseRepoId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentGitSourceDeploymentsResponseRepoId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentGitSourceDeploymentsResponseRepoId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSource5$inboundSchema: z.ZodType<
  CreateDeploymentGitSource5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$inboundSchema,
  repoId: smartUnion([types.string(), types.number()]),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource5$Outbound = {
  type: string;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource5$outboundSchema: z.ZodType<
  CreateDeploymentGitSource5$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource5
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBody5Type$outboundSchema,
  repoId: smartUnion([z.string(), z.number()]),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource5ToJSON(
  createDeploymentGitSource5: CreateDeploymentGitSource5,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource5$outboundSchema.parse(createDeploymentGitSource5),
  );
}
export function createDeploymentGitSource5FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource5' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource4$inboundSchema: z.ZodType<
  CreateDeploymentGitSource4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  host: types.string(),
  org: types.string(),
  repo: types.string(),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource4$Outbound = {
  type: string;
  host: string;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource4$outboundSchema: z.ZodType<
  CreateDeploymentGitSource4$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource4
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  host: z.string(),
  org: z.string(),
  repo: z.string(),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource4ToJSON(
  createDeploymentGitSource4: CreateDeploymentGitSource4,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource4$outboundSchema.parse(createDeploymentGitSource4),
  );
}
export function createDeploymentGitSource4FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource4' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType
  > = z.nativeEnum(
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType,
  );
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType
  > =
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRepoId$inboundSchema:
  z.ZodType<CreateDeploymentGitSourceDeploymentsRepoId, z.ZodTypeDef, unknown> =
    smartUnion([types.string(), types.number()]);
/** @internal */
export type CreateDeploymentGitSourceDeploymentsRepoId$Outbound =
  | string
  | number;

/** @internal */
export const CreateDeploymentGitSourceDeploymentsRepoId$outboundSchema:
  z.ZodType<
    CreateDeploymentGitSourceDeploymentsRepoId$Outbound,
    z.ZodTypeDef,
    CreateDeploymentGitSourceDeploymentsRepoId
  > = smartUnion([z.string(), z.number()]);

export function createDeploymentGitSourceDeploymentsRepoIdToJSON(
  createDeploymentGitSourceDeploymentsRepoId:
    CreateDeploymentGitSourceDeploymentsRepoId,
): string {
  return JSON.stringify(
    CreateDeploymentGitSourceDeploymentsRepoId$outboundSchema.parse(
      createDeploymentGitSourceDeploymentsRepoId,
    ),
  );
}
export function createDeploymentGitSourceDeploymentsRepoIdFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentGitSourceDeploymentsRepoId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentGitSourceDeploymentsRepoId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentGitSourceDeploymentsRepoId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSource3$inboundSchema: z.ZodType<
  CreateDeploymentGitSource3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$inboundSchema,
  host: types.string(),
  repoId: smartUnion([types.string(), types.number()]),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource3$Outbound = {
  type: string;
  host: string;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource3$outboundSchema: z.ZodType<
  CreateDeploymentGitSource3$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource3
> = z.object({
  type:
    CreateDeploymentGitSourceDeploymentsResponse200ApplicationJSONType$outboundSchema,
  host: z.string(),
  repoId: smartUnion([z.string(), z.number()]),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource3ToJSON(
  createDeploymentGitSource3: CreateDeploymentGitSource3,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource3$outboundSchema.parse(createDeploymentGitSource3),
  );
}
export function createDeploymentGitSource3FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource3' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsResponse200Type> =
    z.nativeEnum(CreateDeploymentGitSourceDeploymentsResponse200Type);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsResponse200Type> =
    CreateDeploymentGitSourceDeploymentsResponse200Type$inboundSchema;

/** @internal */
export const CreateDeploymentGitSource2$inboundSchema: z.ZodType<
  CreateDeploymentGitSource2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateDeploymentGitSourceDeploymentsResponse200Type$inboundSchema,
  org: types.string(),
  repo: types.string(),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource2$Outbound = {
  type: string;
  org: string;
  repo: string;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource2$outboundSchema: z.ZodType<
  CreateDeploymentGitSource2$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource2
> = z.object({
  type: CreateDeploymentGitSourceDeploymentsResponse200Type$outboundSchema,
  org: z.string(),
  repo: z.string(),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource2ToJSON(
  createDeploymentGitSource2: CreateDeploymentGitSource2,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource2$outboundSchema.parse(createDeploymentGitSource2),
  );
}
export function createDeploymentGitSource2FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource2' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsResponseType> = z
    .nativeEnum(CreateDeploymentGitSourceDeploymentsResponseType);
/** @internal */
export const CreateDeploymentGitSourceDeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateDeploymentGitSourceDeploymentsResponseType> =
    CreateDeploymentGitSourceDeploymentsResponseType$inboundSchema;

/** @internal */
export const CreateDeploymentGitSourceRepoId$inboundSchema: z.ZodType<
  CreateDeploymentGitSourceRepoId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type CreateDeploymentGitSourceRepoId$Outbound = string | number;

/** @internal */
export const CreateDeploymentGitSourceRepoId$outboundSchema: z.ZodType<
  CreateDeploymentGitSourceRepoId$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSourceRepoId
> = smartUnion([z.string(), z.number()]);

export function createDeploymentGitSourceRepoIdToJSON(
  createDeploymentGitSourceRepoId: CreateDeploymentGitSourceRepoId,
): string {
  return JSON.stringify(
    CreateDeploymentGitSourceRepoId$outboundSchema.parse(
      createDeploymentGitSourceRepoId,
    ),
  );
}
export function createDeploymentGitSourceRepoIdFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSourceRepoId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSourceRepoId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSourceRepoId' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSource1$inboundSchema: z.ZodType<
  CreateDeploymentGitSource1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateDeploymentGitSourceDeploymentsResponseType$inboundSchema,
  repoId: smartUnion([types.string(), types.number()]),
  ref: z.nullable(types.string()).optional(),
  sha: types.optional(types.string()),
  prId: z.nullable(types.number()).optional(),
});
/** @internal */
export type CreateDeploymentGitSource1$Outbound = {
  type: string;
  repoId: string | number;
  ref?: string | null | undefined;
  sha?: string | undefined;
  prId?: number | null | undefined;
};

/** @internal */
export const CreateDeploymentGitSource1$outboundSchema: z.ZodType<
  CreateDeploymentGitSource1$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource1
> = z.object({
  type: CreateDeploymentGitSourceDeploymentsResponseType$outboundSchema,
  repoId: smartUnion([z.string(), z.number()]),
  ref: z.nullable(z.string()).optional(),
  sha: z.string().optional(),
  prId: z.nullable(z.number()).optional(),
});

export function createDeploymentGitSource1ToJSON(
  createDeploymentGitSource1: CreateDeploymentGitSource1,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource1$outboundSchema.parse(createDeploymentGitSource1),
  );
}
export function createDeploymentGitSource1FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource1' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitSource$inboundSchema: z.ZodType<
  CreateDeploymentGitSource,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => CreateDeploymentGitSource12$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource15$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource4$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource10$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource11$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource13$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource14$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource2$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource3$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource6$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource9$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource1$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource5$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource7$inboundSchema),
  z.lazy(() => CreateDeploymentGitSource8$inboundSchema),
]);
/** @internal */
export type CreateDeploymentGitSource$Outbound =
  | CreateDeploymentGitSource12$Outbound
  | CreateDeploymentGitSource15$Outbound
  | CreateDeploymentGitSource4$Outbound
  | CreateDeploymentGitSource10$Outbound
  | CreateDeploymentGitSource11$Outbound
  | CreateDeploymentGitSource13$Outbound
  | CreateDeploymentGitSource14$Outbound
  | CreateDeploymentGitSource2$Outbound
  | CreateDeploymentGitSource3$Outbound
  | CreateDeploymentGitSource6$Outbound
  | CreateDeploymentGitSource9$Outbound
  | CreateDeploymentGitSource1$Outbound
  | CreateDeploymentGitSource5$Outbound
  | CreateDeploymentGitSource7$Outbound
  | CreateDeploymentGitSource8$Outbound;

/** @internal */
export const CreateDeploymentGitSource$outboundSchema: z.ZodType<
  CreateDeploymentGitSource$Outbound,
  z.ZodTypeDef,
  CreateDeploymentGitSource
> = smartUnion([
  z.lazy(() => CreateDeploymentGitSource12$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource15$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource4$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource10$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource11$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource13$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource14$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource2$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource3$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource6$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource9$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource1$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource5$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource7$outboundSchema),
  z.lazy(() => CreateDeploymentGitSource8$outboundSchema),
]);

export function createDeploymentGitSourceToJSON(
  createDeploymentGitSource: CreateDeploymentGitSource,
): string {
  return JSON.stringify(
    CreateDeploymentGitSource$outboundSchema.parse(createDeploymentGitSource),
  );
}
export function createDeploymentGitSourceFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentGitSource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentGitSource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentGitSource' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentState$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentState
> = z.nativeEnum(CreateDeploymentState);
/** @internal */
export const CreateDeploymentState$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentState
> = CreateDeploymentState$inboundSchema;

/** @internal */
export const ManualProvisioning$inboundSchema: z.ZodType<
  ManualProvisioning,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: CreateDeploymentState$inboundSchema,
  completedAt: types.optional(types.number()),
});
/** @internal */
export type ManualProvisioning$Outbound = {
  state: string;
  completedAt?: number | undefined;
};

/** @internal */
export const ManualProvisioning$outboundSchema: z.ZodType<
  ManualProvisioning$Outbound,
  z.ZodTypeDef,
  ManualProvisioning
> = z.object({
  state: CreateDeploymentState$outboundSchema,
  completedAt: z.number().optional(),
});

export function manualProvisioningToJSON(
  manualProvisioning: ManualProvisioning,
): string {
  return JSON.stringify(
    ManualProvisioning$outboundSchema.parse(manualProvisioning),
  );
}
export function manualProvisioningFromJSON(
  jsonString: string,
): SafeParseResult<ManualProvisioning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ManualProvisioning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ManualProvisioning' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentNodeVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentNodeVersion
> = z.nativeEnum(CreateDeploymentNodeVersion);
/** @internal */
export const CreateDeploymentNodeVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentNodeVersion
> = CreateDeploymentNodeVersion$inboundSchema;

/** @internal */
export const CreateDeploymentProject$inboundSchema: z.ZodType<
  CreateDeploymentProject,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
  framework: z.nullable(types.string()).optional(),
});
/** @internal */
export type CreateDeploymentProject$Outbound = {
  id: string;
  name: string;
  framework?: string | null | undefined;
};

/** @internal */
export const CreateDeploymentProject$outboundSchema: z.ZodType<
  CreateDeploymentProject$Outbound,
  z.ZodTypeDef,
  CreateDeploymentProject
> = z.object({
  id: z.string(),
  name: z.string(),
  framework: z.nullable(z.string()).optional(),
});

export function createDeploymentProjectToJSON(
  createDeploymentProject: CreateDeploymentProject,
): string {
  return JSON.stringify(
    CreateDeploymentProject$outboundSchema.parse(createDeploymentProject),
  );
}
export function createDeploymentProjectFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentProject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentProject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentProject' from JSON`,
  );
}

/** @internal */
export const ReadySubstate$inboundSchema: z.ZodNativeEnum<
  typeof ReadySubstate
> = z.nativeEnum(ReadySubstate);
/** @internal */
export const ReadySubstate$outboundSchema: z.ZodNativeEnum<
  typeof ReadySubstate
> = ReadySubstate$inboundSchema;

/** @internal */
export const CreateDeploymentSource$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentSource
> = z.nativeEnum(CreateDeploymentSource);
/** @internal */
export const CreateDeploymentSource$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentSource
> = CreateDeploymentSource$inboundSchema;

/** @internal */
export const CreateDeploymentTarget$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentTarget
> = z.nativeEnum(CreateDeploymentTarget);
/** @internal */
export const CreateDeploymentTarget$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentTarget
> = CreateDeploymentTarget$inboundSchema;

/** @internal */
export const OidcTokenClaims$inboundSchema: z.ZodType<
  OidcTokenClaims,
  z.ZodTypeDef,
  unknown
> = z.object({
  iss: types.string(),
  sub: types.string(),
  scope: types.string(),
  aud: types.string(),
  owner: types.string(),
  owner_id: types.string(),
  project: types.string(),
  project_id: types.string(),
  environment: types.string(),
  plan: types.optional(types.string()),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "project_id": "projectId",
  });
});
/** @internal */
export type OidcTokenClaims$Outbound = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  owner_id: string;
  project: string;
  project_id: string;
  environment: string;
  plan?: string | undefined;
};

/** @internal */
export const OidcTokenClaims$outboundSchema: z.ZodType<
  OidcTokenClaims$Outbound,
  z.ZodTypeDef,
  OidcTokenClaims
> = z.object({
  iss: z.string(),
  sub: z.string(),
  scope: z.string(),
  aud: z.string(),
  owner: z.string(),
  ownerId: z.string(),
  project: z.string(),
  projectId: z.string(),
  environment: z.string(),
  plan: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    projectId: "project_id",
  });
});

export function oidcTokenClaimsToJSON(
  oidcTokenClaims: OidcTokenClaims,
): string {
  return JSON.stringify(OidcTokenClaims$outboundSchema.parse(oidcTokenClaims));
}
export function oidcTokenClaimsFromJSON(
  jsonString: string,
): SafeParseResult<OidcTokenClaims, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OidcTokenClaims$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OidcTokenClaims' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentPlan$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentPlan
> = z.nativeEnum(CreateDeploymentPlan);
/** @internal */
export const CreateDeploymentPlan$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentPlan
> = CreateDeploymentPlan$inboundSchema;

/** @internal */
export const Crons$inboundSchema: z.ZodType<Crons, z.ZodTypeDef, unknown> = z
  .object({
    schedule: types.string(),
    path: types.string(),
  });
/** @internal */
export type Crons$Outbound = {
  schedule: string;
  path: string;
};

/** @internal */
export const Crons$outboundSchema: z.ZodType<
  Crons$Outbound,
  z.ZodTypeDef,
  Crons
> = z.object({
  schedule: z.string(),
  path: z.string(),
});

export function cronsToJSON(crons: Crons): string {
  return JSON.stringify(Crons$outboundSchema.parse(crons));
}
export function cronsFromJSON(
  jsonString: string,
): SafeParseResult<Crons, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Crons$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Crons' from JSON`,
  );
}

/** @internal */
export const Architecture$inboundSchema: z.ZodNativeEnum<typeof Architecture> =
  z.nativeEnum(Architecture);
/** @internal */
export const Architecture$outboundSchema: z.ZodNativeEnum<typeof Architecture> =
  Architecture$inboundSchema;

/** @internal */
export const CreateDeploymentDeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsType
> = z.nativeEnum(CreateDeploymentDeploymentsType);
/** @internal */
export const CreateDeploymentDeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsType
> = CreateDeploymentDeploymentsType$inboundSchema;

/** @internal */
export const ExperimentalTriggers$inboundSchema: z.ZodType<
  ExperimentalTriggers,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateDeploymentDeploymentsType$inboundSchema,
  topic: types.string(),
  consumer: types.string(),
  maxDeliveries: types.optional(types.number()),
  retryAfterSeconds: types.optional(types.number()),
  initialDelaySeconds: types.optional(types.number()),
  maxConcurrency: types.optional(types.number()),
});
/** @internal */
export type ExperimentalTriggers$Outbound = {
  type: string;
  topic: string;
  consumer: string;
  maxDeliveries?: number | undefined;
  retryAfterSeconds?: number | undefined;
  initialDelaySeconds?: number | undefined;
  maxConcurrency?: number | undefined;
};

/** @internal */
export const ExperimentalTriggers$outboundSchema: z.ZodType<
  ExperimentalTriggers$Outbound,
  z.ZodTypeDef,
  ExperimentalTriggers
> = z.object({
  type: CreateDeploymentDeploymentsType$outboundSchema,
  topic: z.string(),
  consumer: z.string(),
  maxDeliveries: z.number().optional(),
  retryAfterSeconds: z.number().optional(),
  initialDelaySeconds: z.number().optional(),
  maxConcurrency: z.number().optional(),
});

export function experimentalTriggersToJSON(
  experimentalTriggers: ExperimentalTriggers,
): string {
  return JSON.stringify(
    ExperimentalTriggers$outboundSchema.parse(experimentalTriggers),
  );
}
export function experimentalTriggersFromJSON(
  jsonString: string,
): SafeParseResult<ExperimentalTriggers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExperimentalTriggers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExperimentalTriggers' from JSON`,
  );
}

/** @internal */
export const Functions$inboundSchema: z.ZodType<
  Functions,
  z.ZodTypeDef,
  unknown
> = z.object({
  architecture: types.optional(Architecture$inboundSchema),
  memory: types.optional(types.number()),
  maxDuration: types.optional(types.number()),
  runtime: types.optional(types.string()),
  includeFiles: types.optional(types.string()),
  excludeFiles: types.optional(types.string()),
  experimentalTriggers: types.optional(
    z.array(z.lazy(() => ExperimentalTriggers$inboundSchema)),
  ),
  supportsCancellation: types.optional(types.boolean()),
});
/** @internal */
export type Functions$Outbound = {
  architecture?: string | undefined;
  memory?: number | undefined;
  maxDuration?: number | undefined;
  runtime?: string | undefined;
  includeFiles?: string | undefined;
  excludeFiles?: string | undefined;
  experimentalTriggers?: Array<ExperimentalTriggers$Outbound> | undefined;
  supportsCancellation?: boolean | undefined;
};

/** @internal */
export const Functions$outboundSchema: z.ZodType<
  Functions$Outbound,
  z.ZodTypeDef,
  Functions
> = z.object({
  architecture: Architecture$outboundSchema.optional(),
  memory: z.number().optional(),
  maxDuration: z.number().optional(),
  runtime: z.string().optional(),
  includeFiles: z.string().optional(),
  excludeFiles: z.string().optional(),
  experimentalTriggers: z.array(
    z.lazy(() => ExperimentalTriggers$outboundSchema),
  ).optional(),
  supportsCancellation: z.boolean().optional(),
});

export function functionsToJSON(functions: Functions): string {
  return JSON.stringify(Functions$outboundSchema.parse(functions));
}
export function functionsFromJSON(
  jsonString: string,
): SafeParseResult<Functions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Functions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Functions' from JSON`,
  );
}

/** @internal */
export const Routes3$inboundSchema: z.ZodType<Routes3, z.ZodTypeDef, unknown> =
  z.object({
    src: types.string(),
    continue: types.boolean(),
    middleware: types.number(),
  });
/** @internal */
export type Routes3$Outbound = {
  src: string;
  continue: boolean;
  middleware: number;
};

/** @internal */
export const Routes3$outboundSchema: z.ZodType<
  Routes3$Outbound,
  z.ZodTypeDef,
  Routes3
> = z.object({
  src: z.string(),
  continue: z.boolean(),
  middleware: z.number(),
});

export function routes3ToJSON(routes3: Routes3): string {
  return JSON.stringify(Routes3$outboundSchema.parse(routes3));
}
export function routes3FromJSON(
  jsonString: string,
): SafeParseResult<Routes3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Routes3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Routes3' from JSON`,
  );
}

/** @internal */
export const Handle$inboundSchema: z.ZodNativeEnum<typeof Handle> = z
  .nativeEnum(Handle);
/** @internal */
export const Handle$outboundSchema: z.ZodNativeEnum<typeof Handle> =
  Handle$inboundSchema;

/** @internal */
export const Routes2$inboundSchema: z.ZodType<Routes2, z.ZodTypeDef, unknown> =
  z.object({
    handle: Handle$inboundSchema,
    src: types.optional(types.string()),
    dest: types.optional(types.string()),
    status: types.optional(types.number()),
  });
/** @internal */
export type Routes2$Outbound = {
  handle: string;
  src?: string | undefined;
  dest?: string | undefined;
  status?: number | undefined;
};

/** @internal */
export const Routes2$outboundSchema: z.ZodType<
  Routes2$Outbound,
  z.ZodTypeDef,
  Routes2
> = z.object({
  handle: Handle$outboundSchema,
  src: z.string().optional(),
  dest: z.string().optional(),
  status: z.number().optional(),
});

export function routes2ToJSON(routes2: Routes2): string {
  return JSON.stringify(Routes2$outboundSchema.parse(routes2));
}
export function routes2FromJSON(
  jsonString: string,
): SafeParseResult<Routes2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Routes2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Routes2' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentHasType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentHasType
> = z.nativeEnum(CreateDeploymentHasType);
/** @internal */
export const CreateDeploymentHasType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentHasType
> = CreateDeploymentHasType$inboundSchema;

/** @internal */
export const ValueEq$inboundSchema: z.ZodType<ValueEq, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), types.number()]);
/** @internal */
export type ValueEq$Outbound = string | number;

/** @internal */
export const ValueEq$outboundSchema: z.ZodType<
  ValueEq$Outbound,
  z.ZodTypeDef,
  ValueEq
> = smartUnion([z.string(), z.number()]);

export function valueEqToJSON(valueEq: ValueEq): string {
  return JSON.stringify(ValueEq$outboundSchema.parse(valueEq));
}
export function valueEqFromJSON(
  jsonString: string,
): SafeParseResult<ValueEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ValueEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ValueEq' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentValue2$inboundSchema: z.ZodType<
  CreateDeploymentValue2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type CreateDeploymentValue2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const CreateDeploymentValue2$outboundSchema: z.ZodType<
  CreateDeploymentValue2$Outbound,
  z.ZodTypeDef,
  CreateDeploymentValue2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  re: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function createDeploymentValue2ToJSON(
  createDeploymentValue2: CreateDeploymentValue2,
): string {
  return JSON.stringify(
    CreateDeploymentValue2$outboundSchema.parse(createDeploymentValue2),
  );
}
export function createDeploymentValue2FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentValue2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentValue2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentValue2' from JSON`,
  );
}

/** @internal */
export const HasValue$inboundSchema: z.ZodType<
  HasValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => CreateDeploymentValue2$inboundSchema),
]);
/** @internal */
export type HasValue$Outbound = string | CreateDeploymentValue2$Outbound;

/** @internal */
export const HasValue$outboundSchema: z.ZodType<
  HasValue$Outbound,
  z.ZodTypeDef,
  HasValue
> = smartUnion([
  z.string(),
  z.lazy(() => CreateDeploymentValue2$outboundSchema),
]);

export function hasValueToJSON(hasValue: HasValue): string {
  return JSON.stringify(HasValue$outboundSchema.parse(hasValue));
}
export function hasValueFromJSON(
  jsonString: string,
): SafeParseResult<HasValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HasValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HasValue' from JSON`,
  );
}

/** @internal */
export const Has2$inboundSchema: z.ZodType<Has2, z.ZodTypeDef, unknown> = z
  .object({
    type: CreateDeploymentHasType$inboundSchema,
    key: types.string(),
    value: types.optional(
      smartUnion([
        types.string(),
        z.lazy(() => CreateDeploymentValue2$inboundSchema),
      ]),
    ),
  });
/** @internal */
export type Has2$Outbound = {
  type: string;
  key: string;
  value?: string | CreateDeploymentValue2$Outbound | undefined;
};

/** @internal */
export const Has2$outboundSchema: z.ZodType<Has2$Outbound, z.ZodTypeDef, Has2> =
  z.object({
    type: CreateDeploymentHasType$outboundSchema,
    key: z.string(),
    value: smartUnion([
      z.string(),
      z.lazy(() => CreateDeploymentValue2$outboundSchema),
    ]).optional(),
  });

export function has2ToJSON(has2: Has2): string {
  return JSON.stringify(Has2$outboundSchema.parse(has2));
}
export function has2FromJSON(
  jsonString: string,
): SafeParseResult<Has2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has2' from JSON`,
  );
}

/** @internal */
export const Eq$inboundSchema: z.ZodType<Eq, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), types.number()]);
/** @internal */
export type Eq$Outbound = string | number;

/** @internal */
export const Eq$outboundSchema: z.ZodType<Eq$Outbound, z.ZodTypeDef, Eq> =
  smartUnion([z.string(), z.number()]);

export function eqToJSON(eq: Eq): string {
  return JSON.stringify(Eq$outboundSchema.parse(eq));
}
export function eqFromJSON(
  jsonString: string,
): SafeParseResult<Eq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Eq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Eq' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentValueDeploymentsResponse2002$inboundSchema:
  z.ZodType<
    CreateDeploymentValueDeploymentsResponse2002,
    z.ZodTypeDef,
    unknown
  > = z.object({
    eq: types.optional(smartUnion([types.string(), types.number()])),
    neq: types.optional(types.string()),
    inc: types.optional(z.array(types.string())),
    ninc: types.optional(z.array(types.string())),
    pre: types.optional(types.string()),
    suf: types.optional(types.string()),
    re: types.optional(types.string()),
    gt: types.optional(types.number()),
    gte: types.optional(types.number()),
    lt: types.optional(types.number()),
    lte: types.optional(types.number()),
  });
/** @internal */
export type CreateDeploymentValueDeploymentsResponse2002$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const CreateDeploymentValueDeploymentsResponse2002$outboundSchema:
  z.ZodType<
    CreateDeploymentValueDeploymentsResponse2002$Outbound,
    z.ZodTypeDef,
    CreateDeploymentValueDeploymentsResponse2002
  > = z.object({
    eq: smartUnion([z.string(), z.number()]).optional(),
    neq: z.string().optional(),
    inc: z.array(z.string()).optional(),
    ninc: z.array(z.string()).optional(),
    pre: z.string().optional(),
    suf: z.string().optional(),
    re: z.string().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
  });

export function createDeploymentValueDeploymentsResponse2002ToJSON(
  createDeploymentValueDeploymentsResponse2002:
    CreateDeploymentValueDeploymentsResponse2002,
): string {
  return JSON.stringify(
    CreateDeploymentValueDeploymentsResponse2002$outboundSchema.parse(
      createDeploymentValueDeploymentsResponse2002,
    ),
  );
}
export function createDeploymentValueDeploymentsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentValueDeploymentsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentValueDeploymentsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentValueDeploymentsResponse2002' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentHasValue$inboundSchema: z.ZodType<
  CreateDeploymentHasValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => CreateDeploymentValueDeploymentsResponse2002$inboundSchema),
]);
/** @internal */
export type CreateDeploymentHasValue$Outbound =
  | string
  | CreateDeploymentValueDeploymentsResponse2002$Outbound;

/** @internal */
export const CreateDeploymentHasValue$outboundSchema: z.ZodType<
  CreateDeploymentHasValue$Outbound,
  z.ZodTypeDef,
  CreateDeploymentHasValue
> = smartUnion([
  z.string(),
  z.lazy(() => CreateDeploymentValueDeploymentsResponse2002$outboundSchema),
]);

export function createDeploymentHasValueToJSON(
  createDeploymentHasValue: CreateDeploymentHasValue,
): string {
  return JSON.stringify(
    CreateDeploymentHasValue$outboundSchema.parse(createDeploymentHasValue),
  );
}
export function createDeploymentHasValueFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentHasValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentHasValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentHasValue' from JSON`,
  );
}

/** @internal */
export const Has1$inboundSchema: z.ZodType<Has1, z.ZodTypeDef, unknown> = z
  .object({
    type: types.literal("host"),
    value: smartUnion([
      types.string(),
      z.lazy(() => CreateDeploymentValueDeploymentsResponse2002$inboundSchema),
    ]),
  });
/** @internal */
export type Has1$Outbound = {
  type: "host";
  value: string | CreateDeploymentValueDeploymentsResponse2002$Outbound;
};

/** @internal */
export const Has1$outboundSchema: z.ZodType<Has1$Outbound, z.ZodTypeDef, Has1> =
  z.object({
    type: z.literal("host"),
    value: smartUnion([
      z.string(),
      z.lazy(() => CreateDeploymentValueDeploymentsResponse2002$outboundSchema),
    ]),
  });

export function has1ToJSON(has1: Has1): string {
  return JSON.stringify(Has1$outboundSchema.parse(has1));
}
export function has1FromJSON(
  jsonString: string,
): SafeParseResult<Has1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has1' from JSON`,
  );
}

/** @internal */
export const Has$inboundSchema: z.ZodType<Has, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => Has1$inboundSchema),
    z.lazy(() =>
      Has2$inboundSchema
    ).and(z.object({ type: z.literal("header") })),
    z.lazy(() =>
      Has2$inboundSchema
    ).and(z.object({ type: z.literal("cookie") })),
    z.lazy(() =>
      Has2$inboundSchema
    ).and(z.object({ type: z.literal("query") })),
  ],
);
/** @internal */
export type Has$Outbound =
  | Has1$Outbound
  | (Has2$Outbound & { type: "header" })
  | (Has2$Outbound & { type: "cookie" })
  | (Has2$Outbound & { type: "query" });

/** @internal */
export const Has$outboundSchema: z.ZodType<Has$Outbound, z.ZodTypeDef, Has> = z
  .union([
    z.lazy(() => Has1$outboundSchema),
    z.lazy(() => Has2$outboundSchema).and(
      z.object({ type: z.literal("header") }),
    ),
    z.lazy(() => Has2$outboundSchema).and(
      z.object({ type: z.literal("cookie") }),
    ),
    z.lazy(() => Has2$outboundSchema).and(
      z.object({ type: z.literal("query") }),
    ),
  ]);

export function hasToJSON(has: Has): string {
  return JSON.stringify(Has$outboundSchema.parse(has));
}
export function hasFromJSON(
  jsonString: string,
): SafeParseResult<Has, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentMissingType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentMissingType
> = z.nativeEnum(CreateDeploymentMissingType);
/** @internal */
export const CreateDeploymentMissingType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentMissingType
> = CreateDeploymentMissingType$inboundSchema;

/** @internal */
export const CreateDeploymentValueDeploymentsEq$inboundSchema: z.ZodType<
  CreateDeploymentValueDeploymentsEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type CreateDeploymentValueDeploymentsEq$Outbound = string | number;

/** @internal */
export const CreateDeploymentValueDeploymentsEq$outboundSchema: z.ZodType<
  CreateDeploymentValueDeploymentsEq$Outbound,
  z.ZodTypeDef,
  CreateDeploymentValueDeploymentsEq
> = smartUnion([z.string(), z.number()]);

export function createDeploymentValueDeploymentsEqToJSON(
  createDeploymentValueDeploymentsEq: CreateDeploymentValueDeploymentsEq,
): string {
  return JSON.stringify(
    CreateDeploymentValueDeploymentsEq$outboundSchema.parse(
      createDeploymentValueDeploymentsEq,
    ),
  );
}
export function createDeploymentValueDeploymentsEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentValueDeploymentsEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentValueDeploymentsEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentValueDeploymentsEq' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentValueDeploymentsResponse2$inboundSchema: z.ZodType<
  CreateDeploymentValueDeploymentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type CreateDeploymentValueDeploymentsResponse2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const CreateDeploymentValueDeploymentsResponse2$outboundSchema:
  z.ZodType<
    CreateDeploymentValueDeploymentsResponse2$Outbound,
    z.ZodTypeDef,
    CreateDeploymentValueDeploymentsResponse2
  > = z.object({
    eq: smartUnion([z.string(), z.number()]).optional(),
    neq: z.string().optional(),
    inc: z.array(z.string()).optional(),
    ninc: z.array(z.string()).optional(),
    pre: z.string().optional(),
    suf: z.string().optional(),
    re: z.string().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
  });

export function createDeploymentValueDeploymentsResponse2ToJSON(
  createDeploymentValueDeploymentsResponse2:
    CreateDeploymentValueDeploymentsResponse2,
): string {
  return JSON.stringify(
    CreateDeploymentValueDeploymentsResponse2$outboundSchema.parse(
      createDeploymentValueDeploymentsResponse2,
    ),
  );
}
export function createDeploymentValueDeploymentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateDeploymentValueDeploymentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateDeploymentValueDeploymentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateDeploymentValueDeploymentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentMissingValue$inboundSchema: z.ZodType<
  CreateDeploymentMissingValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => CreateDeploymentValueDeploymentsResponse2$inboundSchema),
]);
/** @internal */
export type CreateDeploymentMissingValue$Outbound =
  | string
  | CreateDeploymentValueDeploymentsResponse2$Outbound;

/** @internal */
export const CreateDeploymentMissingValue$outboundSchema: z.ZodType<
  CreateDeploymentMissingValue$Outbound,
  z.ZodTypeDef,
  CreateDeploymentMissingValue
> = smartUnion([
  z.string(),
  z.lazy(() => CreateDeploymentValueDeploymentsResponse2$outboundSchema),
]);

export function createDeploymentMissingValueToJSON(
  createDeploymentMissingValue: CreateDeploymentMissingValue,
): string {
  return JSON.stringify(
    CreateDeploymentMissingValue$outboundSchema.parse(
      createDeploymentMissingValue,
    ),
  );
}
export function createDeploymentMissingValueFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentMissingValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentMissingValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentMissingValue' from JSON`,
  );
}

/** @internal */
export const Missing2$inboundSchema: z.ZodType<
  Missing2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateDeploymentMissingType$inboundSchema,
  key: types.string(),
  value: types.optional(
    smartUnion([
      types.string(),
      z.lazy(() => CreateDeploymentValueDeploymentsResponse2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type Missing2$Outbound = {
  type: string;
  key: string;
  value?:
    | string
    | CreateDeploymentValueDeploymentsResponse2$Outbound
    | undefined;
};

/** @internal */
export const Missing2$outboundSchema: z.ZodType<
  Missing2$Outbound,
  z.ZodTypeDef,
  Missing2
> = z.object({
  type: CreateDeploymentMissingType$outboundSchema,
  key: z.string(),
  value: smartUnion([
    z.string(),
    z.lazy(() => CreateDeploymentValueDeploymentsResponse2$outboundSchema),
  ]).optional(),
});

export function missing2ToJSON(missing2: Missing2): string {
  return JSON.stringify(Missing2$outboundSchema.parse(missing2));
}
export function missing2FromJSON(
  jsonString: string,
): SafeParseResult<Missing2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Missing2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Missing2' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentValueEq$inboundSchema: z.ZodType<
  CreateDeploymentValueEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type CreateDeploymentValueEq$Outbound = string | number;

/** @internal */
export const CreateDeploymentValueEq$outboundSchema: z.ZodType<
  CreateDeploymentValueEq$Outbound,
  z.ZodTypeDef,
  CreateDeploymentValueEq
> = smartUnion([z.string(), z.number()]);

export function createDeploymentValueEqToJSON(
  createDeploymentValueEq: CreateDeploymentValueEq,
): string {
  return JSON.stringify(
    CreateDeploymentValueEq$outboundSchema.parse(createDeploymentValueEq),
  );
}
export function createDeploymentValueEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentValueEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentValueEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentValueEq' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentValueDeployments2$inboundSchema: z.ZodType<
  CreateDeploymentValueDeployments2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type CreateDeploymentValueDeployments2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const CreateDeploymentValueDeployments2$outboundSchema: z.ZodType<
  CreateDeploymentValueDeployments2$Outbound,
  z.ZodTypeDef,
  CreateDeploymentValueDeployments2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  re: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function createDeploymentValueDeployments2ToJSON(
  createDeploymentValueDeployments2: CreateDeploymentValueDeployments2,
): string {
  return JSON.stringify(
    CreateDeploymentValueDeployments2$outboundSchema.parse(
      createDeploymentValueDeployments2,
    ),
  );
}
export function createDeploymentValueDeployments2FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentValueDeployments2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentValueDeployments2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentValueDeployments2' from JSON`,
  );
}

/** @internal */
export const MissingValue$inboundSchema: z.ZodType<
  MissingValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => CreateDeploymentValueDeployments2$inboundSchema),
]);
/** @internal */
export type MissingValue$Outbound =
  | string
  | CreateDeploymentValueDeployments2$Outbound;

/** @internal */
export const MissingValue$outboundSchema: z.ZodType<
  MissingValue$Outbound,
  z.ZodTypeDef,
  MissingValue
> = smartUnion([
  z.string(),
  z.lazy(() => CreateDeploymentValueDeployments2$outboundSchema),
]);

export function missingValueToJSON(missingValue: MissingValue): string {
  return JSON.stringify(MissingValue$outboundSchema.parse(missingValue));
}
export function missingValueFromJSON(
  jsonString: string,
): SafeParseResult<MissingValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MissingValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MissingValue' from JSON`,
  );
}

/** @internal */
export const Missing1$inboundSchema: z.ZodType<
  Missing1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("host"),
  value: smartUnion([
    types.string(),
    z.lazy(() => CreateDeploymentValueDeployments2$inboundSchema),
  ]),
});
/** @internal */
export type Missing1$Outbound = {
  type: "host";
  value: string | CreateDeploymentValueDeployments2$Outbound;
};

/** @internal */
export const Missing1$outboundSchema: z.ZodType<
  Missing1$Outbound,
  z.ZodTypeDef,
  Missing1
> = z.object({
  type: z.literal("host"),
  value: smartUnion([
    z.string(),
    z.lazy(() => CreateDeploymentValueDeployments2$outboundSchema),
  ]),
});

export function missing1ToJSON(missing1: Missing1): string {
  return JSON.stringify(Missing1$outboundSchema.parse(missing1));
}
export function missing1FromJSON(
  jsonString: string,
): SafeParseResult<Missing1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Missing1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Missing1' from JSON`,
  );
}

/** @internal */
export const Missing$inboundSchema: z.ZodType<Missing, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => Missing1$inboundSchema),
    z.lazy(() => Missing2$inboundSchema).and(
      z.object({ type: z.literal("header") }),
    ),
    z.lazy(() => Missing2$inboundSchema).and(
      z.object({ type: z.literal("cookie") }),
    ),
    z.lazy(() => Missing2$inboundSchema).and(
      z.object({ type: z.literal("query") }),
    ),
  ]);
/** @internal */
export type Missing$Outbound =
  | Missing1$Outbound
  | (Missing2$Outbound & { type: "header" })
  | (Missing2$Outbound & { type: "cookie" })
  | (Missing2$Outbound & { type: "query" });

/** @internal */
export const Missing$outboundSchema: z.ZodType<
  Missing$Outbound,
  z.ZodTypeDef,
  Missing
> = z.union([
  z.lazy(() => Missing1$outboundSchema),
  z.lazy(() => Missing2$outboundSchema).and(
    z.object({ type: z.literal("header") }),
  ),
  z.lazy(() => Missing2$outboundSchema).and(
    z.object({ type: z.literal("cookie") }),
  ),
  z.lazy(() => Missing2$outboundSchema).and(
    z.object({ type: z.literal("query") }),
  ),
]);

export function missingToJSON(missing: Missing): string {
  return JSON.stringify(Missing$outboundSchema.parse(missing));
}
export function missingFromJSON(
  jsonString: string,
): SafeParseResult<Missing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Missing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Missing' from JSON`,
  );
}

/** @internal */
export const RoutesAction$inboundSchema: z.ZodNativeEnum<typeof RoutesAction> =
  z.nativeEnum(RoutesAction);
/** @internal */
export const RoutesAction$outboundSchema: z.ZodNativeEnum<typeof RoutesAction> =
  RoutesAction$inboundSchema;

/** @internal */
export const CreateDeploymentRoutesMitigate$inboundSchema: z.ZodType<
  CreateDeploymentRoutesMitigate,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: RoutesAction$inboundSchema,
});
/** @internal */
export type CreateDeploymentRoutesMitigate$Outbound = {
  action: string;
};

/** @internal */
export const CreateDeploymentRoutesMitigate$outboundSchema: z.ZodType<
  CreateDeploymentRoutesMitigate$Outbound,
  z.ZodTypeDef,
  CreateDeploymentRoutesMitigate
> = z.object({
  action: RoutesAction$outboundSchema,
});

export function createDeploymentRoutesMitigateToJSON(
  createDeploymentRoutesMitigate: CreateDeploymentRoutesMitigate,
): string {
  return JSON.stringify(
    CreateDeploymentRoutesMitigate$outboundSchema.parse(
      createDeploymentRoutesMitigate,
    ),
  );
}
export function createDeploymentRoutesMitigateFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentRoutesMitigate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentRoutesMitigate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentRoutesMitigate' from JSON`,
  );
}

/** @internal */
export const RoutesType$inboundSchema: z.ZodNativeEnum<typeof RoutesType> = z
  .nativeEnum(RoutesType);
/** @internal */
export const RoutesType$outboundSchema: z.ZodNativeEnum<typeof RoutesType> =
  RoutesType$inboundSchema;

/** @internal */
export const CreateDeploymentRoutesOp$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentRoutesOp
> = z.nativeEnum(CreateDeploymentRoutesOp);
/** @internal */
export const CreateDeploymentRoutesOp$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentRoutesOp
> = CreateDeploymentRoutesOp$inboundSchema;

/** @internal */
export const KeyEq$inboundSchema: z.ZodType<KeyEq, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), types.number()]);
/** @internal */
export type KeyEq$Outbound = string | number;

/** @internal */
export const KeyEq$outboundSchema: z.ZodType<
  KeyEq$Outbound,
  z.ZodTypeDef,
  KeyEq
> = smartUnion([z.string(), z.number()]);

export function keyEqToJSON(keyEq: KeyEq): string {
  return JSON.stringify(KeyEq$outboundSchema.parse(keyEq));
}
export function keyEqFromJSON(
  jsonString: string,
): SafeParseResult<KeyEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KeyEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KeyEq' from JSON`,
  );
}

/** @internal */
export const Key2$inboundSchema: z.ZodType<Key2, z.ZodTypeDef, unknown> = z
  .object({
    eq: types.optional(smartUnion([types.string(), types.number()])),
    neq: types.optional(types.string()),
    inc: types.optional(z.array(types.string())),
    ninc: types.optional(z.array(types.string())),
    pre: types.optional(types.string()),
    suf: types.optional(types.string()),
    gt: types.optional(types.number()),
    gte: types.optional(types.number()),
    lt: types.optional(types.number()),
    lte: types.optional(types.number()),
  });
/** @internal */
export type Key2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const Key2$outboundSchema: z.ZodType<Key2$Outbound, z.ZodTypeDef, Key2> =
  z.object({
    eq: smartUnion([z.string(), z.number()]).optional(),
    neq: z.string().optional(),
    inc: z.array(z.string()).optional(),
    ninc: z.array(z.string()).optional(),
    pre: z.string().optional(),
    suf: z.string().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
  });

export function key2ToJSON(key2: Key2): string {
  return JSON.stringify(Key2$outboundSchema.parse(key2));
}
export function key2FromJSON(
  jsonString: string,
): SafeParseResult<Key2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Key2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Key2' from JSON`,
  );
}

/** @internal */
export const Key$inboundSchema: z.ZodType<Key, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), z.lazy(() => Key2$inboundSchema)]);
/** @internal */
export type Key$Outbound = string | Key2$Outbound;

/** @internal */
export const Key$outboundSchema: z.ZodType<Key$Outbound, z.ZodTypeDef, Key> =
  smartUnion([z.string(), z.lazy(() => Key2$outboundSchema)]);

export function keyToJSON(key: Key): string {
  return JSON.stringify(Key$outboundSchema.parse(key));
}
export function keyFromJSON(
  jsonString: string,
): SafeParseResult<Key, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Key$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Key' from JSON`,
  );
}

/** @internal */
export const RoutesTarget$inboundSchema: z.ZodType<
  RoutesTarget,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: smartUnion([types.string(), z.lazy(() => Key2$inboundSchema)]),
});
/** @internal */
export type RoutesTarget$Outbound = {
  key: string | Key2$Outbound;
};

/** @internal */
export const RoutesTarget$outboundSchema: z.ZodType<
  RoutesTarget$Outbound,
  z.ZodTypeDef,
  RoutesTarget
> = z.object({
  key: smartUnion([z.string(), z.lazy(() => Key2$outboundSchema)]),
});

export function routesTargetToJSON(routesTarget: RoutesTarget): string {
  return JSON.stringify(RoutesTarget$outboundSchema.parse(routesTarget));
}
export function routesTargetFromJSON(
  jsonString: string,
): SafeParseResult<RoutesTarget, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RoutesTarget$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RoutesTarget' from JSON`,
  );
}

/** @internal */
export const Args$inboundSchema: z.ZodType<Args, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), z.array(types.string())]);
/** @internal */
export type Args$Outbound = string | Array<string>;

/** @internal */
export const Args$outboundSchema: z.ZodType<Args$Outbound, z.ZodTypeDef, Args> =
  smartUnion([z.string(), z.array(z.string())]);

export function argsToJSON(args: Args): string {
  return JSON.stringify(Args$outboundSchema.parse(args));
}
export function argsFromJSON(
  jsonString: string,
): SafeParseResult<Args, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Args$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Args' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentRoutesTransforms$inboundSchema: z.ZodType<
  CreateDeploymentRoutesTransforms,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RoutesType$inboundSchema,
  op: CreateDeploymentRoutesOp$inboundSchema,
  target: z.lazy(() => RoutesTarget$inboundSchema),
  args: types.optional(smartUnion([types.string(), z.array(types.string())])),
  env: types.optional(z.array(types.string())),
});
/** @internal */
export type CreateDeploymentRoutesTransforms$Outbound = {
  type: string;
  op: string;
  target: RoutesTarget$Outbound;
  args?: string | Array<string> | undefined;
  env?: Array<string> | undefined;
};

/** @internal */
export const CreateDeploymentRoutesTransforms$outboundSchema: z.ZodType<
  CreateDeploymentRoutesTransforms$Outbound,
  z.ZodTypeDef,
  CreateDeploymentRoutesTransforms
> = z.object({
  type: RoutesType$outboundSchema,
  op: CreateDeploymentRoutesOp$outboundSchema,
  target: z.lazy(() => RoutesTarget$outboundSchema),
  args: smartUnion([z.string(), z.array(z.string())]).optional(),
  env: z.array(z.string()).optional(),
});

export function createDeploymentRoutesTransformsToJSON(
  createDeploymentRoutesTransforms: CreateDeploymentRoutesTransforms,
): string {
  return JSON.stringify(
    CreateDeploymentRoutesTransforms$outboundSchema.parse(
      createDeploymentRoutesTransforms,
    ),
  );
}
export function createDeploymentRoutesTransformsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentRoutesTransforms, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentRoutesTransforms$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentRoutesTransforms' from JSON`,
  );
}

/** @internal */
export const Locale$inboundSchema: z.ZodType<Locale, z.ZodTypeDef, unknown> = z
  .object({
    redirect: types.optional(z.record(types.string())),
    cookie: types.optional(types.string()),
  });
/** @internal */
export type Locale$Outbound = {
  redirect?: { [k: string]: string } | undefined;
  cookie?: string | undefined;
};

/** @internal */
export const Locale$outboundSchema: z.ZodType<
  Locale$Outbound,
  z.ZodTypeDef,
  Locale
> = z.object({
  redirect: z.record(z.string()).optional(),
  cookie: z.string().optional(),
});

export function localeToJSON(locale: Locale): string {
  return JSON.stringify(Locale$outboundSchema.parse(locale));
}
export function localeFromJSON(
  jsonString: string,
): SafeParseResult<Locale, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Locale$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Locale' from JSON`,
  );
}

/** @internal */
export const Routes1$inboundSchema: z.ZodType<Routes1, z.ZodTypeDef, unknown> =
  z.object({
    src: types.string(),
    dest: types.optional(types.string()),
    headers: types.optional(z.record(types.string())),
    methods: types.optional(z.array(types.string())),
    continue: types.optional(types.boolean()),
    override: types.optional(types.boolean()),
    caseSensitive: types.optional(types.boolean()),
    check: types.optional(types.boolean()),
    important: types.optional(types.boolean()),
    status: types.optional(types.number()),
    has: types.optional(
      z.array(z.union([
        z.lazy(() => Has1$inboundSchema),
        z.lazy(() =>
          Has2$inboundSchema
        ).and(z.object({ type: z.literal("header") })),
        z.lazy(() => Has2$inboundSchema).and(
          z.object({ type: z.literal("cookie") }),
        ),
        z.lazy(() => Has2$inboundSchema).and(
          z.object({ type: z.literal("query") }),
        ),
      ])),
    ),
    missing: types.optional(
      z.array(z.union([
        z.lazy(() => Missing1$inboundSchema),
        z.lazy(() =>
          Missing2$inboundSchema
        ).and(z.object({ type: z.literal("header") })),
        z.lazy(() => Missing2$inboundSchema).and(
          z.object({ type: z.literal("cookie") }),
        ),
        z.lazy(() => Missing2$inboundSchema).and(
          z.object({ type: z.literal("query") }),
        ),
      ])),
    ),
    mitigate: types.optional(
      z.lazy(() => CreateDeploymentRoutesMitigate$inboundSchema),
    ),
    transforms: types.optional(
      z.array(z.lazy(() => CreateDeploymentRoutesTransforms$inboundSchema)),
    ),
    env: types.optional(z.array(types.string())),
    locale: types.optional(z.lazy(() => Locale$inboundSchema)),
    middlewarePath: types.optional(types.string()),
    middlewareRawSrc: types.optional(z.array(types.string())),
    middleware: types.optional(types.number()),
    respectOriginCacheControl: types.optional(types.boolean()),
  });
/** @internal */
export type Routes1$Outbound = {
  src: string;
  dest?: string | undefined;
  headers?: { [k: string]: string } | undefined;
  methods?: Array<string> | undefined;
  continue?: boolean | undefined;
  override?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  check?: boolean | undefined;
  important?: boolean | undefined;
  status?: number | undefined;
  has?:
    | Array<
      | Has1$Outbound
      | (Has2$Outbound & { type: "header" })
      | (Has2$Outbound & { type: "cookie" })
      | (Has2$Outbound & { type: "query" })
    >
    | undefined;
  missing?:
    | Array<
      | Missing1$Outbound
      | (Missing2$Outbound & { type: "header" })
      | (Missing2$Outbound & { type: "cookie" })
      | (Missing2$Outbound & { type: "query" })
    >
    | undefined;
  mitigate?: CreateDeploymentRoutesMitigate$Outbound | undefined;
  transforms?: Array<CreateDeploymentRoutesTransforms$Outbound> | undefined;
  env?: Array<string> | undefined;
  locale?: Locale$Outbound | undefined;
  middlewarePath?: string | undefined;
  middlewareRawSrc?: Array<string> | undefined;
  middleware?: number | undefined;
  respectOriginCacheControl?: boolean | undefined;
};

/** @internal */
export const Routes1$outboundSchema: z.ZodType<
  Routes1$Outbound,
  z.ZodTypeDef,
  Routes1
> = z.object({
  src: z.string(),
  dest: z.string().optional(),
  headers: z.record(z.string()).optional(),
  methods: z.array(z.string()).optional(),
  continue: z.boolean().optional(),
  override: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  check: z.boolean().optional(),
  important: z.boolean().optional(),
  status: z.number().optional(),
  has: z.array(
    z.union([
      z.lazy(() => Has1$outboundSchema),
      z.lazy(() =>
        Has2$outboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() =>
        Has2$outboundSchema
      ).and(z.object({ type: z.literal("cookie") })),
      z.lazy(() =>
        Has2$outboundSchema
      ).and(z.object({ type: z.literal("query") })),
    ]),
  ).optional(),
  missing: z.array(
    z.union([
      z.lazy(() => Missing1$outboundSchema),
      z.lazy(() =>
        Missing2$outboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() =>
        Missing2$outboundSchema
      ).and(z.object({ type: z.literal("cookie") })),
      z.lazy(() =>
        Missing2$outboundSchema
      ).and(z.object({ type: z.literal("query") })),
    ]),
  ).optional(),
  mitigate: z.lazy(() => CreateDeploymentRoutesMitigate$outboundSchema)
    .optional(),
  transforms: z.array(
    z.lazy(() => CreateDeploymentRoutesTransforms$outboundSchema),
  ).optional(),
  env: z.array(z.string()).optional(),
  locale: z.lazy(() => Locale$outboundSchema).optional(),
  middlewarePath: z.string().optional(),
  middlewareRawSrc: z.array(z.string()).optional(),
  middleware: z.number().optional(),
  respectOriginCacheControl: z.boolean().optional(),
});

export function routes1ToJSON(routes1: Routes1): string {
  return JSON.stringify(Routes1$outboundSchema.parse(routes1));
}
export function routes1FromJSON(
  jsonString: string,
): SafeParseResult<Routes1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Routes1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Routes1' from JSON`,
  );
}

/** @internal */
export const Routes$inboundSchema: z.ZodType<Routes, z.ZodTypeDef, unknown> =
  smartUnion([
    z.lazy(() => Routes3$inboundSchema),
    z.lazy(() => Routes1$inboundSchema),
    z.lazy(() => Routes2$inboundSchema),
  ]);
/** @internal */
export type Routes$Outbound =
  | Routes3$Outbound
  | Routes1$Outbound
  | Routes2$Outbound;

/** @internal */
export const Routes$outboundSchema: z.ZodType<
  Routes$Outbound,
  z.ZodTypeDef,
  Routes
> = smartUnion([
  z.lazy(() => Routes3$outboundSchema),
  z.lazy(() => Routes1$outboundSchema),
  z.lazy(() => Routes2$outboundSchema),
]);

export function routesToJSON(routes: Routes): string {
  return JSON.stringify(Routes$outboundSchema.parse(routes));
}
export function routesFromJSON(
  jsonString: string,
): SafeParseResult<Routes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Routes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Routes' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentGitRepoOwnerType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentGitRepoOwnerType
> = z.nativeEnum(CreateDeploymentGitRepoOwnerType);
/** @internal */
export const CreateDeploymentGitRepoOwnerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentGitRepoOwnerType
> = CreateDeploymentGitRepoOwnerType$inboundSchema;

/** @internal */
export const GitRepo3$inboundSchema: z.ZodType<
  GitRepo3,
  z.ZodTypeDef,
  unknown
> = z.object({
  owner: types.string(),
  repoUuid: types.string(),
  slug: types.string(),
  type: types.literal("bitbucket"),
  workspaceUuid: types.string(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: CreateDeploymentGitRepoOwnerType$inboundSchema,
});
/** @internal */
export type GitRepo3$Outbound = {
  owner: string;
  repoUuid: string;
  slug: string;
  type: "bitbucket";
  workspaceUuid: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GitRepo3$outboundSchema: z.ZodType<
  GitRepo3$Outbound,
  z.ZodTypeDef,
  GitRepo3
> = z.object({
  owner: z.string(),
  repoUuid: z.string(),
  slug: z.string(),
  type: z.literal("bitbucket"),
  workspaceUuid: z.string(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: CreateDeploymentGitRepoOwnerType$outboundSchema,
});

export function gitRepo3ToJSON(gitRepo3: GitRepo3): string {
  return JSON.stringify(GitRepo3$outboundSchema.parse(gitRepo3));
}
export function gitRepo3FromJSON(
  jsonString: string,
): SafeParseResult<GitRepo3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitRepo3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitRepo3' from JSON`,
  );
}

/** @internal */
export const GitRepoOwnerType$inboundSchema: z.ZodNativeEnum<
  typeof GitRepoOwnerType
> = z.nativeEnum(GitRepoOwnerType);
/** @internal */
export const GitRepoOwnerType$outboundSchema: z.ZodNativeEnum<
  typeof GitRepoOwnerType
> = GitRepoOwnerType$inboundSchema;

/** @internal */
export const GitRepo2$inboundSchema: z.ZodType<
  GitRepo2,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  repo: types.string(),
  repoId: types.number(),
  type: types.literal("github"),
  repoOwnerId: types.number(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: GitRepoOwnerType$inboundSchema,
});
/** @internal */
export type GitRepo2$Outbound = {
  org: string;
  repo: string;
  repoId: number;
  type: "github";
  repoOwnerId: number;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GitRepo2$outboundSchema: z.ZodType<
  GitRepo2$Outbound,
  z.ZodTypeDef,
  GitRepo2
> = z.object({
  org: z.string(),
  repo: z.string(),
  repoId: z.number(),
  type: z.literal("github"),
  repoOwnerId: z.number(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: GitRepoOwnerType$outboundSchema,
});

export function gitRepo2ToJSON(gitRepo2: GitRepo2): string {
  return JSON.stringify(GitRepo2$outboundSchema.parse(gitRepo2));
}
export function gitRepo2FromJSON(
  jsonString: string,
): SafeParseResult<GitRepo2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitRepo2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitRepo2' from JSON`,
  );
}

/** @internal */
export const OwnerType$inboundSchema: z.ZodNativeEnum<typeof OwnerType> = z
  .nativeEnum(OwnerType);
/** @internal */
export const OwnerType$outboundSchema: z.ZodNativeEnum<typeof OwnerType> =
  OwnerType$inboundSchema;

/** @internal */
export const GitRepo1$inboundSchema: z.ZodType<
  GitRepo1,
  z.ZodTypeDef,
  unknown
> = z.object({
  namespace: types.string(),
  projectId: types.number(),
  type: types.literal("gitlab"),
  url: types.string(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: OwnerType$inboundSchema,
});
/** @internal */
export type GitRepo1$Outbound = {
  namespace: string;
  projectId: number;
  type: "gitlab";
  url: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GitRepo1$outboundSchema: z.ZodType<
  GitRepo1$Outbound,
  z.ZodTypeDef,
  GitRepo1
> = z.object({
  namespace: z.string(),
  projectId: z.number(),
  type: z.literal("gitlab"),
  url: z.string(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: OwnerType$outboundSchema,
});

export function gitRepo1ToJSON(gitRepo1: GitRepo1): string {
  return JSON.stringify(GitRepo1$outboundSchema.parse(gitRepo1));
}
export function gitRepo1FromJSON(
  jsonString: string,
): SafeParseResult<GitRepo1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitRepo1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitRepo1' from JSON`,
  );
}

/** @internal */
export const GitRepo$inboundSchema: z.ZodType<GitRepo, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => GitRepo1$inboundSchema),
    z.lazy(() => GitRepo2$inboundSchema),
    z.lazy(() => GitRepo3$inboundSchema),
  ]);
/** @internal */
export type GitRepo$Outbound =
  | GitRepo1$Outbound
  | GitRepo2$Outbound
  | GitRepo3$Outbound;

/** @internal */
export const GitRepo$outboundSchema: z.ZodType<
  GitRepo$Outbound,
  z.ZodTypeDef,
  GitRepo
> = z.union([
  z.lazy(() => GitRepo1$outboundSchema),
  z.lazy(() => GitRepo2$outboundSchema),
  z.lazy(() => GitRepo3$outboundSchema),
]);

export function gitRepoToJSON(gitRepo: GitRepo): string {
  return JSON.stringify(GitRepo$outboundSchema.parse(gitRepo));
}
export function gitRepoFromJSON(
  jsonString: string,
): SafeParseResult<GitRepo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitRepo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitRepo' from JSON`,
  );
}

/** @internal */
export const Flags2$inboundSchema: z.ZodType<Flags2, z.ZodTypeDef, unknown> = z
  .object({});
/** @internal */
export type Flags2$Outbound = {};

/** @internal */
export const Flags2$outboundSchema: z.ZodType<
  Flags2$Outbound,
  z.ZodTypeDef,
  Flags2
> = z.object({});

export function flags2ToJSON(flags2: Flags2): string {
  return JSON.stringify(Flags2$outboundSchema.parse(flags2));
}
export function flags2FromJSON(
  jsonString: string,
): SafeParseResult<Flags2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Flags2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Flags2' from JSON`,
  );
}

/** @internal */
export const Options$inboundSchema: z.ZodType<Options, z.ZodTypeDef, unknown> =
  z.object({
    value: types.nullable(FlagJSONValue$inboundSchema),
    label: types.optional(types.string()),
  });
/** @internal */
export type Options$Outbound = {
  value: FlagJSONValue$Outbound | null;
  label?: string | undefined;
};

/** @internal */
export const Options$outboundSchema: z.ZodType<
  Options$Outbound,
  z.ZodTypeDef,
  Options
> = z.object({
  value: z.nullable(FlagJSONValue$outboundSchema),
  label: z.string().optional(),
});

export function optionsToJSON(options: Options): string {
  return JSON.stringify(Options$outboundSchema.parse(options));
}
export function optionsFromJSON(
  jsonString: string,
): SafeParseResult<Options, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Options$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Options' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentFlagsDefinitions$inboundSchema: z.ZodType<
  CreateDeploymentFlagsDefinitions,
  z.ZodTypeDef,
  unknown
> = z.object({
  options: types.optional(z.array(z.lazy(() => Options$inboundSchema))),
  url: types.optional(types.string()),
  description: types.optional(types.string()),
});
/** @internal */
export type CreateDeploymentFlagsDefinitions$Outbound = {
  options?: Array<Options$Outbound> | undefined;
  url?: string | undefined;
  description?: string | undefined;
};

/** @internal */
export const CreateDeploymentFlagsDefinitions$outboundSchema: z.ZodType<
  CreateDeploymentFlagsDefinitions$Outbound,
  z.ZodTypeDef,
  CreateDeploymentFlagsDefinitions
> = z.object({
  options: z.array(z.lazy(() => Options$outboundSchema)).optional(),
  url: z.string().optional(),
  description: z.string().optional(),
});

export function createDeploymentFlagsDefinitionsToJSON(
  createDeploymentFlagsDefinitions: CreateDeploymentFlagsDefinitions,
): string {
  return JSON.stringify(
    CreateDeploymentFlagsDefinitions$outboundSchema.parse(
      createDeploymentFlagsDefinitions,
    ),
  );
}
export function createDeploymentFlagsDefinitionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentFlagsDefinitions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentFlagsDefinitions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentFlagsDefinitions' from JSON`,
  );
}

/** @internal */
export const Flags1$inboundSchema: z.ZodType<Flags1, z.ZodTypeDef, unknown> = z
  .object({
    definitions: z.record(
      z.lazy(() => CreateDeploymentFlagsDefinitions$inboundSchema),
    ),
  });
/** @internal */
export type Flags1$Outbound = {
  definitions: { [k: string]: CreateDeploymentFlagsDefinitions$Outbound };
};

/** @internal */
export const Flags1$outboundSchema: z.ZodType<
  Flags1$Outbound,
  z.ZodTypeDef,
  Flags1
> = z.object({
  definitions: z.record(
    z.lazy(() => CreateDeploymentFlagsDefinitions$outboundSchema),
  ),
});

export function flags1ToJSON(flags1: Flags1): string {
  return JSON.stringify(Flags1$outboundSchema.parse(flags1));
}
export function flags1FromJSON(
  jsonString: string,
): SafeParseResult<Flags1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Flags1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Flags1' from JSON`,
  );
}

/** @internal */
export const Flags$inboundSchema: z.ZodType<Flags, z.ZodTypeDef, unknown> =
  smartUnion([
    z.lazy(() => Flags1$inboundSchema),
    z.array(z.lazy(() => Flags2$inboundSchema)),
  ]);
/** @internal */
export type Flags$Outbound = Flags1$Outbound | Array<Flags2$Outbound>;

/** @internal */
export const Flags$outboundSchema: z.ZodType<
  Flags$Outbound,
  z.ZodTypeDef,
  Flags
> = smartUnion([
  z.lazy(() => Flags1$outboundSchema),
  z.array(z.lazy(() => Flags2$outboundSchema)),
]);

export function flagsToJSON(flags: Flags): string {
  return JSON.stringify(Flags$outboundSchema.parse(flags));
}
export function flagsFromJSON(
  jsonString: string,
): SafeParseResult<Flags, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Flags$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Flags' from JSON`,
  );
}

/** @internal */
export const MfeConfigUploadState$inboundSchema: z.ZodNativeEnum<
  typeof MfeConfigUploadState
> = z.nativeEnum(MfeConfigUploadState);
/** @internal */
export const MfeConfigUploadState$outboundSchema: z.ZodNativeEnum<
  typeof MfeConfigUploadState
> = MfeConfigUploadState$inboundSchema;

/** @internal */
export const CreateDeploymentMicrofrontends2$inboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends2,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: types.boolean(),
  mfeConfigUploadState: types.optional(MfeConfigUploadState$inboundSchema),
  defaultAppProjectName: types.string(),
  defaultRoute: types.optional(types.string()),
  groupIds: z.array(types.string()),
});
/** @internal */
export type CreateDeploymentMicrofrontends2$Outbound = {
  isDefaultApp: boolean;
  mfeConfigUploadState?: string | undefined;
  defaultAppProjectName: string;
  defaultRoute?: string | undefined;
  groupIds: Array<string>;
};

/** @internal */
export const CreateDeploymentMicrofrontends2$outboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends2$Outbound,
  z.ZodTypeDef,
  CreateDeploymentMicrofrontends2
> = z.object({
  isDefaultApp: z.boolean(),
  mfeConfigUploadState: MfeConfigUploadState$outboundSchema.optional(),
  defaultAppProjectName: z.string(),
  defaultRoute: z.string().optional(),
  groupIds: z.array(z.string()),
});

export function createDeploymentMicrofrontends2ToJSON(
  createDeploymentMicrofrontends2: CreateDeploymentMicrofrontends2,
): string {
  return JSON.stringify(
    CreateDeploymentMicrofrontends2$outboundSchema.parse(
      createDeploymentMicrofrontends2,
    ),
  );
}
export function createDeploymentMicrofrontends2FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentMicrofrontends2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentMicrofrontends2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentMicrofrontends2' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentMicrofrontends1$inboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends1,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: types.optional(types.boolean()),
  defaultAppProjectName: types.string(),
  defaultRoute: types.optional(types.string()),
  groupIds: z.array(types.string()),
});
/** @internal */
export type CreateDeploymentMicrofrontends1$Outbound = {
  isDefaultApp?: boolean | undefined;
  defaultAppProjectName: string;
  defaultRoute?: string | undefined;
  groupIds: Array<string>;
};

/** @internal */
export const CreateDeploymentMicrofrontends1$outboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends1$Outbound,
  z.ZodTypeDef,
  CreateDeploymentMicrofrontends1
> = z.object({
  isDefaultApp: z.boolean().optional(),
  defaultAppProjectName: z.string(),
  defaultRoute: z.string().optional(),
  groupIds: z.array(z.string()),
});

export function createDeploymentMicrofrontends1ToJSON(
  createDeploymentMicrofrontends1: CreateDeploymentMicrofrontends1,
): string {
  return JSON.stringify(
    CreateDeploymentMicrofrontends1$outboundSchema.parse(
      createDeploymentMicrofrontends1,
    ),
  );
}
export function createDeploymentMicrofrontends1FromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentMicrofrontends1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentMicrofrontends1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentMicrofrontends1' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentMicrofrontends$inboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => CreateDeploymentMicrofrontends2$inboundSchema),
  z.lazy(() => CreateDeploymentMicrofrontends1$inboundSchema),
]);
/** @internal */
export type CreateDeploymentMicrofrontends$Outbound =
  | CreateDeploymentMicrofrontends2$Outbound
  | CreateDeploymentMicrofrontends1$Outbound;

/** @internal */
export const CreateDeploymentMicrofrontends$outboundSchema: z.ZodType<
  CreateDeploymentMicrofrontends$Outbound,
  z.ZodTypeDef,
  CreateDeploymentMicrofrontends
> = smartUnion([
  z.lazy(() => CreateDeploymentMicrofrontends2$outboundSchema),
  z.lazy(() => CreateDeploymentMicrofrontends1$outboundSchema),
]);

export function createDeploymentMicrofrontendsToJSON(
  createDeploymentMicrofrontends: CreateDeploymentMicrofrontends,
): string {
  return JSON.stringify(
    CreateDeploymentMicrofrontends$outboundSchema.parse(
      createDeploymentMicrofrontends,
    ),
  );
}
export function createDeploymentMicrofrontendsFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentMicrofrontends, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentMicrofrontends$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentMicrofrontends' from JSON`,
  );
}

/** @internal */
export const FunctionType$inboundSchema: z.ZodNativeEnum<typeof FunctionType> =
  z.nativeEnum(FunctionType);
/** @internal */
export const FunctionType$outboundSchema: z.ZodNativeEnum<typeof FunctionType> =
  FunctionType$inboundSchema;

/** @internal */
export const FunctionMemoryType$inboundSchema: z.ZodNativeEnum<
  typeof FunctionMemoryType
> = z.nativeEnum(FunctionMemoryType);
/** @internal */
export const FunctionMemoryType$outboundSchema: z.ZodNativeEnum<
  typeof FunctionMemoryType
> = FunctionMemoryType$inboundSchema;

/** @internal */
export const CreateDeploymentConfiguration$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentConfiguration
> = z.nativeEnum(CreateDeploymentConfiguration);
/** @internal */
export const CreateDeploymentConfiguration$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentConfiguration
> = CreateDeploymentConfiguration$inboundSchema;

/** @internal */
export const CreateDeploymentBuildQueue$inboundSchema: z.ZodType<
  CreateDeploymentBuildQueue,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: types.optional(CreateDeploymentConfiguration$inboundSchema),
});
/** @internal */
export type CreateDeploymentBuildQueue$Outbound = {
  configuration?: string | undefined;
};

/** @internal */
export const CreateDeploymentBuildQueue$outboundSchema: z.ZodType<
  CreateDeploymentBuildQueue$Outbound,
  z.ZodTypeDef,
  CreateDeploymentBuildQueue
> = z.object({
  configuration: CreateDeploymentConfiguration$outboundSchema.optional(),
});

export function createDeploymentBuildQueueToJSON(
  createDeploymentBuildQueue: CreateDeploymentBuildQueue,
): string {
  return JSON.stringify(
    CreateDeploymentBuildQueue$outboundSchema.parse(createDeploymentBuildQueue),
  );
}
export function createDeploymentBuildQueueFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentBuildQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentBuildQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentBuildQueue' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentPurchaseType$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentPurchaseType
> = z.nativeEnum(CreateDeploymentPurchaseType);
/** @internal */
export const CreateDeploymentPurchaseType$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentPurchaseType
> = CreateDeploymentPurchaseType$inboundSchema;

/** @internal */
export const CreateDeploymentBuildMachine$inboundSchema: z.ZodType<
  CreateDeploymentBuildMachine,
  z.ZodTypeDef,
  unknown
> = z.object({
  purchaseType: types.optional(CreateDeploymentPurchaseType$inboundSchema),
  isDefaultBuildMachine: types.optional(types.boolean()),
  cores: types.optional(types.number()),
  memory: types.optional(types.number()),
});
/** @internal */
export type CreateDeploymentBuildMachine$Outbound = {
  purchaseType?: string | undefined;
  isDefaultBuildMachine?: boolean | undefined;
  cores?: number | undefined;
  memory?: number | undefined;
};

/** @internal */
export const CreateDeploymentBuildMachine$outboundSchema: z.ZodType<
  CreateDeploymentBuildMachine$Outbound,
  z.ZodTypeDef,
  CreateDeploymentBuildMachine
> = z.object({
  purchaseType: CreateDeploymentPurchaseType$outboundSchema.optional(),
  isDefaultBuildMachine: z.boolean().optional(),
  cores: z.number().optional(),
  memory: z.number().optional(),
});

export function createDeploymentBuildMachineToJSON(
  createDeploymentBuildMachine: CreateDeploymentBuildMachine,
): string {
  return JSON.stringify(
    CreateDeploymentBuildMachine$outboundSchema.parse(
      createDeploymentBuildMachine,
    ),
  );
}
export function createDeploymentBuildMachineFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentBuildMachine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentBuildMachine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentBuildMachine' from JSON`,
  );
}

/** @internal */
export const ElasticConcurrency$inboundSchema: z.ZodNativeEnum<
  typeof ElasticConcurrency
> = z.nativeEnum(ElasticConcurrency);
/** @internal */
export const ElasticConcurrency$outboundSchema: z.ZodNativeEnum<
  typeof ElasticConcurrency
> = ElasticConcurrency$inboundSchema;

/** @internal */
export const CreateDeploymentResourceConfig$inboundSchema: z.ZodType<
  CreateDeploymentResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  buildQueue: types.optional(
    z.lazy(() => CreateDeploymentBuildQueue$inboundSchema),
  ),
  buildMachine: types.optional(
    z.lazy(() => CreateDeploymentBuildMachine$inboundSchema),
  ),
  elasticConcurrency: types.optional(ElasticConcurrency$inboundSchema),
});
/** @internal */
export type CreateDeploymentResourceConfig$Outbound = {
  buildQueue?: CreateDeploymentBuildQueue$Outbound | undefined;
  buildMachine?: CreateDeploymentBuildMachine$Outbound | undefined;
  elasticConcurrency?: string | undefined;
};

/** @internal */
export const CreateDeploymentResourceConfig$outboundSchema: z.ZodType<
  CreateDeploymentResourceConfig$Outbound,
  z.ZodTypeDef,
  CreateDeploymentResourceConfig
> = z.object({
  buildQueue: z.lazy(() => CreateDeploymentBuildQueue$outboundSchema)
    .optional(),
  buildMachine: z.lazy(() => CreateDeploymentBuildMachine$outboundSchema)
    .optional(),
  elasticConcurrency: ElasticConcurrency$outboundSchema.optional(),
});

export function createDeploymentResourceConfigToJSON(
  createDeploymentResourceConfig: CreateDeploymentResourceConfig,
): string {
  return JSON.stringify(
    CreateDeploymentResourceConfig$outboundSchema.parse(
      createDeploymentResourceConfig,
    ),
  );
}
export function createDeploymentResourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentResourceConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentResourceConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentResourceConfig' from JSON`,
  );
}

/** @internal */
export const Config$inboundSchema: z.ZodType<Config, z.ZodTypeDef, unknown> = z
  .object({
    version: types.optional(types.number()),
    functionType: FunctionType$inboundSchema,
    functionMemoryType: FunctionMemoryType$inboundSchema,
    functionTimeout: types.nullable(types.number()),
    secureComputePrimaryRegion: types.nullable(types.string()),
    secureComputeFallbackRegion: types.nullable(types.string()),
    isUsingActiveCPU: types.optional(types.boolean()),
    resourceConfig: types.optional(
      z.lazy(() => CreateDeploymentResourceConfig$inboundSchema),
    ),
  });
/** @internal */
export type Config$Outbound = {
  version?: number | undefined;
  functionType: string;
  functionMemoryType: string;
  functionTimeout: number | null;
  secureComputePrimaryRegion: string | null;
  secureComputeFallbackRegion: string | null;
  isUsingActiveCPU?: boolean | undefined;
  resourceConfig?: CreateDeploymentResourceConfig$Outbound | undefined;
};

/** @internal */
export const Config$outboundSchema: z.ZodType<
  Config$Outbound,
  z.ZodTypeDef,
  Config
> = z.object({
  version: z.number().optional(),
  functionType: FunctionType$outboundSchema,
  functionMemoryType: FunctionMemoryType$outboundSchema,
  functionTimeout: z.nullable(z.number()),
  secureComputePrimaryRegion: z.nullable(z.string()),
  secureComputeFallbackRegion: z.nullable(z.string()),
  isUsingActiveCPU: z.boolean().optional(),
  resourceConfig: z.lazy(() => CreateDeploymentResourceConfig$outboundSchema)
    .optional(),
});

export function configToJSON(config: Config): string {
  return JSON.stringify(Config$outboundSchema.parse(config));
}
export function configFromJSON(
  jsonString: string,
): SafeParseResult<Config, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Config$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Config' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentDeploymentsState$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsState
> = z.nativeEnum(CreateDeploymentDeploymentsState);
/** @internal */
export const CreateDeploymentDeploymentsState$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeploymentDeploymentsState
> = CreateDeploymentDeploymentsState$inboundSchema;

/** @internal */
export const DeploymentAlias$inboundSchema: z.ZodType<
  DeploymentAlias,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: CreateDeploymentDeploymentsState$inboundSchema,
  startedAt: types.number(),
  completedAt: types.optional(types.number()),
});
/** @internal */
export type DeploymentAlias$Outbound = {
  state: string;
  startedAt: number;
  completedAt?: number | undefined;
};

/** @internal */
export const DeploymentAlias$outboundSchema: z.ZodType<
  DeploymentAlias$Outbound,
  z.ZodTypeDef,
  DeploymentAlias
> = z.object({
  state: CreateDeploymentDeploymentsState$outboundSchema,
  startedAt: z.number(),
  completedAt: z.number().optional(),
});

export function deploymentAliasToJSON(
  deploymentAlias: DeploymentAlias,
): string {
  return JSON.stringify(DeploymentAlias$outboundSchema.parse(deploymentAlias));
}
export function deploymentAliasFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentAlias, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentAlias$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentAlias' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentChecks$inboundSchema: z.ZodType<
  CreateDeploymentChecks,
  z.ZodTypeDef,
  unknown
> = z.object({
  "deployment-alias": z.lazy(() => DeploymentAlias$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "deployment-alias": "deploymentAlias",
  });
});
/** @internal */
export type CreateDeploymentChecks$Outbound = {
  "deployment-alias": DeploymentAlias$Outbound;
};

/** @internal */
export const CreateDeploymentChecks$outboundSchema: z.ZodType<
  CreateDeploymentChecks$Outbound,
  z.ZodTypeDef,
  CreateDeploymentChecks
> = z.object({
  deploymentAlias: z.lazy(() => DeploymentAlias$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    deploymentAlias: "deployment-alias",
  });
});

export function createDeploymentChecksToJSON(
  createDeploymentChecks: CreateDeploymentChecks,
): string {
  return JSON.stringify(
    CreateDeploymentChecks$outboundSchema.parse(createDeploymentChecks),
  );
}
export function createDeploymentChecksFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentChecks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentChecks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentChecks' from JSON`,
  );
}

/** @internal */
export const CreateDeploymentResponseBody$inboundSchema: z.ZodType<
  CreateDeploymentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  aliasAssignedAt: z.nullable(smartUnion([types.number(), types.boolean()]))
    .optional(),
  alwaysRefuseToBuild: types.optional(types.boolean()),
  build: z.lazy(() => Build$inboundSchema),
  buildArtifactUrls: types.optional(z.array(types.string())),
  builds: types.optional(z.array(z.lazy(() => Builds$inboundSchema))),
  env: z.array(types.string()),
  inspectorUrl: types.nullable(types.string()),
  isInConcurrentBuildsQueue: types.boolean(),
  isInSystemBuildsQueue: types.boolean(),
  projectSettings: z.lazy(() => CreateDeploymentProjectSettings$inboundSchema),
  readyStateReason: types.optional(types.string()),
  integrations: types.optional(z.lazy(() => Integrations$inboundSchema)),
  images: types.optional(z.lazy(() => Images$inboundSchema)),
  alias: types.optional(z.array(types.string())),
  aliasAssigned: types.boolean(),
  bootedAt: types.number(),
  buildingAt: types.number(),
  buildContainerFinishedAt: types.optional(types.number()),
  buildSkipped: types.boolean(),
  creator: z.lazy(() => Creator$inboundSchema),
  initReadyAt: types.optional(types.number()),
  isFirstBranchDeployment: types.optional(types.boolean()),
  lambdas: types.optional(z.array(z.lazy(() => Lambdas$inboundSchema))),
  public: types.boolean(),
  ready: types.optional(types.number()),
  status: CreateDeploymentStatus$inboundSchema,
  team: types.optional(z.lazy(() => CreateDeploymentTeam$inboundSchema)),
  userAliases: types.optional(z.array(types.string())),
  previewCommentsEnabled: types.optional(types.boolean()),
  ttyBuildLogs: types.optional(types.boolean()),
  customEnvironment: types.optional(
    smartUnion([
      z.lazy(() => CustomEnvironment1$inboundSchema),
      z.lazy(() => CustomEnvironment2$inboundSchema),
    ]),
  ),
  oomReport: types.optional(OomReport$inboundSchema),
  aliasWarning: z.nullable(z.lazy(() => AliasWarning$inboundSchema)).optional(),
  id: types.string(),
  createdAt: types.number(),
  readyState: ReadyState$inboundSchema,
  name: types.string(),
  type: CreateDeploymentType$inboundSchema,
  aliasError: z.nullable(z.lazy(() => AliasError$inboundSchema)).optional(),
  aliasFinal: z.nullable(types.string()).optional(),
  autoAssignCustomDomains: types.optional(types.boolean()),
  automaticAliases: types.optional(z.array(types.string())),
  buildErrorAt: types.optional(types.number()),
  checksState: types.optional(ChecksState$inboundSchema),
  checksConclusion: types.optional(ChecksConclusion$inboundSchema),
  deletedAt: z.nullable(types.number()).optional(),
  defaultRoute: types.optional(types.string()),
  canceledAt: types.optional(types.number()),
  errorCode: types.optional(types.string()),
  errorLink: types.optional(types.string()),
  errorMessage: z.nullable(types.string()).optional(),
  errorStep: types.optional(types.string()),
  passiveRegions: types.optional(z.array(types.string())),
  gitSource: types.optional(
    smartUnion([
      z.lazy(() => CreateDeploymentGitSource12$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource15$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource4$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource10$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource11$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource13$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource14$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource2$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource3$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource6$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource9$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource1$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource5$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource7$inboundSchema),
      z.lazy(() => CreateDeploymentGitSource8$inboundSchema),
    ]),
  ),
  manualProvisioning: types.optional(
    z.lazy(() => ManualProvisioning$inboundSchema),
  ),
  meta: z.record(types.string()),
  originCacheRegion: types.optional(types.string()),
  nodeVersion: types.optional(CreateDeploymentNodeVersion$inboundSchema),
  project: types.optional(z.lazy(() => CreateDeploymentProject$inboundSchema)),
  prebuilt: types.optional(types.boolean()),
  readySubstate: types.optional(ReadySubstate$inboundSchema),
  regions: z.array(types.string()),
  softDeletedByRetention: types.optional(types.boolean()),
  source: types.optional(CreateDeploymentSource$inboundSchema),
  target: z.nullable(CreateDeploymentTarget$inboundSchema).optional(),
  undeletedAt: types.optional(types.number()),
  url: types.string(),
  userConfiguredDeploymentId: types.optional(types.string()),
  version: types.number(),
  oidcTokenClaims: types.optional(z.lazy(() => OidcTokenClaims$inboundSchema)),
  projectId: types.string(),
  plan: CreateDeploymentPlan$inboundSchema,
  connectBuildsEnabled: types.optional(types.boolean()),
  connectConfigurationId: types.optional(types.string()),
  createdIn: types.string(),
  crons: types.optional(z.array(z.lazy(() => Crons$inboundSchema))),
  functions: z.nullable(z.record(z.lazy(() => Functions$inboundSchema)))
    .optional(),
  monorepoManager: z.nullable(types.string()).optional(),
  ownerId: types.string(),
  passiveConnectConfigurationId: types.optional(types.string()),
  routes: types.nullable(
    z.array(smartUnion([
      z.lazy(() => Routes3$inboundSchema),
      z.lazy(() =>
        Routes1$inboundSchema
      ),
      z.lazy(() => Routes2$inboundSchema),
    ])),
  ),
  gitRepo: z.nullable(
    z.union([
      z.lazy(() => GitRepo1$inboundSchema),
      z.lazy(() => GitRepo2$inboundSchema),
      z.lazy(() => GitRepo3$inboundSchema),
    ]),
  ).optional(),
  flags: types.optional(
    smartUnion([
      z.lazy(() => Flags1$inboundSchema),
      z.array(z.lazy(() => Flags2$inboundSchema)),
    ]),
  ),
  microfrontends: types.optional(
    smartUnion([
      z.lazy(() => CreateDeploymentMicrofrontends2$inboundSchema),
      z.lazy(() => CreateDeploymentMicrofrontends1$inboundSchema),
    ]),
  ),
  config: types.optional(z.lazy(() => Config$inboundSchema)),
  checks: types.optional(z.lazy(() => CreateDeploymentChecks$inboundSchema)),
});
/** @internal */
export type CreateDeploymentResponseBody$Outbound = {
  aliasAssignedAt?: number | boolean | null | undefined;
  alwaysRefuseToBuild?: boolean | undefined;
  build: Build$Outbound;
  buildArtifactUrls?: Array<string> | undefined;
  builds?: Array<Builds$Outbound> | undefined;
  env: Array<string>;
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  isInSystemBuildsQueue: boolean;
  projectSettings: CreateDeploymentProjectSettings$Outbound;
  readyStateReason?: string | undefined;
  integrations?: Integrations$Outbound | undefined;
  images?: Images$Outbound | undefined;
  alias?: Array<string> | undefined;
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  buildContainerFinishedAt?: number | undefined;
  buildSkipped: boolean;
  creator: Creator$Outbound;
  initReadyAt?: number | undefined;
  isFirstBranchDeployment?: boolean | undefined;
  lambdas?: Array<Lambdas$Outbound> | undefined;
  public: boolean;
  ready?: number | undefined;
  status: string;
  team?: CreateDeploymentTeam$Outbound | undefined;
  userAliases?: Array<string> | undefined;
  previewCommentsEnabled?: boolean | undefined;
  ttyBuildLogs?: boolean | undefined;
  customEnvironment?:
    | CustomEnvironment1$Outbound
    | CustomEnvironment2$Outbound
    | undefined;
  oomReport?: string | undefined;
  aliasWarning?: AliasWarning$Outbound | null | undefined;
  id: string;
  createdAt: number;
  readyState: string;
  name: string;
  type: string;
  aliasError?: AliasError$Outbound | null | undefined;
  aliasFinal?: string | null | undefined;
  autoAssignCustomDomains?: boolean | undefined;
  automaticAliases?: Array<string> | undefined;
  buildErrorAt?: number | undefined;
  checksState?: string | undefined;
  checksConclusion?: string | undefined;
  deletedAt?: number | null | undefined;
  defaultRoute?: string | undefined;
  canceledAt?: number | undefined;
  errorCode?: string | undefined;
  errorLink?: string | undefined;
  errorMessage?: string | null | undefined;
  errorStep?: string | undefined;
  passiveRegions?: Array<string> | undefined;
  gitSource?:
    | CreateDeploymentGitSource12$Outbound
    | CreateDeploymentGitSource15$Outbound
    | CreateDeploymentGitSource4$Outbound
    | CreateDeploymentGitSource10$Outbound
    | CreateDeploymentGitSource11$Outbound
    | CreateDeploymentGitSource13$Outbound
    | CreateDeploymentGitSource14$Outbound
    | CreateDeploymentGitSource2$Outbound
    | CreateDeploymentGitSource3$Outbound
    | CreateDeploymentGitSource6$Outbound
    | CreateDeploymentGitSource9$Outbound
    | CreateDeploymentGitSource1$Outbound
    | CreateDeploymentGitSource5$Outbound
    | CreateDeploymentGitSource7$Outbound
    | CreateDeploymentGitSource8$Outbound
    | undefined;
  manualProvisioning?: ManualProvisioning$Outbound | undefined;
  meta: { [k: string]: string };
  originCacheRegion?: string | undefined;
  nodeVersion?: string | undefined;
  project?: CreateDeploymentProject$Outbound | undefined;
  prebuilt?: boolean | undefined;
  readySubstate?: string | undefined;
  regions: Array<string>;
  softDeletedByRetention?: boolean | undefined;
  source?: string | undefined;
  target?: string | null | undefined;
  undeletedAt?: number | undefined;
  url: string;
  userConfiguredDeploymentId?: string | undefined;
  version: number;
  oidcTokenClaims?: OidcTokenClaims$Outbound | undefined;
  projectId: string;
  plan: string;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdIn: string;
  crons?: Array<Crons$Outbound> | undefined;
  functions?: { [k: string]: Functions$Outbound } | null | undefined;
  monorepoManager?: string | null | undefined;
  ownerId: string;
  passiveConnectConfigurationId?: string | undefined;
  routes: Array<Routes3$Outbound | Routes1$Outbound | Routes2$Outbound> | null;
  gitRepo?:
    | GitRepo1$Outbound
    | GitRepo2$Outbound
    | GitRepo3$Outbound
    | null
    | undefined;
  flags?: Flags1$Outbound | Array<Flags2$Outbound> | undefined;
  microfrontends?:
    | CreateDeploymentMicrofrontends2$Outbound
    | CreateDeploymentMicrofrontends1$Outbound
    | undefined;
  config?: Config$Outbound | undefined;
  checks?: CreateDeploymentChecks$Outbound | undefined;
};

/** @internal */
export const CreateDeploymentResponseBody$outboundSchema: z.ZodType<
  CreateDeploymentResponseBody$Outbound,
  z.ZodTypeDef,
  CreateDeploymentResponseBody
> = z.object({
  aliasAssignedAt: z.nullable(smartUnion([z.number(), z.boolean()])).optional(),
  alwaysRefuseToBuild: z.boolean().optional(),
  build: z.lazy(() => Build$outboundSchema),
  buildArtifactUrls: z.array(z.string()).optional(),
  builds: z.array(z.lazy(() => Builds$outboundSchema)).optional(),
  env: z.array(z.string()),
  inspectorUrl: z.nullable(z.string()),
  isInConcurrentBuildsQueue: z.boolean(),
  isInSystemBuildsQueue: z.boolean(),
  projectSettings: z.lazy(() => CreateDeploymentProjectSettings$outboundSchema),
  readyStateReason: z.string().optional(),
  integrations: z.lazy(() => Integrations$outboundSchema).optional(),
  images: z.lazy(() => Images$outboundSchema).optional(),
  alias: z.array(z.string()).optional(),
  aliasAssigned: z.boolean(),
  bootedAt: z.number(),
  buildingAt: z.number(),
  buildContainerFinishedAt: z.number().optional(),
  buildSkipped: z.boolean(),
  creator: z.lazy(() => Creator$outboundSchema),
  initReadyAt: z.number().optional(),
  isFirstBranchDeployment: z.boolean().optional(),
  lambdas: z.array(z.lazy(() => Lambdas$outboundSchema)).optional(),
  public: z.boolean(),
  ready: z.number().optional(),
  status: CreateDeploymentStatus$outboundSchema,
  team: z.lazy(() => CreateDeploymentTeam$outboundSchema).optional(),
  userAliases: z.array(z.string()).optional(),
  previewCommentsEnabled: z.boolean().optional(),
  ttyBuildLogs: z.boolean().optional(),
  customEnvironment: smartUnion([
    z.lazy(() => CustomEnvironment1$outboundSchema),
    z.lazy(() => CustomEnvironment2$outboundSchema),
  ]).optional(),
  oomReport: OomReport$outboundSchema.optional(),
  aliasWarning: z.nullable(z.lazy(() => AliasWarning$outboundSchema))
    .optional(),
  id: z.string(),
  createdAt: z.number(),
  readyState: ReadyState$outboundSchema,
  name: z.string(),
  type: CreateDeploymentType$outboundSchema,
  aliasError: z.nullable(z.lazy(() => AliasError$outboundSchema)).optional(),
  aliasFinal: z.nullable(z.string()).optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  automaticAliases: z.array(z.string()).optional(),
  buildErrorAt: z.number().optional(),
  checksState: ChecksState$outboundSchema.optional(),
  checksConclusion: ChecksConclusion$outboundSchema.optional(),
  deletedAt: z.nullable(z.number()).optional(),
  defaultRoute: z.string().optional(),
  canceledAt: z.number().optional(),
  errorCode: z.string().optional(),
  errorLink: z.string().optional(),
  errorMessage: z.nullable(z.string()).optional(),
  errorStep: z.string().optional(),
  passiveRegions: z.array(z.string()).optional(),
  gitSource: smartUnion([
    z.lazy(() => CreateDeploymentGitSource12$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource15$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource4$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource10$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource11$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource13$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource14$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource2$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource3$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource6$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource9$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource1$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource5$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource7$outboundSchema),
    z.lazy(() => CreateDeploymentGitSource8$outboundSchema),
  ]).optional(),
  manualProvisioning: z.lazy(() => ManualProvisioning$outboundSchema)
    .optional(),
  meta: z.record(z.string()),
  originCacheRegion: z.string().optional(),
  nodeVersion: CreateDeploymentNodeVersion$outboundSchema.optional(),
  project: z.lazy(() => CreateDeploymentProject$outboundSchema).optional(),
  prebuilt: z.boolean().optional(),
  readySubstate: ReadySubstate$outboundSchema.optional(),
  regions: z.array(z.string()),
  softDeletedByRetention: z.boolean().optional(),
  source: CreateDeploymentSource$outboundSchema.optional(),
  target: z.nullable(CreateDeploymentTarget$outboundSchema).optional(),
  undeletedAt: z.number().optional(),
  url: z.string(),
  userConfiguredDeploymentId: z.string().optional(),
  version: z.number(),
  oidcTokenClaims: z.lazy(() => OidcTokenClaims$outboundSchema).optional(),
  projectId: z.string(),
  plan: CreateDeploymentPlan$outboundSchema,
  connectBuildsEnabled: z.boolean().optional(),
  connectConfigurationId: z.string().optional(),
  createdIn: z.string(),
  crons: z.array(z.lazy(() => Crons$outboundSchema)).optional(),
  functions: z.nullable(z.record(z.lazy(() => Functions$outboundSchema)))
    .optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  ownerId: z.string(),
  passiveConnectConfigurationId: z.string().optional(),
  routes: z.nullable(
    z.array(smartUnion([
      z.lazy(() => Routes3$outboundSchema),
      z.lazy(() =>
        Routes1$outboundSchema
      ),
      z.lazy(() => Routes2$outboundSchema),
    ])),
  ),
  gitRepo: z.nullable(
    z.union([
      z.lazy(() => GitRepo1$outboundSchema),
      z.lazy(() => GitRepo2$outboundSchema),
      z.lazy(() => GitRepo3$outboundSchema),
    ]),
  ).optional(),
  flags: smartUnion([
    z.lazy(() => Flags1$outboundSchema),
    z.array(z.lazy(() => Flags2$outboundSchema)),
  ]).optional(),
  microfrontends: smartUnion([
    z.lazy(() => CreateDeploymentMicrofrontends2$outboundSchema),
    z.lazy(() => CreateDeploymentMicrofrontends1$outboundSchema),
  ]).optional(),
  config: z.lazy(() => Config$outboundSchema).optional(),
  checks: z.lazy(() => CreateDeploymentChecks$outboundSchema).optional(),
});

export function createDeploymentResponseBodyToJSON(
  createDeploymentResponseBody: CreateDeploymentResponseBody,
): string {
  return JSON.stringify(
    CreateDeploymentResponseBody$outboundSchema.parse(
      createDeploymentResponseBody,
    ),
  );
}
export function createDeploymentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateDeploymentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDeploymentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDeploymentResponseBody' from JSON`,
  );
}
