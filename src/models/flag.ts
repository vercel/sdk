/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type Value = string | number | boolean;

export type Variants = {
  description?: string | undefined;
  label?: string | undefined;
  value: string | number | boolean;
  id: string;
};

export type Reuse = {
  active: boolean;
  environment: string;
};

export type Targets = {
  note?: string | undefined;
  value: string;
};

export const FlagType = {
  Variant: "variant",
} as const;
export type FlagType = ClosedEnum<typeof FlagType>;

export type PausedOutcome = {
  type: FlagType;
  variantId: string;
};

export const FlagFallthroughEnvironmentsType = {
  Entity: "entity",
} as const;
export type FlagFallthroughEnvironmentsType = ClosedEnum<
  typeof FlagFallthroughEnvironmentsType
>;

export type Base = {
  type: FlagFallthroughEnvironmentsType;
  kind: string;
  attribute: string;
};

export type Fallthrough2 = {
  type: "split";
  base: Base;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

export type Fallthrough1 = {
  type: "variant";
  variantId: string;
};

export type Fallthrough = Fallthrough1 | Fallthrough2;

export const FlagOutcomeEnvironmentsType = {
  Entity: "entity",
} as const;
export type FlagOutcomeEnvironmentsType = ClosedEnum<
  typeof FlagOutcomeEnvironmentsType
>;

export type OutcomeBase = {
  type: FlagOutcomeEnvironmentsType;
  kind: string;
  attribute: string;
};

export type Outcome2 = {
  type: "split";
  base: OutcomeBase;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

export type Outcome1 = {
  type: "variant";
  variantId: string;
};

export type Outcome = Outcome1 | Outcome2;

export const FlagRhsType = {
  Regex: "regex",
} as const;
export type FlagRhsType = ClosedEnum<typeof FlagRhsType>;

export type Rhs4 = {
  type: FlagRhsType;
  pattern: string;
  flags: string;
};

export const RhsType = {
  ListInline: "list/inline",
  List: "list",
} as const;
export type RhsType = ClosedEnum<typeof RhsType>;

export type Items2 = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

export type Items1 = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

export type RhsItems = Items1 | Items2;

export type Rhs3 = {
  type: RhsType;
  items: Array<Items1 | Items2>;
};

export type Rhs = Rhs4 | Rhs3 | string | number | boolean;

export type Lhs2 = {
  type: "entity";
  kind: string;
  attribute: string;
};

export type Lhs1 = {
  type: "segment";
};

export type Lhs = Lhs1 | Lhs2;

export const Cmp = {
  Eq: "eq",
  NotEq: "!eq",
  OneOf: "oneOf",
  NotOneOf: "!oneOf",
  ContainsAllOf: "containsAllOf",
  ContainsAnyOf: "containsAnyOf",
  ContainsNoneOf: "containsNoneOf",
  StartsWith: "startsWith",
  NotStartsWith: "!startsWith",
  EndsWith: "endsWith",
  NotEndsWith: "!endsWith",
  Ex: "ex",
  NotEx: "!ex",
  Gt: "gt",
  Gte: "gte",
  Lt: "lt",
  Lte: "lte",
  Regex: "regex",
  NotRegex: "!regex",
  Before: "before",
  After: "after",
} as const;
export type Cmp = ClosedEnum<typeof Cmp>;

export type Conditions = {
  rhs?: Rhs4 | Rhs3 | string | number | boolean | undefined;
  lhs: Lhs1 | Lhs2;
  cmp: Cmp;
};

export type Rules = {
  id: string;
  outcome: Outcome1 | Outcome2;
  conditions: Array<Conditions>;
};

export type Environments = {
  reuse?: Reuse | undefined;
  targets?:
    | { [k: string]: { [k: string]: { [k: string]: Array<Targets> } } }
    | undefined;
  revision?: number | undefined;
  pausedOutcome: PausedOutcome;
  fallthrough: Fallthrough1 | Fallthrough2;
  active: boolean;
  rules: Array<Rules>;
};

export const Kind = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
export type Kind = ClosedEnum<typeof Kind>;

export const State = {
  Active: "active",
  Archived: "archived",
} as const;
export type State = ClosedEnum<typeof State>;

export const TypeName = {
  Flag: "flag",
} as const;
export type TypeName = ClosedEnum<typeof TypeName>;

export type Creator = {
  id: string;
  name: string;
};

export type Metadata = {
  creator?: Creator | undefined;
};

export type Flag = {
  description?: string | undefined;
  variants: Array<Variants>;
  id: string;
  environments: { [k: string]: Environments };
  kind: Kind;
  revision: number;
  seed: number;
  state: State;
  slug: string;
  createdAt: number;
  updatedAt: number;
  createdBy: string;
  ownerId: string;
  projectId: string;
  typeName: TypeName;
  metadata?: Metadata | undefined;
};

/** @internal */
export const Value$inboundSchema: z.ZodType<Value, z.ZodTypeDef, unknown> =
  smartUnion([types.string(), types.number(), types.boolean()]);
/** @internal */
export type Value$Outbound = string | number | boolean;

/** @internal */
export const Value$outboundSchema: z.ZodType<
  Value$Outbound,
  z.ZodTypeDef,
  Value
> = smartUnion([z.string(), z.number(), z.boolean()]);

export function valueToJSON(value: Value): string {
  return JSON.stringify(Value$outboundSchema.parse(value));
}
export function valueFromJSON(
  jsonString: string,
): SafeParseResult<Value, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value' from JSON`,
  );
}

/** @internal */
export const Variants$inboundSchema: z.ZodType<
  Variants,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: types.optional(types.string()),
  label: types.optional(types.string()),
  value: smartUnion([types.string(), types.number(), types.boolean()]),
  id: types.string(),
});
/** @internal */
export type Variants$Outbound = {
  description?: string | undefined;
  label?: string | undefined;
  value: string | number | boolean;
  id: string;
};

/** @internal */
export const Variants$outboundSchema: z.ZodType<
  Variants$Outbound,
  z.ZodTypeDef,
  Variants
> = z.object({
  description: z.string().optional(),
  label: z.string().optional(),
  value: smartUnion([z.string(), z.number(), z.boolean()]),
  id: z.string(),
});

export function variantsToJSON(variants: Variants): string {
  return JSON.stringify(Variants$outboundSchema.parse(variants));
}
export function variantsFromJSON(
  jsonString: string,
): SafeParseResult<Variants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Variants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Variants' from JSON`,
  );
}

/** @internal */
export const Reuse$inboundSchema: z.ZodType<Reuse, z.ZodTypeDef, unknown> = z
  .object({
    active: types.boolean(),
    environment: types.string(),
  });
/** @internal */
export type Reuse$Outbound = {
  active: boolean;
  environment: string;
};

/** @internal */
export const Reuse$outboundSchema: z.ZodType<
  Reuse$Outbound,
  z.ZodTypeDef,
  Reuse
> = z.object({
  active: z.boolean(),
  environment: z.string(),
});

export function reuseToJSON(reuse: Reuse): string {
  return JSON.stringify(Reuse$outboundSchema.parse(reuse));
}
export function reuseFromJSON(
  jsonString: string,
): SafeParseResult<Reuse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Reuse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Reuse' from JSON`,
  );
}

/** @internal */
export const Targets$inboundSchema: z.ZodType<Targets, z.ZodTypeDef, unknown> =
  z.object({
    note: types.optional(types.string()),
    value: types.string(),
  });
/** @internal */
export type Targets$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const Targets$outboundSchema: z.ZodType<
  Targets$Outbound,
  z.ZodTypeDef,
  Targets
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function targetsToJSON(targets: Targets): string {
  return JSON.stringify(Targets$outboundSchema.parse(targets));
}
export function targetsFromJSON(
  jsonString: string,
): SafeParseResult<Targets, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Targets$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Targets' from JSON`,
  );
}

/** @internal */
export const FlagType$inboundSchema: z.ZodNativeEnum<typeof FlagType> = z
  .nativeEnum(FlagType);
/** @internal */
export const FlagType$outboundSchema: z.ZodNativeEnum<typeof FlagType> =
  FlagType$inboundSchema;

/** @internal */
export const PausedOutcome$inboundSchema: z.ZodType<
  PausedOutcome,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FlagType$inboundSchema,
  variantId: types.string(),
});
/** @internal */
export type PausedOutcome$Outbound = {
  type: string;
  variantId: string;
};

/** @internal */
export const PausedOutcome$outboundSchema: z.ZodType<
  PausedOutcome$Outbound,
  z.ZodTypeDef,
  PausedOutcome
> = z.object({
  type: FlagType$outboundSchema,
  variantId: z.string(),
});

export function pausedOutcomeToJSON(pausedOutcome: PausedOutcome): string {
  return JSON.stringify(PausedOutcome$outboundSchema.parse(pausedOutcome));
}
export function pausedOutcomeFromJSON(
  jsonString: string,
): SafeParseResult<PausedOutcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PausedOutcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PausedOutcome' from JSON`,
  );
}

/** @internal */
export const FlagFallthroughEnvironmentsType$inboundSchema: z.ZodNativeEnum<
  typeof FlagFallthroughEnvironmentsType
> = z.nativeEnum(FlagFallthroughEnvironmentsType);
/** @internal */
export const FlagFallthroughEnvironmentsType$outboundSchema: z.ZodNativeEnum<
  typeof FlagFallthroughEnvironmentsType
> = FlagFallthroughEnvironmentsType$inboundSchema;

/** @internal */
export const Base$inboundSchema: z.ZodType<Base, z.ZodTypeDef, unknown> = z
  .object({
    type: FlagFallthroughEnvironmentsType$inboundSchema,
    kind: types.string(),
    attribute: types.string(),
  });
/** @internal */
export type Base$Outbound = {
  type: string;
  kind: string;
  attribute: string;
};

/** @internal */
export const Base$outboundSchema: z.ZodType<Base$Outbound, z.ZodTypeDef, Base> =
  z.object({
    type: FlagFallthroughEnvironmentsType$outboundSchema,
    kind: z.string(),
    attribute: z.string(),
  });

export function baseToJSON(base: Base): string {
  return JSON.stringify(Base$outboundSchema.parse(base));
}
export function baseFromJSON(
  jsonString: string,
): SafeParseResult<Base, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Base$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Base' from JSON`,
  );
}

/** @internal */
export const Fallthrough2$inboundSchema: z.ZodType<
  Fallthrough2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("split"),
  base: z.lazy(() => Base$inboundSchema),
  weights: z.record(types.number()),
  defaultVariantId: types.string(),
});
/** @internal */
export type Fallthrough2$Outbound = {
  type: "split";
  base: Base$Outbound;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

/** @internal */
export const Fallthrough2$outboundSchema: z.ZodType<
  Fallthrough2$Outbound,
  z.ZodTypeDef,
  Fallthrough2
> = z.object({
  type: z.literal("split"),
  base: z.lazy(() => Base$outboundSchema),
  weights: z.record(z.number()),
  defaultVariantId: z.string(),
});

export function fallthrough2ToJSON(fallthrough2: Fallthrough2): string {
  return JSON.stringify(Fallthrough2$outboundSchema.parse(fallthrough2));
}
export function fallthrough2FromJSON(
  jsonString: string,
): SafeParseResult<Fallthrough2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fallthrough2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fallthrough2' from JSON`,
  );
}

/** @internal */
export const Fallthrough1$inboundSchema: z.ZodType<
  Fallthrough1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("variant"),
  variantId: types.string(),
});
/** @internal */
export type Fallthrough1$Outbound = {
  type: "variant";
  variantId: string;
};

/** @internal */
export const Fallthrough1$outboundSchema: z.ZodType<
  Fallthrough1$Outbound,
  z.ZodTypeDef,
  Fallthrough1
> = z.object({
  type: z.literal("variant"),
  variantId: z.string(),
});

export function fallthrough1ToJSON(fallthrough1: Fallthrough1): string {
  return JSON.stringify(Fallthrough1$outboundSchema.parse(fallthrough1));
}
export function fallthrough1FromJSON(
  jsonString: string,
): SafeParseResult<Fallthrough1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fallthrough1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fallthrough1' from JSON`,
  );
}

/** @internal */
export const Fallthrough$inboundSchema: z.ZodType<
  Fallthrough,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Fallthrough1$inboundSchema),
  z.lazy(() => Fallthrough2$inboundSchema),
]);
/** @internal */
export type Fallthrough$Outbound =
  | Fallthrough1$Outbound
  | Fallthrough2$Outbound;

/** @internal */
export const Fallthrough$outboundSchema: z.ZodType<
  Fallthrough$Outbound,
  z.ZodTypeDef,
  Fallthrough
> = z.union([
  z.lazy(() => Fallthrough1$outboundSchema),
  z.lazy(() => Fallthrough2$outboundSchema),
]);

export function fallthroughToJSON(fallthrough: Fallthrough): string {
  return JSON.stringify(Fallthrough$outboundSchema.parse(fallthrough));
}
export function fallthroughFromJSON(
  jsonString: string,
): SafeParseResult<Fallthrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fallthrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fallthrough' from JSON`,
  );
}

/** @internal */
export const FlagOutcomeEnvironmentsType$inboundSchema: z.ZodNativeEnum<
  typeof FlagOutcomeEnvironmentsType
> = z.nativeEnum(FlagOutcomeEnvironmentsType);
/** @internal */
export const FlagOutcomeEnvironmentsType$outboundSchema: z.ZodNativeEnum<
  typeof FlagOutcomeEnvironmentsType
> = FlagOutcomeEnvironmentsType$inboundSchema;

/** @internal */
export const OutcomeBase$inboundSchema: z.ZodType<
  OutcomeBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FlagOutcomeEnvironmentsType$inboundSchema,
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type OutcomeBase$Outbound = {
  type: string;
  kind: string;
  attribute: string;
};

/** @internal */
export const OutcomeBase$outboundSchema: z.ZodType<
  OutcomeBase$Outbound,
  z.ZodTypeDef,
  OutcomeBase
> = z.object({
  type: FlagOutcomeEnvironmentsType$outboundSchema,
  kind: z.string(),
  attribute: z.string(),
});

export function outcomeBaseToJSON(outcomeBase: OutcomeBase): string {
  return JSON.stringify(OutcomeBase$outboundSchema.parse(outcomeBase));
}
export function outcomeBaseFromJSON(
  jsonString: string,
): SafeParseResult<OutcomeBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutcomeBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutcomeBase' from JSON`,
  );
}

/** @internal */
export const Outcome2$inboundSchema: z.ZodType<
  Outcome2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("split"),
  base: z.lazy(() => OutcomeBase$inboundSchema),
  weights: z.record(types.number()),
  defaultVariantId: types.string(),
});
/** @internal */
export type Outcome2$Outbound = {
  type: "split";
  base: OutcomeBase$Outbound;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

/** @internal */
export const Outcome2$outboundSchema: z.ZodType<
  Outcome2$Outbound,
  z.ZodTypeDef,
  Outcome2
> = z.object({
  type: z.literal("split"),
  base: z.lazy(() => OutcomeBase$outboundSchema),
  weights: z.record(z.number()),
  defaultVariantId: z.string(),
});

export function outcome2ToJSON(outcome2: Outcome2): string {
  return JSON.stringify(Outcome2$outboundSchema.parse(outcome2));
}
export function outcome2FromJSON(
  jsonString: string,
): SafeParseResult<Outcome2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Outcome2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Outcome2' from JSON`,
  );
}

/** @internal */
export const Outcome1$inboundSchema: z.ZodType<
  Outcome1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("variant"),
  variantId: types.string(),
});
/** @internal */
export type Outcome1$Outbound = {
  type: "variant";
  variantId: string;
};

/** @internal */
export const Outcome1$outboundSchema: z.ZodType<
  Outcome1$Outbound,
  z.ZodTypeDef,
  Outcome1
> = z.object({
  type: z.literal("variant"),
  variantId: z.string(),
});

export function outcome1ToJSON(outcome1: Outcome1): string {
  return JSON.stringify(Outcome1$outboundSchema.parse(outcome1));
}
export function outcome1FromJSON(
  jsonString: string,
): SafeParseResult<Outcome1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Outcome1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Outcome1' from JSON`,
  );
}

/** @internal */
export const Outcome$inboundSchema: z.ZodType<Outcome, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => Outcome1$inboundSchema),
    z.lazy(() => Outcome2$inboundSchema),
  ]);
/** @internal */
export type Outcome$Outbound = Outcome1$Outbound | Outcome2$Outbound;

/** @internal */
export const Outcome$outboundSchema: z.ZodType<
  Outcome$Outbound,
  z.ZodTypeDef,
  Outcome
> = z.union([
  z.lazy(() => Outcome1$outboundSchema),
  z.lazy(() => Outcome2$outboundSchema),
]);

export function outcomeToJSON(outcome: Outcome): string {
  return JSON.stringify(Outcome$outboundSchema.parse(outcome));
}
export function outcomeFromJSON(
  jsonString: string,
): SafeParseResult<Outcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Outcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Outcome' from JSON`,
  );
}

/** @internal */
export const FlagRhsType$inboundSchema: z.ZodNativeEnum<typeof FlagRhsType> = z
  .nativeEnum(FlagRhsType);
/** @internal */
export const FlagRhsType$outboundSchema: z.ZodNativeEnum<typeof FlagRhsType> =
  FlagRhsType$inboundSchema;

/** @internal */
export const Rhs4$inboundSchema: z.ZodType<Rhs4, z.ZodTypeDef, unknown> = z
  .object({
    type: FlagRhsType$inboundSchema,
    pattern: types.string(),
    flags: types.string(),
  });
/** @internal */
export type Rhs4$Outbound = {
  type: string;
  pattern: string;
  flags: string;
};

/** @internal */
export const Rhs4$outboundSchema: z.ZodType<Rhs4$Outbound, z.ZodTypeDef, Rhs4> =
  z.object({
    type: FlagRhsType$outboundSchema,
    pattern: z.string(),
    flags: z.string(),
  });

export function rhs4ToJSON(rhs4: Rhs4): string {
  return JSON.stringify(Rhs4$outboundSchema.parse(rhs4));
}
export function rhs4FromJSON(
  jsonString: string,
): SafeParseResult<Rhs4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rhs4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rhs4' from JSON`,
  );
}

/** @internal */
export const RhsType$inboundSchema: z.ZodNativeEnum<typeof RhsType> = z
  .nativeEnum(RhsType);
/** @internal */
export const RhsType$outboundSchema: z.ZodNativeEnum<typeof RhsType> =
  RhsType$inboundSchema;

/** @internal */
export const Items2$inboundSchema: z.ZodType<Items2, z.ZodTypeDef, unknown> = z
  .object({
    label: types.optional(types.string()),
    note: types.optional(types.string()),
    value: types.string(),
  });
/** @internal */
export type Items2$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

/** @internal */
export const Items2$outboundSchema: z.ZodType<
  Items2$Outbound,
  z.ZodTypeDef,
  Items2
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.string(),
});

export function items2ToJSON(items2: Items2): string {
  return JSON.stringify(Items2$outboundSchema.parse(items2));
}
export function items2FromJSON(
  jsonString: string,
): SafeParseResult<Items2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Items2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Items2' from JSON`,
  );
}

/** @internal */
export const Items1$inboundSchema: z.ZodType<Items1, z.ZodTypeDef, unknown> = z
  .object({
    label: types.optional(types.string()),
    note: types.optional(types.string()),
    value: types.number(),
  });
/** @internal */
export type Items1$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

/** @internal */
export const Items1$outboundSchema: z.ZodType<
  Items1$Outbound,
  z.ZodTypeDef,
  Items1
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.number(),
});

export function items1ToJSON(items1: Items1): string {
  return JSON.stringify(Items1$outboundSchema.parse(items1));
}
export function items1FromJSON(
  jsonString: string,
): SafeParseResult<Items1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Items1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Items1' from JSON`,
  );
}

/** @internal */
export const RhsItems$inboundSchema: z.ZodType<
  RhsItems,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => Items1$inboundSchema),
  z.lazy(() => Items2$inboundSchema),
]);
/** @internal */
export type RhsItems$Outbound = Items1$Outbound | Items2$Outbound;

/** @internal */
export const RhsItems$outboundSchema: z.ZodType<
  RhsItems$Outbound,
  z.ZodTypeDef,
  RhsItems
> = smartUnion([
  z.lazy(() => Items1$outboundSchema),
  z.lazy(() => Items2$outboundSchema),
]);

export function rhsItemsToJSON(rhsItems: RhsItems): string {
  return JSON.stringify(RhsItems$outboundSchema.parse(rhsItems));
}
export function rhsItemsFromJSON(
  jsonString: string,
): SafeParseResult<RhsItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RhsItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RhsItems' from JSON`,
  );
}

/** @internal */
export const Rhs3$inboundSchema: z.ZodType<Rhs3, z.ZodTypeDef, unknown> = z
  .object({
    type: RhsType$inboundSchema,
    items: z.array(
      smartUnion([
        z.lazy(() => Items1$inboundSchema),
        z.lazy(() => Items2$inboundSchema),
      ]),
    ),
  });
/** @internal */
export type Rhs3$Outbound = {
  type: string;
  items: Array<Items1$Outbound | Items2$Outbound>;
};

/** @internal */
export const Rhs3$outboundSchema: z.ZodType<Rhs3$Outbound, z.ZodTypeDef, Rhs3> =
  z.object({
    type: RhsType$outboundSchema,
    items: z.array(
      smartUnion([
        z.lazy(() => Items1$outboundSchema),
        z.lazy(() => Items2$outboundSchema),
      ]),
    ),
  });

export function rhs3ToJSON(rhs3: Rhs3): string {
  return JSON.stringify(Rhs3$outboundSchema.parse(rhs3));
}
export function rhs3FromJSON(
  jsonString: string,
): SafeParseResult<Rhs3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rhs3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rhs3' from JSON`,
  );
}

/** @internal */
export const Rhs$inboundSchema: z.ZodType<Rhs, z.ZodTypeDef, unknown> =
  smartUnion([
    z.lazy(() => Rhs4$inboundSchema),
    z.lazy(() => Rhs3$inboundSchema),
    types.string(),
    types.number(),
    types.boolean(),
  ]);
/** @internal */
export type Rhs$Outbound =
  | Rhs4$Outbound
  | Rhs3$Outbound
  | string
  | number
  | boolean;

/** @internal */
export const Rhs$outboundSchema: z.ZodType<Rhs$Outbound, z.ZodTypeDef, Rhs> =
  smartUnion([
    z.lazy(() => Rhs4$outboundSchema),
    z.lazy(() => Rhs3$outboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
  ]);

export function rhsToJSON(rhs: Rhs): string {
  return JSON.stringify(Rhs$outboundSchema.parse(rhs));
}
export function rhsFromJSON(
  jsonString: string,
): SafeParseResult<Rhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rhs' from JSON`,
  );
}

/** @internal */
export const Lhs2$inboundSchema: z.ZodType<Lhs2, z.ZodTypeDef, unknown> = z
  .object({
    type: types.literal("entity"),
    kind: types.string(),
    attribute: types.string(),
  });
/** @internal */
export type Lhs2$Outbound = {
  type: "entity";
  kind: string;
  attribute: string;
};

/** @internal */
export const Lhs2$outboundSchema: z.ZodType<Lhs2$Outbound, z.ZodTypeDef, Lhs2> =
  z.object({
    type: z.literal("entity"),
    kind: z.string(),
    attribute: z.string(),
  });

export function lhs2ToJSON(lhs2: Lhs2): string {
  return JSON.stringify(Lhs2$outboundSchema.parse(lhs2));
}
export function lhs2FromJSON(
  jsonString: string,
): SafeParseResult<Lhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lhs2' from JSON`,
  );
}

/** @internal */
export const Lhs1$inboundSchema: z.ZodType<Lhs1, z.ZodTypeDef, unknown> = z
  .object({
    type: types.literal("segment"),
  });
/** @internal */
export type Lhs1$Outbound = {
  type: "segment";
};

/** @internal */
export const Lhs1$outboundSchema: z.ZodType<Lhs1$Outbound, z.ZodTypeDef, Lhs1> =
  z.object({
    type: z.literal("segment"),
  });

export function lhs1ToJSON(lhs1: Lhs1): string {
  return JSON.stringify(Lhs1$outboundSchema.parse(lhs1));
}
export function lhs1FromJSON(
  jsonString: string,
): SafeParseResult<Lhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lhs1' from JSON`,
  );
}

/** @internal */
export const Lhs$inboundSchema: z.ZodType<Lhs, z.ZodTypeDef, unknown> = z.union(
  [z.lazy(() => Lhs1$inboundSchema), z.lazy(() => Lhs2$inboundSchema)],
);
/** @internal */
export type Lhs$Outbound = Lhs1$Outbound | Lhs2$Outbound;

/** @internal */
export const Lhs$outboundSchema: z.ZodType<Lhs$Outbound, z.ZodTypeDef, Lhs> = z
  .union([
    z.lazy(() => Lhs1$outboundSchema),
    z.lazy(() => Lhs2$outboundSchema),
  ]);

export function lhsToJSON(lhs: Lhs): string {
  return JSON.stringify(Lhs$outboundSchema.parse(lhs));
}
export function lhsFromJSON(
  jsonString: string,
): SafeParseResult<Lhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lhs' from JSON`,
  );
}

/** @internal */
export const Cmp$inboundSchema: z.ZodNativeEnum<typeof Cmp> = z.nativeEnum(Cmp);
/** @internal */
export const Cmp$outboundSchema: z.ZodNativeEnum<typeof Cmp> =
  Cmp$inboundSchema;

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  rhs: types.optional(
    smartUnion([
      z.lazy(() => Rhs4$inboundSchema),
      z.lazy(() => Rhs3$inboundSchema),
      types.string(),
      types.number(),
      types.boolean(),
    ]),
  ),
  lhs: z.union([
    z.lazy(() => Lhs1$inboundSchema),
    z.lazy(() => Lhs2$inboundSchema),
  ]),
  cmp: Cmp$inboundSchema,
});
/** @internal */
export type Conditions$Outbound = {
  rhs?: Rhs4$Outbound | Rhs3$Outbound | string | number | boolean | undefined;
  lhs: Lhs1$Outbound | Lhs2$Outbound;
  cmp: string;
};

/** @internal */
export const Conditions$outboundSchema: z.ZodType<
  Conditions$Outbound,
  z.ZodTypeDef,
  Conditions
> = z.object({
  rhs: smartUnion([
    z.lazy(() => Rhs4$outboundSchema),
    z.lazy(() => Rhs3$outboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
  ]).optional(),
  lhs: z.union([
    z.lazy(() => Lhs1$outboundSchema),
    z.lazy(() => Lhs2$outboundSchema),
  ]),
  cmp: Cmp$outboundSchema,
});

export function conditionsToJSON(conditions: Conditions): string {
  return JSON.stringify(Conditions$outboundSchema.parse(conditions));
}
export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const Rules$inboundSchema: z.ZodType<Rules, z.ZodTypeDef, unknown> = z
  .object({
    id: types.string(),
    outcome: z.union([
      z.lazy(() => Outcome1$inboundSchema),
      z.lazy(() => Outcome2$inboundSchema),
    ]),
    conditions: z.array(z.lazy(() => Conditions$inboundSchema)),
  });
/** @internal */
export type Rules$Outbound = {
  id: string;
  outcome: Outcome1$Outbound | Outcome2$Outbound;
  conditions: Array<Conditions$Outbound>;
};

/** @internal */
export const Rules$outboundSchema: z.ZodType<
  Rules$Outbound,
  z.ZodTypeDef,
  Rules
> = z.object({
  id: z.string(),
  outcome: z.union([
    z.lazy(() => Outcome1$outboundSchema),
    z.lazy(() => Outcome2$outboundSchema),
  ]),
  conditions: z.array(z.lazy(() => Conditions$outboundSchema)),
});

export function rulesToJSON(rules: Rules): string {
  return JSON.stringify(Rules$outboundSchema.parse(rules));
}
export function rulesFromJSON(
  jsonString: string,
): SafeParseResult<Rules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rules' from JSON`,
  );
}

/** @internal */
export const Environments$inboundSchema: z.ZodType<
  Environments,
  z.ZodTypeDef,
  unknown
> = z.object({
  reuse: types.optional(z.lazy(() => Reuse$inboundSchema)),
  targets: types.optional(
    z.record(z.record(z.record(z.array(z.lazy(() => Targets$inboundSchema))))),
  ),
  revision: types.optional(types.number()),
  pausedOutcome: z.lazy(() => PausedOutcome$inboundSchema),
  fallthrough: z.union([
    z.lazy(() => Fallthrough1$inboundSchema),
    z.lazy(() => Fallthrough2$inboundSchema),
  ]),
  active: types.boolean(),
  rules: z.array(z.lazy(() => Rules$inboundSchema)),
});
/** @internal */
export type Environments$Outbound = {
  reuse?: Reuse$Outbound | undefined;
  targets?: {
    [k: string]: { [k: string]: { [k: string]: Array<Targets$Outbound> } };
  } | undefined;
  revision?: number | undefined;
  pausedOutcome: PausedOutcome$Outbound;
  fallthrough: Fallthrough1$Outbound | Fallthrough2$Outbound;
  active: boolean;
  rules: Array<Rules$Outbound>;
};

/** @internal */
export const Environments$outboundSchema: z.ZodType<
  Environments$Outbound,
  z.ZodTypeDef,
  Environments
> = z.object({
  reuse: z.lazy(() => Reuse$outboundSchema).optional(),
  targets: z.record(
    z.record(z.record(z.array(z.lazy(() => Targets$outboundSchema)))),
  ).optional(),
  revision: z.number().optional(),
  pausedOutcome: z.lazy(() => PausedOutcome$outboundSchema),
  fallthrough: z.union([
    z.lazy(() => Fallthrough1$outboundSchema),
    z.lazy(() => Fallthrough2$outboundSchema),
  ]),
  active: z.boolean(),
  rules: z.array(z.lazy(() => Rules$outboundSchema)),
});

export function environmentsToJSON(environments: Environments): string {
  return JSON.stringify(Environments$outboundSchema.parse(environments));
}
export function environmentsFromJSON(
  jsonString: string,
): SafeParseResult<Environments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Environments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Environments' from JSON`,
  );
}

/** @internal */
export const Kind$inboundSchema: z.ZodNativeEnum<typeof Kind> = z.nativeEnum(
  Kind,
);
/** @internal */
export const Kind$outboundSchema: z.ZodNativeEnum<typeof Kind> =
  Kind$inboundSchema;

/** @internal */
export const State$inboundSchema: z.ZodNativeEnum<typeof State> = z.nativeEnum(
  State,
);
/** @internal */
export const State$outboundSchema: z.ZodNativeEnum<typeof State> =
  State$inboundSchema;

/** @internal */
export const TypeName$inboundSchema: z.ZodNativeEnum<typeof TypeName> = z
  .nativeEnum(TypeName);
/** @internal */
export const TypeName$outboundSchema: z.ZodNativeEnum<typeof TypeName> =
  TypeName$inboundSchema;

/** @internal */
export const Creator$inboundSchema: z.ZodType<Creator, z.ZodTypeDef, unknown> =
  z.object({
    id: types.string(),
    name: types.string(),
  });
/** @internal */
export type Creator$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const Creator$outboundSchema: z.ZodType<
  Creator$Outbound,
  z.ZodTypeDef,
  Creator
> = z.object({
  id: z.string(),
  name: z.string(),
});

export function creatorToJSON(creator: Creator): string {
  return JSON.stringify(Creator$outboundSchema.parse(creator));
}
export function creatorFromJSON(
  jsonString: string,
): SafeParseResult<Creator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Creator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Creator' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  creator: types.optional(z.lazy(() => Creator$inboundSchema)),
});
/** @internal */
export type Metadata$Outbound = {
  creator?: Creator$Outbound | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  creator: z.lazy(() => Creator$outboundSchema).optional(),
});

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}
export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const Flag$inboundSchema: z.ZodType<Flag, z.ZodTypeDef, unknown> = z
  .object({
    description: types.optional(types.string()),
    variants: z.array(z.lazy(() => Variants$inboundSchema)),
    id: types.string(),
    environments: z.record(z.lazy(() => Environments$inboundSchema)),
    kind: Kind$inboundSchema,
    revision: types.number(),
    seed: types.number(),
    state: State$inboundSchema,
    slug: types.string(),
    createdAt: types.number(),
    updatedAt: types.number(),
    createdBy: types.string(),
    ownerId: types.string(),
    projectId: types.string(),
    typeName: TypeName$inboundSchema,
    metadata: types.optional(z.lazy(() => Metadata$inboundSchema)),
  });
/** @internal */
export type Flag$Outbound = {
  description?: string | undefined;
  variants: Array<Variants$Outbound>;
  id: string;
  environments: { [k: string]: Environments$Outbound };
  kind: string;
  revision: number;
  seed: number;
  state: string;
  slug: string;
  createdAt: number;
  updatedAt: number;
  createdBy: string;
  ownerId: string;
  projectId: string;
  typeName: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Flag$outboundSchema: z.ZodType<Flag$Outbound, z.ZodTypeDef, Flag> =
  z.object({
    description: z.string().optional(),
    variants: z.array(z.lazy(() => Variants$outboundSchema)),
    id: z.string(),
    environments: z.record(z.lazy(() => Environments$outboundSchema)),
    kind: Kind$outboundSchema,
    revision: z.number(),
    seed: z.number(),
    state: State$outboundSchema,
    slug: z.string(),
    createdAt: z.number(),
    updatedAt: z.number(),
    createdBy: z.string(),
    ownerId: z.string(),
    projectId: z.string(),
    typeName: TypeName$outboundSchema,
    metadata: z.lazy(() => Metadata$outboundSchema).optional(),
  });

export function flagToJSON(flag: Flag): string {
  return JSON.stringify(Flag$outboundSchema.parse(flag));
}
export function flagFromJSON(
  jsonString: string,
): SafeParseResult<Flag, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Flag$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Flag' from JSON`,
  );
}
