/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type GetConfigurationRequest = {
  /**
   * ID of the configuration to check
   */
  id: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

/**
 * The configuration status. Optional. If not defined, assume 'ready'.
 */
export const GetConfigurationResponseBodyIntegrationsStatus = {
  Pending: "pending",
  Ready: "ready",
  Onboarding: "onboarding",
  Suspended: "suspended",
  Resumed: "resumed",
  Error: "error",
  Uninstalled: "uninstalled",
} as const;
/**
 * The configuration status. Optional. If not defined, assume 'ready'.
 */
export type GetConfigurationResponseBodyIntegrationsStatus = ClosedEnum<
  typeof GetConfigurationResponseBodyIntegrationsStatus
>;

export const GetConfigurationResponseBodyIntegrationsType = {
  IntegrationConfiguration: "integration-configuration",
} as const;
export type GetConfigurationResponseBodyIntegrationsType = ClosedEnum<
  typeof GetConfigurationResponseBodyIntegrationsType
>;

export const GetConfigurationResponseBodyIntegrationsDisabledReason = {
  DisabledByOwner: "disabled-by-owner",
  FeatureNotAvailable: "feature-not-available",
  DisabledByAdmin: "disabled-by-admin",
  OriginalOwnerLeftTheTeam: "original-owner-left-the-team",
  AccountPlanDowngrade: "account-plan-downgrade",
  OriginalOwnerRoleDowngraded: "original-owner-role-downgraded",
} as const;
export type GetConfigurationResponseBodyIntegrationsDisabledReason = ClosedEnum<
  typeof GetConfigurationResponseBodyIntegrationsDisabledReason
>;

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export const GetConfigurationResponseBodyIntegrationsInstallationType = {
  Marketplace: "marketplace",
  External: "external",
} as const;
/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export type GetConfigurationResponseBodyIntegrationsInstallationType =
  ClosedEnum<typeof GetConfigurationResponseBodyIntegrationsInstallationType>;

/**
 * The configuration with the provided id
 */
export type GetConfigurationResponseBody2 = {
  /**
   * A timestamp that tells you when the configuration was installed successfully
   */
  completedAt?: number | undefined;
  /**
   * A timestamp that tells you when the configuration was created
   */
  createdAt: number;
  /**
   * The unique identifier of the configuration
   */
  id: string;
  /**
   * The unique identifier of the app the configuration was created for
   */
  integrationId: string;
  /**
   * The user or team ID that owns the configuration
   */
  ownerId: string;
  /**
   * The configuration status. Optional. If not defined, assume 'ready'.
   */
  status?: GetConfigurationResponseBodyIntegrationsStatus | undefined;
  /**
   * An external identifier defined by the integration vendor.
   */
  externalId?: string | undefined;
  /**
   * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
   */
  projects?: Array<string> | undefined;
  /**
   * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
   */
  source?: string | undefined;
  /**
   * The slug of the integration the configuration is created for.
   */
  slug: string;
  /**
   * When the configuration was created for a team, this will show the ID of the team.
   */
  teamId?: string | null | undefined;
  type: GetConfigurationResponseBodyIntegrationsType;
  /**
   * A timestamp that tells you when the configuration was updated.
   */
  updatedAt: number;
  /**
   * The ID of the user that created the configuration.
   */
  userId: string;
  /**
   * The resources that are allowed to be accessed by the configuration.
   */
  scopes: Array<string>;
  /**
   * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
   */
  disabledAt?: number | undefined;
  /**
   * A timestamp that tells you when the configuration was deleted.
   */
  deletedAt?: number | null | undefined;
  /**
   * A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.
   */
  deleteRequestedAt?: number | null | undefined;
  disabledReason?:
    | GetConfigurationResponseBodyIntegrationsDisabledReason
    | undefined;
  /**
   * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
   */
  installationType?:
    | GetConfigurationResponseBodyIntegrationsInstallationType
    | undefined;
};

/**
 * A string representing the permission for projects. Possible values are `all` or `selected`.
 */
export const ProjectSelection = {
  Selected: "selected",
  All: "all",
} as const;
/**
 * A string representing the permission for projects. Possible values are `all` or `selected`.
 */
export type ProjectSelection = ClosedEnum<typeof ProjectSelection>;

export const GetConfigurationResponseBodyLevel = {
  Error: "error",
  Info: "info",
  Warn: "warn",
} as const;
export type GetConfigurationResponseBodyLevel = ClosedEnum<
  typeof GetConfigurationResponseBodyLevel
>;

export type ResponseBodyNotification = {
  level: GetConfigurationResponseBodyLevel;
  title: string;
  message?: string | undefined;
  href?: string | undefined;
};

export type TransferRequestRequester = {
  name: string;
  email?: string | undefined;
};

export type TransferRequest2 = {
  kind: "transfer-from-marketplace";
  requestId: string;
  transferId: string;
  requester: TransferRequestRequester;
  createdAt: number;
  expiresAt: number;
  discardedAt?: number | undefined;
  discardedBy?: string | undefined;
  approvedAt?: number | undefined;
  approvedBy?: string | undefined;
  authorizationId?: string | undefined;
};

export const TransferRequestType = {
  Subscription: "subscription",
  Prepayment: "prepayment",
} as const;
export type TransferRequestType = ClosedEnum<typeof TransferRequestType>;

export const TransferRequestScope = {
  Installation: "installation",
  Resource: "resource",
} as const;
export type TransferRequestScope = ClosedEnum<typeof TransferRequestScope>;

export type TransferRequestBillingPlan = {
  id: string;
  type: TransferRequestType;
  scope?: TransferRequestScope | undefined;
  name: string;
  description: string;
  paymentMethodRequired?: boolean | undefined;
  preauthorizationAmount?: number | undefined;
};

export type Requester = {
  name: string;
  email?: string | undefined;
};

export type TransferRequest1 = {
  kind: "transfer-to-marketplace";
  metadata?: { [k: string]: any } | undefined;
  billingPlan?: TransferRequestBillingPlan | undefined;
  requestId: string;
  transferId: string;
  requester: Requester;
  createdAt: number;
  expiresAt: number;
  discardedAt?: number | undefined;
  discardedBy?: string | undefined;
  approvedAt?: number | undefined;
  approvedBy?: string | undefined;
  authorizationId?: string | undefined;
};

export type TransferRequest = TransferRequest1 | TransferRequest2;

export const GetConfigurationResponseBodyDisabledReason = {
  DisabledByOwner: "disabled-by-owner",
  FeatureNotAvailable: "feature-not-available",
  DisabledByAdmin: "disabled-by-admin",
  OriginalOwnerLeftTheTeam: "original-owner-left-the-team",
  AccountPlanDowngrade: "account-plan-downgrade",
  OriginalOwnerRoleDowngraded: "original-owner-role-downgraded",
} as const;
export type GetConfigurationResponseBodyDisabledReason = ClosedEnum<
  typeof GetConfigurationResponseBodyDisabledReason
>;

/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export const GetConfigurationResponseBodyInstallationType = {
  Marketplace: "marketplace",
  External: "external",
} as const;
/**
 * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
 */
export type GetConfigurationResponseBodyInstallationType = ClosedEnum<
  typeof GetConfigurationResponseBodyInstallationType
>;

/**
 * The configuration status. Optional. If not defined, assume 'ready'.
 */
export const GetConfigurationResponseBodyStatus = {
  Pending: "pending",
  Ready: "ready",
  Onboarding: "onboarding",
  Suspended: "suspended",
  Resumed: "resumed",
  Error: "error",
  Uninstalled: "uninstalled",
} as const;
/**
 * The configuration status. Optional. If not defined, assume 'ready'.
 */
export type GetConfigurationResponseBodyStatus = ClosedEnum<
  typeof GetConfigurationResponseBodyStatus
>;

export const GetConfigurationResponseBodyType = {
  IntegrationConfiguration: "integration-configuration",
} as const;
export type GetConfigurationResponseBodyType = ClosedEnum<
  typeof GetConfigurationResponseBodyType
>;

export type GetConfigurationResponseBody1 = {
  /**
   * A string representing the permission for projects. Possible values are `all` or `selected`.
   */
  projectSelection: ProjectSelection;
  notification: ResponseBodyNotification;
  transferRequest: TransferRequest1 | TransferRequest2;
  /**
   * When a configuration is limited to access certain projects, this will contain each of the project ID it is allowed to access. If it is not defined, the configuration has full access.
   */
  projects?: Array<string> | undefined;
  /**
   * A timestamp that tells you when the configuration was created
   */
  createdAt: number;
  /**
   * A timestamp that tells you when the configuration was installed successfully
   */
  completedAt?: number | undefined;
  /**
   * The unique identifier of the configuration
   */
  id: string;
  /**
   * The unique identifier of the app the configuration was created for
   */
  integrationId: string;
  /**
   * The user or team ID that owns the configuration
   */
  ownerId: string;
  /**
   * The slug of the integration the configuration is created for.
   */
  slug: string;
  /**
   * When the configuration was created for a team, this will show the ID of the team.
   */
  teamId?: string | null | undefined;
  /**
   * A timestamp that tells you when the configuration was updated.
   */
  updatedAt: number;
  /**
   * The ID of the user that created the configuration.
   */
  userId: string;
  /**
   * The resources that are allowed to be accessed by the configuration.
   */
  scopes: Array<string>;
  /**
   * A timestamp that tells you when the configuration was disabled. Note: Configurations can be disabled when the associated user loses access to a team. They do not function during this time until the configuration is 'transferred', meaning the associated user is changed to one with access to the team.
   */
  disabledAt?: number | undefined;
  disabledReason?: GetConfigurationResponseBodyDisabledReason | undefined;
  /**
   * Source defines where the configuration was installed from. It is used to analyze user engagement for integration installations in product metrics.
   */
  source?: string | undefined;
  canConfigureOpenTelemetry?: boolean | undefined;
  /**
   * Defines the installation type. - 'external' integrations are installed via the existing integrations flow - 'marketplace' integrations are natively installed: - when accepting the TOS of a partner during the store creation process - if undefined, assume 'external'
   */
  installationType?: GetConfigurationResponseBodyInstallationType | undefined;
  /**
   * A timestamp that tells you when the configuration deletion has been started for cases when the deletion needs to be settled/approved by partners, such as when marketplace invoices have been paid.
   */
  deleteRequestedAt?: number | null | undefined;
  /**
   * The configuration status. Optional. If not defined, assume 'ready'.
   */
  status?: GetConfigurationResponseBodyStatus | undefined;
  /**
   * An external identifier defined by the integration vendor.
   */
  externalId?: string | undefined;
  type: GetConfigurationResponseBodyType;
  /**
   * A timestamp that tells you when the configuration was deleted.
   */
  deletedAt?: number | null | undefined;
};

/**
 * The configuration with the provided id
 */
export type GetConfigurationResponseBody =
  | GetConfigurationResponseBody1
  | GetConfigurationResponseBody2;

/** @internal */
export const GetConfigurationRequest$inboundSchema: z.ZodType<
  GetConfigurationRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
});
/** @internal */
export type GetConfigurationRequest$Outbound = {
  id: string;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const GetConfigurationRequest$outboundSchema: z.ZodType<
  GetConfigurationRequest$Outbound,
  z.ZodTypeDef,
  GetConfigurationRequest
> = z.object({
  id: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

export function getConfigurationRequestToJSON(
  getConfigurationRequest: GetConfigurationRequest,
): string {
  return JSON.stringify(
    GetConfigurationRequest$outboundSchema.parse(getConfigurationRequest),
  );
}
export function getConfigurationRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetConfigurationRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConfigurationRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConfigurationRequest' from JSON`,
  );
}

/** @internal */
export const GetConfigurationResponseBodyIntegrationsStatus$inboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyIntegrationsStatus> = z
    .nativeEnum(GetConfigurationResponseBodyIntegrationsStatus);
/** @internal */
export const GetConfigurationResponseBodyIntegrationsStatus$outboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyIntegrationsStatus> =
    GetConfigurationResponseBodyIntegrationsStatus$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyIntegrationsType$inboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyIntegrationsType> = z
    .nativeEnum(GetConfigurationResponseBodyIntegrationsType);
/** @internal */
export const GetConfigurationResponseBodyIntegrationsType$outboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyIntegrationsType> =
    GetConfigurationResponseBodyIntegrationsType$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyIntegrationsDisabledReason$inboundSchema:
  z.ZodNativeEnum<
    typeof GetConfigurationResponseBodyIntegrationsDisabledReason
  > = z.nativeEnum(GetConfigurationResponseBodyIntegrationsDisabledReason);
/** @internal */
export const GetConfigurationResponseBodyIntegrationsDisabledReason$outboundSchema:
  z.ZodNativeEnum<
    typeof GetConfigurationResponseBodyIntegrationsDisabledReason
  > = GetConfigurationResponseBodyIntegrationsDisabledReason$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyIntegrationsInstallationType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetConfigurationResponseBodyIntegrationsInstallationType
  > = z.nativeEnum(GetConfigurationResponseBodyIntegrationsInstallationType);
/** @internal */
export const GetConfigurationResponseBodyIntegrationsInstallationType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetConfigurationResponseBodyIntegrationsInstallationType
  > = GetConfigurationResponseBodyIntegrationsInstallationType$inboundSchema;

/** @internal */
export const GetConfigurationResponseBody2$inboundSchema: z.ZodType<
  GetConfigurationResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  completedAt: types.optional(types.number()),
  createdAt: types.number(),
  id: types.string(),
  integrationId: types.string(),
  ownerId: types.string(),
  status: types.optional(
    GetConfigurationResponseBodyIntegrationsStatus$inboundSchema,
  ),
  externalId: types.optional(types.string()),
  projects: types.optional(z.array(types.string())),
  source: types.optional(types.string()),
  slug: types.string(),
  teamId: z.nullable(types.string()).optional(),
  type: GetConfigurationResponseBodyIntegrationsType$inboundSchema,
  updatedAt: types.number(),
  userId: types.string(),
  scopes: z.array(types.string()),
  disabledAt: types.optional(types.number()),
  deletedAt: z.nullable(types.number()).optional(),
  deleteRequestedAt: z.nullable(types.number()).optional(),
  disabledReason: types.optional(
    GetConfigurationResponseBodyIntegrationsDisabledReason$inboundSchema,
  ),
  installationType: types.optional(
    GetConfigurationResponseBodyIntegrationsInstallationType$inboundSchema,
  ),
});
/** @internal */
export type GetConfigurationResponseBody2$Outbound = {
  completedAt?: number | undefined;
  createdAt: number;
  id: string;
  integrationId: string;
  ownerId: string;
  status?: string | undefined;
  externalId?: string | undefined;
  projects?: Array<string> | undefined;
  source?: string | undefined;
  slug: string;
  teamId?: string | null | undefined;
  type: string;
  updatedAt: number;
  userId: string;
  scopes: Array<string>;
  disabledAt?: number | undefined;
  deletedAt?: number | null | undefined;
  deleteRequestedAt?: number | null | undefined;
  disabledReason?: string | undefined;
  installationType?: string | undefined;
};

/** @internal */
export const GetConfigurationResponseBody2$outboundSchema: z.ZodType<
  GetConfigurationResponseBody2$Outbound,
  z.ZodTypeDef,
  GetConfigurationResponseBody2
> = z.object({
  completedAt: z.number().optional(),
  createdAt: z.number(),
  id: z.string(),
  integrationId: z.string(),
  ownerId: z.string(),
  status: GetConfigurationResponseBodyIntegrationsStatus$outboundSchema
    .optional(),
  externalId: z.string().optional(),
  projects: z.array(z.string()).optional(),
  source: z.string().optional(),
  slug: z.string(),
  teamId: z.nullable(z.string()).optional(),
  type: GetConfigurationResponseBodyIntegrationsType$outboundSchema,
  updatedAt: z.number(),
  userId: z.string(),
  scopes: z.array(z.string()),
  disabledAt: z.number().optional(),
  deletedAt: z.nullable(z.number()).optional(),
  deleteRequestedAt: z.nullable(z.number()).optional(),
  disabledReason:
    GetConfigurationResponseBodyIntegrationsDisabledReason$outboundSchema
      .optional(),
  installationType:
    GetConfigurationResponseBodyIntegrationsInstallationType$outboundSchema
      .optional(),
});

export function getConfigurationResponseBody2ToJSON(
  getConfigurationResponseBody2: GetConfigurationResponseBody2,
): string {
  return JSON.stringify(
    GetConfigurationResponseBody2$outboundSchema.parse(
      getConfigurationResponseBody2,
    ),
  );
}
export function getConfigurationResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<GetConfigurationResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConfigurationResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConfigurationResponseBody2' from JSON`,
  );
}

/** @internal */
export const ProjectSelection$inboundSchema: z.ZodNativeEnum<
  typeof ProjectSelection
> = z.nativeEnum(ProjectSelection);
/** @internal */
export const ProjectSelection$outboundSchema: z.ZodNativeEnum<
  typeof ProjectSelection
> = ProjectSelection$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyLevel$inboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyLevel
> = z.nativeEnum(GetConfigurationResponseBodyLevel);
/** @internal */
export const GetConfigurationResponseBodyLevel$outboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyLevel
> = GetConfigurationResponseBodyLevel$inboundSchema;

/** @internal */
export const ResponseBodyNotification$inboundSchema: z.ZodType<
  ResponseBodyNotification,
  z.ZodTypeDef,
  unknown
> = z.object({
  level: GetConfigurationResponseBodyLevel$inboundSchema,
  title: types.string(),
  message: types.optional(types.string()),
  href: types.optional(types.string()),
});
/** @internal */
export type ResponseBodyNotification$Outbound = {
  level: string;
  title: string;
  message?: string | undefined;
  href?: string | undefined;
};

/** @internal */
export const ResponseBodyNotification$outboundSchema: z.ZodType<
  ResponseBodyNotification$Outbound,
  z.ZodTypeDef,
  ResponseBodyNotification
> = z.object({
  level: GetConfigurationResponseBodyLevel$outboundSchema,
  title: z.string(),
  message: z.string().optional(),
  href: z.string().optional(),
});

export function responseBodyNotificationToJSON(
  responseBodyNotification: ResponseBodyNotification,
): string {
  return JSON.stringify(
    ResponseBodyNotification$outboundSchema.parse(responseBodyNotification),
  );
}
export function responseBodyNotificationFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyNotification, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyNotification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyNotification' from JSON`,
  );
}

/** @internal */
export const TransferRequestRequester$inboundSchema: z.ZodType<
  TransferRequestRequester,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.string(),
  email: types.optional(types.string()),
});
/** @internal */
export type TransferRequestRequester$Outbound = {
  name: string;
  email?: string | undefined;
};

/** @internal */
export const TransferRequestRequester$outboundSchema: z.ZodType<
  TransferRequestRequester$Outbound,
  z.ZodTypeDef,
  TransferRequestRequester
> = z.object({
  name: z.string(),
  email: z.string().optional(),
});

export function transferRequestRequesterToJSON(
  transferRequestRequester: TransferRequestRequester,
): string {
  return JSON.stringify(
    TransferRequestRequester$outboundSchema.parse(transferRequestRequester),
  );
}
export function transferRequestRequesterFromJSON(
  jsonString: string,
): SafeParseResult<TransferRequestRequester, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferRequestRequester$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferRequestRequester' from JSON`,
  );
}

/** @internal */
export const TransferRequest2$inboundSchema: z.ZodType<
  TransferRequest2,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: types.literal("transfer-from-marketplace"),
  requestId: types.string(),
  transferId: types.string(),
  requester: z.lazy(() => TransferRequestRequester$inboundSchema),
  createdAt: types.number(),
  expiresAt: types.number(),
  discardedAt: types.optional(types.number()),
  discardedBy: types.optional(types.string()),
  approvedAt: types.optional(types.number()),
  approvedBy: types.optional(types.string()),
  authorizationId: types.optional(types.string()),
});
/** @internal */
export type TransferRequest2$Outbound = {
  kind: "transfer-from-marketplace";
  requestId: string;
  transferId: string;
  requester: TransferRequestRequester$Outbound;
  createdAt: number;
  expiresAt: number;
  discardedAt?: number | undefined;
  discardedBy?: string | undefined;
  approvedAt?: number | undefined;
  approvedBy?: string | undefined;
  authorizationId?: string | undefined;
};

/** @internal */
export const TransferRequest2$outboundSchema: z.ZodType<
  TransferRequest2$Outbound,
  z.ZodTypeDef,
  TransferRequest2
> = z.object({
  kind: z.literal("transfer-from-marketplace"),
  requestId: z.string(),
  transferId: z.string(),
  requester: z.lazy(() => TransferRequestRequester$outboundSchema),
  createdAt: z.number(),
  expiresAt: z.number(),
  discardedAt: z.number().optional(),
  discardedBy: z.string().optional(),
  approvedAt: z.number().optional(),
  approvedBy: z.string().optional(),
  authorizationId: z.string().optional(),
});

export function transferRequest2ToJSON(
  transferRequest2: TransferRequest2,
): string {
  return JSON.stringify(
    TransferRequest2$outboundSchema.parse(transferRequest2),
  );
}
export function transferRequest2FromJSON(
  jsonString: string,
): SafeParseResult<TransferRequest2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferRequest2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferRequest2' from JSON`,
  );
}

/** @internal */
export const TransferRequestType$inboundSchema: z.ZodNativeEnum<
  typeof TransferRequestType
> = z.nativeEnum(TransferRequestType);
/** @internal */
export const TransferRequestType$outboundSchema: z.ZodNativeEnum<
  typeof TransferRequestType
> = TransferRequestType$inboundSchema;

/** @internal */
export const TransferRequestScope$inboundSchema: z.ZodNativeEnum<
  typeof TransferRequestScope
> = z.nativeEnum(TransferRequestScope);
/** @internal */
export const TransferRequestScope$outboundSchema: z.ZodNativeEnum<
  typeof TransferRequestScope
> = TransferRequestScope$inboundSchema;

/** @internal */
export const TransferRequestBillingPlan$inboundSchema: z.ZodType<
  TransferRequestBillingPlan,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  type: TransferRequestType$inboundSchema,
  scope: types.optional(TransferRequestScope$inboundSchema),
  name: types.string(),
  description: types.string(),
  paymentMethodRequired: types.optional(types.boolean()),
  preauthorizationAmount: types.optional(types.number()),
});
/** @internal */
export type TransferRequestBillingPlan$Outbound = {
  id: string;
  type: string;
  scope?: string | undefined;
  name: string;
  description: string;
  paymentMethodRequired?: boolean | undefined;
  preauthorizationAmount?: number | undefined;
};

/** @internal */
export const TransferRequestBillingPlan$outboundSchema: z.ZodType<
  TransferRequestBillingPlan$Outbound,
  z.ZodTypeDef,
  TransferRequestBillingPlan
> = z.object({
  id: z.string(),
  type: TransferRequestType$outboundSchema,
  scope: TransferRequestScope$outboundSchema.optional(),
  name: z.string(),
  description: z.string(),
  paymentMethodRequired: z.boolean().optional(),
  preauthorizationAmount: z.number().optional(),
});

export function transferRequestBillingPlanToJSON(
  transferRequestBillingPlan: TransferRequestBillingPlan,
): string {
  return JSON.stringify(
    TransferRequestBillingPlan$outboundSchema.parse(transferRequestBillingPlan),
  );
}
export function transferRequestBillingPlanFromJSON(
  jsonString: string,
): SafeParseResult<TransferRequestBillingPlan, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferRequestBillingPlan$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferRequestBillingPlan' from JSON`,
  );
}

/** @internal */
export const Requester$inboundSchema: z.ZodType<
  Requester,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.string(),
  email: types.optional(types.string()),
});
/** @internal */
export type Requester$Outbound = {
  name: string;
  email?: string | undefined;
};

/** @internal */
export const Requester$outboundSchema: z.ZodType<
  Requester$Outbound,
  z.ZodTypeDef,
  Requester
> = z.object({
  name: z.string(),
  email: z.string().optional(),
});

export function requesterToJSON(requester: Requester): string {
  return JSON.stringify(Requester$outboundSchema.parse(requester));
}
export function requesterFromJSON(
  jsonString: string,
): SafeParseResult<Requester, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Requester$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Requester' from JSON`,
  );
}

/** @internal */
export const TransferRequest1$inboundSchema: z.ZodType<
  TransferRequest1,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: types.literal("transfer-to-marketplace"),
  metadata: types.optional(z.record(z.any())),
  billingPlan: types.optional(
    z.lazy(() => TransferRequestBillingPlan$inboundSchema),
  ),
  requestId: types.string(),
  transferId: types.string(),
  requester: z.lazy(() => Requester$inboundSchema),
  createdAt: types.number(),
  expiresAt: types.number(),
  discardedAt: types.optional(types.number()),
  discardedBy: types.optional(types.string()),
  approvedAt: types.optional(types.number()),
  approvedBy: types.optional(types.string()),
  authorizationId: types.optional(types.string()),
});
/** @internal */
export type TransferRequest1$Outbound = {
  kind: "transfer-to-marketplace";
  metadata?: { [k: string]: any } | undefined;
  billingPlan?: TransferRequestBillingPlan$Outbound | undefined;
  requestId: string;
  transferId: string;
  requester: Requester$Outbound;
  createdAt: number;
  expiresAt: number;
  discardedAt?: number | undefined;
  discardedBy?: string | undefined;
  approvedAt?: number | undefined;
  approvedBy?: string | undefined;
  authorizationId?: string | undefined;
};

/** @internal */
export const TransferRequest1$outboundSchema: z.ZodType<
  TransferRequest1$Outbound,
  z.ZodTypeDef,
  TransferRequest1
> = z.object({
  kind: z.literal("transfer-to-marketplace"),
  metadata: z.record(z.any()).optional(),
  billingPlan: z.lazy(() => TransferRequestBillingPlan$outboundSchema)
    .optional(),
  requestId: z.string(),
  transferId: z.string(),
  requester: z.lazy(() => Requester$outboundSchema),
  createdAt: z.number(),
  expiresAt: z.number(),
  discardedAt: z.number().optional(),
  discardedBy: z.string().optional(),
  approvedAt: z.number().optional(),
  approvedBy: z.string().optional(),
  authorizationId: z.string().optional(),
});

export function transferRequest1ToJSON(
  transferRequest1: TransferRequest1,
): string {
  return JSON.stringify(
    TransferRequest1$outboundSchema.parse(transferRequest1),
  );
}
export function transferRequest1FromJSON(
  jsonString: string,
): SafeParseResult<TransferRequest1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferRequest1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferRequest1' from JSON`,
  );
}

/** @internal */
export const TransferRequest$inboundSchema: z.ZodType<
  TransferRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TransferRequest1$inboundSchema),
  z.lazy(() => TransferRequest2$inboundSchema),
]);
/** @internal */
export type TransferRequest$Outbound =
  | TransferRequest1$Outbound
  | TransferRequest2$Outbound;

/** @internal */
export const TransferRequest$outboundSchema: z.ZodType<
  TransferRequest$Outbound,
  z.ZodTypeDef,
  TransferRequest
> = z.union([
  z.lazy(() => TransferRequest1$outboundSchema),
  z.lazy(() => TransferRequest2$outboundSchema),
]);

export function transferRequestToJSON(
  transferRequest: TransferRequest,
): string {
  return JSON.stringify(TransferRequest$outboundSchema.parse(transferRequest));
}
export function transferRequestFromJSON(
  jsonString: string,
): SafeParseResult<TransferRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransferRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransferRequest' from JSON`,
  );
}

/** @internal */
export const GetConfigurationResponseBodyDisabledReason$inboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyDisabledReason> = z
    .nativeEnum(GetConfigurationResponseBodyDisabledReason);
/** @internal */
export const GetConfigurationResponseBodyDisabledReason$outboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyDisabledReason> =
    GetConfigurationResponseBodyDisabledReason$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyInstallationType$inboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyInstallationType> = z
    .nativeEnum(GetConfigurationResponseBodyInstallationType);
/** @internal */
export const GetConfigurationResponseBodyInstallationType$outboundSchema:
  z.ZodNativeEnum<typeof GetConfigurationResponseBodyInstallationType> =
    GetConfigurationResponseBodyInstallationType$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyStatus
> = z.nativeEnum(GetConfigurationResponseBodyStatus);
/** @internal */
export const GetConfigurationResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyStatus
> = GetConfigurationResponseBodyStatus$inboundSchema;

/** @internal */
export const GetConfigurationResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyType
> = z.nativeEnum(GetConfigurationResponseBodyType);
/** @internal */
export const GetConfigurationResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof GetConfigurationResponseBodyType
> = GetConfigurationResponseBodyType$inboundSchema;

/** @internal */
export const GetConfigurationResponseBody1$inboundSchema: z.ZodType<
  GetConfigurationResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectSelection: ProjectSelection$inboundSchema,
  notification: z.lazy(() => ResponseBodyNotification$inboundSchema),
  transferRequest: z.union([
    z.lazy(() => TransferRequest1$inboundSchema),
    z.lazy(() => TransferRequest2$inboundSchema),
  ]),
  projects: types.optional(z.array(types.string())),
  createdAt: types.number(),
  completedAt: types.optional(types.number()),
  id: types.string(),
  integrationId: types.string(),
  ownerId: types.string(),
  slug: types.string(),
  teamId: z.nullable(types.string()).optional(),
  updatedAt: types.number(),
  userId: types.string(),
  scopes: z.array(types.string()),
  disabledAt: types.optional(types.number()),
  disabledReason: types.optional(
    GetConfigurationResponseBodyDisabledReason$inboundSchema,
  ),
  source: types.optional(types.string()),
  canConfigureOpenTelemetry: types.optional(types.boolean()),
  installationType: types.optional(
    GetConfigurationResponseBodyInstallationType$inboundSchema,
  ),
  deleteRequestedAt: z.nullable(types.number()).optional(),
  status: types.optional(GetConfigurationResponseBodyStatus$inboundSchema),
  externalId: types.optional(types.string()),
  type: GetConfigurationResponseBodyType$inboundSchema,
  deletedAt: z.nullable(types.number()).optional(),
});
/** @internal */
export type GetConfigurationResponseBody1$Outbound = {
  projectSelection: string;
  notification: ResponseBodyNotification$Outbound;
  transferRequest: TransferRequest1$Outbound | TransferRequest2$Outbound;
  projects?: Array<string> | undefined;
  createdAt: number;
  completedAt?: number | undefined;
  id: string;
  integrationId: string;
  ownerId: string;
  slug: string;
  teamId?: string | null | undefined;
  updatedAt: number;
  userId: string;
  scopes: Array<string>;
  disabledAt?: number | undefined;
  disabledReason?: string | undefined;
  source?: string | undefined;
  canConfigureOpenTelemetry?: boolean | undefined;
  installationType?: string | undefined;
  deleteRequestedAt?: number | null | undefined;
  status?: string | undefined;
  externalId?: string | undefined;
  type: string;
  deletedAt?: number | null | undefined;
};

/** @internal */
export const GetConfigurationResponseBody1$outboundSchema: z.ZodType<
  GetConfigurationResponseBody1$Outbound,
  z.ZodTypeDef,
  GetConfigurationResponseBody1
> = z.object({
  projectSelection: ProjectSelection$outboundSchema,
  notification: z.lazy(() => ResponseBodyNotification$outboundSchema),
  transferRequest: z.union([
    z.lazy(() => TransferRequest1$outboundSchema),
    z.lazy(() => TransferRequest2$outboundSchema),
  ]),
  projects: z.array(z.string()).optional(),
  createdAt: z.number(),
  completedAt: z.number().optional(),
  id: z.string(),
  integrationId: z.string(),
  ownerId: z.string(),
  slug: z.string(),
  teamId: z.nullable(z.string()).optional(),
  updatedAt: z.number(),
  userId: z.string(),
  scopes: z.array(z.string()),
  disabledAt: z.number().optional(),
  disabledReason: GetConfigurationResponseBodyDisabledReason$outboundSchema
    .optional(),
  source: z.string().optional(),
  canConfigureOpenTelemetry: z.boolean().optional(),
  installationType: GetConfigurationResponseBodyInstallationType$outboundSchema
    .optional(),
  deleteRequestedAt: z.nullable(z.number()).optional(),
  status: GetConfigurationResponseBodyStatus$outboundSchema.optional(),
  externalId: z.string().optional(),
  type: GetConfigurationResponseBodyType$outboundSchema,
  deletedAt: z.nullable(z.number()).optional(),
});

export function getConfigurationResponseBody1ToJSON(
  getConfigurationResponseBody1: GetConfigurationResponseBody1,
): string {
  return JSON.stringify(
    GetConfigurationResponseBody1$outboundSchema.parse(
      getConfigurationResponseBody1,
    ),
  );
}
export function getConfigurationResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<GetConfigurationResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConfigurationResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConfigurationResponseBody1' from JSON`,
  );
}

/** @internal */
export const GetConfigurationResponseBody$inboundSchema: z.ZodType<
  GetConfigurationResponseBody,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GetConfigurationResponseBody1$inboundSchema),
  z.lazy(() => GetConfigurationResponseBody2$inboundSchema),
]);
/** @internal */
export type GetConfigurationResponseBody$Outbound =
  | GetConfigurationResponseBody1$Outbound
  | GetConfigurationResponseBody2$Outbound;

/** @internal */
export const GetConfigurationResponseBody$outboundSchema: z.ZodType<
  GetConfigurationResponseBody$Outbound,
  z.ZodTypeDef,
  GetConfigurationResponseBody
> = smartUnion([
  z.lazy(() => GetConfigurationResponseBody1$outboundSchema),
  z.lazy(() => GetConfigurationResponseBody2$outboundSchema),
]);

export function getConfigurationResponseBodyToJSON(
  getConfigurationResponseBody: GetConfigurationResponseBody,
): string {
  return JSON.stringify(
    GetConfigurationResponseBody$outboundSchema.parse(
      getConfigurationResponseBody,
    ),
  );
}
export function getConfigurationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetConfigurationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetConfigurationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetConfigurationResponseBody' from JSON`,
  );
}
