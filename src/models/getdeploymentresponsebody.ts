/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  FlagJSONValue,
  FlagJSONValue$inboundSchema,
  FlagJSONValue$Outbound,
  FlagJSONValue$outboundSchema,
} from "./flagjsonvalue.js";
import {
  GetDeploymentResponseBody2,
  GetDeploymentResponseBody2$inboundSchema,
  GetDeploymentResponseBody2$Outbound,
  GetDeploymentResponseBody2$outboundSchema,
  GetDeploymentResponseBodyAliasError,
  GetDeploymentResponseBodyAliasError$inboundSchema,
  GetDeploymentResponseBodyAliasError$Outbound,
  GetDeploymentResponseBodyAliasError$outboundSchema,
  GetDeploymentResponseBodyAliasWarning,
  GetDeploymentResponseBodyAliasWarning$inboundSchema,
  GetDeploymentResponseBodyAliasWarning$Outbound,
  GetDeploymentResponseBodyAliasWarning$outboundSchema,
  GetDeploymentResponseBodyChecksConclusion,
  GetDeploymentResponseBodyChecksConclusion$inboundSchema,
  GetDeploymentResponseBodyChecksConclusion$outboundSchema,
  GetDeploymentResponseBodyChecksState,
  GetDeploymentResponseBodyChecksState$inboundSchema,
  GetDeploymentResponseBodyChecksState$outboundSchema,
  GetDeploymentResponseBodyCreator,
  GetDeploymentResponseBodyCreator$inboundSchema,
  GetDeploymentResponseBodyCreator$Outbound,
  GetDeploymentResponseBodyCreator$outboundSchema,
  GetDeploymentResponseBodyCustomEnvironment,
  GetDeploymentResponseBodyCustomEnvironment$inboundSchema,
  GetDeploymentResponseBodyCustomEnvironment$Outbound,
  GetDeploymentResponseBodyCustomEnvironment$outboundSchema,
  GetDeploymentResponseBodyDeploymentsSource,
  GetDeploymentResponseBodyDeploymentsSource$inboundSchema,
  GetDeploymentResponseBodyDeploymentsSource$Outbound,
  GetDeploymentResponseBodyDeploymentsSource$outboundSchema,
  GetDeploymentResponseBodyGitSource,
  GetDeploymentResponseBodyGitSource$inboundSchema,
  GetDeploymentResponseBodyGitSource$Outbound,
  GetDeploymentResponseBodyGitSource$outboundSchema,
  GetDeploymentResponseBodyLambdas,
  GetDeploymentResponseBodyLambdas$inboundSchema,
  GetDeploymentResponseBodyLambdas$Outbound,
  GetDeploymentResponseBodyLambdas$outboundSchema,
  GetDeploymentResponseBodyManualProvisioning,
  GetDeploymentResponseBodyManualProvisioning$inboundSchema,
  GetDeploymentResponseBodyManualProvisioning$Outbound,
  GetDeploymentResponseBodyManualProvisioning$outboundSchema,
  GetDeploymentResponseBodyNodeVersion,
  GetDeploymentResponseBodyNodeVersion$inboundSchema,
  GetDeploymentResponseBodyNodeVersion$outboundSchema,
  GetDeploymentResponseBodyOidcTokenClaims,
  GetDeploymentResponseBodyOidcTokenClaims$inboundSchema,
  GetDeploymentResponseBodyOidcTokenClaims$Outbound,
  GetDeploymentResponseBodyOidcTokenClaims$outboundSchema,
  GetDeploymentResponseBodyOomReport,
  GetDeploymentResponseBodyOomReport$inboundSchema,
  GetDeploymentResponseBodyOomReport$outboundSchema,
  GetDeploymentResponseBodyReadyState,
  GetDeploymentResponseBodyReadyState$inboundSchema,
  GetDeploymentResponseBodyReadyState$outboundSchema,
  GetDeploymentResponseBodyReadySubstate,
  GetDeploymentResponseBodyReadySubstate$inboundSchema,
  GetDeploymentResponseBodyReadySubstate$outboundSchema,
  GetDeploymentResponseBodyTarget,
  GetDeploymentResponseBodyTarget$inboundSchema,
  GetDeploymentResponseBodyTarget$outboundSchema,
  GetDeploymentResponseBodyTeam,
  GetDeploymentResponseBodyTeam$inboundSchema,
  GetDeploymentResponseBodyTeam$Outbound,
  GetDeploymentResponseBodyTeam$outboundSchema,
  GetDeploymentResponseBodyType,
  GetDeploymentResponseBodyType$inboundSchema,
  GetDeploymentResponseBodyType$outboundSchema,
  ResponseBodyAliasAssignedAt,
  ResponseBodyAliasAssignedAt$inboundSchema,
  ResponseBodyAliasAssignedAt$Outbound,
  ResponseBodyAliasAssignedAt$outboundSchema,
  ResponseBodyBuild,
  ResponseBodyBuild$inboundSchema,
  ResponseBodyBuild$Outbound,
  ResponseBodyBuild$outboundSchema,
  ResponseBodyBuilds,
  ResponseBodyBuilds$inboundSchema,
  ResponseBodyBuilds$Outbound,
  ResponseBodyBuilds$outboundSchema,
  ResponseBodyImages,
  ResponseBodyImages$inboundSchema,
  ResponseBodyImages$Outbound,
  ResponseBodyImages$outboundSchema,
  ResponseBodyIntegrations,
  ResponseBodyIntegrations$inboundSchema,
  ResponseBodyIntegrations$Outbound,
  ResponseBodyIntegrations$outboundSchema,
  ResponseBodyOrigin,
  ResponseBodyOrigin$inboundSchema,
  ResponseBodyOrigin$Outbound,
  ResponseBodyOrigin$outboundSchema,
  ResponseBodyPlan,
  ResponseBodyPlan$inboundSchema,
  ResponseBodyPlan$outboundSchema,
  ResponseBodyProject,
  ResponseBodyProject$inboundSchema,
  ResponseBodyProject$Outbound,
  ResponseBodyProject$outboundSchema,
  ResponseBodyProjectSettings,
  ResponseBodyProjectSettings$inboundSchema,
  ResponseBodyProjectSettings$Outbound,
  ResponseBodyProjectSettings$outboundSchema,
  ResponseBodySource,
  ResponseBodySource$inboundSchema,
  ResponseBodySource$outboundSchema,
  ResponseBodyStatus,
  ResponseBodyStatus$inboundSchema,
  ResponseBodyStatus$outboundSchema,
} from "./responsebodyorigin.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * Metadata about the source platform that triggered the deployment. Allows us to map a deployment back to a platform (e.g. the chat that created it)
 */
export type ResponseBodyPlatform = {
  source: GetDeploymentResponseBodyDeploymentsSource;
  origin: ResponseBodyOrigin;
  meta?: { [k: string]: string } | undefined;
};

export type ResponseBodyCrons = {
  schedule: string;
  path: string;
};

export const ResponseBodyArchitecture = {
  X8664: "x86_64",
  Arm64: "arm64",
} as const;
export type ResponseBodyArchitecture = ClosedEnum<
  typeof ResponseBodyArchitecture
>;

/**
 * Queue trigger input event for v2beta (from vercel.json config). Consumer name is implicitly derived from the function path. Only one trigger per function is allowed.
 */
export type GetDeploymentExperimentalTriggers2 = {
  /**
   * Event type - must be "queue/v2beta" (REQUIRED)
   */
  type: "queue/v2beta";
  /**
   * Name of the queue topic to consume from (REQUIRED)
   */
  topic: string;
  /**
   * Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxDeliveries?: number | undefined;
  /**
   * Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
   */
  retryAfterSeconds?: number | undefined;
  /**
   * Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
   */
  initialDelaySeconds?: number | undefined;
  /**
   * Maximum number of concurrent executions for this consumer (OPTIONAL) Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxConcurrency?: number | undefined;
};

/**
 * Queue trigger input event for v1beta (from vercel.json config). Requires explicit consumer name.
 */
export type GetDeploymentExperimentalTriggers1 = {
  /**
   * Event type - must be "queue/v1beta" (REQUIRED)
   */
  type: "queue/v1beta";
  /**
   * Name of the consumer group for this trigger (REQUIRED)
   */
  consumer: string;
  /**
   * Name of the queue topic to consume from (REQUIRED)
   */
  topic: string;
  /**
   * Maximum number of delivery attempts for message processing (OPTIONAL) This represents the total number of times a message can be delivered, not the number of retries. Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxDeliveries?: number | undefined;
  /**
   * Delay in seconds before retrying failed executions (OPTIONAL) Behavior when not specified depends on the server's default configuration.
   */
  retryAfterSeconds?: number | undefined;
  /**
   * Initial delay in seconds before first execution attempt (OPTIONAL) Must be 0 or greater. Use 0 for no initial delay. Behavior when not specified depends on the server's default configuration.
   */
  initialDelaySeconds?: number | undefined;
  /**
   * Maximum number of concurrent executions for this consumer (OPTIONAL) Must be at least 1 if specified. Behavior when not specified depends on the server's default configuration.
   */
  maxConcurrency?: number | undefined;
};

export type ResponseBodyExperimentalTriggers =
  | GetDeploymentExperimentalTriggers1
  | GetDeploymentExperimentalTriggers2;

export type ResponseBodyFunctions = {
  architecture?: ResponseBodyArchitecture | undefined;
  memory?: number | undefined;
  maxDuration?: number | undefined;
  regions?: Array<string> | undefined;
  functionFailoverRegions?: Array<string> | undefined;
  runtime?: string | undefined;
  includeFiles?: string | undefined;
  excludeFiles?: string | undefined;
  experimentalTriggers?:
    | Array<
      GetDeploymentExperimentalTriggers1 | GetDeploymentExperimentalTriggers2
    >
    | undefined;
  supportsCancellation?: boolean | undefined;
};

export type GetDeploymentRoutes3 = {
  src: string;
  continue: boolean;
  middleware: number;
};

export const GetDeploymentRoutesHandle = {
  Error: "error",
  Filesystem: "filesystem",
  Hit: "hit",
  Miss: "miss",
  Rewrite: "rewrite",
  Resource: "resource",
} as const;
export type GetDeploymentRoutesHandle = ClosedEnum<
  typeof GetDeploymentRoutesHandle
>;

export type GetDeploymentRoutes2 = {
  handle: GetDeploymentRoutesHandle;
  src?: string | undefined;
  dest?: string | undefined;
  status?: number | undefined;
};

export const GetDeploymentHasType = {
  Header: "header",
  Cookie: "cookie",
  Query: "query",
} as const;
export type GetDeploymentHasType = ClosedEnum<typeof GetDeploymentHasType>;

export type GetDeploymentValueDeploymentsResponse200Eq = string | number;

export type GetDeploymentValue2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type GetDeploymentHasDeploymentsValue = string | GetDeploymentValue2;

export type GetDeploymentHas2 = {
  type: GetDeploymentHasType;
  key: string;
  value?: string | GetDeploymentValue2 | undefined;
};

export type GetDeploymentValueDeploymentsResponseEq = string | number;

export type GetDeploymentValueDeploymentsResponse2002 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type GetDeploymentHasValue =
  | string
  | GetDeploymentValueDeploymentsResponse2002;

export type GetDeploymentHas1 = {
  type: "host";
  value: string | GetDeploymentValueDeploymentsResponse2002;
};

export type GetDeploymentRoutesHas =
  | GetDeploymentHas1
  | (GetDeploymentHas2 & { type: "header" })
  | (GetDeploymentHas2 & { type: "cookie" })
  | (GetDeploymentHas2 & { type: "query" });

export const GetDeploymentMissingType = {
  Header: "header",
  Cookie: "cookie",
  Query: "query",
} as const;
export type GetDeploymentMissingType = ClosedEnum<
  typeof GetDeploymentMissingType
>;

export type GetDeploymentValueDeploymentsEq = string | number;

export type GetDeploymentValueDeploymentsResponse2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type GetDeploymentMissingValue =
  | string
  | GetDeploymentValueDeploymentsResponse2;

export type GetDeploymentMissing2 = {
  type: GetDeploymentMissingType;
  key: string;
  value?: string | GetDeploymentValueDeploymentsResponse2 | undefined;
};

export type GetDeploymentValueEq = string | number;

export type GetDeploymentValueDeployments2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type GetDeploymentMissingDeploymentsValue =
  | string
  | GetDeploymentValueDeployments2;

export type GetDeploymentMissing1 = {
  type: "host";
  value: string | GetDeploymentValueDeployments2;
};

export type GetDeploymentRoutesMissing =
  | GetDeploymentMissing1
  | (GetDeploymentMissing2 & { type: "header" })
  | (GetDeploymentMissing2 & { type: "cookie" })
  | (GetDeploymentMissing2 & { type: "query" });

export const GetDeploymentRoutesAction = {
  Challenge: "challenge",
  Deny: "deny",
} as const;
export type GetDeploymentRoutesAction = ClosedEnum<
  typeof GetDeploymentRoutesAction
>;

export type GetDeploymentRoutesMitigate = {
  action: GetDeploymentRoutesAction;
};

export const GetDeploymentRoutesType = {
  RequestHeaders: "request.headers",
  RequestQuery: "request.query",
  ResponseHeaders: "response.headers",
} as const;
export type GetDeploymentRoutesType = ClosedEnum<
  typeof GetDeploymentRoutesType
>;

export const GetDeploymentRoutesOp = {
  Append: "append",
  Set: "set",
  Delete: "delete",
} as const;
export type GetDeploymentRoutesOp = ClosedEnum<typeof GetDeploymentRoutesOp>;

export type GetDeploymentKeyEq = string | number;

export type GetDeploymentKey2 = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

export type GetDeploymentRoutesKey = string | GetDeploymentKey2;

export type GetDeploymentRoutesTarget = {
  key: string | GetDeploymentKey2;
};

export type GetDeploymentRoutesArgs = string | Array<string>;

export type GetDeploymentRoutesTransforms = {
  type: GetDeploymentRoutesType;
  op: GetDeploymentRoutesOp;
  target: GetDeploymentRoutesTarget;
  args?: string | Array<string> | undefined;
  env?: Array<string> | undefined;
};

export type GetDeploymentRoutesLocale = {
  redirect?: { [k: string]: string } | undefined;
  cookie?: string | undefined;
};

export type GetDeploymentRoutes1 = {
  src: string;
  dest?: string | undefined;
  headers?: { [k: string]: string } | undefined;
  methods?: Array<string> | undefined;
  continue?: boolean | undefined;
  override?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  check?: boolean | undefined;
  important?: boolean | undefined;
  status?: number | undefined;
  has?:
    | Array<
      | GetDeploymentHas1
      | (GetDeploymentHas2 & { type: "header" })
      | (GetDeploymentHas2 & { type: "cookie" })
      | (GetDeploymentHas2 & { type: "query" })
    >
    | undefined;
  missing?:
    | Array<
      | GetDeploymentMissing1
      | (GetDeploymentMissing2 & { type: "header" })
      | (GetDeploymentMissing2 & { type: "cookie" })
      | (GetDeploymentMissing2 & { type: "query" })
    >
    | undefined;
  mitigate?: GetDeploymentRoutesMitigate | undefined;
  transforms?: Array<GetDeploymentRoutesTransforms> | undefined;
  env?: Array<string> | undefined;
  locale?: GetDeploymentRoutesLocale | undefined;
  /**
   * A middleware key within the `output` key under the build result. Overrides a `middleware` definition.
   */
  middlewarePath?: string | undefined;
  /**
   * The original middleware matchers.
   */
  middlewareRawSrc?: Array<string> | undefined;
  /**
   * A middleware index in the `middleware` key under the build result
   */
  middleware?: number | undefined;
  respectOriginCacheControl?: boolean | undefined;
};

export type ResponseBodyRoutes =
  | GetDeploymentRoutes3
  | GetDeploymentRoutes1
  | GetDeploymentRoutes2;

export const GetDeploymentGitRepoOwnerType = {
  Team: "team",
  User: "user",
} as const;
export type GetDeploymentGitRepoOwnerType = ClosedEnum<
  typeof GetDeploymentGitRepoOwnerType
>;

export type GetDeploymentGitRepo3 = {
  owner: string;
  repoUuid: string;
  slug: string;
  type: "bitbucket";
  workspaceUuid: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: GetDeploymentGitRepoOwnerType;
};

export const GetDeploymentGitRepoDeploymentsResponseOwnerType = {
  Team: "team",
  User: "user",
} as const;
export type GetDeploymentGitRepoDeploymentsResponseOwnerType = ClosedEnum<
  typeof GetDeploymentGitRepoDeploymentsResponseOwnerType
>;

export type GetDeploymentGitRepo2 = {
  org: string;
  repo: string;
  repoId: number;
  type: "github";
  repoOwnerId: number;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: GetDeploymentGitRepoDeploymentsResponseOwnerType;
};

export const GetDeploymentGitRepoDeploymentsOwnerType = {
  Team: "team",
  User: "user",
} as const;
export type GetDeploymentGitRepoDeploymentsOwnerType = ClosedEnum<
  typeof GetDeploymentGitRepoDeploymentsOwnerType
>;

export type GetDeploymentGitRepo1 = {
  namespace: string;
  projectId: number;
  type: "gitlab";
  url: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: GetDeploymentGitRepoDeploymentsOwnerType;
};

export type ResponseBodyGitRepo =
  | GetDeploymentGitRepo1
  | GetDeploymentGitRepo2
  | GetDeploymentGitRepo3;

/**
 * Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
 */
export type GetDeploymentFlags2 = {};

export type GetDeploymentFlagsOptions = {
  value: FlagJSONValue | null;
  label?: string | undefined;
};

export type GetDeploymentFlagsDefinitions = {
  options?: Array<GetDeploymentFlagsOptions> | undefined;
  url?: string | undefined;
  description?: string | undefined;
};

/**
 * Flags defined in the Build Output API, used by this deployment. Primarily used by the Toolbar to know about the used flags.
 */
export type GetDeploymentFlags1 = {
  definitions: { [k: string]: GetDeploymentFlagsDefinitions };
};

export type ResponseBodyFlags =
  | GetDeploymentFlags1
  | Array<GetDeploymentFlags2>;

/**
 * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
 */
export const GetDeploymentMicrofrontendsMfeConfigUploadState = {
  Success: "success",
  WaitingOnBuild: "waiting_on_build",
  NoConfig: "no_config",
} as const;
/**
 * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
 */
export type GetDeploymentMicrofrontendsMfeConfigUploadState = ClosedEnum<
  typeof GetDeploymentMicrofrontendsMfeConfigUploadState
>;

export type GetDeploymentMicrofrontends2 = {
  isDefaultApp: boolean;
  /**
   * The result of the microfrontends config upload during deployment creation / build. Only set for default app deployments. The config upload is attempted during deployment create, and then again during the build. If the config is not in the root directory, or the deployment is prebuilt, the config cannot be uploaded during deployment create. The upload during deployment build finds the config even if it's not in the root directory, as it has access to all files. Uploading the config during create is ideal, as then all child deployments are guaranteed to have access to the default app deployment config even if the default app has not yet started building. If the config is not uploaded, the child app will show as building until the config has been uploaded during the default app build. - `success` - The config was uploaded successfully, either when the deployment was created or during the build. - `waiting_on_build` - The config could not be uploaded during deployment create, will be attempted again during the build. - `no_config` - No config was found. Only set once the build has not found the config in any of the deployment's files. - `undefined` - Legacy deployments, or there was an error uploading the config during deployment create.
   */
  mfeConfigUploadState?:
    | GetDeploymentMicrofrontendsMfeConfigUploadState
    | undefined;
  /**
   * The project name of the default app of this deployment's microfrontends group.
   */
  defaultAppProjectName: string;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
   */
  defaultRoute?: string | undefined;
  /**
   * The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
};

export type GetDeploymentMicrofrontends1 = {
  isDefaultApp?: boolean | undefined;
  /**
   * The project name of the default app of this deployment's microfrontends group.
   */
  defaultAppProjectName: string;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI.
   */
  defaultRoute?: string | undefined;
  /**
   * The group of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
};

export type ResponseBodyMicrofrontends =
  | GetDeploymentMicrofrontends2
  | GetDeploymentMicrofrontends1;

export const ResponseBodyFunctionType = {
  Standard: "standard",
  Fluid: "fluid",
} as const;
export type ResponseBodyFunctionType = ClosedEnum<
  typeof ResponseBodyFunctionType
>;

export const ResponseBodyFunctionMemoryType = {
  Standard: "standard",
  StandardLegacy: "standard_legacy",
  Performance: "performance",
} as const;
export type ResponseBodyFunctionMemoryType = ClosedEnum<
  typeof ResponseBodyFunctionMemoryType
>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export const GetDeploymentResponseBodyConfiguration = {
  SkipNamespaceQueue: "SKIP_NAMESPACE_QUEUE",
  WaitForNamespaceQueue: "WAIT_FOR_NAMESPACE_QUEUE",
} as const;
/**
 * Build resource configuration snapshot for this deployment.
 */
export type GetDeploymentResponseBodyConfiguration = ClosedEnum<
  typeof GetDeploymentResponseBodyConfiguration
>;

/**
 * Build resource configuration snapshot for this deployment.
 */
export type GetDeploymentResponseBodyBuildQueue = {
  /**
   * Build resource configuration snapshot for this deployment.
   */
  configuration?: GetDeploymentResponseBodyConfiguration | undefined;
};

/**
 * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
 */
export const ResponseBodyElasticConcurrency = {
  TeamSetting: "TEAM_SETTING",
  ProjectSetting: "PROJECT_SETTING",
  SkipQueue: "SKIP_QUEUE",
} as const;
/**
 * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
 */
export type ResponseBodyElasticConcurrency = ClosedEnum<
  typeof ResponseBodyElasticConcurrency
>;

/**
 * Machine type that was used for the build.
 */
export const ResponseBodyPurchaseType = {
  Standard: "standard",
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
/**
 * Machine type that was used for the build.
 */
export type ResponseBodyPurchaseType = ClosedEnum<
  typeof ResponseBodyPurchaseType
>;

export type ResponseBodyBuildMachine = {
  /**
   * Machine type that was used for the build.
   */
  purchaseType?: ResponseBodyPurchaseType | null | undefined;
};

/**
 * Build resource configuration snapshot for this deployment.
 */
export type GetDeploymentResponseBodyResourceConfig = {
  /**
   * Build resource configuration snapshot for this deployment.
   */
  buildQueue?: GetDeploymentResponseBodyBuildQueue | undefined;
  /**
   * When elastic concurrency is used for this deployment, a value is set. The value tells the reason where the setting was coming from. - TEAM_SETTING: Inherited from team settings - PROJECT_SETTING: Inherited from project settings - SKIP_QUEUE: Manually triggered by user to skip the queues
   */
  elasticConcurrency?: ResponseBodyElasticConcurrency | undefined;
  buildMachine?: ResponseBodyBuildMachine | undefined;
};

/**
 * Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
 */
export type ResponseBodyConfig = {
  version?: number | undefined;
  functionType: ResponseBodyFunctionType;
  functionMemoryType: ResponseBodyFunctionMemoryType;
  functionTimeout: number | null;
  secureComputePrimaryRegion: string | null;
  secureComputeFallbackRegion: string | null;
  isUsingActiveCPU?: boolean | undefined;
  /**
   * Build resource configuration snapshot for this deployment.
   */
  resourceConfig?: GetDeploymentResponseBodyResourceConfig | undefined;
};

export const GetDeploymentResponseBodyDeploymentsState = {
  Succeeded: "succeeded",
  Failed: "failed",
  Pending: "pending",
} as const;
export type GetDeploymentResponseBodyDeploymentsState = ClosedEnum<
  typeof GetDeploymentResponseBodyDeploymentsState
>;

/**
 * Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
 */
export type ResponseBodyDeploymentAlias = {
  state: GetDeploymentResponseBodyDeploymentsState;
  startedAt: number;
  completedAt?: number | undefined;
};

export type ResponseBodyChecks = {
  /**
   * Condensed check data. Retrieve individual check and check run data using api-checks v2 routes.
   */
  deploymentAlias: ResponseBodyDeploymentAlias;
};

/**
 * The NSNB decision code for the seat block. TODO: We should consolidate block types.
 */
export const ResponseBodyBlockCode = {
  TeamAccessRequired: "TEAM_ACCESS_REQUIRED",
  CommitAuthorRequired: "COMMIT_AUTHOR_REQUIRED",
} as const;
/**
 * The NSNB decision code for the seat block. TODO: We should consolidate block types.
 */
export type ResponseBodyBlockCode = ClosedEnum<typeof ResponseBodyBlockCode>;

/**
 * NSNB Blocked metadata
 */
export type ResponseBodySeatBlock = {
  /**
   * The NSNB decision code for the seat block. TODO: We should consolidate block types.
   */
  blockCode: ResponseBodyBlockCode;
  /**
   * The blocked vercel user ID.
   */
  userId?: string | undefined;
};

/**
 * The deployment including both public and private information
 */
export type GetDeploymentResponseBody1 = {
  aliasAssignedAt?: ResponseBodyAliasAssignedAt | null | undefined;
  alwaysRefuseToBuild?: boolean | undefined;
  build: ResponseBodyBuild;
  buildArtifactUrls?: Array<string> | undefined;
  builds?: Array<ResponseBodyBuilds> | undefined;
  env: Array<string>;
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  isInSystemBuildsQueue: boolean;
  projectSettings: ResponseBodyProjectSettings;
  readyStateReason?: string | undefined;
  integrations?: ResponseBodyIntegrations | undefined;
  images?: ResponseBodyImages | undefined;
  /**
   * A list of all the aliases (default aliases, staging aliases and production aliases) that were assigned upon deployment creation
   */
  alias?: Array<string> | undefined;
  /**
   * A boolean that will be true when the aliases from the alias property were assigned successfully
   */
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  /**
   * Since April 2025 it necessary for On-Demand Concurrency Minutes calculation
   */
  buildContainerFinishedAt?: number | undefined;
  buildSkipped: boolean;
  /**
   * Information about the deployment creator
   */
  creator: GetDeploymentResponseBodyCreator;
  initReadyAt?: number | undefined;
  isFirstBranchDeployment?: boolean | undefined;
  lambdas?: Array<GetDeploymentResponseBodyLambdas> | undefined;
  /**
   * A boolean representing if the deployment is public or not. By default this is `false`
   */
  public: boolean;
  ready?: number | undefined;
  status: ResponseBodyStatus;
  /**
   * The team that owns the deployment if any
   */
  team?: GetDeploymentResponseBodyTeam | undefined;
  /**
   * An array of domains that were provided by the user when creating the Deployment.
   */
  userAliases?: Array<string> | undefined;
  /**
   * Whether or not preview comments are enabled for the deployment
   */
  previewCommentsEnabled?: boolean | undefined;
  ttyBuildLogs?: boolean | undefined;
  customEnvironment?: GetDeploymentResponseBodyCustomEnvironment | undefined;
  oomReport?: GetDeploymentResponseBodyOomReport | undefined;
  aliasWarning?: GetDeploymentResponseBodyAliasWarning | null | undefined;
  /**
   * A string holding the unique ID of the deployment
   */
  id: string;
  /**
   * A number containing the date when the deployment was created in milliseconds
   */
  createdAt: number;
  /**
   * The state of the deployment depending on the process of deploying, or if it is ready or in an error state
   */
  readyState: GetDeploymentResponseBodyReadyState;
  /**
   * The name of the project associated with the deployment at the time that the deployment was created
   */
  name: string;
  type: GetDeploymentResponseBodyType;
  /**
   * An object that will contain a `code` and a `message` when the aliasing fails, otherwise the value will be `null`
   */
  aliasError?: GetDeploymentResponseBodyAliasError | null | undefined;
  aliasFinal?: string | null | undefined;
  /**
   * applies to custom domains only, defaults to `true`
   */
  autoAssignCustomDomains?: boolean | undefined;
  automaticAliases?: Array<string> | undefined;
  buildErrorAt?: number | undefined;
  checksState?: GetDeploymentResponseBodyChecksState | undefined;
  checksConclusion?: GetDeploymentResponseBodyChecksConclusion | undefined;
  /**
   * A number containing the date when the deployment was deleted at milliseconds
   */
  deletedAt?: number | null | undefined;
  /**
   * Computed field that is only available for deployments with a microfrontend configuration.
   */
  defaultRoute?: string | undefined;
  canceledAt?: number | undefined;
  errorCode?: string | undefined;
  errorLink?: string | undefined;
  errorMessage?: string | null | undefined;
  errorStep?: string | undefined;
  /**
   * Since November 2023 this field defines a set of regions that we will deploy the lambda to passively Lambdas will be deployed to these regions but only invoked if all of the primary `regions` are marked as out of service
   */
  passiveRegions?: Array<string> | undefined;
  gitSource?: GetDeploymentResponseBodyGitSource | undefined;
  /**
   * Present when deployment was created with VERCEL_MANUAL_PROVISIONING=true. The deployment stays in INITIALIZING until /continue is called.
   */
  manualProvisioning?: GetDeploymentResponseBodyManualProvisioning | undefined;
  meta: { [k: string]: string };
  originCacheRegion?: string | undefined;
  /**
   * If set it overrides the `projectSettings.nodeVersion` for this deployment.
   */
  nodeVersion?: GetDeploymentResponseBodyNodeVersion | undefined;
  /**
   * The public project information associated with the deployment.
   */
  project?: ResponseBodyProject | undefined;
  prebuilt?: boolean | undefined;
  /**
   * Substate of deployment when readyState is 'READY' Tracks whether or not deployment has seen production traffic: - STAGED: never seen production traffic - ROLLING: in the process of having production traffic gradually transitioned. - PROMOTED: has seen production traffic
   */
  readySubstate?: GetDeploymentResponseBodyReadySubstate | undefined;
  /**
   * The regions the deployment exists in
   */
  regions: Array<string>;
  /**
   * flag to indicate if the deployment was deleted by retention policy
   */
  softDeletedByRetention?: boolean | undefined;
  /**
   * Where was the deployment created from
   */
  source?: ResponseBodySource | undefined;
  /**
   * If defined, either `staging` if a staging alias in the format `<project>.<team>.now.sh` was assigned upon creation, or `production` if the aliases from `alias` were assigned. `null` value indicates the "preview" deployment.
   */
  target?: GetDeploymentResponseBodyTarget | null | undefined;
  /**
   * A number containing the date when the deployment was undeleted at milliseconds
   */
  undeletedAt?: number | undefined;
  /**
   * A string with the unique URL of the deployment
   */
  url: string;
  /**
   * Since January 2025 User-configured deployment ID for skew protection with pre-built deployments. This is set when users configure a custom deploymentId in their next.config.js file. This allows Next.js to use skew protection even when deployments are pre-built outside of Vercel's build system.
   */
  userConfiguredDeploymentId?: string | undefined;
  /**
   * The platform version that was used to create the deployment.
   */
  version: number;
  oidcTokenClaims?: GetDeploymentResponseBodyOidcTokenClaims | undefined;
  projectId: string;
  plan: ResponseBodyPlan;
  /**
   * Metadata about the source platform that triggered the deployment. Allows us to map a deployment back to a platform (e.g. the chat that created it)
   */
  platform?: ResponseBodyPlatform | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdIn: string;
  crons?: Array<ResponseBodyCrons> | undefined;
  functions?: { [k: string]: ResponseBodyFunctions } | null | undefined;
  monorepoManager?: string | null | undefined;
  ownerId: string;
  /**
   * Since November 2023 this field defines a Secure Compute network that will only be used to deploy passive lambdas to (as in passiveRegions)
   */
  passiveConnectConfigurationId?: string | undefined;
  routes:
    | Array<GetDeploymentRoutes3 | GetDeploymentRoutes1 | GetDeploymentRoutes2>
    | null;
  gitRepo?:
    | GetDeploymentGitRepo1
    | GetDeploymentGitRepo2
    | GetDeploymentGitRepo3
    | null
    | undefined;
  flags?: GetDeploymentFlags1 | Array<GetDeploymentFlags2> | undefined;
  microfrontends?:
    | GetDeploymentMicrofrontends2
    | GetDeploymentMicrofrontends1
    | undefined;
  /**
   * Since February 2025 the configuration must include snapshot data at the time of deployment creation to capture properties for the /deployments/:id/config endpoint utilized for displaying Deployment Configuration on the frontend This is optional because older deployments may not have this data captured
   */
  config?: ResponseBodyConfig | undefined;
  checks?: ResponseBodyChecks | undefined;
  /**
   * NSNB Blocked metadata
   */
  seatBlock?: ResponseBodySeatBlock | undefined;
};

/**
 * The deployment including only public information
 *
 * @remarks
 * The deployment including both public and private information
 */
export type GetDeploymentResponseBody =
  | GetDeploymentResponseBody1
  | GetDeploymentResponseBody2;

/** @internal */
export const ResponseBodyPlatform$inboundSchema: z.ZodType<
  ResponseBodyPlatform,
  z.ZodTypeDef,
  unknown
> = z.object({
  source: GetDeploymentResponseBodyDeploymentsSource$inboundSchema,
  origin: ResponseBodyOrigin$inboundSchema,
  meta: types.optional(z.record(types.string())),
});
/** @internal */
export type ResponseBodyPlatform$Outbound = {
  source: GetDeploymentResponseBodyDeploymentsSource$Outbound;
  origin: ResponseBodyOrigin$Outbound;
  meta?: { [k: string]: string } | undefined;
};

/** @internal */
export const ResponseBodyPlatform$outboundSchema: z.ZodType<
  ResponseBodyPlatform$Outbound,
  z.ZodTypeDef,
  ResponseBodyPlatform
> = z.object({
  source: GetDeploymentResponseBodyDeploymentsSource$outboundSchema,
  origin: ResponseBodyOrigin$outboundSchema,
  meta: z.record(z.string()).optional(),
});

export function responseBodyPlatformToJSON(
  responseBodyPlatform: ResponseBodyPlatform,
): string {
  return JSON.stringify(
    ResponseBodyPlatform$outboundSchema.parse(responseBodyPlatform),
  );
}
export function responseBodyPlatformFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyPlatform, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyPlatform$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyPlatform' from JSON`,
  );
}

/** @internal */
export const ResponseBodyCrons$inboundSchema: z.ZodType<
  ResponseBodyCrons,
  z.ZodTypeDef,
  unknown
> = z.object({
  schedule: types.string(),
  path: types.string(),
});
/** @internal */
export type ResponseBodyCrons$Outbound = {
  schedule: string;
  path: string;
};

/** @internal */
export const ResponseBodyCrons$outboundSchema: z.ZodType<
  ResponseBodyCrons$Outbound,
  z.ZodTypeDef,
  ResponseBodyCrons
> = z.object({
  schedule: z.string(),
  path: z.string(),
});

export function responseBodyCronsToJSON(
  responseBodyCrons: ResponseBodyCrons,
): string {
  return JSON.stringify(
    ResponseBodyCrons$outboundSchema.parse(responseBodyCrons),
  );
}
export function responseBodyCronsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCrons, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCrons$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCrons' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArchitecture$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyArchitecture
> = z.nativeEnum(ResponseBodyArchitecture);
/** @internal */
export const ResponseBodyArchitecture$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyArchitecture
> = ResponseBodyArchitecture$inboundSchema;

/** @internal */
export const GetDeploymentExperimentalTriggers2$inboundSchema: z.ZodType<
  GetDeploymentExperimentalTriggers2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("queue/v2beta"),
  topic: types.string(),
  maxDeliveries: types.optional(types.number()),
  retryAfterSeconds: types.optional(types.number()),
  initialDelaySeconds: types.optional(types.number()),
  maxConcurrency: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentExperimentalTriggers2$Outbound = {
  type: "queue/v2beta";
  topic: string;
  maxDeliveries?: number | undefined;
  retryAfterSeconds?: number | undefined;
  initialDelaySeconds?: number | undefined;
  maxConcurrency?: number | undefined;
};

/** @internal */
export const GetDeploymentExperimentalTriggers2$outboundSchema: z.ZodType<
  GetDeploymentExperimentalTriggers2$Outbound,
  z.ZodTypeDef,
  GetDeploymentExperimentalTriggers2
> = z.object({
  type: z.literal("queue/v2beta"),
  topic: z.string(),
  maxDeliveries: z.number().optional(),
  retryAfterSeconds: z.number().optional(),
  initialDelaySeconds: z.number().optional(),
  maxConcurrency: z.number().optional(),
});

export function getDeploymentExperimentalTriggers2ToJSON(
  getDeploymentExperimentalTriggers2: GetDeploymentExperimentalTriggers2,
): string {
  return JSON.stringify(
    GetDeploymentExperimentalTriggers2$outboundSchema.parse(
      getDeploymentExperimentalTriggers2,
    ),
  );
}
export function getDeploymentExperimentalTriggers2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentExperimentalTriggers2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentExperimentalTriggers2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentExperimentalTriggers2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentExperimentalTriggers1$inboundSchema: z.ZodType<
  GetDeploymentExperimentalTriggers1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("queue/v1beta"),
  consumer: types.string(),
  topic: types.string(),
  maxDeliveries: types.optional(types.number()),
  retryAfterSeconds: types.optional(types.number()),
  initialDelaySeconds: types.optional(types.number()),
  maxConcurrency: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentExperimentalTriggers1$Outbound = {
  type: "queue/v1beta";
  consumer: string;
  topic: string;
  maxDeliveries?: number | undefined;
  retryAfterSeconds?: number | undefined;
  initialDelaySeconds?: number | undefined;
  maxConcurrency?: number | undefined;
};

/** @internal */
export const GetDeploymentExperimentalTriggers1$outboundSchema: z.ZodType<
  GetDeploymentExperimentalTriggers1$Outbound,
  z.ZodTypeDef,
  GetDeploymentExperimentalTriggers1
> = z.object({
  type: z.literal("queue/v1beta"),
  consumer: z.string(),
  topic: z.string(),
  maxDeliveries: z.number().optional(),
  retryAfterSeconds: z.number().optional(),
  initialDelaySeconds: z.number().optional(),
  maxConcurrency: z.number().optional(),
});

export function getDeploymentExperimentalTriggers1ToJSON(
  getDeploymentExperimentalTriggers1: GetDeploymentExperimentalTriggers1,
): string {
  return JSON.stringify(
    GetDeploymentExperimentalTriggers1$outboundSchema.parse(
      getDeploymentExperimentalTriggers1,
    ),
  );
}
export function getDeploymentExperimentalTriggers1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentExperimentalTriggers1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentExperimentalTriggers1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentExperimentalTriggers1' from JSON`,
  );
}

/** @internal */
export const ResponseBodyExperimentalTriggers$inboundSchema: z.ZodType<
  ResponseBodyExperimentalTriggers,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetDeploymentExperimentalTriggers1$inboundSchema),
  z.lazy(() => GetDeploymentExperimentalTriggers2$inboundSchema),
]);
/** @internal */
export type ResponseBodyExperimentalTriggers$Outbound =
  | GetDeploymentExperimentalTriggers1$Outbound
  | GetDeploymentExperimentalTriggers2$Outbound;

/** @internal */
export const ResponseBodyExperimentalTriggers$outboundSchema: z.ZodType<
  ResponseBodyExperimentalTriggers$Outbound,
  z.ZodTypeDef,
  ResponseBodyExperimentalTriggers
> = z.union([
  z.lazy(() => GetDeploymentExperimentalTriggers1$outboundSchema),
  z.lazy(() => GetDeploymentExperimentalTriggers2$outboundSchema),
]);

export function responseBodyExperimentalTriggersToJSON(
  responseBodyExperimentalTriggers: ResponseBodyExperimentalTriggers,
): string {
  return JSON.stringify(
    ResponseBodyExperimentalTriggers$outboundSchema.parse(
      responseBodyExperimentalTriggers,
    ),
  );
}
export function responseBodyExperimentalTriggersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyExperimentalTriggers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyExperimentalTriggers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyExperimentalTriggers' from JSON`,
  );
}

/** @internal */
export const ResponseBodyFunctions$inboundSchema: z.ZodType<
  ResponseBodyFunctions,
  z.ZodTypeDef,
  unknown
> = z.object({
  architecture: types.optional(ResponseBodyArchitecture$inboundSchema),
  memory: types.optional(types.number()),
  maxDuration: types.optional(types.number()),
  regions: types.optional(z.array(types.string())),
  functionFailoverRegions: types.optional(z.array(types.string())),
  runtime: types.optional(types.string()),
  includeFiles: types.optional(types.string()),
  excludeFiles: types.optional(types.string()),
  experimentalTriggers: types.optional(
    z.array(z.union([
      z.lazy(() => GetDeploymentExperimentalTriggers1$inboundSchema),
      z.lazy(() =>
        GetDeploymentExperimentalTriggers2$inboundSchema
      ),
    ])),
  ),
  supportsCancellation: types.optional(types.boolean()),
});
/** @internal */
export type ResponseBodyFunctions$Outbound = {
  architecture?: string | undefined;
  memory?: number | undefined;
  maxDuration?: number | undefined;
  regions?: Array<string> | undefined;
  functionFailoverRegions?: Array<string> | undefined;
  runtime?: string | undefined;
  includeFiles?: string | undefined;
  excludeFiles?: string | undefined;
  experimentalTriggers?:
    | Array<
      | GetDeploymentExperimentalTriggers1$Outbound
      | GetDeploymentExperimentalTriggers2$Outbound
    >
    | undefined;
  supportsCancellation?: boolean | undefined;
};

/** @internal */
export const ResponseBodyFunctions$outboundSchema: z.ZodType<
  ResponseBodyFunctions$Outbound,
  z.ZodTypeDef,
  ResponseBodyFunctions
> = z.object({
  architecture: ResponseBodyArchitecture$outboundSchema.optional(),
  memory: z.number().optional(),
  maxDuration: z.number().optional(),
  regions: z.array(z.string()).optional(),
  functionFailoverRegions: z.array(z.string()).optional(),
  runtime: z.string().optional(),
  includeFiles: z.string().optional(),
  excludeFiles: z.string().optional(),
  experimentalTriggers: z.array(
    z.union([
      z.lazy(() => GetDeploymentExperimentalTriggers1$outboundSchema),
      z.lazy(() => GetDeploymentExperimentalTriggers2$outboundSchema),
    ]),
  ).optional(),
  supportsCancellation: z.boolean().optional(),
});

export function responseBodyFunctionsToJSON(
  responseBodyFunctions: ResponseBodyFunctions,
): string {
  return JSON.stringify(
    ResponseBodyFunctions$outboundSchema.parse(responseBodyFunctions),
  );
}
export function responseBodyFunctionsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyFunctions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyFunctions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyFunctions' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutes3$inboundSchema: z.ZodType<
  GetDeploymentRoutes3,
  z.ZodTypeDef,
  unknown
> = z.object({
  src: types.string(),
  continue: types.boolean(),
  middleware: types.number(),
});
/** @internal */
export type GetDeploymentRoutes3$Outbound = {
  src: string;
  continue: boolean;
  middleware: number;
};

/** @internal */
export const GetDeploymentRoutes3$outboundSchema: z.ZodType<
  GetDeploymentRoutes3$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutes3
> = z.object({
  src: z.string(),
  continue: z.boolean(),
  middleware: z.number(),
});

export function getDeploymentRoutes3ToJSON(
  getDeploymentRoutes3: GetDeploymentRoutes3,
): string {
  return JSON.stringify(
    GetDeploymentRoutes3$outboundSchema.parse(getDeploymentRoutes3),
  );
}
export function getDeploymentRoutes3FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutes3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutes3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutes3' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesHandle$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesHandle
> = z.nativeEnum(GetDeploymentRoutesHandle);
/** @internal */
export const GetDeploymentRoutesHandle$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesHandle
> = GetDeploymentRoutesHandle$inboundSchema;

/** @internal */
export const GetDeploymentRoutes2$inboundSchema: z.ZodType<
  GetDeploymentRoutes2,
  z.ZodTypeDef,
  unknown
> = z.object({
  handle: GetDeploymentRoutesHandle$inboundSchema,
  src: types.optional(types.string()),
  dest: types.optional(types.string()),
  status: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentRoutes2$Outbound = {
  handle: string;
  src?: string | undefined;
  dest?: string | undefined;
  status?: number | undefined;
};

/** @internal */
export const GetDeploymentRoutes2$outboundSchema: z.ZodType<
  GetDeploymentRoutes2$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutes2
> = z.object({
  handle: GetDeploymentRoutesHandle$outboundSchema,
  src: z.string().optional(),
  dest: z.string().optional(),
  status: z.number().optional(),
});

export function getDeploymentRoutes2ToJSON(
  getDeploymentRoutes2: GetDeploymentRoutes2,
): string {
  return JSON.stringify(
    GetDeploymentRoutes2$outboundSchema.parse(getDeploymentRoutes2),
  );
}
export function getDeploymentRoutes2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutes2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutes2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutes2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentHasType$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentHasType
> = z.nativeEnum(GetDeploymentHasType);
/** @internal */
export const GetDeploymentHasType$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentHasType
> = GetDeploymentHasType$inboundSchema;

/** @internal */
export const GetDeploymentValueDeploymentsResponse200Eq$inboundSchema:
  z.ZodType<GetDeploymentValueDeploymentsResponse200Eq, z.ZodTypeDef, unknown> =
    smartUnion([types.string(), types.number()]);
/** @internal */
export type GetDeploymentValueDeploymentsResponse200Eq$Outbound =
  | string
  | number;

/** @internal */
export const GetDeploymentValueDeploymentsResponse200Eq$outboundSchema:
  z.ZodType<
    GetDeploymentValueDeploymentsResponse200Eq$Outbound,
    z.ZodTypeDef,
    GetDeploymentValueDeploymentsResponse200Eq
  > = smartUnion([z.string(), z.number()]);

export function getDeploymentValueDeploymentsResponse200EqToJSON(
  getDeploymentValueDeploymentsResponse200Eq:
    GetDeploymentValueDeploymentsResponse200Eq,
): string {
  return JSON.stringify(
    GetDeploymentValueDeploymentsResponse200Eq$outboundSchema.parse(
      getDeploymentValueDeploymentsResponse200Eq,
    ),
  );
}
export function getDeploymentValueDeploymentsResponse200EqFromJSON(
  jsonString: string,
): SafeParseResult<
  GetDeploymentValueDeploymentsResponse200Eq,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentValueDeploymentsResponse200Eq$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetDeploymentValueDeploymentsResponse200Eq' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValue2$inboundSchema: z.ZodType<
  GetDeploymentValue2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentValue2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const GetDeploymentValue2$outboundSchema: z.ZodType<
  GetDeploymentValue2$Outbound,
  z.ZodTypeDef,
  GetDeploymentValue2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  re: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function getDeploymentValue2ToJSON(
  getDeploymentValue2: GetDeploymentValue2,
): string {
  return JSON.stringify(
    GetDeploymentValue2$outboundSchema.parse(getDeploymentValue2),
  );
}
export function getDeploymentValue2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentValue2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentValue2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentValue2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentHasDeploymentsValue$inboundSchema: z.ZodType<
  GetDeploymentHasDeploymentsValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => GetDeploymentValue2$inboundSchema),
]);
/** @internal */
export type GetDeploymentHasDeploymentsValue$Outbound =
  | string
  | GetDeploymentValue2$Outbound;

/** @internal */
export const GetDeploymentHasDeploymentsValue$outboundSchema: z.ZodType<
  GetDeploymentHasDeploymentsValue$Outbound,
  z.ZodTypeDef,
  GetDeploymentHasDeploymentsValue
> = smartUnion([z.string(), z.lazy(() => GetDeploymentValue2$outboundSchema)]);

export function getDeploymentHasDeploymentsValueToJSON(
  getDeploymentHasDeploymentsValue: GetDeploymentHasDeploymentsValue,
): string {
  return JSON.stringify(
    GetDeploymentHasDeploymentsValue$outboundSchema.parse(
      getDeploymentHasDeploymentsValue,
    ),
  );
}
export function getDeploymentHasDeploymentsValueFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentHasDeploymentsValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentHasDeploymentsValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentHasDeploymentsValue' from JSON`,
  );
}

/** @internal */
export const GetDeploymentHas2$inboundSchema: z.ZodType<
  GetDeploymentHas2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetDeploymentHasType$inboundSchema,
  key: types.string(),
  value: types.optional(
    smartUnion([
      types.string(),
      z.lazy(() => GetDeploymentValue2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type GetDeploymentHas2$Outbound = {
  type: string;
  key: string;
  value?: string | GetDeploymentValue2$Outbound | undefined;
};

/** @internal */
export const GetDeploymentHas2$outboundSchema: z.ZodType<
  GetDeploymentHas2$Outbound,
  z.ZodTypeDef,
  GetDeploymentHas2
> = z.object({
  type: GetDeploymentHasType$outboundSchema,
  key: z.string(),
  value: smartUnion([
    z.string(),
    z.lazy(() => GetDeploymentValue2$outboundSchema),
  ]).optional(),
});

export function getDeploymentHas2ToJSON(
  getDeploymentHas2: GetDeploymentHas2,
): string {
  return JSON.stringify(
    GetDeploymentHas2$outboundSchema.parse(getDeploymentHas2),
  );
}
export function getDeploymentHas2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentHas2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentHas2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentHas2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValueDeploymentsResponseEq$inboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsResponseEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GetDeploymentValueDeploymentsResponseEq$Outbound = string | number;

/** @internal */
export const GetDeploymentValueDeploymentsResponseEq$outboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsResponseEq$Outbound,
  z.ZodTypeDef,
  GetDeploymentValueDeploymentsResponseEq
> = smartUnion([z.string(), z.number()]);

export function getDeploymentValueDeploymentsResponseEqToJSON(
  getDeploymentValueDeploymentsResponseEq:
    GetDeploymentValueDeploymentsResponseEq,
): string {
  return JSON.stringify(
    GetDeploymentValueDeploymentsResponseEq$outboundSchema.parse(
      getDeploymentValueDeploymentsResponseEq,
    ),
  );
}
export function getDeploymentValueDeploymentsResponseEqFromJSON(
  jsonString: string,
): SafeParseResult<
  GetDeploymentValueDeploymentsResponseEq,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentValueDeploymentsResponseEq$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetDeploymentValueDeploymentsResponseEq' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValueDeploymentsResponse2002$inboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsResponse2002,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentValueDeploymentsResponse2002$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const GetDeploymentValueDeploymentsResponse2002$outboundSchema:
  z.ZodType<
    GetDeploymentValueDeploymentsResponse2002$Outbound,
    z.ZodTypeDef,
    GetDeploymentValueDeploymentsResponse2002
  > = z.object({
    eq: smartUnion([z.string(), z.number()]).optional(),
    neq: z.string().optional(),
    inc: z.array(z.string()).optional(),
    ninc: z.array(z.string()).optional(),
    pre: z.string().optional(),
    suf: z.string().optional(),
    re: z.string().optional(),
    gt: z.number().optional(),
    gte: z.number().optional(),
    lt: z.number().optional(),
    lte: z.number().optional(),
  });

export function getDeploymentValueDeploymentsResponse2002ToJSON(
  getDeploymentValueDeploymentsResponse2002:
    GetDeploymentValueDeploymentsResponse2002,
): string {
  return JSON.stringify(
    GetDeploymentValueDeploymentsResponse2002$outboundSchema.parse(
      getDeploymentValueDeploymentsResponse2002,
    ),
  );
}
export function getDeploymentValueDeploymentsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  GetDeploymentValueDeploymentsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentValueDeploymentsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetDeploymentValueDeploymentsResponse2002' from JSON`,
  );
}

/** @internal */
export const GetDeploymentHasValue$inboundSchema: z.ZodType<
  GetDeploymentHasValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => GetDeploymentValueDeploymentsResponse2002$inboundSchema),
]);
/** @internal */
export type GetDeploymentHasValue$Outbound =
  | string
  | GetDeploymentValueDeploymentsResponse2002$Outbound;

/** @internal */
export const GetDeploymentHasValue$outboundSchema: z.ZodType<
  GetDeploymentHasValue$Outbound,
  z.ZodTypeDef,
  GetDeploymentHasValue
> = smartUnion([
  z.string(),
  z.lazy(() => GetDeploymentValueDeploymentsResponse2002$outboundSchema),
]);

export function getDeploymentHasValueToJSON(
  getDeploymentHasValue: GetDeploymentHasValue,
): string {
  return JSON.stringify(
    GetDeploymentHasValue$outboundSchema.parse(getDeploymentHasValue),
  );
}
export function getDeploymentHasValueFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentHasValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentHasValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentHasValue' from JSON`,
  );
}

/** @internal */
export const GetDeploymentHas1$inboundSchema: z.ZodType<
  GetDeploymentHas1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("host"),
  value: smartUnion([
    types.string(),
    z.lazy(() => GetDeploymentValueDeploymentsResponse2002$inboundSchema),
  ]),
});
/** @internal */
export type GetDeploymentHas1$Outbound = {
  type: "host";
  value: string | GetDeploymentValueDeploymentsResponse2002$Outbound;
};

/** @internal */
export const GetDeploymentHas1$outboundSchema: z.ZodType<
  GetDeploymentHas1$Outbound,
  z.ZodTypeDef,
  GetDeploymentHas1
> = z.object({
  type: z.literal("host"),
  value: smartUnion([
    z.string(),
    z.lazy(() => GetDeploymentValueDeploymentsResponse2002$outboundSchema),
  ]),
});

export function getDeploymentHas1ToJSON(
  getDeploymentHas1: GetDeploymentHas1,
): string {
  return JSON.stringify(
    GetDeploymentHas1$outboundSchema.parse(getDeploymentHas1),
  );
}
export function getDeploymentHas1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentHas1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentHas1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentHas1' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesHas$inboundSchema: z.ZodType<
  GetDeploymentRoutesHas,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetDeploymentHas1$inboundSchema),
  z.lazy(() => GetDeploymentHas2$inboundSchema).and(
    z.object({ type: z.literal("header") }),
  ),
  z.lazy(() => GetDeploymentHas2$inboundSchema).and(
    z.object({ type: z.literal("cookie") }),
  ),
  z.lazy(() => GetDeploymentHas2$inboundSchema).and(
    z.object({ type: z.literal("query") }),
  ),
]);
/** @internal */
export type GetDeploymentRoutesHas$Outbound =
  | GetDeploymentHas1$Outbound
  | (GetDeploymentHas2$Outbound & { type: "header" })
  | (GetDeploymentHas2$Outbound & { type: "cookie" })
  | (GetDeploymentHas2$Outbound & { type: "query" });

/** @internal */
export const GetDeploymentRoutesHas$outboundSchema: z.ZodType<
  GetDeploymentRoutesHas$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesHas
> = z.union([
  z.lazy(() => GetDeploymentHas1$outboundSchema),
  z.lazy(() => GetDeploymentHas2$outboundSchema).and(
    z.object({ type: z.literal("header") }),
  ),
  z.lazy(() => GetDeploymentHas2$outboundSchema).and(
    z.object({ type: z.literal("cookie") }),
  ),
  z.lazy(() => GetDeploymentHas2$outboundSchema).and(
    z.object({ type: z.literal("query") }),
  ),
]);

export function getDeploymentRoutesHasToJSON(
  getDeploymentRoutesHas: GetDeploymentRoutesHas,
): string {
  return JSON.stringify(
    GetDeploymentRoutesHas$outboundSchema.parse(getDeploymentRoutesHas),
  );
}
export function getDeploymentRoutesHasFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesHas, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesHas$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesHas' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMissingType$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentMissingType
> = z.nativeEnum(GetDeploymentMissingType);
/** @internal */
export const GetDeploymentMissingType$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentMissingType
> = GetDeploymentMissingType$inboundSchema;

/** @internal */
export const GetDeploymentValueDeploymentsEq$inboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GetDeploymentValueDeploymentsEq$Outbound = string | number;

/** @internal */
export const GetDeploymentValueDeploymentsEq$outboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsEq$Outbound,
  z.ZodTypeDef,
  GetDeploymentValueDeploymentsEq
> = smartUnion([z.string(), z.number()]);

export function getDeploymentValueDeploymentsEqToJSON(
  getDeploymentValueDeploymentsEq: GetDeploymentValueDeploymentsEq,
): string {
  return JSON.stringify(
    GetDeploymentValueDeploymentsEq$outboundSchema.parse(
      getDeploymentValueDeploymentsEq,
    ),
  );
}
export function getDeploymentValueDeploymentsEqFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentValueDeploymentsEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentValueDeploymentsEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentValueDeploymentsEq' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValueDeploymentsResponse2$inboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentValueDeploymentsResponse2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const GetDeploymentValueDeploymentsResponse2$outboundSchema: z.ZodType<
  GetDeploymentValueDeploymentsResponse2$Outbound,
  z.ZodTypeDef,
  GetDeploymentValueDeploymentsResponse2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  re: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function getDeploymentValueDeploymentsResponse2ToJSON(
  getDeploymentValueDeploymentsResponse2:
    GetDeploymentValueDeploymentsResponse2,
): string {
  return JSON.stringify(
    GetDeploymentValueDeploymentsResponse2$outboundSchema.parse(
      getDeploymentValueDeploymentsResponse2,
    ),
  );
}
export function getDeploymentValueDeploymentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentValueDeploymentsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentValueDeploymentsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentValueDeploymentsResponse2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMissingValue$inboundSchema: z.ZodType<
  GetDeploymentMissingValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => GetDeploymentValueDeploymentsResponse2$inboundSchema),
]);
/** @internal */
export type GetDeploymentMissingValue$Outbound =
  | string
  | GetDeploymentValueDeploymentsResponse2$Outbound;

/** @internal */
export const GetDeploymentMissingValue$outboundSchema: z.ZodType<
  GetDeploymentMissingValue$Outbound,
  z.ZodTypeDef,
  GetDeploymentMissingValue
> = smartUnion([
  z.string(),
  z.lazy(() => GetDeploymentValueDeploymentsResponse2$outboundSchema),
]);

export function getDeploymentMissingValueToJSON(
  getDeploymentMissingValue: GetDeploymentMissingValue,
): string {
  return JSON.stringify(
    GetDeploymentMissingValue$outboundSchema.parse(getDeploymentMissingValue),
  );
}
export function getDeploymentMissingValueFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMissingValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentMissingValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMissingValue' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMissing2$inboundSchema: z.ZodType<
  GetDeploymentMissing2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetDeploymentMissingType$inboundSchema,
  key: types.string(),
  value: types.optional(
    smartUnion([
      types.string(),
      z.lazy(() => GetDeploymentValueDeploymentsResponse2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type GetDeploymentMissing2$Outbound = {
  type: string;
  key: string;
  value?: string | GetDeploymentValueDeploymentsResponse2$Outbound | undefined;
};

/** @internal */
export const GetDeploymentMissing2$outboundSchema: z.ZodType<
  GetDeploymentMissing2$Outbound,
  z.ZodTypeDef,
  GetDeploymentMissing2
> = z.object({
  type: GetDeploymentMissingType$outboundSchema,
  key: z.string(),
  value: smartUnion([
    z.string(),
    z.lazy(() => GetDeploymentValueDeploymentsResponse2$outboundSchema),
  ]).optional(),
});

export function getDeploymentMissing2ToJSON(
  getDeploymentMissing2: GetDeploymentMissing2,
): string {
  return JSON.stringify(
    GetDeploymentMissing2$outboundSchema.parse(getDeploymentMissing2),
  );
}
export function getDeploymentMissing2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMissing2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentMissing2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMissing2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValueEq$inboundSchema: z.ZodType<
  GetDeploymentValueEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GetDeploymentValueEq$Outbound = string | number;

/** @internal */
export const GetDeploymentValueEq$outboundSchema: z.ZodType<
  GetDeploymentValueEq$Outbound,
  z.ZodTypeDef,
  GetDeploymentValueEq
> = smartUnion([z.string(), z.number()]);

export function getDeploymentValueEqToJSON(
  getDeploymentValueEq: GetDeploymentValueEq,
): string {
  return JSON.stringify(
    GetDeploymentValueEq$outboundSchema.parse(getDeploymentValueEq),
  );
}
export function getDeploymentValueEqFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentValueEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentValueEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentValueEq' from JSON`,
  );
}

/** @internal */
export const GetDeploymentValueDeployments2$inboundSchema: z.ZodType<
  GetDeploymentValueDeployments2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  re: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentValueDeployments2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  re?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const GetDeploymentValueDeployments2$outboundSchema: z.ZodType<
  GetDeploymentValueDeployments2$Outbound,
  z.ZodTypeDef,
  GetDeploymentValueDeployments2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  re: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function getDeploymentValueDeployments2ToJSON(
  getDeploymentValueDeployments2: GetDeploymentValueDeployments2,
): string {
  return JSON.stringify(
    GetDeploymentValueDeployments2$outboundSchema.parse(
      getDeploymentValueDeployments2,
    ),
  );
}
export function getDeploymentValueDeployments2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentValueDeployments2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentValueDeployments2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentValueDeployments2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMissingDeploymentsValue$inboundSchema: z.ZodType<
  GetDeploymentMissingDeploymentsValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  types.string(),
  z.lazy(() => GetDeploymentValueDeployments2$inboundSchema),
]);
/** @internal */
export type GetDeploymentMissingDeploymentsValue$Outbound =
  | string
  | GetDeploymentValueDeployments2$Outbound;

/** @internal */
export const GetDeploymentMissingDeploymentsValue$outboundSchema: z.ZodType<
  GetDeploymentMissingDeploymentsValue$Outbound,
  z.ZodTypeDef,
  GetDeploymentMissingDeploymentsValue
> = smartUnion([
  z.string(),
  z.lazy(() => GetDeploymentValueDeployments2$outboundSchema),
]);

export function getDeploymentMissingDeploymentsValueToJSON(
  getDeploymentMissingDeploymentsValue: GetDeploymentMissingDeploymentsValue,
): string {
  return JSON.stringify(
    GetDeploymentMissingDeploymentsValue$outboundSchema.parse(
      getDeploymentMissingDeploymentsValue,
    ),
  );
}
export function getDeploymentMissingDeploymentsValueFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMissingDeploymentsValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentMissingDeploymentsValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMissingDeploymentsValue' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMissing1$inboundSchema: z.ZodType<
  GetDeploymentMissing1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("host"),
  value: smartUnion([
    types.string(),
    z.lazy(() => GetDeploymentValueDeployments2$inboundSchema),
  ]),
});
/** @internal */
export type GetDeploymentMissing1$Outbound = {
  type: "host";
  value: string | GetDeploymentValueDeployments2$Outbound;
};

/** @internal */
export const GetDeploymentMissing1$outboundSchema: z.ZodType<
  GetDeploymentMissing1$Outbound,
  z.ZodTypeDef,
  GetDeploymentMissing1
> = z.object({
  type: z.literal("host"),
  value: smartUnion([
    z.string(),
    z.lazy(() => GetDeploymentValueDeployments2$outboundSchema),
  ]),
});

export function getDeploymentMissing1ToJSON(
  getDeploymentMissing1: GetDeploymentMissing1,
): string {
  return JSON.stringify(
    GetDeploymentMissing1$outboundSchema.parse(getDeploymentMissing1),
  );
}
export function getDeploymentMissing1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMissing1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentMissing1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMissing1' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesMissing$inboundSchema: z.ZodType<
  GetDeploymentRoutesMissing,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetDeploymentMissing1$inboundSchema),
  z.lazy(() => GetDeploymentMissing2$inboundSchema).and(
    z.object({ type: z.literal("header") }),
  ),
  z.lazy(() => GetDeploymentMissing2$inboundSchema).and(
    z.object({ type: z.literal("cookie") }),
  ),
  z.lazy(() => GetDeploymentMissing2$inboundSchema).and(
    z.object({ type: z.literal("query") }),
  ),
]);
/** @internal */
export type GetDeploymentRoutesMissing$Outbound =
  | GetDeploymentMissing1$Outbound
  | (GetDeploymentMissing2$Outbound & { type: "header" })
  | (GetDeploymentMissing2$Outbound & { type: "cookie" })
  | (GetDeploymentMissing2$Outbound & { type: "query" });

/** @internal */
export const GetDeploymentRoutesMissing$outboundSchema: z.ZodType<
  GetDeploymentRoutesMissing$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesMissing
> = z.union([
  z.lazy(() => GetDeploymentMissing1$outboundSchema),
  z.lazy(() => GetDeploymentMissing2$outboundSchema).and(
    z.object({ type: z.literal("header") }),
  ),
  z.lazy(() => GetDeploymentMissing2$outboundSchema).and(
    z.object({ type: z.literal("cookie") }),
  ),
  z.lazy(() => GetDeploymentMissing2$outboundSchema).and(
    z.object({ type: z.literal("query") }),
  ),
]);

export function getDeploymentRoutesMissingToJSON(
  getDeploymentRoutesMissing: GetDeploymentRoutesMissing,
): string {
  return JSON.stringify(
    GetDeploymentRoutesMissing$outboundSchema.parse(getDeploymentRoutesMissing),
  );
}
export function getDeploymentRoutesMissingFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesMissing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesMissing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesMissing' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesAction$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesAction
> = z.nativeEnum(GetDeploymentRoutesAction);
/** @internal */
export const GetDeploymentRoutesAction$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesAction
> = GetDeploymentRoutesAction$inboundSchema;

/** @internal */
export const GetDeploymentRoutesMitigate$inboundSchema: z.ZodType<
  GetDeploymentRoutesMitigate,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: GetDeploymentRoutesAction$inboundSchema,
});
/** @internal */
export type GetDeploymentRoutesMitigate$Outbound = {
  action: string;
};

/** @internal */
export const GetDeploymentRoutesMitigate$outboundSchema: z.ZodType<
  GetDeploymentRoutesMitigate$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesMitigate
> = z.object({
  action: GetDeploymentRoutesAction$outboundSchema,
});

export function getDeploymentRoutesMitigateToJSON(
  getDeploymentRoutesMitigate: GetDeploymentRoutesMitigate,
): string {
  return JSON.stringify(
    GetDeploymentRoutesMitigate$outboundSchema.parse(
      getDeploymentRoutesMitigate,
    ),
  );
}
export function getDeploymentRoutesMitigateFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesMitigate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesMitigate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesMitigate' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesType$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesType
> = z.nativeEnum(GetDeploymentRoutesType);
/** @internal */
export const GetDeploymentRoutesType$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesType
> = GetDeploymentRoutesType$inboundSchema;

/** @internal */
export const GetDeploymentRoutesOp$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesOp
> = z.nativeEnum(GetDeploymentRoutesOp);
/** @internal */
export const GetDeploymentRoutesOp$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentRoutesOp
> = GetDeploymentRoutesOp$inboundSchema;

/** @internal */
export const GetDeploymentKeyEq$inboundSchema: z.ZodType<
  GetDeploymentKeyEq,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GetDeploymentKeyEq$Outbound = string | number;

/** @internal */
export const GetDeploymentKeyEq$outboundSchema: z.ZodType<
  GetDeploymentKeyEq$Outbound,
  z.ZodTypeDef,
  GetDeploymentKeyEq
> = smartUnion([z.string(), z.number()]);

export function getDeploymentKeyEqToJSON(
  getDeploymentKeyEq: GetDeploymentKeyEq,
): string {
  return JSON.stringify(
    GetDeploymentKeyEq$outboundSchema.parse(getDeploymentKeyEq),
  );
}
export function getDeploymentKeyEqFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentKeyEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentKeyEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentKeyEq' from JSON`,
  );
}

/** @internal */
export const GetDeploymentKey2$inboundSchema: z.ZodType<
  GetDeploymentKey2,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: types.optional(smartUnion([types.string(), types.number()])),
  neq: types.optional(types.string()),
  inc: types.optional(z.array(types.string())),
  ninc: types.optional(z.array(types.string())),
  pre: types.optional(types.string()),
  suf: types.optional(types.string()),
  gt: types.optional(types.number()),
  gte: types.optional(types.number()),
  lt: types.optional(types.number()),
  lte: types.optional(types.number()),
});
/** @internal */
export type GetDeploymentKey2$Outbound = {
  eq?: string | number | undefined;
  neq?: string | undefined;
  inc?: Array<string> | undefined;
  ninc?: Array<string> | undefined;
  pre?: string | undefined;
  suf?: string | undefined;
  gt?: number | undefined;
  gte?: number | undefined;
  lt?: number | undefined;
  lte?: number | undefined;
};

/** @internal */
export const GetDeploymentKey2$outboundSchema: z.ZodType<
  GetDeploymentKey2$Outbound,
  z.ZodTypeDef,
  GetDeploymentKey2
> = z.object({
  eq: smartUnion([z.string(), z.number()]).optional(),
  neq: z.string().optional(),
  inc: z.array(z.string()).optional(),
  ninc: z.array(z.string()).optional(),
  pre: z.string().optional(),
  suf: z.string().optional(),
  gt: z.number().optional(),
  gte: z.number().optional(),
  lt: z.number().optional(),
  lte: z.number().optional(),
});

export function getDeploymentKey2ToJSON(
  getDeploymentKey2: GetDeploymentKey2,
): string {
  return JSON.stringify(
    GetDeploymentKey2$outboundSchema.parse(getDeploymentKey2),
  );
}
export function getDeploymentKey2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentKey2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentKey2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentKey2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesKey$inboundSchema: z.ZodType<
  GetDeploymentRoutesKey,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), z.lazy(() => GetDeploymentKey2$inboundSchema)]);
/** @internal */
export type GetDeploymentRoutesKey$Outbound =
  | string
  | GetDeploymentKey2$Outbound;

/** @internal */
export const GetDeploymentRoutesKey$outboundSchema: z.ZodType<
  GetDeploymentRoutesKey$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesKey
> = smartUnion([z.string(), z.lazy(() => GetDeploymentKey2$outboundSchema)]);

export function getDeploymentRoutesKeyToJSON(
  getDeploymentRoutesKey: GetDeploymentRoutesKey,
): string {
  return JSON.stringify(
    GetDeploymentRoutesKey$outboundSchema.parse(getDeploymentRoutesKey),
  );
}
export function getDeploymentRoutesKeyFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesKey, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesKey$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesKey' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesTarget$inboundSchema: z.ZodType<
  GetDeploymentRoutesTarget,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: smartUnion([
    types.string(),
    z.lazy(() => GetDeploymentKey2$inboundSchema),
  ]),
});
/** @internal */
export type GetDeploymentRoutesTarget$Outbound = {
  key: string | GetDeploymentKey2$Outbound;
};

/** @internal */
export const GetDeploymentRoutesTarget$outboundSchema: z.ZodType<
  GetDeploymentRoutesTarget$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesTarget
> = z.object({
  key: smartUnion([z.string(), z.lazy(() => GetDeploymentKey2$outboundSchema)]),
});

export function getDeploymentRoutesTargetToJSON(
  getDeploymentRoutesTarget: GetDeploymentRoutesTarget,
): string {
  return JSON.stringify(
    GetDeploymentRoutesTarget$outboundSchema.parse(getDeploymentRoutesTarget),
  );
}
export function getDeploymentRoutesTargetFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesTarget, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesTarget$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesTarget' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesArgs$inboundSchema: z.ZodType<
  GetDeploymentRoutesArgs,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), z.array(types.string())]);
/** @internal */
export type GetDeploymentRoutesArgs$Outbound = string | Array<string>;

/** @internal */
export const GetDeploymentRoutesArgs$outboundSchema: z.ZodType<
  GetDeploymentRoutesArgs$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesArgs
> = smartUnion([z.string(), z.array(z.string())]);

export function getDeploymentRoutesArgsToJSON(
  getDeploymentRoutesArgs: GetDeploymentRoutesArgs,
): string {
  return JSON.stringify(
    GetDeploymentRoutesArgs$outboundSchema.parse(getDeploymentRoutesArgs),
  );
}
export function getDeploymentRoutesArgsFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesArgs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesArgs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesArgs' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesTransforms$inboundSchema: z.ZodType<
  GetDeploymentRoutesTransforms,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetDeploymentRoutesType$inboundSchema,
  op: GetDeploymentRoutesOp$inboundSchema,
  target: z.lazy(() => GetDeploymentRoutesTarget$inboundSchema),
  args: types.optional(smartUnion([types.string(), z.array(types.string())])),
  env: types.optional(z.array(types.string())),
});
/** @internal */
export type GetDeploymentRoutesTransforms$Outbound = {
  type: string;
  op: string;
  target: GetDeploymentRoutesTarget$Outbound;
  args?: string | Array<string> | undefined;
  env?: Array<string> | undefined;
};

/** @internal */
export const GetDeploymentRoutesTransforms$outboundSchema: z.ZodType<
  GetDeploymentRoutesTransforms$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesTransforms
> = z.object({
  type: GetDeploymentRoutesType$outboundSchema,
  op: GetDeploymentRoutesOp$outboundSchema,
  target: z.lazy(() => GetDeploymentRoutesTarget$outboundSchema),
  args: smartUnion([z.string(), z.array(z.string())]).optional(),
  env: z.array(z.string()).optional(),
});

export function getDeploymentRoutesTransformsToJSON(
  getDeploymentRoutesTransforms: GetDeploymentRoutesTransforms,
): string {
  return JSON.stringify(
    GetDeploymentRoutesTransforms$outboundSchema.parse(
      getDeploymentRoutesTransforms,
    ),
  );
}
export function getDeploymentRoutesTransformsFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesTransforms, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesTransforms$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesTransforms' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutesLocale$inboundSchema: z.ZodType<
  GetDeploymentRoutesLocale,
  z.ZodTypeDef,
  unknown
> = z.object({
  redirect: types.optional(z.record(types.string())),
  cookie: types.optional(types.string()),
});
/** @internal */
export type GetDeploymentRoutesLocale$Outbound = {
  redirect?: { [k: string]: string } | undefined;
  cookie?: string | undefined;
};

/** @internal */
export const GetDeploymentRoutesLocale$outboundSchema: z.ZodType<
  GetDeploymentRoutesLocale$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutesLocale
> = z.object({
  redirect: z.record(z.string()).optional(),
  cookie: z.string().optional(),
});

export function getDeploymentRoutesLocaleToJSON(
  getDeploymentRoutesLocale: GetDeploymentRoutesLocale,
): string {
  return JSON.stringify(
    GetDeploymentRoutesLocale$outboundSchema.parse(getDeploymentRoutesLocale),
  );
}
export function getDeploymentRoutesLocaleFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutesLocale, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutesLocale$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutesLocale' from JSON`,
  );
}

/** @internal */
export const GetDeploymentRoutes1$inboundSchema: z.ZodType<
  GetDeploymentRoutes1,
  z.ZodTypeDef,
  unknown
> = z.object({
  src: types.string(),
  dest: types.optional(types.string()),
  headers: types.optional(z.record(types.string())),
  methods: types.optional(z.array(types.string())),
  continue: types.optional(types.boolean()),
  override: types.optional(types.boolean()),
  caseSensitive: types.optional(types.boolean()),
  check: types.optional(types.boolean()),
  important: types.optional(types.boolean()),
  status: types.optional(types.number()),
  has: types.optional(
    z.array(z.union([
      z.lazy(() => GetDeploymentHas1$inboundSchema),
      z.lazy(() =>
        GetDeploymentHas2$inboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() => GetDeploymentHas2$inboundSchema).and(
        z.object({ type: z.literal("cookie") }),
      ),
      z.lazy(() => GetDeploymentHas2$inboundSchema).and(
        z.object({ type: z.literal("query") }),
      ),
    ])),
  ),
  missing: types.optional(
    z.array(z.union([
      z.lazy(() => GetDeploymentMissing1$inboundSchema),
      z.lazy(() =>
        GetDeploymentMissing2$inboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() => GetDeploymentMissing2$inboundSchema).and(
        z.object({ type: z.literal("cookie") }),
      ),
      z.lazy(() => GetDeploymentMissing2$inboundSchema).and(
        z.object({ type: z.literal("query") }),
      ),
    ])),
  ),
  mitigate: types.optional(
    z.lazy(() => GetDeploymentRoutesMitigate$inboundSchema),
  ),
  transforms: types.optional(
    z.array(z.lazy(() => GetDeploymentRoutesTransforms$inboundSchema)),
  ),
  env: types.optional(z.array(types.string())),
  locale: types.optional(z.lazy(() => GetDeploymentRoutesLocale$inboundSchema)),
  middlewarePath: types.optional(types.string()),
  middlewareRawSrc: types.optional(z.array(types.string())),
  middleware: types.optional(types.number()),
  respectOriginCacheControl: types.optional(types.boolean()),
});
/** @internal */
export type GetDeploymentRoutes1$Outbound = {
  src: string;
  dest?: string | undefined;
  headers?: { [k: string]: string } | undefined;
  methods?: Array<string> | undefined;
  continue?: boolean | undefined;
  override?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  check?: boolean | undefined;
  important?: boolean | undefined;
  status?: number | undefined;
  has?:
    | Array<
      | GetDeploymentHas1$Outbound
      | (GetDeploymentHas2$Outbound & { type: "header" })
      | (GetDeploymentHas2$Outbound & { type: "cookie" })
      | (GetDeploymentHas2$Outbound & { type: "query" })
    >
    | undefined;
  missing?:
    | Array<
      | GetDeploymentMissing1$Outbound
      | (GetDeploymentMissing2$Outbound & { type: "header" })
      | (GetDeploymentMissing2$Outbound & { type: "cookie" })
      | (GetDeploymentMissing2$Outbound & { type: "query" })
    >
    | undefined;
  mitigate?: GetDeploymentRoutesMitigate$Outbound | undefined;
  transforms?: Array<GetDeploymentRoutesTransforms$Outbound> | undefined;
  env?: Array<string> | undefined;
  locale?: GetDeploymentRoutesLocale$Outbound | undefined;
  middlewarePath?: string | undefined;
  middlewareRawSrc?: Array<string> | undefined;
  middleware?: number | undefined;
  respectOriginCacheControl?: boolean | undefined;
};

/** @internal */
export const GetDeploymentRoutes1$outboundSchema: z.ZodType<
  GetDeploymentRoutes1$Outbound,
  z.ZodTypeDef,
  GetDeploymentRoutes1
> = z.object({
  src: z.string(),
  dest: z.string().optional(),
  headers: z.record(z.string()).optional(),
  methods: z.array(z.string()).optional(),
  continue: z.boolean().optional(),
  override: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  check: z.boolean().optional(),
  important: z.boolean().optional(),
  status: z.number().optional(),
  has: z.array(
    z.union([
      z.lazy(() => GetDeploymentHas1$outboundSchema),
      z.lazy(() =>
        GetDeploymentHas2$outboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() =>
        GetDeploymentHas2$outboundSchema
      ).and(z.object({ type: z.literal("cookie") })),
      z.lazy(() =>
        GetDeploymentHas2$outboundSchema
      ).and(z.object({ type: z.literal("query") })),
    ]),
  ).optional(),
  missing: z.array(
    z.union([
      z.lazy(() => GetDeploymentMissing1$outboundSchema),
      z.lazy(() =>
        GetDeploymentMissing2$outboundSchema
      ).and(z.object({ type: z.literal("header") })),
      z.lazy(() =>
        GetDeploymentMissing2$outboundSchema
      ).and(z.object({ type: z.literal("cookie") })),
      z.lazy(() =>
        GetDeploymentMissing2$outboundSchema
      ).and(z.object({ type: z.literal("query") })),
    ]),
  ).optional(),
  mitigate: z.lazy(() => GetDeploymentRoutesMitigate$outboundSchema).optional(),
  transforms: z.array(
    z.lazy(() => GetDeploymentRoutesTransforms$outboundSchema),
  ).optional(),
  env: z.array(z.string()).optional(),
  locale: z.lazy(() => GetDeploymentRoutesLocale$outboundSchema).optional(),
  middlewarePath: z.string().optional(),
  middlewareRawSrc: z.array(z.string()).optional(),
  middleware: z.number().optional(),
  respectOriginCacheControl: z.boolean().optional(),
});

export function getDeploymentRoutes1ToJSON(
  getDeploymentRoutes1: GetDeploymentRoutes1,
): string {
  return JSON.stringify(
    GetDeploymentRoutes1$outboundSchema.parse(getDeploymentRoutes1),
  );
}
export function getDeploymentRoutes1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentRoutes1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentRoutes1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentRoutes1' from JSON`,
  );
}

/** @internal */
export const ResponseBodyRoutes$inboundSchema: z.ZodType<
  ResponseBodyRoutes,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GetDeploymentRoutes3$inboundSchema),
  z.lazy(() => GetDeploymentRoutes1$inboundSchema),
  z.lazy(() => GetDeploymentRoutes2$inboundSchema),
]);
/** @internal */
export type ResponseBodyRoutes$Outbound =
  | GetDeploymentRoutes3$Outbound
  | GetDeploymentRoutes1$Outbound
  | GetDeploymentRoutes2$Outbound;

/** @internal */
export const ResponseBodyRoutes$outboundSchema: z.ZodType<
  ResponseBodyRoutes$Outbound,
  z.ZodTypeDef,
  ResponseBodyRoutes
> = smartUnion([
  z.lazy(() => GetDeploymentRoutes3$outboundSchema),
  z.lazy(() => GetDeploymentRoutes1$outboundSchema),
  z.lazy(() => GetDeploymentRoutes2$outboundSchema),
]);

export function responseBodyRoutesToJSON(
  responseBodyRoutes: ResponseBodyRoutes,
): string {
  return JSON.stringify(
    ResponseBodyRoutes$outboundSchema.parse(responseBodyRoutes),
  );
}
export function responseBodyRoutesFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyRoutes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyRoutes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyRoutes' from JSON`,
  );
}

/** @internal */
export const GetDeploymentGitRepoOwnerType$inboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentGitRepoOwnerType
> = z.nativeEnum(GetDeploymentGitRepoOwnerType);
/** @internal */
export const GetDeploymentGitRepoOwnerType$outboundSchema: z.ZodNativeEnum<
  typeof GetDeploymentGitRepoOwnerType
> = GetDeploymentGitRepoOwnerType$inboundSchema;

/** @internal */
export const GetDeploymentGitRepo3$inboundSchema: z.ZodType<
  GetDeploymentGitRepo3,
  z.ZodTypeDef,
  unknown
> = z.object({
  owner: types.string(),
  repoUuid: types.string(),
  slug: types.string(),
  type: types.literal("bitbucket"),
  workspaceUuid: types.string(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: GetDeploymentGitRepoOwnerType$inboundSchema,
});
/** @internal */
export type GetDeploymentGitRepo3$Outbound = {
  owner: string;
  repoUuid: string;
  slug: string;
  type: "bitbucket";
  workspaceUuid: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GetDeploymentGitRepo3$outboundSchema: z.ZodType<
  GetDeploymentGitRepo3$Outbound,
  z.ZodTypeDef,
  GetDeploymentGitRepo3
> = z.object({
  owner: z.string(),
  repoUuid: z.string(),
  slug: z.string(),
  type: z.literal("bitbucket"),
  workspaceUuid: z.string(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: GetDeploymentGitRepoOwnerType$outboundSchema,
});

export function getDeploymentGitRepo3ToJSON(
  getDeploymentGitRepo3: GetDeploymentGitRepo3,
): string {
  return JSON.stringify(
    GetDeploymentGitRepo3$outboundSchema.parse(getDeploymentGitRepo3),
  );
}
export function getDeploymentGitRepo3FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentGitRepo3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentGitRepo3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentGitRepo3' from JSON`,
  );
}

/** @internal */
export const GetDeploymentGitRepoDeploymentsResponseOwnerType$inboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentGitRepoDeploymentsResponseOwnerType> = z
    .nativeEnum(GetDeploymentGitRepoDeploymentsResponseOwnerType);
/** @internal */
export const GetDeploymentGitRepoDeploymentsResponseOwnerType$outboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentGitRepoDeploymentsResponseOwnerType> =
    GetDeploymentGitRepoDeploymentsResponseOwnerType$inboundSchema;

/** @internal */
export const GetDeploymentGitRepo2$inboundSchema: z.ZodType<
  GetDeploymentGitRepo2,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  repo: types.string(),
  repoId: types.number(),
  type: types.literal("github"),
  repoOwnerId: types.number(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: GetDeploymentGitRepoDeploymentsResponseOwnerType$inboundSchema,
});
/** @internal */
export type GetDeploymentGitRepo2$Outbound = {
  org: string;
  repo: string;
  repoId: number;
  type: "github";
  repoOwnerId: number;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GetDeploymentGitRepo2$outboundSchema: z.ZodType<
  GetDeploymentGitRepo2$Outbound,
  z.ZodTypeDef,
  GetDeploymentGitRepo2
> = z.object({
  org: z.string(),
  repo: z.string(),
  repoId: z.number(),
  type: z.literal("github"),
  repoOwnerId: z.number(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: GetDeploymentGitRepoDeploymentsResponseOwnerType$outboundSchema,
});

export function getDeploymentGitRepo2ToJSON(
  getDeploymentGitRepo2: GetDeploymentGitRepo2,
): string {
  return JSON.stringify(
    GetDeploymentGitRepo2$outboundSchema.parse(getDeploymentGitRepo2),
  );
}
export function getDeploymentGitRepo2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentGitRepo2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentGitRepo2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentGitRepo2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentGitRepoDeploymentsOwnerType$inboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentGitRepoDeploymentsOwnerType> = z
    .nativeEnum(GetDeploymentGitRepoDeploymentsOwnerType);
/** @internal */
export const GetDeploymentGitRepoDeploymentsOwnerType$outboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentGitRepoDeploymentsOwnerType> =
    GetDeploymentGitRepoDeploymentsOwnerType$inboundSchema;

/** @internal */
export const GetDeploymentGitRepo1$inboundSchema: z.ZodType<
  GetDeploymentGitRepo1,
  z.ZodTypeDef,
  unknown
> = z.object({
  namespace: types.string(),
  projectId: types.number(),
  type: types.literal("gitlab"),
  url: types.string(),
  path: types.string(),
  defaultBranch: types.string(),
  name: types.string(),
  private: types.boolean(),
  ownerType: GetDeploymentGitRepoDeploymentsOwnerType$inboundSchema,
});
/** @internal */
export type GetDeploymentGitRepo1$Outbound = {
  namespace: string;
  projectId: number;
  type: "gitlab";
  url: string;
  path: string;
  defaultBranch: string;
  name: string;
  private: boolean;
  ownerType: string;
};

/** @internal */
export const GetDeploymentGitRepo1$outboundSchema: z.ZodType<
  GetDeploymentGitRepo1$Outbound,
  z.ZodTypeDef,
  GetDeploymentGitRepo1
> = z.object({
  namespace: z.string(),
  projectId: z.number(),
  type: z.literal("gitlab"),
  url: z.string(),
  path: z.string(),
  defaultBranch: z.string(),
  name: z.string(),
  private: z.boolean(),
  ownerType: GetDeploymentGitRepoDeploymentsOwnerType$outboundSchema,
});

export function getDeploymentGitRepo1ToJSON(
  getDeploymentGitRepo1: GetDeploymentGitRepo1,
): string {
  return JSON.stringify(
    GetDeploymentGitRepo1$outboundSchema.parse(getDeploymentGitRepo1),
  );
}
export function getDeploymentGitRepo1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentGitRepo1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentGitRepo1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentGitRepo1' from JSON`,
  );
}

/** @internal */
export const ResponseBodyGitRepo$inboundSchema: z.ZodType<
  ResponseBodyGitRepo,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetDeploymentGitRepo1$inboundSchema),
  z.lazy(() => GetDeploymentGitRepo2$inboundSchema),
  z.lazy(() => GetDeploymentGitRepo3$inboundSchema),
]);
/** @internal */
export type ResponseBodyGitRepo$Outbound =
  | GetDeploymentGitRepo1$Outbound
  | GetDeploymentGitRepo2$Outbound
  | GetDeploymentGitRepo3$Outbound;

/** @internal */
export const ResponseBodyGitRepo$outboundSchema: z.ZodType<
  ResponseBodyGitRepo$Outbound,
  z.ZodTypeDef,
  ResponseBodyGitRepo
> = z.union([
  z.lazy(() => GetDeploymentGitRepo1$outboundSchema),
  z.lazy(() => GetDeploymentGitRepo2$outboundSchema),
  z.lazy(() => GetDeploymentGitRepo3$outboundSchema),
]);

export function responseBodyGitRepoToJSON(
  responseBodyGitRepo: ResponseBodyGitRepo,
): string {
  return JSON.stringify(
    ResponseBodyGitRepo$outboundSchema.parse(responseBodyGitRepo),
  );
}
export function responseBodyGitRepoFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyGitRepo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyGitRepo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyGitRepo' from JSON`,
  );
}

/** @internal */
export const GetDeploymentFlags2$inboundSchema: z.ZodType<
  GetDeploymentFlags2,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type GetDeploymentFlags2$Outbound = {};

/** @internal */
export const GetDeploymentFlags2$outboundSchema: z.ZodType<
  GetDeploymentFlags2$Outbound,
  z.ZodTypeDef,
  GetDeploymentFlags2
> = z.object({});

export function getDeploymentFlags2ToJSON(
  getDeploymentFlags2: GetDeploymentFlags2,
): string {
  return JSON.stringify(
    GetDeploymentFlags2$outboundSchema.parse(getDeploymentFlags2),
  );
}
export function getDeploymentFlags2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentFlags2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentFlags2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentFlags2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentFlagsOptions$inboundSchema: z.ZodType<
  GetDeploymentFlagsOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: types.nullable(FlagJSONValue$inboundSchema),
  label: types.optional(types.string()),
});
/** @internal */
export type GetDeploymentFlagsOptions$Outbound = {
  value: FlagJSONValue$Outbound | null;
  label?: string | undefined;
};

/** @internal */
export const GetDeploymentFlagsOptions$outboundSchema: z.ZodType<
  GetDeploymentFlagsOptions$Outbound,
  z.ZodTypeDef,
  GetDeploymentFlagsOptions
> = z.object({
  value: z.nullable(FlagJSONValue$outboundSchema),
  label: z.string().optional(),
});

export function getDeploymentFlagsOptionsToJSON(
  getDeploymentFlagsOptions: GetDeploymentFlagsOptions,
): string {
  return JSON.stringify(
    GetDeploymentFlagsOptions$outboundSchema.parse(getDeploymentFlagsOptions),
  );
}
export function getDeploymentFlagsOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentFlagsOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentFlagsOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentFlagsOptions' from JSON`,
  );
}

/** @internal */
export const GetDeploymentFlagsDefinitions$inboundSchema: z.ZodType<
  GetDeploymentFlagsDefinitions,
  z.ZodTypeDef,
  unknown
> = z.object({
  options: types.optional(
    z.array(z.lazy(() => GetDeploymentFlagsOptions$inboundSchema)),
  ),
  url: types.optional(types.string()),
  description: types.optional(types.string()),
});
/** @internal */
export type GetDeploymentFlagsDefinitions$Outbound = {
  options?: Array<GetDeploymentFlagsOptions$Outbound> | undefined;
  url?: string | undefined;
  description?: string | undefined;
};

/** @internal */
export const GetDeploymentFlagsDefinitions$outboundSchema: z.ZodType<
  GetDeploymentFlagsDefinitions$Outbound,
  z.ZodTypeDef,
  GetDeploymentFlagsDefinitions
> = z.object({
  options: z.array(z.lazy(() => GetDeploymentFlagsOptions$outboundSchema))
    .optional(),
  url: z.string().optional(),
  description: z.string().optional(),
});

export function getDeploymentFlagsDefinitionsToJSON(
  getDeploymentFlagsDefinitions: GetDeploymentFlagsDefinitions,
): string {
  return JSON.stringify(
    GetDeploymentFlagsDefinitions$outboundSchema.parse(
      getDeploymentFlagsDefinitions,
    ),
  );
}
export function getDeploymentFlagsDefinitionsFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentFlagsDefinitions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentFlagsDefinitions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentFlagsDefinitions' from JSON`,
  );
}

/** @internal */
export const GetDeploymentFlags1$inboundSchema: z.ZodType<
  GetDeploymentFlags1,
  z.ZodTypeDef,
  unknown
> = z.object({
  definitions: z.record(
    z.lazy(() => GetDeploymentFlagsDefinitions$inboundSchema),
  ),
});
/** @internal */
export type GetDeploymentFlags1$Outbound = {
  definitions: { [k: string]: GetDeploymentFlagsDefinitions$Outbound };
};

/** @internal */
export const GetDeploymentFlags1$outboundSchema: z.ZodType<
  GetDeploymentFlags1$Outbound,
  z.ZodTypeDef,
  GetDeploymentFlags1
> = z.object({
  definitions: z.record(
    z.lazy(() => GetDeploymentFlagsDefinitions$outboundSchema),
  ),
});

export function getDeploymentFlags1ToJSON(
  getDeploymentFlags1: GetDeploymentFlags1,
): string {
  return JSON.stringify(
    GetDeploymentFlags1$outboundSchema.parse(getDeploymentFlags1),
  );
}
export function getDeploymentFlags1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentFlags1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentFlags1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentFlags1' from JSON`,
  );
}

/** @internal */
export const ResponseBodyFlags$inboundSchema: z.ZodType<
  ResponseBodyFlags,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GetDeploymentFlags1$inboundSchema),
  z.array(z.lazy(() => GetDeploymentFlags2$inboundSchema)),
]);
/** @internal */
export type ResponseBodyFlags$Outbound =
  | GetDeploymentFlags1$Outbound
  | Array<GetDeploymentFlags2$Outbound>;

/** @internal */
export const ResponseBodyFlags$outboundSchema: z.ZodType<
  ResponseBodyFlags$Outbound,
  z.ZodTypeDef,
  ResponseBodyFlags
> = smartUnion([
  z.lazy(() => GetDeploymentFlags1$outboundSchema),
  z.array(z.lazy(() => GetDeploymentFlags2$outboundSchema)),
]);

export function responseBodyFlagsToJSON(
  responseBodyFlags: ResponseBodyFlags,
): string {
  return JSON.stringify(
    ResponseBodyFlags$outboundSchema.parse(responseBodyFlags),
  );
}
export function responseBodyFlagsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyFlags, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyFlags$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyFlags' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMicrofrontendsMfeConfigUploadState$inboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentMicrofrontendsMfeConfigUploadState> = z
    .nativeEnum(GetDeploymentMicrofrontendsMfeConfigUploadState);
/** @internal */
export const GetDeploymentMicrofrontendsMfeConfigUploadState$outboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentMicrofrontendsMfeConfigUploadState> =
    GetDeploymentMicrofrontendsMfeConfigUploadState$inboundSchema;

/** @internal */
export const GetDeploymentMicrofrontends2$inboundSchema: z.ZodType<
  GetDeploymentMicrofrontends2,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: types.boolean(),
  mfeConfigUploadState: types.optional(
    GetDeploymentMicrofrontendsMfeConfigUploadState$inboundSchema,
  ),
  defaultAppProjectName: types.string(),
  defaultRoute: types.optional(types.string()),
  groupIds: z.array(types.string()),
});
/** @internal */
export type GetDeploymentMicrofrontends2$Outbound = {
  isDefaultApp: boolean;
  mfeConfigUploadState?: string | undefined;
  defaultAppProjectName: string;
  defaultRoute?: string | undefined;
  groupIds: Array<string>;
};

/** @internal */
export const GetDeploymentMicrofrontends2$outboundSchema: z.ZodType<
  GetDeploymentMicrofrontends2$Outbound,
  z.ZodTypeDef,
  GetDeploymentMicrofrontends2
> = z.object({
  isDefaultApp: z.boolean(),
  mfeConfigUploadState:
    GetDeploymentMicrofrontendsMfeConfigUploadState$outboundSchema.optional(),
  defaultAppProjectName: z.string(),
  defaultRoute: z.string().optional(),
  groupIds: z.array(z.string()),
});

export function getDeploymentMicrofrontends2ToJSON(
  getDeploymentMicrofrontends2: GetDeploymentMicrofrontends2,
): string {
  return JSON.stringify(
    GetDeploymentMicrofrontends2$outboundSchema.parse(
      getDeploymentMicrofrontends2,
    ),
  );
}
export function getDeploymentMicrofrontends2FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMicrofrontends2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentMicrofrontends2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMicrofrontends2' from JSON`,
  );
}

/** @internal */
export const GetDeploymentMicrofrontends1$inboundSchema: z.ZodType<
  GetDeploymentMicrofrontends1,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: types.optional(types.boolean()),
  defaultAppProjectName: types.string(),
  defaultRoute: types.optional(types.string()),
  groupIds: z.array(types.string()),
});
/** @internal */
export type GetDeploymentMicrofrontends1$Outbound = {
  isDefaultApp?: boolean | undefined;
  defaultAppProjectName: string;
  defaultRoute?: string | undefined;
  groupIds: Array<string>;
};

/** @internal */
export const GetDeploymentMicrofrontends1$outboundSchema: z.ZodType<
  GetDeploymentMicrofrontends1$Outbound,
  z.ZodTypeDef,
  GetDeploymentMicrofrontends1
> = z.object({
  isDefaultApp: z.boolean().optional(),
  defaultAppProjectName: z.string(),
  defaultRoute: z.string().optional(),
  groupIds: z.array(z.string()),
});

export function getDeploymentMicrofrontends1ToJSON(
  getDeploymentMicrofrontends1: GetDeploymentMicrofrontends1,
): string {
  return JSON.stringify(
    GetDeploymentMicrofrontends1$outboundSchema.parse(
      getDeploymentMicrofrontends1,
    ),
  );
}
export function getDeploymentMicrofrontends1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentMicrofrontends1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentMicrofrontends1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentMicrofrontends1' from JSON`,
  );
}

/** @internal */
export const ResponseBodyMicrofrontends$inboundSchema: z.ZodType<
  ResponseBodyMicrofrontends,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GetDeploymentMicrofrontends2$inboundSchema),
  z.lazy(() => GetDeploymentMicrofrontends1$inboundSchema),
]);
/** @internal */
export type ResponseBodyMicrofrontends$Outbound =
  | GetDeploymentMicrofrontends2$Outbound
  | GetDeploymentMicrofrontends1$Outbound;

/** @internal */
export const ResponseBodyMicrofrontends$outboundSchema: z.ZodType<
  ResponseBodyMicrofrontends$Outbound,
  z.ZodTypeDef,
  ResponseBodyMicrofrontends
> = smartUnion([
  z.lazy(() => GetDeploymentMicrofrontends2$outboundSchema),
  z.lazy(() => GetDeploymentMicrofrontends1$outboundSchema),
]);

export function responseBodyMicrofrontendsToJSON(
  responseBodyMicrofrontends: ResponseBodyMicrofrontends,
): string {
  return JSON.stringify(
    ResponseBodyMicrofrontends$outboundSchema.parse(responseBodyMicrofrontends),
  );
}
export function responseBodyMicrofrontendsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMicrofrontends, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMicrofrontends$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMicrofrontends' from JSON`,
  );
}

/** @internal */
export const ResponseBodyFunctionType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyFunctionType
> = z.nativeEnum(ResponseBodyFunctionType);
/** @internal */
export const ResponseBodyFunctionType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyFunctionType
> = ResponseBodyFunctionType$inboundSchema;

/** @internal */
export const ResponseBodyFunctionMemoryType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyFunctionMemoryType
> = z.nativeEnum(ResponseBodyFunctionMemoryType);
/** @internal */
export const ResponseBodyFunctionMemoryType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyFunctionMemoryType
> = ResponseBodyFunctionMemoryType$inboundSchema;

/** @internal */
export const GetDeploymentResponseBodyConfiguration$inboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentResponseBodyConfiguration> = z.nativeEnum(
    GetDeploymentResponseBodyConfiguration,
  );
/** @internal */
export const GetDeploymentResponseBodyConfiguration$outboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentResponseBodyConfiguration> =
    GetDeploymentResponseBodyConfiguration$inboundSchema;

/** @internal */
export const GetDeploymentResponseBodyBuildQueue$inboundSchema: z.ZodType<
  GetDeploymentResponseBodyBuildQueue,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: types.optional(
    GetDeploymentResponseBodyConfiguration$inboundSchema,
  ),
});
/** @internal */
export type GetDeploymentResponseBodyBuildQueue$Outbound = {
  configuration?: string | undefined;
};

/** @internal */
export const GetDeploymentResponseBodyBuildQueue$outboundSchema: z.ZodType<
  GetDeploymentResponseBodyBuildQueue$Outbound,
  z.ZodTypeDef,
  GetDeploymentResponseBodyBuildQueue
> = z.object({
  configuration: GetDeploymentResponseBodyConfiguration$outboundSchema
    .optional(),
});

export function getDeploymentResponseBodyBuildQueueToJSON(
  getDeploymentResponseBodyBuildQueue: GetDeploymentResponseBodyBuildQueue,
): string {
  return JSON.stringify(
    GetDeploymentResponseBodyBuildQueue$outboundSchema.parse(
      getDeploymentResponseBodyBuildQueue,
    ),
  );
}
export function getDeploymentResponseBodyBuildQueueFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentResponseBodyBuildQueue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentResponseBodyBuildQueue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentResponseBodyBuildQueue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyElasticConcurrency$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyElasticConcurrency
> = z.nativeEnum(ResponseBodyElasticConcurrency);
/** @internal */
export const ResponseBodyElasticConcurrency$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyElasticConcurrency
> = ResponseBodyElasticConcurrency$inboundSchema;

/** @internal */
export const ResponseBodyPurchaseType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyPurchaseType
> = z.nativeEnum(ResponseBodyPurchaseType);
/** @internal */
export const ResponseBodyPurchaseType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyPurchaseType
> = ResponseBodyPurchaseType$inboundSchema;

/** @internal */
export const ResponseBodyBuildMachine$inboundSchema: z.ZodType<
  ResponseBodyBuildMachine,
  z.ZodTypeDef,
  unknown
> = z.object({
  purchaseType: z.nullable(ResponseBodyPurchaseType$inboundSchema).optional(),
});
/** @internal */
export type ResponseBodyBuildMachine$Outbound = {
  purchaseType?: string | null | undefined;
};

/** @internal */
export const ResponseBodyBuildMachine$outboundSchema: z.ZodType<
  ResponseBodyBuildMachine$Outbound,
  z.ZodTypeDef,
  ResponseBodyBuildMachine
> = z.object({
  purchaseType: z.nullable(ResponseBodyPurchaseType$outboundSchema).optional(),
});

export function responseBodyBuildMachineToJSON(
  responseBodyBuildMachine: ResponseBodyBuildMachine,
): string {
  return JSON.stringify(
    ResponseBodyBuildMachine$outboundSchema.parse(responseBodyBuildMachine),
  );
}
export function responseBodyBuildMachineFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBuildMachine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBuildMachine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBuildMachine' from JSON`,
  );
}

/** @internal */
export const GetDeploymentResponseBodyResourceConfig$inboundSchema: z.ZodType<
  GetDeploymentResponseBodyResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  buildQueue: types.optional(
    z.lazy(() => GetDeploymentResponseBodyBuildQueue$inboundSchema),
  ),
  elasticConcurrency: types.optional(
    ResponseBodyElasticConcurrency$inboundSchema,
  ),
  buildMachine: types.optional(
    z.lazy(() => ResponseBodyBuildMachine$inboundSchema),
  ),
});
/** @internal */
export type GetDeploymentResponseBodyResourceConfig$Outbound = {
  buildQueue?: GetDeploymentResponseBodyBuildQueue$Outbound | undefined;
  elasticConcurrency?: string | undefined;
  buildMachine?: ResponseBodyBuildMachine$Outbound | undefined;
};

/** @internal */
export const GetDeploymentResponseBodyResourceConfig$outboundSchema: z.ZodType<
  GetDeploymentResponseBodyResourceConfig$Outbound,
  z.ZodTypeDef,
  GetDeploymentResponseBodyResourceConfig
> = z.object({
  buildQueue: z.lazy(() => GetDeploymentResponseBodyBuildQueue$outboundSchema)
    .optional(),
  elasticConcurrency: ResponseBodyElasticConcurrency$outboundSchema.optional(),
  buildMachine: z.lazy(() => ResponseBodyBuildMachine$outboundSchema)
    .optional(),
});

export function getDeploymentResponseBodyResourceConfigToJSON(
  getDeploymentResponseBodyResourceConfig:
    GetDeploymentResponseBodyResourceConfig,
): string {
  return JSON.stringify(
    GetDeploymentResponseBodyResourceConfig$outboundSchema.parse(
      getDeploymentResponseBodyResourceConfig,
    ),
  );
}
export function getDeploymentResponseBodyResourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  GetDeploymentResponseBodyResourceConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetDeploymentResponseBodyResourceConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetDeploymentResponseBodyResourceConfig' from JSON`,
  );
}

/** @internal */
export const ResponseBodyConfig$inboundSchema: z.ZodType<
  ResponseBodyConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  version: types.optional(types.number()),
  functionType: ResponseBodyFunctionType$inboundSchema,
  functionMemoryType: ResponseBodyFunctionMemoryType$inboundSchema,
  functionTimeout: types.nullable(types.number()),
  secureComputePrimaryRegion: types.nullable(types.string()),
  secureComputeFallbackRegion: types.nullable(types.string()),
  isUsingActiveCPU: types.optional(types.boolean()),
  resourceConfig: types.optional(
    z.lazy(() => GetDeploymentResponseBodyResourceConfig$inboundSchema),
  ),
});
/** @internal */
export type ResponseBodyConfig$Outbound = {
  version?: number | undefined;
  functionType: string;
  functionMemoryType: string;
  functionTimeout: number | null;
  secureComputePrimaryRegion: string | null;
  secureComputeFallbackRegion: string | null;
  isUsingActiveCPU?: boolean | undefined;
  resourceConfig?: GetDeploymentResponseBodyResourceConfig$Outbound | undefined;
};

/** @internal */
export const ResponseBodyConfig$outboundSchema: z.ZodType<
  ResponseBodyConfig$Outbound,
  z.ZodTypeDef,
  ResponseBodyConfig
> = z.object({
  version: z.number().optional(),
  functionType: ResponseBodyFunctionType$outboundSchema,
  functionMemoryType: ResponseBodyFunctionMemoryType$outboundSchema,
  functionTimeout: z.nullable(z.number()),
  secureComputePrimaryRegion: z.nullable(z.string()),
  secureComputeFallbackRegion: z.nullable(z.string()),
  isUsingActiveCPU: z.boolean().optional(),
  resourceConfig: z.lazy(() =>
    GetDeploymentResponseBodyResourceConfig$outboundSchema
  ).optional(),
});

export function responseBodyConfigToJSON(
  responseBodyConfig: ResponseBodyConfig,
): string {
  return JSON.stringify(
    ResponseBodyConfig$outboundSchema.parse(responseBodyConfig),
  );
}
export function responseBodyConfigFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyConfig' from JSON`,
  );
}

/** @internal */
export const GetDeploymentResponseBodyDeploymentsState$inboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentResponseBodyDeploymentsState> = z
    .nativeEnum(GetDeploymentResponseBodyDeploymentsState);
/** @internal */
export const GetDeploymentResponseBodyDeploymentsState$outboundSchema:
  z.ZodNativeEnum<typeof GetDeploymentResponseBodyDeploymentsState> =
    GetDeploymentResponseBodyDeploymentsState$inboundSchema;

/** @internal */
export const ResponseBodyDeploymentAlias$inboundSchema: z.ZodType<
  ResponseBodyDeploymentAlias,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: GetDeploymentResponseBodyDeploymentsState$inboundSchema,
  startedAt: types.number(),
  completedAt: types.optional(types.number()),
});
/** @internal */
export type ResponseBodyDeploymentAlias$Outbound = {
  state: string;
  startedAt: number;
  completedAt?: number | undefined;
};

/** @internal */
export const ResponseBodyDeploymentAlias$outboundSchema: z.ZodType<
  ResponseBodyDeploymentAlias$Outbound,
  z.ZodTypeDef,
  ResponseBodyDeploymentAlias
> = z.object({
  state: GetDeploymentResponseBodyDeploymentsState$outboundSchema,
  startedAt: z.number(),
  completedAt: z.number().optional(),
});

export function responseBodyDeploymentAliasToJSON(
  responseBodyDeploymentAlias: ResponseBodyDeploymentAlias,
): string {
  return JSON.stringify(
    ResponseBodyDeploymentAlias$outboundSchema.parse(
      responseBodyDeploymentAlias,
    ),
  );
}
export function responseBodyDeploymentAliasFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDeploymentAlias, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDeploymentAlias$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDeploymentAlias' from JSON`,
  );
}

/** @internal */
export const ResponseBodyChecks$inboundSchema: z.ZodType<
  ResponseBodyChecks,
  z.ZodTypeDef,
  unknown
> = z.object({
  "deployment-alias": z.lazy(() => ResponseBodyDeploymentAlias$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "deployment-alias": "deploymentAlias",
  });
});
/** @internal */
export type ResponseBodyChecks$Outbound = {
  "deployment-alias": ResponseBodyDeploymentAlias$Outbound;
};

/** @internal */
export const ResponseBodyChecks$outboundSchema: z.ZodType<
  ResponseBodyChecks$Outbound,
  z.ZodTypeDef,
  ResponseBodyChecks
> = z.object({
  deploymentAlias: z.lazy(() => ResponseBodyDeploymentAlias$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    deploymentAlias: "deployment-alias",
  });
});

export function responseBodyChecksToJSON(
  responseBodyChecks: ResponseBodyChecks,
): string {
  return JSON.stringify(
    ResponseBodyChecks$outboundSchema.parse(responseBodyChecks),
  );
}
export function responseBodyChecksFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyChecks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyChecks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyChecks' from JSON`,
  );
}

/** @internal */
export const ResponseBodyBlockCode$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyBlockCode
> = z.nativeEnum(ResponseBodyBlockCode);
/** @internal */
export const ResponseBodyBlockCode$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyBlockCode
> = ResponseBodyBlockCode$inboundSchema;

/** @internal */
export const ResponseBodySeatBlock$inboundSchema: z.ZodType<
  ResponseBodySeatBlock,
  z.ZodTypeDef,
  unknown
> = z.object({
  blockCode: ResponseBodyBlockCode$inboundSchema,
  userId: types.optional(types.string()),
});
/** @internal */
export type ResponseBodySeatBlock$Outbound = {
  blockCode: string;
  userId?: string | undefined;
};

/** @internal */
export const ResponseBodySeatBlock$outboundSchema: z.ZodType<
  ResponseBodySeatBlock$Outbound,
  z.ZodTypeDef,
  ResponseBodySeatBlock
> = z.object({
  blockCode: ResponseBodyBlockCode$outboundSchema,
  userId: z.string().optional(),
});

export function responseBodySeatBlockToJSON(
  responseBodySeatBlock: ResponseBodySeatBlock,
): string {
  return JSON.stringify(
    ResponseBodySeatBlock$outboundSchema.parse(responseBodySeatBlock),
  );
}
export function responseBodySeatBlockFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySeatBlock, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySeatBlock$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySeatBlock' from JSON`,
  );
}

/** @internal */
export const GetDeploymentResponseBody1$inboundSchema: z.ZodType<
  GetDeploymentResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  aliasAssignedAt: z.nullable(ResponseBodyAliasAssignedAt$inboundSchema)
    .optional(),
  alwaysRefuseToBuild: types.optional(types.boolean()),
  build: ResponseBodyBuild$inboundSchema,
  buildArtifactUrls: types.optional(z.array(types.string())),
  builds: types.optional(z.array(ResponseBodyBuilds$inboundSchema)),
  env: z.array(types.string()),
  inspectorUrl: types.nullable(types.string()),
  isInConcurrentBuildsQueue: types.boolean(),
  isInSystemBuildsQueue: types.boolean(),
  projectSettings: ResponseBodyProjectSettings$inboundSchema,
  readyStateReason: types.optional(types.string()),
  integrations: types.optional(ResponseBodyIntegrations$inboundSchema),
  images: types.optional(ResponseBodyImages$inboundSchema),
  alias: types.optional(z.array(types.string())),
  aliasAssigned: types.boolean(),
  bootedAt: types.number(),
  buildingAt: types.number(),
  buildContainerFinishedAt: types.optional(types.number()),
  buildSkipped: types.boolean(),
  creator: GetDeploymentResponseBodyCreator$inboundSchema,
  initReadyAt: types.optional(types.number()),
  isFirstBranchDeployment: types.optional(types.boolean()),
  lambdas: types.optional(
    z.array(GetDeploymentResponseBodyLambdas$inboundSchema),
  ),
  public: types.boolean(),
  ready: types.optional(types.number()),
  status: ResponseBodyStatus$inboundSchema,
  team: types.optional(GetDeploymentResponseBodyTeam$inboundSchema),
  userAliases: types.optional(z.array(types.string())),
  previewCommentsEnabled: types.optional(types.boolean()),
  ttyBuildLogs: types.optional(types.boolean()),
  customEnvironment: types.optional(
    GetDeploymentResponseBodyCustomEnvironment$inboundSchema,
  ),
  oomReport: types.optional(GetDeploymentResponseBodyOomReport$inboundSchema),
  aliasWarning: z.nullable(GetDeploymentResponseBodyAliasWarning$inboundSchema)
    .optional(),
  id: types.string(),
  createdAt: types.number(),
  readyState: GetDeploymentResponseBodyReadyState$inboundSchema,
  name: types.string(),
  type: GetDeploymentResponseBodyType$inboundSchema,
  aliasError: z.nullable(GetDeploymentResponseBodyAliasError$inboundSchema)
    .optional(),
  aliasFinal: z.nullable(types.string()).optional(),
  autoAssignCustomDomains: types.optional(types.boolean()),
  automaticAliases: types.optional(z.array(types.string())),
  buildErrorAt: types.optional(types.number()),
  checksState: types.optional(
    GetDeploymentResponseBodyChecksState$inboundSchema,
  ),
  checksConclusion: types.optional(
    GetDeploymentResponseBodyChecksConclusion$inboundSchema,
  ),
  deletedAt: z.nullable(types.number()).optional(),
  defaultRoute: types.optional(types.string()),
  canceledAt: types.optional(types.number()),
  errorCode: types.optional(types.string()),
  errorLink: types.optional(types.string()),
  errorMessage: z.nullable(types.string()).optional(),
  errorStep: types.optional(types.string()),
  passiveRegions: types.optional(z.array(types.string())),
  gitSource: types.optional(GetDeploymentResponseBodyGitSource$inboundSchema),
  manualProvisioning: types.optional(
    GetDeploymentResponseBodyManualProvisioning$inboundSchema,
  ),
  meta: z.record(types.string()),
  originCacheRegion: types.optional(types.string()),
  nodeVersion: types.optional(
    GetDeploymentResponseBodyNodeVersion$inboundSchema,
  ),
  project: types.optional(ResponseBodyProject$inboundSchema),
  prebuilt: types.optional(types.boolean()),
  readySubstate: types.optional(
    GetDeploymentResponseBodyReadySubstate$inboundSchema,
  ),
  regions: z.array(types.string()),
  softDeletedByRetention: types.optional(types.boolean()),
  source: types.optional(ResponseBodySource$inboundSchema),
  target: z.nullable(GetDeploymentResponseBodyTarget$inboundSchema).optional(),
  undeletedAt: types.optional(types.number()),
  url: types.string(),
  userConfiguredDeploymentId: types.optional(types.string()),
  version: types.number(),
  oidcTokenClaims: types.optional(
    GetDeploymentResponseBodyOidcTokenClaims$inboundSchema,
  ),
  projectId: types.string(),
  plan: ResponseBodyPlan$inboundSchema,
  platform: types.optional(z.lazy(() => ResponseBodyPlatform$inboundSchema)),
  connectBuildsEnabled: types.optional(types.boolean()),
  connectConfigurationId: types.optional(types.string()),
  createdIn: types.string(),
  crons: types.optional(z.array(z.lazy(() => ResponseBodyCrons$inboundSchema))),
  functions: z.nullable(
    z.record(z.lazy(() => ResponseBodyFunctions$inboundSchema)),
  ).optional(),
  monorepoManager: z.nullable(types.string()).optional(),
  ownerId: types.string(),
  passiveConnectConfigurationId: types.optional(types.string()),
  routes: types.nullable(
    z.array(smartUnion([
      z.lazy(() => GetDeploymentRoutes3$inboundSchema),
      z.lazy(() =>
        GetDeploymentRoutes1$inboundSchema
      ),
      z.lazy(() => GetDeploymentRoutes2$inboundSchema),
    ])),
  ),
  gitRepo: z.nullable(
    z.union([
      z.lazy(() => GetDeploymentGitRepo1$inboundSchema),
      z.lazy(() => GetDeploymentGitRepo2$inboundSchema),
      z.lazy(() => GetDeploymentGitRepo3$inboundSchema),
    ]),
  ).optional(),
  flags: types.optional(
    smartUnion([
      z.lazy(() => GetDeploymentFlags1$inboundSchema),
      z.array(z.lazy(() => GetDeploymentFlags2$inboundSchema)),
    ]),
  ),
  microfrontends: types.optional(
    smartUnion([
      z.lazy(() => GetDeploymentMicrofrontends2$inboundSchema),
      z.lazy(() => GetDeploymentMicrofrontends1$inboundSchema),
    ]),
  ),
  config: types.optional(z.lazy(() => ResponseBodyConfig$inboundSchema)),
  checks: types.optional(z.lazy(() => ResponseBodyChecks$inboundSchema)),
  seatBlock: types.optional(z.lazy(() => ResponseBodySeatBlock$inboundSchema)),
});
/** @internal */
export type GetDeploymentResponseBody1$Outbound = {
  aliasAssignedAt?: ResponseBodyAliasAssignedAt$Outbound | null | undefined;
  alwaysRefuseToBuild?: boolean | undefined;
  build: ResponseBodyBuild$Outbound;
  buildArtifactUrls?: Array<string> | undefined;
  builds?: Array<ResponseBodyBuilds$Outbound> | undefined;
  env: Array<string>;
  inspectorUrl: string | null;
  isInConcurrentBuildsQueue: boolean;
  isInSystemBuildsQueue: boolean;
  projectSettings: ResponseBodyProjectSettings$Outbound;
  readyStateReason?: string | undefined;
  integrations?: ResponseBodyIntegrations$Outbound | undefined;
  images?: ResponseBodyImages$Outbound | undefined;
  alias?: Array<string> | undefined;
  aliasAssigned: boolean;
  bootedAt: number;
  buildingAt: number;
  buildContainerFinishedAt?: number | undefined;
  buildSkipped: boolean;
  creator: GetDeploymentResponseBodyCreator$Outbound;
  initReadyAt?: number | undefined;
  isFirstBranchDeployment?: boolean | undefined;
  lambdas?: Array<GetDeploymentResponseBodyLambdas$Outbound> | undefined;
  public: boolean;
  ready?: number | undefined;
  status: string;
  team?: GetDeploymentResponseBodyTeam$Outbound | undefined;
  userAliases?: Array<string> | undefined;
  previewCommentsEnabled?: boolean | undefined;
  ttyBuildLogs?: boolean | undefined;
  customEnvironment?:
    | GetDeploymentResponseBodyCustomEnvironment$Outbound
    | undefined;
  oomReport?: string | undefined;
  aliasWarning?:
    | GetDeploymentResponseBodyAliasWarning$Outbound
    | null
    | undefined;
  id: string;
  createdAt: number;
  readyState: string;
  name: string;
  type: string;
  aliasError?: GetDeploymentResponseBodyAliasError$Outbound | null | undefined;
  aliasFinal?: string | null | undefined;
  autoAssignCustomDomains?: boolean | undefined;
  automaticAliases?: Array<string> | undefined;
  buildErrorAt?: number | undefined;
  checksState?: string | undefined;
  checksConclusion?: string | undefined;
  deletedAt?: number | null | undefined;
  defaultRoute?: string | undefined;
  canceledAt?: number | undefined;
  errorCode?: string | undefined;
  errorLink?: string | undefined;
  errorMessage?: string | null | undefined;
  errorStep?: string | undefined;
  passiveRegions?: Array<string> | undefined;
  gitSource?: GetDeploymentResponseBodyGitSource$Outbound | undefined;
  manualProvisioning?:
    | GetDeploymentResponseBodyManualProvisioning$Outbound
    | undefined;
  meta: { [k: string]: string };
  originCacheRegion?: string | undefined;
  nodeVersion?: string | undefined;
  project?: ResponseBodyProject$Outbound | undefined;
  prebuilt?: boolean | undefined;
  readySubstate?: string | undefined;
  regions: Array<string>;
  softDeletedByRetention?: boolean | undefined;
  source?: string | undefined;
  target?: string | null | undefined;
  undeletedAt?: number | undefined;
  url: string;
  userConfiguredDeploymentId?: string | undefined;
  version: number;
  oidcTokenClaims?:
    | GetDeploymentResponseBodyOidcTokenClaims$Outbound
    | undefined;
  projectId: string;
  plan: string;
  platform?: ResponseBodyPlatform$Outbound | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdIn: string;
  crons?: Array<ResponseBodyCrons$Outbound> | undefined;
  functions?:
    | { [k: string]: ResponseBodyFunctions$Outbound }
    | null
    | undefined;
  monorepoManager?: string | null | undefined;
  ownerId: string;
  passiveConnectConfigurationId?: string | undefined;
  routes:
    | Array<
      | GetDeploymentRoutes3$Outbound
      | GetDeploymentRoutes1$Outbound
      | GetDeploymentRoutes2$Outbound
    >
    | null;
  gitRepo?:
    | GetDeploymentGitRepo1$Outbound
    | GetDeploymentGitRepo2$Outbound
    | GetDeploymentGitRepo3$Outbound
    | null
    | undefined;
  flags?:
    | GetDeploymentFlags1$Outbound
    | Array<GetDeploymentFlags2$Outbound>
    | undefined;
  microfrontends?:
    | GetDeploymentMicrofrontends2$Outbound
    | GetDeploymentMicrofrontends1$Outbound
    | undefined;
  config?: ResponseBodyConfig$Outbound | undefined;
  checks?: ResponseBodyChecks$Outbound | undefined;
  seatBlock?: ResponseBodySeatBlock$Outbound | undefined;
};

/** @internal */
export const GetDeploymentResponseBody1$outboundSchema: z.ZodType<
  GetDeploymentResponseBody1$Outbound,
  z.ZodTypeDef,
  GetDeploymentResponseBody1
> = z.object({
  aliasAssignedAt: z.nullable(ResponseBodyAliasAssignedAt$outboundSchema)
    .optional(),
  alwaysRefuseToBuild: z.boolean().optional(),
  build: ResponseBodyBuild$outboundSchema,
  buildArtifactUrls: z.array(z.string()).optional(),
  builds: z.array(ResponseBodyBuilds$outboundSchema).optional(),
  env: z.array(z.string()),
  inspectorUrl: z.nullable(z.string()),
  isInConcurrentBuildsQueue: z.boolean(),
  isInSystemBuildsQueue: z.boolean(),
  projectSettings: ResponseBodyProjectSettings$outboundSchema,
  readyStateReason: z.string().optional(),
  integrations: ResponseBodyIntegrations$outboundSchema.optional(),
  images: ResponseBodyImages$outboundSchema.optional(),
  alias: z.array(z.string()).optional(),
  aliasAssigned: z.boolean(),
  bootedAt: z.number(),
  buildingAt: z.number(),
  buildContainerFinishedAt: z.number().optional(),
  buildSkipped: z.boolean(),
  creator: GetDeploymentResponseBodyCreator$outboundSchema,
  initReadyAt: z.number().optional(),
  isFirstBranchDeployment: z.boolean().optional(),
  lambdas: z.array(GetDeploymentResponseBodyLambdas$outboundSchema).optional(),
  public: z.boolean(),
  ready: z.number().optional(),
  status: ResponseBodyStatus$outboundSchema,
  team: GetDeploymentResponseBodyTeam$outboundSchema.optional(),
  userAliases: z.array(z.string()).optional(),
  previewCommentsEnabled: z.boolean().optional(),
  ttyBuildLogs: z.boolean().optional(),
  customEnvironment: GetDeploymentResponseBodyCustomEnvironment$outboundSchema
    .optional(),
  oomReport: GetDeploymentResponseBodyOomReport$outboundSchema.optional(),
  aliasWarning: z.nullable(GetDeploymentResponseBodyAliasWarning$outboundSchema)
    .optional(),
  id: z.string(),
  createdAt: z.number(),
  readyState: GetDeploymentResponseBodyReadyState$outboundSchema,
  name: z.string(),
  type: GetDeploymentResponseBodyType$outboundSchema,
  aliasError: z.nullable(GetDeploymentResponseBodyAliasError$outboundSchema)
    .optional(),
  aliasFinal: z.nullable(z.string()).optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  automaticAliases: z.array(z.string()).optional(),
  buildErrorAt: z.number().optional(),
  checksState: GetDeploymentResponseBodyChecksState$outboundSchema.optional(),
  checksConclusion: GetDeploymentResponseBodyChecksConclusion$outboundSchema
    .optional(),
  deletedAt: z.nullable(z.number()).optional(),
  defaultRoute: z.string().optional(),
  canceledAt: z.number().optional(),
  errorCode: z.string().optional(),
  errorLink: z.string().optional(),
  errorMessage: z.nullable(z.string()).optional(),
  errorStep: z.string().optional(),
  passiveRegions: z.array(z.string()).optional(),
  gitSource: GetDeploymentResponseBodyGitSource$outboundSchema.optional(),
  manualProvisioning: GetDeploymentResponseBodyManualProvisioning$outboundSchema
    .optional(),
  meta: z.record(z.string()),
  originCacheRegion: z.string().optional(),
  nodeVersion: GetDeploymentResponseBodyNodeVersion$outboundSchema.optional(),
  project: ResponseBodyProject$outboundSchema.optional(),
  prebuilt: z.boolean().optional(),
  readySubstate: GetDeploymentResponseBodyReadySubstate$outboundSchema
    .optional(),
  regions: z.array(z.string()),
  softDeletedByRetention: z.boolean().optional(),
  source: ResponseBodySource$outboundSchema.optional(),
  target: z.nullable(GetDeploymentResponseBodyTarget$outboundSchema).optional(),
  undeletedAt: z.number().optional(),
  url: z.string(),
  userConfiguredDeploymentId: z.string().optional(),
  version: z.number(),
  oidcTokenClaims: GetDeploymentResponseBodyOidcTokenClaims$outboundSchema
    .optional(),
  projectId: z.string(),
  plan: ResponseBodyPlan$outboundSchema,
  platform: z.lazy(() => ResponseBodyPlatform$outboundSchema).optional(),
  connectBuildsEnabled: z.boolean().optional(),
  connectConfigurationId: z.string().optional(),
  createdIn: z.string(),
  crons: z.array(z.lazy(() => ResponseBodyCrons$outboundSchema)).optional(),
  functions: z.nullable(
    z.record(z.lazy(() => ResponseBodyFunctions$outboundSchema)),
  ).optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  ownerId: z.string(),
  passiveConnectConfigurationId: z.string().optional(),
  routes: z.nullable(
    z.array(smartUnion([
      z.lazy(() => GetDeploymentRoutes3$outboundSchema),
      z.lazy(() =>
        GetDeploymentRoutes1$outboundSchema
      ),
      z.lazy(() => GetDeploymentRoutes2$outboundSchema),
    ])),
  ),
  gitRepo: z.nullable(
    z.union([
      z.lazy(() => GetDeploymentGitRepo1$outboundSchema),
      z.lazy(() => GetDeploymentGitRepo2$outboundSchema),
      z.lazy(() => GetDeploymentGitRepo3$outboundSchema),
    ]),
  ).optional(),
  flags: smartUnion([
    z.lazy(() => GetDeploymentFlags1$outboundSchema),
    z.array(z.lazy(() => GetDeploymentFlags2$outboundSchema)),
  ]).optional(),
  microfrontends: smartUnion([
    z.lazy(() => GetDeploymentMicrofrontends2$outboundSchema),
    z.lazy(() => GetDeploymentMicrofrontends1$outboundSchema),
  ]).optional(),
  config: z.lazy(() => ResponseBodyConfig$outboundSchema).optional(),
  checks: z.lazy(() => ResponseBodyChecks$outboundSchema).optional(),
  seatBlock: z.lazy(() => ResponseBodySeatBlock$outboundSchema).optional(),
});

export function getDeploymentResponseBody1ToJSON(
  getDeploymentResponseBody1: GetDeploymentResponseBody1,
): string {
  return JSON.stringify(
    GetDeploymentResponseBody1$outboundSchema.parse(getDeploymentResponseBody1),
  );
}
export function getDeploymentResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentResponseBody1' from JSON`,
  );
}

/** @internal */
export const GetDeploymentResponseBody$inboundSchema: z.ZodType<
  GetDeploymentResponseBody,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => GetDeploymentResponseBody1$inboundSchema),
  GetDeploymentResponseBody2$inboundSchema,
]);
/** @internal */
export type GetDeploymentResponseBody$Outbound =
  | GetDeploymentResponseBody1$Outbound
  | GetDeploymentResponseBody2$Outbound;

/** @internal */
export const GetDeploymentResponseBody$outboundSchema: z.ZodType<
  GetDeploymentResponseBody$Outbound,
  z.ZodTypeDef,
  GetDeploymentResponseBody
> = smartUnion([
  z.lazy(() => GetDeploymentResponseBody1$outboundSchema),
  GetDeploymentResponseBody2$outboundSchema,
]);

export function getDeploymentResponseBodyToJSON(
  getDeploymentResponseBody: GetDeploymentResponseBody,
): string {
  return JSON.stringify(
    GetDeploymentResponseBody$outboundSchema.parse(getDeploymentResponseBody),
  );
}
export function getDeploymentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetDeploymentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetDeploymentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetDeploymentResponseBody' from JSON`,
  );
}
