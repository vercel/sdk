/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const QueryParam2 = {
  Only: "only",
} as const;
export type QueryParam2 = ClosedEnum<typeof QueryParam2>;

export type Diff = boolean | QueryParam2;

export const SortBy = {
  Source: "source",
  Destination: "destination",
  StatusCode: "statusCode",
} as const;
export type SortBy = ClosedEnum<typeof SortBy>;

export const SortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
export type SortOrder = ClosedEnum<typeof SortOrder>;

export type GetRedirectsRequest = {
  projectId: string;
  versionId?: string | undefined;
  q?: string | undefined;
  diff?: boolean | QueryParam2 | undefined;
  page?: number | undefined;
  perPage?: number | undefined;
  sortBy?: SortBy | undefined;
  sortOrder?: SortOrder | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

export type ResponseBodyRedirects = {
  statusCode?: number | undefined;
  permanent?: boolean | undefined;
  sensitive?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  destination: string;
  source: string;
};

export type ResponseBodyVersion = {
  /**
   * The unique identifier for the version.
   */
  id: string;
  /**
   * The key of the version. The key may be duplicated across versions if the contents are the same as a different version.
   */
  key: string;
  lastModified: number;
  createdBy: string;
  /**
   * Optional name for the version. If not provided, defaults to an ISO timestamp string.
   */
  name?: string | undefined;
  /**
   * Whether this version has not been promoted to production yet and is not serving end users.
   */
  isStaging?: boolean | undefined;
  /**
   * Whether this version is currently live in production.
   */
  isLive?: boolean | undefined;
  /**
   * The number of redirects in this version.
   */
  redirectCount?: number | undefined;
  /**
   * The staging link for previewing redirects in this version.
   */
  alias?: string | undefined;
};

export type GetRedirectsResponseBodyPagination = {
  page: number;
  perPage: number;
  numPages: number;
};

export type GetRedirectsResponseBody2 = {
  redirects: Array<ResponseBodyRedirects>;
  version?: ResponseBodyVersion | undefined;
  pagination: GetRedirectsResponseBodyPagination;
};

export type GetRedirectsResponseBody = GetRedirectsResponseBody2 | {
  [k: string]: any;
};

/** @internal */
export const QueryParam2$inboundSchema: z.ZodNativeEnum<typeof QueryParam2> = z
  .nativeEnum(QueryParam2);
/** @internal */
export const QueryParam2$outboundSchema: z.ZodNativeEnum<typeof QueryParam2> =
  QueryParam2$inboundSchema;

/** @internal */
export const Diff$inboundSchema: z.ZodType<Diff, z.ZodTypeDef, unknown> = z
  .union([z.boolean(), QueryParam2$inboundSchema]);
/** @internal */
export type Diff$Outbound = boolean | string;

/** @internal */
export const Diff$outboundSchema: z.ZodType<Diff$Outbound, z.ZodTypeDef, Diff> =
  z.union([z.boolean(), QueryParam2$outboundSchema]);

export function diffToJSON(diff: Diff): string {
  return JSON.stringify(Diff$outboundSchema.parse(diff));
}
export function diffFromJSON(
  jsonString: string,
): SafeParseResult<Diff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Diff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Diff' from JSON`,
  );
}

/** @internal */
export const SortBy$inboundSchema: z.ZodNativeEnum<typeof SortBy> = z
  .nativeEnum(SortBy);
/** @internal */
export const SortBy$outboundSchema: z.ZodNativeEnum<typeof SortBy> =
  SortBy$inboundSchema;

/** @internal */
export const SortOrder$inboundSchema: z.ZodNativeEnum<typeof SortOrder> = z
  .nativeEnum(SortOrder);
/** @internal */
export const SortOrder$outboundSchema: z.ZodNativeEnum<typeof SortOrder> =
  SortOrder$inboundSchema;

/** @internal */
export const GetRedirectsRequest$inboundSchema: z.ZodType<
  GetRedirectsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: z.string(),
  versionId: z.string().optional(),
  q: z.string().optional(),
  diff: z.union([z.boolean(), QueryParam2$inboundSchema]).optional(),
  page: z.number().int().optional(),
  per_page: z.number().int().optional(),
  sort_by: SortBy$inboundSchema.optional(),
  sort_order: SortOrder$inboundSchema.optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "per_page": "perPage",
    "sort_by": "sortBy",
    "sort_order": "sortOrder",
  });
});
/** @internal */
export type GetRedirectsRequest$Outbound = {
  projectId: string;
  versionId?: string | undefined;
  q?: string | undefined;
  diff?: boolean | string | undefined;
  page?: number | undefined;
  per_page?: number | undefined;
  sort_by?: string | undefined;
  sort_order?: string | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const GetRedirectsRequest$outboundSchema: z.ZodType<
  GetRedirectsRequest$Outbound,
  z.ZodTypeDef,
  GetRedirectsRequest
> = z.object({
  projectId: z.string(),
  versionId: z.string().optional(),
  q: z.string().optional(),
  diff: z.union([z.boolean(), QueryParam2$outboundSchema]).optional(),
  page: z.number().int().optional(),
  perPage: z.number().int().optional(),
  sortBy: SortBy$outboundSchema.optional(),
  sortOrder: SortOrder$outboundSchema.optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    perPage: "per_page",
    sortBy: "sort_by",
    sortOrder: "sort_order",
  });
});

export function getRedirectsRequestToJSON(
  getRedirectsRequest: GetRedirectsRequest,
): string {
  return JSON.stringify(
    GetRedirectsRequest$outboundSchema.parse(getRedirectsRequest),
  );
}
export function getRedirectsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetRedirectsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRedirectsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRedirectsRequest' from JSON`,
  );
}

/** @internal */
export const ResponseBodyRedirects$inboundSchema: z.ZodType<
  ResponseBodyRedirects,
  z.ZodTypeDef,
  unknown
> = z.object({
  statusCode: z.number().optional(),
  permanent: z.boolean().optional(),
  sensitive: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  query: z.boolean().optional(),
  destination: z.string(),
  source: z.string(),
});
/** @internal */
export type ResponseBodyRedirects$Outbound = {
  statusCode?: number | undefined;
  permanent?: boolean | undefined;
  sensitive?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  destination: string;
  source: string;
};

/** @internal */
export const ResponseBodyRedirects$outboundSchema: z.ZodType<
  ResponseBodyRedirects$Outbound,
  z.ZodTypeDef,
  ResponseBodyRedirects
> = z.object({
  statusCode: z.number().optional(),
  permanent: z.boolean().optional(),
  sensitive: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  query: z.boolean().optional(),
  destination: z.string(),
  source: z.string(),
});

export function responseBodyRedirectsToJSON(
  responseBodyRedirects: ResponseBodyRedirects,
): string {
  return JSON.stringify(
    ResponseBodyRedirects$outboundSchema.parse(responseBodyRedirects),
  );
}
export function responseBodyRedirectsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyRedirects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyRedirects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyRedirects' from JSON`,
  );
}

/** @internal */
export const ResponseBodyVersion$inboundSchema: z.ZodType<
  ResponseBodyVersion,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string(),
  lastModified: z.number(),
  createdBy: z.string(),
  name: z.string().optional(),
  isStaging: z.boolean().optional(),
  isLive: z.boolean().optional(),
  redirectCount: z.number().optional(),
  alias: z.string().optional(),
});
/** @internal */
export type ResponseBodyVersion$Outbound = {
  id: string;
  key: string;
  lastModified: number;
  createdBy: string;
  name?: string | undefined;
  isStaging?: boolean | undefined;
  isLive?: boolean | undefined;
  redirectCount?: number | undefined;
  alias?: string | undefined;
};

/** @internal */
export const ResponseBodyVersion$outboundSchema: z.ZodType<
  ResponseBodyVersion$Outbound,
  z.ZodTypeDef,
  ResponseBodyVersion
> = z.object({
  id: z.string(),
  key: z.string(),
  lastModified: z.number(),
  createdBy: z.string(),
  name: z.string().optional(),
  isStaging: z.boolean().optional(),
  isLive: z.boolean().optional(),
  redirectCount: z.number().optional(),
  alias: z.string().optional(),
});

export function responseBodyVersionToJSON(
  responseBodyVersion: ResponseBodyVersion,
): string {
  return JSON.stringify(
    ResponseBodyVersion$outboundSchema.parse(responseBodyVersion),
  );
}
export function responseBodyVersionFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyVersion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyVersion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyVersion' from JSON`,
  );
}

/** @internal */
export const GetRedirectsResponseBodyPagination$inboundSchema: z.ZodType<
  GetRedirectsResponseBodyPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  page: z.number(),
  per_page: z.number(),
  numPages: z.number(),
}).transform((v) => {
  return remap$(v, {
    "per_page": "perPage",
  });
});
/** @internal */
export type GetRedirectsResponseBodyPagination$Outbound = {
  page: number;
  per_page: number;
  numPages: number;
};

/** @internal */
export const GetRedirectsResponseBodyPagination$outboundSchema: z.ZodType<
  GetRedirectsResponseBodyPagination$Outbound,
  z.ZodTypeDef,
  GetRedirectsResponseBodyPagination
> = z.object({
  page: z.number(),
  perPage: z.number(),
  numPages: z.number(),
}).transform((v) => {
  return remap$(v, {
    perPage: "per_page",
  });
});

export function getRedirectsResponseBodyPaginationToJSON(
  getRedirectsResponseBodyPagination: GetRedirectsResponseBodyPagination,
): string {
  return JSON.stringify(
    GetRedirectsResponseBodyPagination$outboundSchema.parse(
      getRedirectsResponseBodyPagination,
    ),
  );
}
export function getRedirectsResponseBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<GetRedirectsResponseBodyPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetRedirectsResponseBodyPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRedirectsResponseBodyPagination' from JSON`,
  );
}

/** @internal */
export const GetRedirectsResponseBody2$inboundSchema: z.ZodType<
  GetRedirectsResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  redirects: z.array(z.lazy(() => ResponseBodyRedirects$inboundSchema)),
  version: z.lazy(() => ResponseBodyVersion$inboundSchema).optional(),
  pagination: z.lazy(() => GetRedirectsResponseBodyPagination$inboundSchema),
});
/** @internal */
export type GetRedirectsResponseBody2$Outbound = {
  redirects: Array<ResponseBodyRedirects$Outbound>;
  version?: ResponseBodyVersion$Outbound | undefined;
  pagination: GetRedirectsResponseBodyPagination$Outbound;
};

/** @internal */
export const GetRedirectsResponseBody2$outboundSchema: z.ZodType<
  GetRedirectsResponseBody2$Outbound,
  z.ZodTypeDef,
  GetRedirectsResponseBody2
> = z.object({
  redirects: z.array(z.lazy(() => ResponseBodyRedirects$outboundSchema)),
  version: z.lazy(() => ResponseBodyVersion$outboundSchema).optional(),
  pagination: z.lazy(() => GetRedirectsResponseBodyPagination$outboundSchema),
});

export function getRedirectsResponseBody2ToJSON(
  getRedirectsResponseBody2: GetRedirectsResponseBody2,
): string {
  return JSON.stringify(
    GetRedirectsResponseBody2$outboundSchema.parse(getRedirectsResponseBody2),
  );
}
export function getRedirectsResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<GetRedirectsResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRedirectsResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRedirectsResponseBody2' from JSON`,
  );
}

/** @internal */
export const GetRedirectsResponseBody$inboundSchema: z.ZodType<
  GetRedirectsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetRedirectsResponseBody2$inboundSchema),
  z.record(z.any()),
]);
/** @internal */
export type GetRedirectsResponseBody$Outbound =
  | GetRedirectsResponseBody2$Outbound
  | { [k: string]: any };

/** @internal */
export const GetRedirectsResponseBody$outboundSchema: z.ZodType<
  GetRedirectsResponseBody$Outbound,
  z.ZodTypeDef,
  GetRedirectsResponseBody
> = z.union([
  z.lazy(() => GetRedirectsResponseBody2$outboundSchema),
  z.record(z.any()),
]);

export function getRedirectsResponseBodyToJSON(
  getRedirectsResponseBody: GetRedirectsResponseBody,
): string {
  return JSON.stringify(
    GetRedirectsResponseBody$outboundSchema.parse(getRedirectsResponseBody),
  );
}
export function getRedirectsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetRedirectsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetRedirectsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetRedirectsResponseBody' from JSON`,
  );
}
