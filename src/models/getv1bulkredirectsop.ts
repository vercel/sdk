/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const QueryParam2 = {
  Only: "only",
} as const;
export type QueryParam2 = ClosedEnum<typeof QueryParam2>;

export type Diff = boolean | QueryParam2;

export const SortBy = {
  Source: "source",
  Destination: "destination",
  StatusCode: "statusCode",
} as const;
export type SortBy = ClosedEnum<typeof SortBy>;

export const SortOrder = {
  Asc: "asc",
  Desc: "desc",
} as const;
export type SortOrder = ClosedEnum<typeof SortOrder>;

export type GetV1BulkRedirectsRequest = {
  projectId: string;
  versionId?: string | undefined;
  q?: string | undefined;
  diff?: boolean | QueryParam2 | undefined;
  page?: number | undefined;
  perPage?: number | undefined;
  sortBy?: SortBy | undefined;
  sortOrder?: SortOrder | undefined;
};

export type ResponseBodyRedirects = {
  statusCode?: number | undefined;
  permanent?: boolean | undefined;
  sensitive?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  destination: string;
  source: string;
};

export type ResponseBodyVersion = {
  /**
   * The unique identifier for the version.
   */
  id: string;
  /**
   * The key of the version. The key may be duplicated across versions if the contents are the same as a different version.
   */
  key: string;
  lastModified: number;
  createdBy: string;
  /**
   * Optional name for the version. If not provided, defaults to an ISO timestamp string.
   */
  name?: string | undefined;
  /**
   * Whether this version has not been promoted to production yet and is not serving end users.
   */
  isStaging?: boolean | undefined;
  /**
   * Whether this version is currently live in production.
   */
  isLive?: boolean | undefined;
  /**
   * The number of redirects in this version.
   */
  redirectCount?: number | undefined;
  /**
   * The staging link for previewing redirects in this version.
   */
  alias?: string | undefined;
};

export type ResponseBodyPagination = {
  page: number;
  perPage: number;
  numPages: number;
};

export type ResponseBody2 = {
  redirects: Array<ResponseBodyRedirects>;
  version?: ResponseBodyVersion | undefined;
  pagination: ResponseBodyPagination;
};

export type GetV1BulkRedirectsResponseBody = ResponseBody2 | {
  [k: string]: any;
};

/** @internal */
export const QueryParam2$inboundSchema: z.ZodNativeEnum<typeof QueryParam2> = z
  .nativeEnum(QueryParam2);
/** @internal */
export const QueryParam2$outboundSchema: z.ZodNativeEnum<typeof QueryParam2> =
  QueryParam2$inboundSchema;

/** @internal */
export const Diff$inboundSchema: z.ZodType<Diff, z.ZodTypeDef, unknown> = z
  .union([z.boolean(), QueryParam2$inboundSchema]);
/** @internal */
export type Diff$Outbound = boolean | string;

/** @internal */
export const Diff$outboundSchema: z.ZodType<Diff$Outbound, z.ZodTypeDef, Diff> =
  z.union([z.boolean(), QueryParam2$outboundSchema]);

export function diffToJSON(diff: Diff): string {
  return JSON.stringify(Diff$outboundSchema.parse(diff));
}
export function diffFromJSON(
  jsonString: string,
): SafeParseResult<Diff, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Diff$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Diff' from JSON`,
  );
}

/** @internal */
export const SortBy$inboundSchema: z.ZodNativeEnum<typeof SortBy> = z
  .nativeEnum(SortBy);
/** @internal */
export const SortBy$outboundSchema: z.ZodNativeEnum<typeof SortBy> =
  SortBy$inboundSchema;

/** @internal */
export const SortOrder$inboundSchema: z.ZodNativeEnum<typeof SortOrder> = z
  .nativeEnum(SortOrder);
/** @internal */
export const SortOrder$outboundSchema: z.ZodNativeEnum<typeof SortOrder> =
  SortOrder$inboundSchema;

/** @internal */
export const GetV1BulkRedirectsRequest$inboundSchema: z.ZodType<
  GetV1BulkRedirectsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: z.string(),
  versionId: z.string().optional(),
  q: z.string().optional(),
  diff: z.union([z.boolean(), QueryParam2$inboundSchema]).optional(),
  page: z.number().int().optional(),
  per_page: z.number().int().optional(),
  sort_by: SortBy$inboundSchema.optional(),
  sort_order: SortOrder$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "per_page": "perPage",
    "sort_by": "sortBy",
    "sort_order": "sortOrder",
  });
});
/** @internal */
export type GetV1BulkRedirectsRequest$Outbound = {
  projectId: string;
  versionId?: string | undefined;
  q?: string | undefined;
  diff?: boolean | string | undefined;
  page?: number | undefined;
  per_page?: number | undefined;
  sort_by?: string | undefined;
  sort_order?: string | undefined;
};

/** @internal */
export const GetV1BulkRedirectsRequest$outboundSchema: z.ZodType<
  GetV1BulkRedirectsRequest$Outbound,
  z.ZodTypeDef,
  GetV1BulkRedirectsRequest
> = z.object({
  projectId: z.string(),
  versionId: z.string().optional(),
  q: z.string().optional(),
  diff: z.union([z.boolean(), QueryParam2$outboundSchema]).optional(),
  page: z.number().int().optional(),
  perPage: z.number().int().optional(),
  sortBy: SortBy$outboundSchema.optional(),
  sortOrder: SortOrder$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    perPage: "per_page",
    sortBy: "sort_by",
    sortOrder: "sort_order",
  });
});

export function getV1BulkRedirectsRequestToJSON(
  getV1BulkRedirectsRequest: GetV1BulkRedirectsRequest,
): string {
  return JSON.stringify(
    GetV1BulkRedirectsRequest$outboundSchema.parse(getV1BulkRedirectsRequest),
  );
}
export function getV1BulkRedirectsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetV1BulkRedirectsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetV1BulkRedirectsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetV1BulkRedirectsRequest' from JSON`,
  );
}

/** @internal */
export const ResponseBodyRedirects$inboundSchema: z.ZodType<
  ResponseBodyRedirects,
  z.ZodTypeDef,
  unknown
> = z.object({
  statusCode: z.number().optional(),
  permanent: z.boolean().optional(),
  sensitive: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  query: z.boolean().optional(),
  destination: z.string(),
  source: z.string(),
});
/** @internal */
export type ResponseBodyRedirects$Outbound = {
  statusCode?: number | undefined;
  permanent?: boolean | undefined;
  sensitive?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  destination: string;
  source: string;
};

/** @internal */
export const ResponseBodyRedirects$outboundSchema: z.ZodType<
  ResponseBodyRedirects$Outbound,
  z.ZodTypeDef,
  ResponseBodyRedirects
> = z.object({
  statusCode: z.number().optional(),
  permanent: z.boolean().optional(),
  sensitive: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  query: z.boolean().optional(),
  destination: z.string(),
  source: z.string(),
});

export function responseBodyRedirectsToJSON(
  responseBodyRedirects: ResponseBodyRedirects,
): string {
  return JSON.stringify(
    ResponseBodyRedirects$outboundSchema.parse(responseBodyRedirects),
  );
}
export function responseBodyRedirectsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyRedirects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyRedirects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyRedirects' from JSON`,
  );
}

/** @internal */
export const ResponseBodyVersion$inboundSchema: z.ZodType<
  ResponseBodyVersion,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string(),
  lastModified: z.number(),
  createdBy: z.string(),
  name: z.string().optional(),
  isStaging: z.boolean().optional(),
  isLive: z.boolean().optional(),
  redirectCount: z.number().optional(),
  alias: z.string().optional(),
});
/** @internal */
export type ResponseBodyVersion$Outbound = {
  id: string;
  key: string;
  lastModified: number;
  createdBy: string;
  name?: string | undefined;
  isStaging?: boolean | undefined;
  isLive?: boolean | undefined;
  redirectCount?: number | undefined;
  alias?: string | undefined;
};

/** @internal */
export const ResponseBodyVersion$outboundSchema: z.ZodType<
  ResponseBodyVersion$Outbound,
  z.ZodTypeDef,
  ResponseBodyVersion
> = z.object({
  id: z.string(),
  key: z.string(),
  lastModified: z.number(),
  createdBy: z.string(),
  name: z.string().optional(),
  isStaging: z.boolean().optional(),
  isLive: z.boolean().optional(),
  redirectCount: z.number().optional(),
  alias: z.string().optional(),
});

export function responseBodyVersionToJSON(
  responseBodyVersion: ResponseBodyVersion,
): string {
  return JSON.stringify(
    ResponseBodyVersion$outboundSchema.parse(responseBodyVersion),
  );
}
export function responseBodyVersionFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyVersion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyVersion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyVersion' from JSON`,
  );
}

/** @internal */
export const ResponseBodyPagination$inboundSchema: z.ZodType<
  ResponseBodyPagination,
  z.ZodTypeDef,
  unknown
> = z.object({
  page: z.number(),
  per_page: z.number(),
  numPages: z.number(),
}).transform((v) => {
  return remap$(v, {
    "per_page": "perPage",
  });
});
/** @internal */
export type ResponseBodyPagination$Outbound = {
  page: number;
  per_page: number;
  numPages: number;
};

/** @internal */
export const ResponseBodyPagination$outboundSchema: z.ZodType<
  ResponseBodyPagination$Outbound,
  z.ZodTypeDef,
  ResponseBodyPagination
> = z.object({
  page: z.number(),
  perPage: z.number(),
  numPages: z.number(),
}).transform((v) => {
  return remap$(v, {
    perPage: "per_page",
  });
});

export function responseBodyPaginationToJSON(
  responseBodyPagination: ResponseBodyPagination,
): string {
  return JSON.stringify(
    ResponseBodyPagination$outboundSchema.parse(responseBodyPagination),
  );
}
export function responseBodyPaginationFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyPagination, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyPagination$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyPagination' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  redirects: z.array(z.lazy(() => ResponseBodyRedirects$inboundSchema)),
  version: z.lazy(() => ResponseBodyVersion$inboundSchema).optional(),
  pagination: z.lazy(() => ResponseBodyPagination$inboundSchema),
});
/** @internal */
export type ResponseBody2$Outbound = {
  redirects: Array<ResponseBodyRedirects$Outbound>;
  version?: ResponseBodyVersion$Outbound | undefined;
  pagination: ResponseBodyPagination$Outbound;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  redirects: z.array(z.lazy(() => ResponseBodyRedirects$outboundSchema)),
  version: z.lazy(() => ResponseBodyVersion$outboundSchema).optional(),
  pagination: z.lazy(() => ResponseBodyPagination$outboundSchema),
});

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}
export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const GetV1BulkRedirectsResponseBody$inboundSchema: z.ZodType<
  GetV1BulkRedirectsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => ResponseBody2$inboundSchema), z.record(z.any())]);
/** @internal */
export type GetV1BulkRedirectsResponseBody$Outbound = ResponseBody2$Outbound | {
  [k: string]: any;
};

/** @internal */
export const GetV1BulkRedirectsResponseBody$outboundSchema: z.ZodType<
  GetV1BulkRedirectsResponseBody$Outbound,
  z.ZodTypeDef,
  GetV1BulkRedirectsResponseBody
> = z.union([z.lazy(() => ResponseBody2$outboundSchema), z.record(z.any())]);

export function getV1BulkRedirectsResponseBodyToJSON(
  getV1BulkRedirectsResponseBody: GetV1BulkRedirectsResponseBody,
): string {
  return JSON.stringify(
    GetV1BulkRedirectsResponseBody$outboundSchema.parse(
      getV1BulkRedirectsResponseBody,
    ),
  );
}
export function getV1BulkRedirectsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetV1BulkRedirectsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetV1BulkRedirectsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetV1BulkRedirectsResponseBody' from JSON`,
  );
}
