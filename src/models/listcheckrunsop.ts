/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type ListCheckRunsRequest = {
  projectIdOrName: string;
  /**
   * The ID of the resource that will be updated.
   */
  checkId: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

export const ListCheckRunsSourceProvider = {
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
} as const;
export type ListCheckRunsSourceProvider = ClosedEnum<
  typeof ListCheckRunsSourceProvider
>;

export type ListCheckRunsSource3 = {
  kind: "git-provider";
  provider: ListCheckRunsSourceProvider;
  externalCheckName: string;
};

export type ListCheckRunsSource2 = {
  kind: "webhook";
  webhookId?: string | undefined;
};

export type ListCheckRunsSource1 = {
  kind: "integration";
  integrationId: string;
  integrationConfigurationId: string;
  resourceId?: string | undefined;
  externalResourceId?: string | undefined;
};

export type ListCheckRunsSource =
  | ListCheckRunsSource1
  | ListCheckRunsSource2
  | ListCheckRunsSource3;

export const ListCheckRunsRequires = {
  BuildReady: "build-ready",
  DeploymentUrl: "deployment-url",
  None: "none",
} as const;
export type ListCheckRunsRequires = ClosedEnum<typeof ListCheckRunsRequires>;

export const ListCheckRunsBlocks = {
  None: "none",
  BuildStart: "build-start",
  DeploymentStart: "deployment-start",
  DeploymentAlias: "deployment-alias",
  DeploymentPromotion: "deployment-promotion",
} as const;
export type ListCheckRunsBlocks = ClosedEnum<typeof ListCheckRunsBlocks>;

export const ListCheckRunsStatus = {
  Queued: "queued",
  Running: "running",
  Completed: "completed",
} as const;
export type ListCheckRunsStatus = ClosedEnum<typeof ListCheckRunsStatus>;

export const ListCheckRunsConclusion = {
  Timeout: "timeout",
  Canceled: "canceled",
  Skipped: "skipped",
  Failed: "failed",
  Neutral: "neutral",
  Succeeded: "succeeded",
} as const;
export type ListCheckRunsConclusion = ClosedEnum<
  typeof ListCheckRunsConclusion
>;

export type Runs = {
  id: string;
  name: string;
  checkId: string;
  ownerId: string;
  deploymentId: string;
  projectId?: string | undefined;
  source: ListCheckRunsSource1 | ListCheckRunsSource2 | ListCheckRunsSource3;
  requires?: ListCheckRunsRequires | undefined;
  blocks?: ListCheckRunsBlocks | undefined;
  targets?: Array<string> | undefined;
  status: ListCheckRunsStatus;
  conclusion?: ListCheckRunsConclusion | undefined;
  conclusionText?: string | undefined;
  externalId?: string | undefined;
  externalUrl?: string | undefined;
  output?: { [k: string]: any } | undefined;
  timeout: number;
  createdAt: number;
  updatedAt: number;
  completedAt?: number | undefined;
};

export type ListCheckRunsResponseBody = {
  runs: Array<Runs>;
};

/** @internal */
export const ListCheckRunsRequest$inboundSchema: z.ZodType<
  ListCheckRunsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: types.string(),
  checkId: types.string(),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
});
/** @internal */
export type ListCheckRunsRequest$Outbound = {
  projectIdOrName: string;
  checkId: string;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const ListCheckRunsRequest$outboundSchema: z.ZodType<
  ListCheckRunsRequest$Outbound,
  z.ZodTypeDef,
  ListCheckRunsRequest
> = z.object({
  projectIdOrName: z.string(),
  checkId: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

export function listCheckRunsRequestToJSON(
  listCheckRunsRequest: ListCheckRunsRequest,
): string {
  return JSON.stringify(
    ListCheckRunsRequest$outboundSchema.parse(listCheckRunsRequest),
  );
}
export function listCheckRunsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsRequest' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsSourceProvider$inboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsSourceProvider
> = z.nativeEnum(ListCheckRunsSourceProvider);
/** @internal */
export const ListCheckRunsSourceProvider$outboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsSourceProvider
> = ListCheckRunsSourceProvider$inboundSchema;

/** @internal */
export const ListCheckRunsSource3$inboundSchema: z.ZodType<
  ListCheckRunsSource3,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: types.literal("git-provider"),
  provider: ListCheckRunsSourceProvider$inboundSchema,
  externalCheckName: types.string(),
});
/** @internal */
export type ListCheckRunsSource3$Outbound = {
  kind: "git-provider";
  provider: string;
  externalCheckName: string;
};

/** @internal */
export const ListCheckRunsSource3$outboundSchema: z.ZodType<
  ListCheckRunsSource3$Outbound,
  z.ZodTypeDef,
  ListCheckRunsSource3
> = z.object({
  kind: z.literal("git-provider"),
  provider: ListCheckRunsSourceProvider$outboundSchema,
  externalCheckName: z.string(),
});

export function listCheckRunsSource3ToJSON(
  listCheckRunsSource3: ListCheckRunsSource3,
): string {
  return JSON.stringify(
    ListCheckRunsSource3$outboundSchema.parse(listCheckRunsSource3),
  );
}
export function listCheckRunsSource3FromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsSource3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsSource3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsSource3' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsSource2$inboundSchema: z.ZodType<
  ListCheckRunsSource2,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: types.literal("webhook"),
  webhookId: types.optional(types.string()),
});
/** @internal */
export type ListCheckRunsSource2$Outbound = {
  kind: "webhook";
  webhookId?: string | undefined;
};

/** @internal */
export const ListCheckRunsSource2$outboundSchema: z.ZodType<
  ListCheckRunsSource2$Outbound,
  z.ZodTypeDef,
  ListCheckRunsSource2
> = z.object({
  kind: z.literal("webhook"),
  webhookId: z.string().optional(),
});

export function listCheckRunsSource2ToJSON(
  listCheckRunsSource2: ListCheckRunsSource2,
): string {
  return JSON.stringify(
    ListCheckRunsSource2$outboundSchema.parse(listCheckRunsSource2),
  );
}
export function listCheckRunsSource2FromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsSource2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsSource2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsSource2' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsSource1$inboundSchema: z.ZodType<
  ListCheckRunsSource1,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: types.literal("integration"),
  integrationId: types.string(),
  integrationConfigurationId: types.string(),
  resourceId: types.optional(types.string()),
  externalResourceId: types.optional(types.string()),
});
/** @internal */
export type ListCheckRunsSource1$Outbound = {
  kind: "integration";
  integrationId: string;
  integrationConfigurationId: string;
  resourceId?: string | undefined;
  externalResourceId?: string | undefined;
};

/** @internal */
export const ListCheckRunsSource1$outboundSchema: z.ZodType<
  ListCheckRunsSource1$Outbound,
  z.ZodTypeDef,
  ListCheckRunsSource1
> = z.object({
  kind: z.literal("integration"),
  integrationId: z.string(),
  integrationConfigurationId: z.string(),
  resourceId: z.string().optional(),
  externalResourceId: z.string().optional(),
});

export function listCheckRunsSource1ToJSON(
  listCheckRunsSource1: ListCheckRunsSource1,
): string {
  return JSON.stringify(
    ListCheckRunsSource1$outboundSchema.parse(listCheckRunsSource1),
  );
}
export function listCheckRunsSource1FromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsSource1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsSource1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsSource1' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsSource$inboundSchema: z.ZodType<
  ListCheckRunsSource,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListCheckRunsSource1$inboundSchema),
  z.lazy(() => ListCheckRunsSource2$inboundSchema),
  z.lazy(() => ListCheckRunsSource3$inboundSchema),
]);
/** @internal */
export type ListCheckRunsSource$Outbound =
  | ListCheckRunsSource1$Outbound
  | ListCheckRunsSource2$Outbound
  | ListCheckRunsSource3$Outbound;

/** @internal */
export const ListCheckRunsSource$outboundSchema: z.ZodType<
  ListCheckRunsSource$Outbound,
  z.ZodTypeDef,
  ListCheckRunsSource
> = z.union([
  z.lazy(() => ListCheckRunsSource1$outboundSchema),
  z.lazy(() => ListCheckRunsSource2$outboundSchema),
  z.lazy(() => ListCheckRunsSource3$outboundSchema),
]);

export function listCheckRunsSourceToJSON(
  listCheckRunsSource: ListCheckRunsSource,
): string {
  return JSON.stringify(
    ListCheckRunsSource$outboundSchema.parse(listCheckRunsSource),
  );
}
export function listCheckRunsSourceFromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsSource, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsSource$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsSource' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsRequires$inboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsRequires
> = z.nativeEnum(ListCheckRunsRequires);
/** @internal */
export const ListCheckRunsRequires$outboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsRequires
> = ListCheckRunsRequires$inboundSchema;

/** @internal */
export const ListCheckRunsBlocks$inboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsBlocks
> = z.nativeEnum(ListCheckRunsBlocks);
/** @internal */
export const ListCheckRunsBlocks$outboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsBlocks
> = ListCheckRunsBlocks$inboundSchema;

/** @internal */
export const ListCheckRunsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsStatus
> = z.nativeEnum(ListCheckRunsStatus);
/** @internal */
export const ListCheckRunsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsStatus
> = ListCheckRunsStatus$inboundSchema;

/** @internal */
export const ListCheckRunsConclusion$inboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsConclusion
> = z.nativeEnum(ListCheckRunsConclusion);
/** @internal */
export const ListCheckRunsConclusion$outboundSchema: z.ZodNativeEnum<
  typeof ListCheckRunsConclusion
> = ListCheckRunsConclusion$inboundSchema;

/** @internal */
export const Runs$inboundSchema: z.ZodType<Runs, z.ZodTypeDef, unknown> = z
  .object({
    id: types.string(),
    name: types.string(),
    checkId: types.string(),
    ownerId: types.string(),
    deploymentId: types.string(),
    projectId: types.optional(types.string()),
    source: z.union([
      z.lazy(() => ListCheckRunsSource1$inboundSchema),
      z.lazy(() => ListCheckRunsSource2$inboundSchema),
      z.lazy(() => ListCheckRunsSource3$inboundSchema),
    ]),
    requires: types.optional(ListCheckRunsRequires$inboundSchema),
    blocks: types.optional(ListCheckRunsBlocks$inboundSchema),
    targets: types.optional(z.array(types.string())),
    status: ListCheckRunsStatus$inboundSchema,
    conclusion: types.optional(ListCheckRunsConclusion$inboundSchema),
    conclusionText: types.optional(types.string()),
    externalId: types.optional(types.string()),
    externalUrl: types.optional(types.string()),
    output: types.optional(z.record(z.any())),
    timeout: types.number(),
    createdAt: types.number(),
    updatedAt: types.number(),
    completedAt: types.optional(types.number()),
  });
/** @internal */
export type Runs$Outbound = {
  id: string;
  name: string;
  checkId: string;
  ownerId: string;
  deploymentId: string;
  projectId?: string | undefined;
  source:
    | ListCheckRunsSource1$Outbound
    | ListCheckRunsSource2$Outbound
    | ListCheckRunsSource3$Outbound;
  requires?: string | undefined;
  blocks?: string | undefined;
  targets?: Array<string> | undefined;
  status: string;
  conclusion?: string | undefined;
  conclusionText?: string | undefined;
  externalId?: string | undefined;
  externalUrl?: string | undefined;
  output?: { [k: string]: any } | undefined;
  timeout: number;
  createdAt: number;
  updatedAt: number;
  completedAt?: number | undefined;
};

/** @internal */
export const Runs$outboundSchema: z.ZodType<Runs$Outbound, z.ZodTypeDef, Runs> =
  z.object({
    id: z.string(),
    name: z.string(),
    checkId: z.string(),
    ownerId: z.string(),
    deploymentId: z.string(),
    projectId: z.string().optional(),
    source: z.union([
      z.lazy(() => ListCheckRunsSource1$outboundSchema),
      z.lazy(() => ListCheckRunsSource2$outboundSchema),
      z.lazy(() => ListCheckRunsSource3$outboundSchema),
    ]),
    requires: ListCheckRunsRequires$outboundSchema.optional(),
    blocks: ListCheckRunsBlocks$outboundSchema.optional(),
    targets: z.array(z.string()).optional(),
    status: ListCheckRunsStatus$outboundSchema,
    conclusion: ListCheckRunsConclusion$outboundSchema.optional(),
    conclusionText: z.string().optional(),
    externalId: z.string().optional(),
    externalUrl: z.string().optional(),
    output: z.record(z.any()).optional(),
    timeout: z.number(),
    createdAt: z.number(),
    updatedAt: z.number(),
    completedAt: z.number().optional(),
  });

export function runsToJSON(runs: Runs): string {
  return JSON.stringify(Runs$outboundSchema.parse(runs));
}
export function runsFromJSON(
  jsonString: string,
): SafeParseResult<Runs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Runs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Runs' from JSON`,
  );
}

/** @internal */
export const ListCheckRunsResponseBody$inboundSchema: z.ZodType<
  ListCheckRunsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  runs: z.array(z.lazy(() => Runs$inboundSchema)),
});
/** @internal */
export type ListCheckRunsResponseBody$Outbound = {
  runs: Array<Runs$Outbound>;
};

/** @internal */
export const ListCheckRunsResponseBody$outboundSchema: z.ZodType<
  ListCheckRunsResponseBody$Outbound,
  z.ZodTypeDef,
  ListCheckRunsResponseBody
> = z.object({
  runs: z.array(z.lazy(() => Runs$outboundSchema)),
});

export function listCheckRunsResponseBodyToJSON(
  listCheckRunsResponseBody: ListCheckRunsResponseBody,
): string {
  return JSON.stringify(
    ListCheckRunsResponseBody$outboundSchema.parse(listCheckRunsResponseBody),
  );
}
export function listCheckRunsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListCheckRunsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListCheckRunsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListCheckRunsResponseBody' from JSON`,
  );
}
