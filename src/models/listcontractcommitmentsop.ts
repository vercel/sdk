/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type ListContractCommitmentsRequest = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

/**
 * Highest-level classification of the contract commitment. 'Spend' for Pro ($20/month), 'Usage' for Enterprise (MIU allocation).
 */
export const ContractCommitmentCategory = {
  Usage: "Usage",
  Spend: "Spend",
} as const;
/**
 * Highest-level classification of the contract commitment. 'Spend' for Pro ($20/month), 'Usage' for Enterprise (MIU allocation).
 */
export type ContractCommitmentCategory = ClosedEnum<
  typeof ContractCommitmentCategory
>;

/**
 * Contract commitment information describing terms within a contract. New in FOCUS v1.3 - tracks commitment terms separate from cost/usage rows. For Vercel: - Pro: $20 monthly spend commitment - Enterprise: MIU allocation per period (usage commitment)
 */
export type ListContractCommitmentsResponseBody = {
  /**
   * Highest-level classification of the contract commitment. 'Spend' for Pro ($20/month), 'Usage' for Enterprise (MIU allocation).
   */
  contractCommitmentCategory: ContractCommitmentCategory;
  /**
   * Monetary value of the contract commitment (in BillingCurrency). Required when ContractCommitmentCategory is 'Spend'. For Pro: 20 (USD)
   */
  contractCommitmentCost?: number | undefined;
  /**
   * Self-contained summary of the contract commitment's terms
   */
  contractCommitmentDescription?: string | undefined;
  /**
   * Unique identifier for a single contract term within a contract. Maps to specific commitment period or allocation ID.
   */
  contractCommitmentId: string;
  /**
   * Inclusive start of the commitment term period (ISO 8601 UTC)
   */
  contractCommitmentPeriodStart: string;
  /**
   * Exclusive end of the commitment term period (ISO 8601 UTC)
   */
  contractCommitmentPeriodEnd: string;
  /**
   * Amount associated with the commitment (in ContractCommitmentUnit). Required when ContractCommitmentCategory is 'Usage'. For Enterprise: MIU allocation amount.
   */
  contractCommitmentQuantity?: number | undefined;
  /**
   * Service-provider-assigned name identifying the commitment type. 'Pro' or 'Enterprise' for Vercel.
   */
  contractCommitmentType: string;
  /**
   * Measurement unit for ContractCommitmentQuantity. 'MIUs' for Enterprise, 'USD' for Pro spend commitments.
   */
  contractCommitmentUnit: string;
  /**
   * Service-provider-assigned identifier for a contract. Maps to Orb Subscription ID for Vercel.
   */
  contractId: string;
  /**
   * Inclusive start of the overall contract period (ISO 8601 UTC)
   */
  contractPeriodStart: string;
  /**
   * Exclusive end of the overall contract period (ISO 8601 UTC)
   */
  contractPeriodEnd: string;
  billingCurrency: string;
};

/** @internal */
export const ListContractCommitmentsRequest$inboundSchema: z.ZodType<
  ListContractCommitmentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
});
/** @internal */
export type ListContractCommitmentsRequest$Outbound = {
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const ListContractCommitmentsRequest$outboundSchema: z.ZodType<
  ListContractCommitmentsRequest$Outbound,
  z.ZodTypeDef,
  ListContractCommitmentsRequest
> = z.object({
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

export function listContractCommitmentsRequestToJSON(
  listContractCommitmentsRequest: ListContractCommitmentsRequest,
): string {
  return JSON.stringify(
    ListContractCommitmentsRequest$outboundSchema.parse(
      listContractCommitmentsRequest,
    ),
  );
}
export function listContractCommitmentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListContractCommitmentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListContractCommitmentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContractCommitmentsRequest' from JSON`,
  );
}

/** @internal */
export const ContractCommitmentCategory$inboundSchema: z.ZodNativeEnum<
  typeof ContractCommitmentCategory
> = z.nativeEnum(ContractCommitmentCategory);
/** @internal */
export const ContractCommitmentCategory$outboundSchema: z.ZodNativeEnum<
  typeof ContractCommitmentCategory
> = ContractCommitmentCategory$inboundSchema;

/** @internal */
export const ListContractCommitmentsResponseBody$inboundSchema: z.ZodType<
  ListContractCommitmentsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  ContractCommitmentCategory: ContractCommitmentCategory$inboundSchema,
  ContractCommitmentCost: types.optional(types.number()),
  ContractCommitmentDescription: types.optional(types.string()),
  ContractCommitmentId: types.string(),
  ContractCommitmentPeriodStart: types.string(),
  ContractCommitmentPeriodEnd: types.string(),
  ContractCommitmentQuantity: types.optional(types.number()),
  ContractCommitmentType: types.string(),
  ContractCommitmentUnit: types.string(),
  ContractId: types.string(),
  ContractPeriodStart: types.string(),
  ContractPeriodEnd: types.string(),
  BillingCurrency: types.string(),
}).transform((v) => {
  return remap$(v, {
    "ContractCommitmentCategory": "contractCommitmentCategory",
    "ContractCommitmentCost": "contractCommitmentCost",
    "ContractCommitmentDescription": "contractCommitmentDescription",
    "ContractCommitmentId": "contractCommitmentId",
    "ContractCommitmentPeriodStart": "contractCommitmentPeriodStart",
    "ContractCommitmentPeriodEnd": "contractCommitmentPeriodEnd",
    "ContractCommitmentQuantity": "contractCommitmentQuantity",
    "ContractCommitmentType": "contractCommitmentType",
    "ContractCommitmentUnit": "contractCommitmentUnit",
    "ContractId": "contractId",
    "ContractPeriodStart": "contractPeriodStart",
    "ContractPeriodEnd": "contractPeriodEnd",
    "BillingCurrency": "billingCurrency",
  });
});
/** @internal */
export type ListContractCommitmentsResponseBody$Outbound = {
  ContractCommitmentCategory: string;
  ContractCommitmentCost?: number | undefined;
  ContractCommitmentDescription?: string | undefined;
  ContractCommitmentId: string;
  ContractCommitmentPeriodStart: string;
  ContractCommitmentPeriodEnd: string;
  ContractCommitmentQuantity?: number | undefined;
  ContractCommitmentType: string;
  ContractCommitmentUnit: string;
  ContractId: string;
  ContractPeriodStart: string;
  ContractPeriodEnd: string;
  BillingCurrency: string;
};

/** @internal */
export const ListContractCommitmentsResponseBody$outboundSchema: z.ZodType<
  ListContractCommitmentsResponseBody$Outbound,
  z.ZodTypeDef,
  ListContractCommitmentsResponseBody
> = z.object({
  contractCommitmentCategory: ContractCommitmentCategory$outboundSchema,
  contractCommitmentCost: z.number().optional(),
  contractCommitmentDescription: z.string().optional(),
  contractCommitmentId: z.string(),
  contractCommitmentPeriodStart: z.string(),
  contractCommitmentPeriodEnd: z.string(),
  contractCommitmentQuantity: z.number().optional(),
  contractCommitmentType: z.string(),
  contractCommitmentUnit: z.string(),
  contractId: z.string(),
  contractPeriodStart: z.string(),
  contractPeriodEnd: z.string(),
  billingCurrency: z.string(),
}).transform((v) => {
  return remap$(v, {
    contractCommitmentCategory: "ContractCommitmentCategory",
    contractCommitmentCost: "ContractCommitmentCost",
    contractCommitmentDescription: "ContractCommitmentDescription",
    contractCommitmentId: "ContractCommitmentId",
    contractCommitmentPeriodStart: "ContractCommitmentPeriodStart",
    contractCommitmentPeriodEnd: "ContractCommitmentPeriodEnd",
    contractCommitmentQuantity: "ContractCommitmentQuantity",
    contractCommitmentType: "ContractCommitmentType",
    contractCommitmentUnit: "ContractCommitmentUnit",
    contractId: "ContractId",
    contractPeriodStart: "ContractPeriodStart",
    contractPeriodEnd: "ContractPeriodEnd",
    billingCurrency: "BillingCurrency",
  });
});

export function listContractCommitmentsResponseBodyToJSON(
  listContractCommitmentsResponseBody: ListContractCommitmentsResponseBody,
): string {
  return JSON.stringify(
    ListContractCommitmentsResponseBody$outboundSchema.parse(
      listContractCommitmentsResponseBody,
    ),
  );
}
export function listContractCommitmentsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListContractCommitmentsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListContractCommitmentsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListContractCommitmentsResponseBody' from JSON`,
  );
}
