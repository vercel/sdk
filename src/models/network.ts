/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * Metadata about any AWS Route53 Hosted Zones associated with the Network.
 */
export type HostedZones = {
  /**
   * The number of AWS Route53 Hosted Zones associated with the Network.
   */
  count: number;
};

/**
 * Metadata about any AWS Route53 Hosted Zones associated with the Network.
 */
export type PeeringConnections = {
  /**
   * The number of AWS Route53 Hosted Zones associated with the Network.
   */
  count: number;
};

/**
 * Metadata about any projects associated with the Network.
 */
export type Projects = {
  count: number;
  ids: Array<string>;
};

/**
 * The status of the Network.
 */
export const Status = {
  CreateInProgress: "create_in_progress",
  DeleteInProgress: "delete_in_progress",
  Error: "error",
  Ready: "ready",
} as const;
/**
 * The status of the Network.
 */
export type Status = ClosedEnum<typeof Status>;

export type Network = {
  /**
   * The ID of the AWS Account in which the network exists.
   */
  awsAccountId: string;
  /**
   * The IDs of the AWS Availability Zones in which the network exists, if specified during creation.
   */
  awsAvailabilityZoneIds?: Array<string> | undefined;
  /**
   * The AWS Region in which the network exists.
   */
  awsRegion: string;
  /**
   * The CIDR range of the Network.
   */
  cidr: string;
  /**
   * The date at which the Network was created, represented as a UNIX timestamp since EPOCH.
   */
  createdAt: number;
  egressIpAddresses?: Array<string> | undefined;
  /**
   * Metadata about any AWS Route53 Hosted Zones associated with the Network.
   */
  hostedZones?: HostedZones | undefined;
  /**
   * The unique identifier of the Network.
   */
  id: string;
  /**
   * The name of the network.
   */
  name: string;
  /**
   * Metadata about any AWS Route53 Hosted Zones associated with the Network.
   */
  peeringConnections?: PeeringConnections | undefined;
  /**
   * Metadata about any projects associated with the Network.
   */
  projects?: Projects | undefined;
  /**
   * The Vercel region in which the Network exists.
   */
  region?: string | undefined;
  /**
   * The status of the Network.
   */
  status: Status;
  /**
   * The unique identifier of the Team that owns the Network.
   */
  teamId: string;
  /**
   * The ID of the VPC which hosts the network.
   */
  vpcId?: string | undefined;
};

/** @internal */
export const HostedZones$inboundSchema: z.ZodType<
  HostedZones,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: types.number(),
});
/** @internal */
export type HostedZones$Outbound = {
  count: number;
};

/** @internal */
export const HostedZones$outboundSchema: z.ZodType<
  HostedZones$Outbound,
  z.ZodTypeDef,
  HostedZones
> = z.object({
  count: z.number(),
});

export function hostedZonesToJSON(hostedZones: HostedZones): string {
  return JSON.stringify(HostedZones$outboundSchema.parse(hostedZones));
}
export function hostedZonesFromJSON(
  jsonString: string,
): SafeParseResult<HostedZones, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HostedZones$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HostedZones' from JSON`,
  );
}

/** @internal */
export const PeeringConnections$inboundSchema: z.ZodType<
  PeeringConnections,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: types.number(),
});
/** @internal */
export type PeeringConnections$Outbound = {
  count: number;
};

/** @internal */
export const PeeringConnections$outboundSchema: z.ZodType<
  PeeringConnections$Outbound,
  z.ZodTypeDef,
  PeeringConnections
> = z.object({
  count: z.number(),
});

export function peeringConnectionsToJSON(
  peeringConnections: PeeringConnections,
): string {
  return JSON.stringify(
    PeeringConnections$outboundSchema.parse(peeringConnections),
  );
}
export function peeringConnectionsFromJSON(
  jsonString: string,
): SafeParseResult<PeeringConnections, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PeeringConnections$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PeeringConnections' from JSON`,
  );
}

/** @internal */
export const Projects$inboundSchema: z.ZodType<
  Projects,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: types.number(),
  ids: z.array(types.string()),
});
/** @internal */
export type Projects$Outbound = {
  count: number;
  ids: Array<string>;
};

/** @internal */
export const Projects$outboundSchema: z.ZodType<
  Projects$Outbound,
  z.ZodTypeDef,
  Projects
> = z.object({
  count: z.number(),
  ids: z.array(z.string()),
});

export function projectsToJSON(projects: Projects): string {
  return JSON.stringify(Projects$outboundSchema.parse(projects));
}
export function projectsFromJSON(
  jsonString: string,
): SafeParseResult<Projects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Projects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Projects' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);
/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/** @internal */
export const Network$inboundSchema: z.ZodType<Network, z.ZodTypeDef, unknown> =
  z.object({
    awsAccountId: types.string(),
    awsAvailabilityZoneIds: types.optional(z.array(types.string())),
    awsRegion: types.string(),
    cidr: types.string(),
    createdAt: types.number(),
    egressIpAddresses: types.optional(z.array(types.string())),
    hostedZones: types.optional(z.lazy(() => HostedZones$inboundSchema)),
    id: types.string(),
    name: types.string(),
    peeringConnections: types.optional(
      z.lazy(() => PeeringConnections$inboundSchema),
    ),
    projects: types.optional(z.lazy(() => Projects$inboundSchema)),
    region: types.optional(types.string()),
    status: Status$inboundSchema,
    teamId: types.string(),
    vpcId: types.optional(types.string()),
  });
/** @internal */
export type Network$Outbound = {
  awsAccountId: string;
  awsAvailabilityZoneIds?: Array<string> | undefined;
  awsRegion: string;
  cidr: string;
  createdAt: number;
  egressIpAddresses?: Array<string> | undefined;
  hostedZones?: HostedZones$Outbound | undefined;
  id: string;
  name: string;
  peeringConnections?: PeeringConnections$Outbound | undefined;
  projects?: Projects$Outbound | undefined;
  region?: string | undefined;
  status: string;
  teamId: string;
  vpcId?: string | undefined;
};

/** @internal */
export const Network$outboundSchema: z.ZodType<
  Network$Outbound,
  z.ZodTypeDef,
  Network
> = z.object({
  awsAccountId: z.string(),
  awsAvailabilityZoneIds: z.array(z.string()).optional(),
  awsRegion: z.string(),
  cidr: z.string(),
  createdAt: z.number(),
  egressIpAddresses: z.array(z.string()).optional(),
  hostedZones: z.lazy(() => HostedZones$outboundSchema).optional(),
  id: z.string(),
  name: z.string(),
  peeringConnections: z.lazy(() => PeeringConnections$outboundSchema)
    .optional(),
  projects: z.lazy(() => Projects$outboundSchema).optional(),
  region: z.string().optional(),
  status: Status$outboundSchema,
  teamId: z.string(),
  vpcId: z.string().optional(),
});

export function networkToJSON(network: Network): string {
  return JSON.stringify(Network$outboundSchema.parse(network));
}
export function networkFromJSON(
  jsonString: string,
): SafeParseResult<Network, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Network$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Network' from JSON`,
  );
}
