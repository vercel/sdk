/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * The type of entity.
 */
export const UserEventType = {
  App: "app",
  Author: "author",
  BitbucketLogin: "bitbucket_login",
  Bold: "bold",
  DeploymentHost: "deployment_host",
  DnsRecord: "dns_record",
  GitLink: "git_link",
  GithubLogin: "github_login",
  GitlabLogin: "gitlab_login",
  HookName: "hook_name",
  Integration: "integration",
  EdgeConfig: "edge-config",
  Flag: "flag",
  FlagsSegment: "flags-segment",
  FlagsSettings: "flags-settings",
  Link: "link",
  ProjectName: "project_name",
  ScalingRules: "scaling_rules",
  EnvVarName: "env_var_name",
  Target: "target",
  Store: "store",
  System: "system",
} as const;
/**
 * The type of entity.
 */
export type UserEventType = ClosedEnum<typeof UserEventType>;

/**
 * A list of "entities" within the event `text`. Useful for enhancing the displayed text with additional styling and links.
 */
export type Entities = {
  /**
   * The type of entity.
   */
  type: UserEventType;
  /**
   * The index of where the entity begins within the `text` (inclusive).
   */
  start: number;
  /**
   * The index of where the entity ends within the `text` (non-inclusive).
   */
  end: number;
};

/**
 * The type of the event.
 */
export const Type = {
  Flag: "flag",
  FlagsSegment: "flags-segment",
  FlagsSettings: "flags-settings",
  ProjectRollingReleaseEnabled: "project-rolling-release-enabled",
  ProjectRollingReleaseDisabled: "project-rolling-release-disabled",
  ProjectRollingReleaseConfigured: "project-rolling-release-configured",
  ProjectRollingReleaseStarted: "project-rolling-release-started",
  ProjectRollingReleaseCompleted: "project-rolling-release-completed",
  ProjectRollingReleaseAborted: "project-rolling-release-aborted",
  ProjectRollingReleaseApproved: "project-rolling-release-approved",
  ProjectRollingReleaseTimer: "project-rolling-release-timer",
  ProtectedGitScopeAdded: "protected-git-scope-added",
  ProtectedGitScopeRemoved: "protected-git-scope-removed",
  Scale: "scale",
  ScaleAuto: "scale-auto",
  SecondaryEmailAdded: "secondary-email-added",
  SecondaryEmailRemoved: "secondary-email-removed",
  SecondaryEmailVerified: "secondary-email-verified",
  EmailNotificationRuleUpdated: "email-notification-rule-updated",
  EmailNotificationRuleRemoved: "email-notification-rule-removed",
  SecretAdd: "secret-add",
  SecretDelete: "secret-delete",
  SecretRename: "secret-rename",
  SetBio: "set-bio",
  SetName: "set-name",
  SetProfiles: "set-profiles",
  SetScale: "set-scale",
  SpendCreated: "spend-created",
  SpendDeleted: "spend-deleted",
  SpendUpdated: "spend-updated",
  StorageCreate: "storage-create",
  StorageResetCredentials: "storage-reset-credentials",
  StorageUpdate: "storage-update",
  StorageConnectProject: "storage-connect-project",
  StorageDisconnectProject: "storage-disconnect-project",
  StorageUpdateProjectConnection: "storage-update-project-connection",
  StorageDelete: "storage-delete",
  StorageAccessedDataBrowser: "storage-accessed-data-browser",
  StorageViewSecret: "storage-view-secret",
  StorageAcceptTos: "storage-accept-tos",
  StorageInactiveStoreDeleted: "storage-inactive-store-deleted",
  StorageResourceReplCommand: "storage-resource-repl-command",
  StorageDisconnectProjects: "storage-disconnect-projects",
  StorageAccessTokenSet: "storage-access-token-set",
  Team: "team",
  TeamAvatarUpdate: "team-avatar-update",
  TeamDelete: "team-delete",
  TeamInviteBulkDelete: "team-invite-bulk-delete",
  TeamMemberAdd: "team-member-add",
  TeamMemberDelete: "team-member-delete",
  TeamMemberLeave: "team-member-leave",
  TeamMemberJoin: "team-member-join",
  TeamMemberRoleUpdate: "team-member-role-update",
  TeamMemberEntitlementAdded: "team-member-entitlement-added",
  TeamMemberEntitlementRemoved: "team-member-entitlement-removed",
  TeamMemberEntitlementCanceled: "team-member-entitlement-canceled",
  TeamMemberEntitlementReactivated: "team-member-entitlement-reactivated",
  TeamMfaEnforcementUpdated: "team-mfa-enforcement-updated",
  TeamNameUpdate: "team-name-update",
  TeamSlugUpdate: "team-slug-update",
  TeamRemoteCachingUpdate: "team-remote-caching-update",
  UserMfaChallengeVerified: "user-mfa-challenge-verified",
  UserMfaConfigurationUpdated: "user-mfa-configuration-updated",
  UserMfaTotpVerificationStarted: "user-mfa-totp-verification-started",
  UserMfaTotpVerified: "user-mfa-totp-verified",
  UserMfaRecoveryCodesRegenerated: "user-mfa-recovery-codes-regenerated",
  UserMfaRemoved: "user-mfa-removed",
  UserPrimaryEmailUpdated: "user-primary-email-updated",
  UserDelete: "user-delete",
  Username: "username",
  PreviewDeploymentSuffixEnabled: "preview-deployment-suffix-enabled",
  PreviewDeploymentSuffixDisabled: "preview-deployment-suffix-disabled",
  PreviewDeploymentSuffixUpdate: "preview-deployment-suffix-update",
  PasswordProtectionEnabled: "password-protection-enabled",
  PasswordProtectionDisabled: "password-protection-disabled",
  InvoiceRefunded: "invoice-refunded",
  InvoiceModified: "invoice-modified",
  PaymentMethodAdded: "payment-method-added",
  PaymentMethodDefaultUpdated: "payment-method-default-updated",
  PaymentMethodRemoved: "payment-method-removed",
  SubscriptionCreated: "subscription-created",
  SubscriptionUpdated: "subscription-updated",
  SubscriptionProductAdded: "subscription-product-added",
  SubscriptionProductRemoved: "subscription-product-removed",
  TeamMemberConfirmRequest: "team-member-confirm-request",
  TeamMemberDeclineRequest: "team-member-decline-request",
  TeamMemberRequestAccess: "team-member-request-access",
  ProjectMoveOutStarted: "project-move-out-started",
  ProjectMoveOutFailed: "project-move-out-failed",
  ProjectMoveOutSuccess: "project-move-out-success",
  ProjectMoveInSuccess: "project-move-in-success",
  ProjectMemberAdded: "project-member-added",
  ProjectMemberRemoved: "project-member-removed",
  ProjectMemberUpdated: "project-member-updated",
  ProjectMemberInvited: "project-member-invited",
  EdgeCachePurgeAll: "edge-cache-purge-all",
  EdgeCacheInvalidateByTags: "edge-cache-invalidate-by-tags",
  EdgeCacheDangerouslyDeleteByTags: "edge-cache-dangerously-delete-by-tags",
  EdgeCacheInvalidateBySrcImages: "edge-cache-invalidate-by-src-images",
  EdgeCacheDangerouslyDeleteBySrcImages:
    "edge-cache-dangerously-delete-by-src-images",
  EdgeCacheRollbackPurge: "edge-cache-rollback-purge",
  RuntimeCachePurgeAll: "runtime-cache-purge-all",
  EdgeConfigCreated: "edge-config-created",
  EdgeConfigDeleted: "edge-config-deleted",
  EdgeConfigItemsUpdated: "edge-config-items-updated",
  EdgeConfigTokenCreated: "edge-config-token-created",
  EdgeConfigTokenDeleted: "edge-config-token-deleted",
  EdgeConfigUpdated: "edge-config-updated",
  FlagsExplorerSubscription: "flags-explorer-subscription",
  MonitoringEnabled: "monitoring-enabled",
  MonitoringDisabled: "monitoring-disabled",
  MicrofrontendGroupAdded: "microfrontend-group-added",
  MicrofrontendGroupDeleted: "microfrontend-group-deleted",
  MicrofrontendGroupUpdated: "microfrontend-group-updated",
  MicrofrontendProjectAddedToGroup: "microfrontend-project-added-to-group",
  MicrofrontendProjectRemovedFromGroup:
    "microfrontend-project-removed-from-group",
  MicrofrontendProjectUpdated: "microfrontend-project-updated",
  ProjectWebAnalyticsDisabled: "project-web-analytics-disabled",
  ProjectWebAnalyticsEnabled: "project-web-analytics-enabled",
  WebAnalyticsTierUpdated: "web-analytics-tier-updated",
  PasskeyCreated: "passkey-created",
  PasskeyUpdated: "passkey-updated",
  PasskeyDeleted: "passkey-deleted",
  OauthAppConnectionCreated: "oauth-app-connection-created",
  OauthAppConnectionUpdated: "oauth-app-connection-updated",
  OauthAppConnectionRemoved: "oauth-app-connection-removed",
  OauthAppCreated: "oauth-app-created",
  OauthAppDeleted: "oauth-app-deleted",
  OauthAppUpdated: "oauth-app-updated",
  OauthAppSecretGenerated: "oauth-app-secret-generated",
  OauthAppSecretDeleted: "oauth-app-secret-deleted",
  OauthAppTokenCreated: "oauth-app-token-created",
  VercelAppInstallationRequested: "vercel-app-installation-requested",
  VercelAppInstallationRequestDismissed:
    "vercel-app-installation-request-dismissed",
  VercelAppInstalled: "vercel-app-installed",
  VercelAppUninstalled: "vercel-app-uninstalled",
  VercelAppInstallationUpdated: "vercel-app-installation-updated",
  VercelAppTokensRevoked: "vercel-app-tokens-revoked",
  VpcPeeringConnectionAccepted: "vpc-peering-connection-accepted",
  VpcPeeringConnectionDeleted: "vpc-peering-connection-deleted",
  VpcPeeringConnectionRejected: "vpc-peering-connection-rejected",
  VpcPeeringConnectionUpdated: "vpc-peering-connection-updated",
  WebhookCreated: "webhook-created",
  WebhookDeleted: "webhook-deleted",
  WebhookUpdated: "webhook-updated",
  EnforceSensitiveEnvironmentVariables:
    "enforce-sensitive-environment-variables",
  ShowIpAddresses: "show-ip-addresses",
  TeamSamlEnforced: "team-saml-enforced",
  TeamSamlRoles: "team-saml-roles",
  TeamIpBlockingRulesCreated: "team-ip-blocking-rules-created",
  TeamIpBlockingRulesRemoved: "team-ip-blocking-rules-removed",
  AuditLogExportRequested: "audit-log-export-requested",
  AuditLogExportDownloaded: "audit-log-export-downloaded",
  StrictDeploymentProtectionSettings: "strict-deployment-protection-settings",
  AlertRuleCreated: "alert-rule-created",
  AlertRuleUpdated: "alert-rule-updated",
  AlertRuleDeleted: "alert-rule-deleted",
  SpeedInsightsSettingsUpdated: "speed-insights-settings-updated",
  OwnerBlocked: "owner-blocked",
  OwnerUnblocked: "owner-unblocked",
  OwnerSoftBlocked: "owner-soft-blocked",
  OwnerSoftUnblocked: "owner-soft-unblocked",
  EdgeConfigSchemaDeleted: "edge-config-schema-deleted",
  EdgeConfigSchemaUpdated: "edge-config-schema-updated",
  EdgeConfigTransferIn: "edge-config-transfer-in",
  EdgeConfigTransferOut: "edge-config-transfer-out",
  ProjectAddAlias: "project-add-alias",
  ProjectAddRedirect: "project-add-redirect",
  ProjectDomainDeleted: "project-domain-deleted",
  ProjectDomainMoved: "project-domain-moved",
  ProjectDomainUpdated: "project-domain-updated",
  ProjectMemberRemovedBatch: "project-member-removed-batch",
  ProjectAliasConfiguredChange: "project-alias-configured-change",
  TeamEndedTrial: "team-ended-trial",
  TeamPaidInvoice: "team-paid-invoice",
  TeamEmailDomainUpdate: "team-email-domain-update",
  TeamInviteCodeReset: "team-invite-code-reset",
  VercelAgentTeamTrialCreditsApplied: "vercel-agent-team-trial-credits-applied",
  AuthorizeGitDeployment: "authorize-git-deployment",
  WorkflowDeploymentKeyAccessed: "workflow-deployment-key-accessed",
  AccessGroupCreated: "access-group-created",
  AccessGroupDeleted: "access-group-deleted",
  AccessGroupUserAdded: "access-group-user-added",
  AccessGroupUserRemoved: "access-group-user-removed",
  AccessGroupProjectUpdated: "access-group-project-updated",
  AiCodeReview: "ai-code-review",
  AiAlertInvestigation: "ai-alert-investigation",
  Alias: "alias",
  AliasProtectionBypassCreated: "alias-protection-bypass-created",
  AliasProtectionBypassRegenerated: "alias-protection-bypass-regenerated",
  AliasProtectionBypassRevoked: "alias-protection-bypass-revoked",
  AliasUserScopedAccessRequested: "alias-user-scoped-access-requested",
  AliasUserScopedAccessGranted: "alias-user-scoped-access-granted",
  AliasUserScopedAccessDenied: "alias-user-scoped-access-denied",
  AliasUserScopedAccessRevoked: "alias-user-scoped-access-revoked",
  AliasProtectionBypassException: "alias-protection-bypass-exception",
  AliasInviteCreated: "alias-invite-created",
  AliasInviteRevoked: "alias-invite-revoked",
  AliasInviteJoined: "alias-invite-joined",
  AliasChown: "alias-chown",
  AliasDelete: "alias-delete",
  AliasSystem: "alias-system",
  AutoExposeSystemEnvs: "auto-expose-system-envs",
  Avatar: "avatar",
  BulkRedirectsSettingsUpdated: "bulk-redirects-settings-updated",
  BulkRedirectsVersionPromoted: "bulk-redirects-version-promoted",
  BulkRedirectsVersionRestored: "bulk-redirects-version-restored",
  ProjectRoutesVersionPromoted: "project-routes-version-promoted",
  ProjectRoutesVersionRestored: "project-routes-version-restored",
  Cert: "cert",
  CertAutorenew: "cert-autorenew",
  CertSystemCreate: "cert-system-create",
  CertChown: "cert-chown",
  CertClone: "cert-clone",
  CertDelete: "cert-delete",
  CertRenew: "cert-renew",
  CertReplace: "cert-replace",
  ProjectClientCertUpload: "project-client-cert-upload",
  ProjectClientCertDelete: "project-client-cert-delete",
  CustomSuffixClear: "custom-suffix-clear",
  CustomSuffixDisable: "custom-suffix-disable",
  CustomSuffixEnable: "custom-suffix-enable",
  CustomSuffixPending: "custom-suffix-pending",
  CustomSuffixReady: "custom-suffix-ready",
  ConcurrentBuildsUpdate: "concurrent-builds-update",
  ConnectConfigurationCreated: "connect-configuration-created",
  ConnectConfigurationDeleted: "connect-configuration-deleted",
  ConnectConfigurationLinkUpdated: "connect-configuration-link-updated",
  ConnectConfigurationLinked: "connect-configuration-linked",
  ConnectConfigurationUnlinked: "connect-configuration-unlinked",
  ConnectConfigurationUpdated: "connect-configuration-updated",
  ConnectGithub: "connect-github",
  DisconnectGithub: "disconnect-github",
  ConnectGithubLimited: "connect-github-limited",
  DisconnectGithubLimited: "disconnect-github-limited",
  ConnectGithubCustomHost: "connect-github-custom-host",
  DisconnectGithubCustomHost: "disconnect-github-custom-host",
  ConnectGitlab: "connect-gitlab",
  ConnectGitlabApp: "connect-gitlab-app",
  DisconnectGitlabApp: "disconnect-gitlab-app",
  ConnectBitbucket: "connect-bitbucket",
  ConnectBitbucketApp: "connect-bitbucket-app",
  DisconnectBitbucketApp: "disconnect-bitbucket-app",
  UnlinkLoginConnection: "unlink-login-connection",
  DeployHookCreated: "deploy-hook-created",
  DeployHookDeleted: "deploy-hook-deleted",
  DeployHookDeduped: "deploy-hook-deduped",
  DeployHookProcessed: "deploy-hook-processed",
  Deployment: "deployment",
  DeploymentChown: "deployment-chown",
  DeploymentDelete: "deployment-delete",
  DnsAdd: "dns-add",
  DnsDelete: "dns-delete",
  DnsUpdate: "dns-update",
  Domain: "domain",
  DomainBuy: "domain-buy",
  DomainCdn: "domain-cdn",
  DomainDelegated: "domain-delegated",
  DomainChown: "domain-chown",
  DomainDelete: "domain-delete",
  DomainMoveIn: "domain-move-in",
  DomainMoveOut: "domain-move-out",
  DomainMoveOutRequestSent: "domain-move-out-request-sent",
  DomainRenewChange: "domain-renew-change",
  DomainTransferIn: "domain-transfer-in",
  DomainTransferInCanceled: "domain-transfer-in-canceled",
  DomainTransferInCompleted: "domain-transfer-in-completed",
  DomainServiceTypeUpdated: "domain-service-type-updated",
  DomainCustomNsChange: "domain-custom-ns-change",
  DnsZonefileImport: "dns-zonefile-import",
  DeploymentCreationBlocked: "deployment-creation-blocked",
  Email: "email",
  EnvVariableAdd: "env-variable-add",
  EnvVariableDelete: "env-variable-delete",
  EnvVariableEdit: "env-variable-edit",
  EnvVariableRead: "env-variable-read",
  EnvVariableReadCliPull: "env-variable-read:cli:pull",
  EnvVariableReadCliDev: "env-variable-read:cli:dev",
  EnvVariableReadCliEnvRm: "env-variable-read:cli:env:rm",
  EnvVariableReadCliEnvAdd: "env-variable-read:cli:env:add",
  EnvVariableReadCliEnvLs: "env-variable-read:cli:env:ls",
  EnvVariableReadCliEnvPull: "env-variable-read:cli:env:pull",
  EnvVariableReadV0EnvPull: "env-variable-read:v0:env:pull",
  EnvVariableReadUnknownSource: "env-variable-read:unknown-source",
  SharedEnvVariableCreate: "shared-env-variable-create",
  SharedEnvVariableDelete: "shared-env-variable-delete",
  SharedEnvVariableUpdate: "shared-env-variable-update",
  SharedEnvVariableRead: "shared-env-variable-read",
  SecurityPlusUpdated: "security-plus-updated",
  FirewallConfigPromoted: "firewall-config-promoted",
  FirewallBypassCreated: "firewall-bypass-created",
  FirewallBypassDeleted: "firewall-bypass-deleted",
  FirewallManagedRulesetUpdated: "firewall-managed-ruleset-updated",
  FirewallManagedRulegroupUpdated: "firewall-managed-rulegroup-updated",
  AttackModeEnabled: "attack-mode-enabled",
  AttackModeDisabled: "attack-mode-disabled",
  FlagsSDKKey: "flags-sdk-key",
  IntegrationScopeChanged: "integration-scope-changed",
  IntegrationConfigurationOwnerChanged:
    "integration-configuration-owner-changed",
  IntegrationConfigurationsDisabled: "integration-configurations-disabled",
  IntegrationInstallationBillingPlanUpdated:
    "integration-installation-billing-plan-updated",
  IntegrationInstallationCompleted: "integration-installation-completed",
  IntegrationInstallationRemoved: "integration-installation-removed",
  IntegrationInstallationPermissionUpdated:
    "integration-installation-permission-updated",
  InstantRollbackCreated: "instant-rollback-created",
  DisabledIntegrationInstallationRemoved:
    "disabled-integration-installation-removed",
  IntegrationConfigurationScopeChangeConfirmed:
    "integration-configuration-scope-change-confirmed",
  LogDrainCreated: "log-drain-created",
  LogDrainDeleted: "log-drain-deleted",
  LogDrainEnabled: "log-drain-enabled",
  LogDrainDisabled: "log-drain-disabled",
  Login: "login",
  Signup: "signup",
  SignupViaBitbucket: "signup-via-bitbucket",
  SignupViaGithub: "signup-via-github",
  SignupViaGitlab: "signup-via-gitlab",
  DrainCreated: "drain-created",
  DrainDeleted: "drain-deleted",
  DrainDisabled: "drain-disabled",
  DrainEnabled: "drain-enabled",
  DrainUpdated: "drain-updated",
  ManualDeploymentPromotionCreated: "manual-deployment-promotion-created",
  ObservabilityDisabled: "observability-disabled",
  ObservabilityEnabled: "observability-enabled",
  ObservabilityPlusProjectEnabled: "observability-plus-project-enabled",
  ObservabilityPlusProjectDisabled: "observability-plus-project-disabled",
  Plan: "plan",
  ProductionBranchUpdated: "production-branch-updated",
  ProjectAnalyticsDisabled: "project-analytics-disabled",
  ProjectAnalyticsEnabled: "project-analytics-enabled",
  ProjectSpeedInsightsDisabled: "project-speed-insights-disabled",
  ProjectSpeedInsightsEnabled: "project-speed-insights-enabled",
  ProjectDelete: "project-delete",
  ProjectCreated: "project-created",
  ProjectCronJobsToggled: "project-cron-jobs-toggled",
  ProjectGitRepositoryConnected: "project-git-repository-connected",
  ProjectGitRepositoryDisconnected: "project-git-repository-disconnected",
  ProjectGitPrCommentsToggled: "project-git-pr-comments-toggled",
  ProjectGitCommitCommentsToggled: "project-git-commit-comments-toggled",
  ProjectGitRepositoryDispatchEventsToggled:
    "project-git-repository-dispatch-events-toggled",
  ProjectGitCreateDeploymentsToggled: "project-git-create-deployments-toggled",
  ProjectGitRequireVerifiedCommitsToggled:
    "project-git-require-verified-commits-toggled",
  ProjectGitLfsToggled: "project-git-lfs-toggled",
  ProjectSsoProtection: "project-sso-protection",
  ProjectPasswordProtection: "project-password-protection",
  ProjectTrustedIps: "project-trusted-ips",
  ProjectOptionsAllowlist: "project-options-allowlist",
  ProjectAutomationBypass: "project-automation-bypass",
  ProjectDomainUnverified: "project-domain-unverified",
  ProjectDomainVerified: "project-domain-verified",
  ProjectConnectConfigurations: "project-connect-configurations",
  ProjectPaused: "project-paused",
  VercelToolbar: "vercel-toolbar",
  ProjectPreviewDeploymentSuffix: "project-preview-deployment-suffix",
  ProjectUnpaused: "project-unpaused",
  ProjectOidcTokenCreated: "project-oidc-token-created",
  ProjectOidcIssuerModeUpdated: "project-oidc-issuer-mode-updated",
  ProjectStaticIpsUpdated: "project-static-ips-updated",
  ProjectAffectedProjectsDeploymentsUpdated:
    "project-affected-projects-deployments-updated",
  ProjectAutoAssignCustomProductionDomainsUpdated:
    "project-auto-assign-custom-production-domains-updated",
  ProjectBuildCommandUpdated: "project-build-command-updated",
  ProjectPreviewEnvironmentBranchTrackingUpdated:
    "project-preview-environment-branch-tracking-updated",
  ProjectCustomEnvironmentUpdated: "project-custom-environment-updated",
  ProjectCustomEnvironmentCreated: "project-custom-environment-created",
  ProjectCustomEnvironmentDeleted: "project-custom-environment-deleted",
  ProjectFrameworkUpdated: "project-framework-updated",
  ProjectInstallCommandUpdated: "project-install-command-updated",
  ProjectNodeVersionUpdated: "project-node-version-updated",
  ProjectName: "project-name",
  ProjectOutputDirectoryUpdated: "project-output-directory-updated",
  ProjectPrioritizeProductionBuildsUpdated:
    "project-prioritize-production-builds-updated",
  ProjectRootDirectoryUpdated: "project-root-directory-updated",
  ProjectSourceFilesOutsideRootDirectoryUpdated:
    "project-source-files-outside-root-directory-updated",
  ProjectBuildMachineUpdated: "project-build-machine-updated",
  ProjectElasticConcurrencyUpdated: "project-elastic-concurrency-updated",
  ProjectFunctionsFluidDisabled: "project-functions-fluid-disabled",
  ProjectFunctionsFluidEnabled: "project-functions-fluid-enabled",
  ProjectFunctionMaxDuration: "project-function-max-duration",
  ProjectFunctionCpuMemory: "project-function-cpu-memory",
  ProjectFunctionRegions: "project-function-regions",
  ProjectFunctionFailover: "project-function-failover",
  ProjectIgnoredBuildStepUpdated: "project-ignored-build-step-updated",
  ProjectSkewProtectionThresholdUpdated:
    "project-skew-protection-threshold-updated",
  ProjectSkewProtectionMaxAgeUpdated: "project-skew-protection-max-age-updated",
  ProjectSkewProtectionAllowedDomainsUpdated:
    "project-skew-protection-allowed-domains-updated",
  ProjectCustomerSuccessCodeVisibilityUpdated:
    "project-customer-success-code-visibility-updated",
  ProjectDirectoryListing: "project-directory-listing",
  ProjectGitForkProtectionUpdated: "project-git-fork-protection-updated",
  ProjectProtectedSourcemapsUpdated: "project-protected-sourcemaps-updated",
  ProjectBuildLogsAndSourceProtectionUpdated:
    "project-build-logs-and-source-protection-updated",
  ProjectDeploymentRetentionUpdated: "project-deployment-retention-updated",
} as const;
/**
 * The type of the event.
 */
export type Type = ClosedEnum<typeof Type>;

/**
 * Metadata for {@link userId}.
 */
export type User = {
  username: string;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
};

export const UserEventPrincipalType = {
  App: "app",
} as const;
export type UserEventPrincipalType = ClosedEnum<typeof UserEventPrincipalType>;

/**
 * Metadata for {@link principalId}.
 */
export type Two = {
  type: UserEventPrincipalType;
  clientId: string;
  name: string;
};

export const PrincipalType = {
  User: "user",
} as const;
export type PrincipalType = ClosedEnum<typeof PrincipalType>;

/**
 * Metadata for {@link principalId}.
 */
export type One = {
  type?: PrincipalType | undefined;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
  username: string;
};

export type Principal = One | Two;

export const UserEventViaType = {
  App: "app",
} as const;
export type UserEventViaType = ClosedEnum<typeof UserEventViaType>;

/**
 * Metadata for {@link viaIds}.
 */
export type Via2 = {
  type: UserEventViaType;
  clientId: string;
  name: string;
};

export const ViaType = {
  User: "user",
} as const;
export type ViaType = ClosedEnum<typeof ViaType>;

/**
 * Metadata for {@link viaIds}.
 */
export type Via1 = {
  type?: ViaType | undefined;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
  username: string;
};

export type Via = Via1 | Via2;

export const GrantType = {
  AuthorizationCode: "authorization_code",
  UrnIetfParamsOauthGrantTypeDeviceCode:
    "urn:ietf:params:oauth:grant-type:device_code",
} as const;
export type GrantType = ClosedEnum<typeof GrantType>;

export const AuthMethod = {
  Email: "email",
  Saml: "saml",
  App: "app",
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Google: "google",
  Apple: "apple",
  Manual: "manual",
  Passkey: "passkey",
  Otp: "otp",
  Sms: "sms",
  Invite: "invite",
  Emu: "emu",
} as const;
export type AuthMethod = ClosedEnum<typeof AuthMethod>;

export const Method = {
  None: "none",
  ClientSecretBasic: "client_secret_basic",
  ClientSecretPost: "client_secret_post",
  ClientSecretJwt: "client_secret_jwt",
  PrivateKeyJwt: "private_key_jwt",
  OidcToken: "oidc_token",
} as const;
export type Method = ClosedEnum<typeof Method>;

export type ClientAuthenticationUsed = {
  method: Method;
  secretId?: string | undefined;
};

/**
 * optional since entries prior to 2025-10-13 do not contain app information
 */
export type PayloadApp = {
  clientId: string;
  /**
   * the app's name at the time the event was published (it could have changed since then)
   */
  name: string;
  clientAuthenticationUsed: ClientAuthenticationUsed;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSeventy = {
  grantType: GrantType;
  /**
   * the app's name at the time the event was published (it could have changed since then)
   */
  appName: string;
  /**
   * access_token TTL
   */
  atTTL: number;
  /**
   * refresh_token TTL
   */
  rtTTL?: number | undefined;
  scope: string;
  authMethod: AuthMethod;
  /**
   * optional since entries prior to 2025-10-13 do not contain app information
   */
  app?: PayloadApp | undefined;
  /**
   * optional since entries prior to 2025-10-13 do not contain this field
   */
  includesRefreshToken?: boolean | undefined;
  /**
   * optional since entries prior to 2025-10-13 do not contain this field
   */
  publicId?: string | undefined;
  /**
   * optional since entries prior to 2025-10-13 do not contain this field
   */
  sessionId?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyNine = {
  deploymentId: string;
  projectId: string;
  runId: string;
};

export type UserEventJobPayloadProject = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/**
 * GitLab
 */
export type UserEventJobPayload2687HeadInfo = {
  project: UserEventJobPayloadProject;
  ref: string;
  sha: string;
};

export type UserEventJobProject = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

export type UserEventJobPayload2687GitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

export const UserEventJobPayload2687Provider = {
  Gitlab: "gitlab",
} as const;
export type UserEventJobPayload2687Provider = ClosedEnum<
  typeof UserEventJobPayload2687Provider
>;

export type Job7 = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  /**
   * GitLab
   */
  headInfo: UserEventJobPayload2687HeadInfo;
  linkedProjectId?: string | undefined;
  prId: number;
  project: UserEventJobProject;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  sha: string;
  type: "gitlab-now-comment";
  gitComments?: UserEventJobPayload2687GitComments | undefined;
  provider: UserEventJobPayload2687Provider;
};

/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export const UserEventJobPayloadGitHashtagVercel = {
  NumberVERCELSDDJBEFOREBUILDJOBQUEUEDERROR:
    "#VERCEL_SDDJ_BEFORE_BUILD_JOB_QUEUED_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCEERROR:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_CANCEL",
  NumberVERCELSDDJAFTERVERIFYFORCEERROR:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_ERROR",
  NumberVERCELSDDJAFTERVERIFYFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_CANCEL",
  NumberVERCELSDDJFORCEGITFORKERROR: "#VERCEL_SDDJ_FORCE_GIT_FORK_ERROR",
  NumberVERCELBUILDPRIO1: "#VERCEL_BUILD_PRIO_1",
  NumberVERCELBUILDPRIO2: "#VERCEL_BUILD_PRIO_2",
  NumberVERCELBUILDPRIO3: "#VERCEL_BUILD_PRIO_3",
  NumberVERCELBUILDPRIO4: "#VERCEL_BUILD_PRIO_4",
  NumberVERCELBUILDPRIO5: "#VERCEL_BUILD_PRIO_5",
  NumberVERCELBUILDPRIO6: "#VERCEL_BUILD_PRIO_6",
  NumberVERCELBUILDPRIO7: "#VERCEL_BUILD_PRIO_7",
  NumberVERCELBUILDPRIO8: "#VERCEL_BUILD_PRIO_8",
  NumberVERCELBUILDPRIO9: "#VERCEL_BUILD_PRIO_9",
  NumberVERCELBUILDPRIO10: "#VERCEL_BUILD_PRIO_10",
  NumberVERCELSKIP: "#VERCEL_SKIP",
  NumberVERCELV0MESSAGE: "#VERCEL_V0_MESSAGE",
} as const;
/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export type UserEventJobPayloadGitHashtagVercel = ClosedEnum<
  typeof UserEventJobPayloadGitHashtagVercel
>;

/**
 * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
 */
export type UserEventJobPayload2686GitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export const UserEventJobPayloadCommitVerification = {
  Unknown: "unknown",
  Verified: "verified",
  Unverified: "unverified",
} as const;
/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export type UserEventJobPayloadCommitVerification = ClosedEnum<
  typeof UserEventJobPayloadCommitVerification
>;

export type Commit = {
  id: string;
  authorAvatar?: string | null | undefined;
  authorEmail?: string | null | undefined;
  authorId?: number | null | undefined;
  authorLogin?: string | null | undefined;
  authorName?: string | null | undefined;
};

export type UserEventJobPayload268DeployHook = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

export type UserEventJobPayload268Project = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/**
 * GitLab
 */
export type UserEventJobPayload2686HeadInfo = {
  project: UserEventJobPayload268Project;
  ref: string;
  sha: string;
};

export type JobProject = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

export const UserEventJobPayload2686Provider = {
  Gitlab: "gitlab",
} as const;
export type UserEventJobPayload2686Provider = ClosedEnum<
  typeof UserEventJobPayload2686Provider
>;

export type Job6 = {
  type: "gitlab-push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  /**
   * Since December 2022 All project ids associated to this job. Think monorepo. This job will be for one of these project.
   */
  jobProjectIds?: Array<string> | undefined;
  /**
   * Since December 2022 Pairs of projects and owner ids to build for this build request.
   */
  jobPairs?: Array<Array<string>> | undefined;
  /**
   * Since June 2024 Pairs of projects and owner ids to immediately finish (without building) because we want to create them in a skipped state.
   */
  skippedJobPairs?: Array<Array<string>> | undefined;
  /**
   * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
   */
  gitHashtagVercel?: Array<UserEventJobPayloadGitHashtagVercel> | undefined;
  /**
   * Since April 2023 Cached count of how many projects are connected to the repo. Saves a few Cosmos queries down the road in the main flow.
   */
  connectedProjectCount?: number | undefined;
  /**
   * Since April 2023 If set then it is a cached result of asking the remote for the PR ID the commit that triggered this Job. Or zero if it was not a PR. This prevents a few git round trips by the git updater.
   */
  prIdOrZero?: number | undefined;
  /**
   * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
   */
  gitComments?: UserEventJobPayload2686GitComments | undefined;
  /**
   * Since 28 Feb 2024 If set to true, identifies that the git job was created for a manual git deployment
   */
  isManualGitDeploy?: boolean | undefined;
  /**
   * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
   */
  commitVerification?: UserEventJobPayloadCommitVerification | undefined;
  commit?: Commit | undefined;
  createdAt?: number | undefined;
  deployHook?: UserEventJobPayload268DeployHook | undefined;
  deploymentId?: string | undefined;
  eventful?: boolean | undefined;
  forceNew?: boolean | undefined;
  /**
   * GitLab
   */
  headInfo: UserEventJobPayload2686HeadInfo;
  linkedProjectId?: string | undefined;
  prId?: number | undefined;
  project: JobProject;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoPushedAt?: number | null | undefined;
  sha: string;
  silent?: boolean | undefined;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: UserEventJobPayload2686Provider;
};

/**
 * Information about the head commit/branch for a GitHub repository
 */
export type UserEventJobPayload268HeadInfo = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

export type UserEventJobPayload268GitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

export const UserEventJobPayload2685Provider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
} as const;
export type UserEventJobPayload2685Provider = ClosedEnum<
  typeof UserEventJobPayload2685Provider
>;

export type Job5 = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  /**
   * Information about the head commit/branch for a GitHub repository
   */
  headInfo: UserEventJobPayload268HeadInfo;
  beforeSha?: string | undefined;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  prId: number;
  projectId?: any | null | undefined;
  customEnvId?: any | null | undefined;
  repo: string;
  repoId: number;
  type: "now-comment";
  gitComments?: UserEventJobPayload268GitComments | undefined;
  provider: UserEventJobPayload2685Provider;
  customHost?: string | undefined;
};

export type CommitInfo = {
  total: number;
  earliestSha?: string | undefined;
};

/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export const UserEventJobGitHashtagVercel = {
  NumberVERCELSDDJBEFOREBUILDJOBQUEUEDERROR:
    "#VERCEL_SDDJ_BEFORE_BUILD_JOB_QUEUED_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCEERROR:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_CANCEL",
  NumberVERCELSDDJAFTERVERIFYFORCEERROR:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_ERROR",
  NumberVERCELSDDJAFTERVERIFYFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_CANCEL",
  NumberVERCELSDDJFORCEGITFORKERROR: "#VERCEL_SDDJ_FORCE_GIT_FORK_ERROR",
  NumberVERCELBUILDPRIO1: "#VERCEL_BUILD_PRIO_1",
  NumberVERCELBUILDPRIO2: "#VERCEL_BUILD_PRIO_2",
  NumberVERCELBUILDPRIO3: "#VERCEL_BUILD_PRIO_3",
  NumberVERCELBUILDPRIO4: "#VERCEL_BUILD_PRIO_4",
  NumberVERCELBUILDPRIO5: "#VERCEL_BUILD_PRIO_5",
  NumberVERCELBUILDPRIO6: "#VERCEL_BUILD_PRIO_6",
  NumberVERCELBUILDPRIO7: "#VERCEL_BUILD_PRIO_7",
  NumberVERCELBUILDPRIO8: "#VERCEL_BUILD_PRIO_8",
  NumberVERCELBUILDPRIO9: "#VERCEL_BUILD_PRIO_9",
  NumberVERCELBUILDPRIO10: "#VERCEL_BUILD_PRIO_10",
  NumberVERCELSKIP: "#VERCEL_SKIP",
  NumberVERCELV0MESSAGE: "#VERCEL_V0_MESSAGE",
} as const;
/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export type UserEventJobGitHashtagVercel = ClosedEnum<
  typeof UserEventJobGitHashtagVercel
>;

/**
 * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
 */
export type UserEventJobPayloadGitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export const UserEventJobCommitVerification = {
  Unknown: "unknown",
  Verified: "verified",
  Unverified: "unverified",
} as const;
/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export type UserEventJobCommitVerification = ClosedEnum<
  typeof UserEventJobCommitVerification
>;

export type UserEventJobPayloadDeployHook = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/**
 * Information about the head commit/branch for a GitHub repository
 */
export type UserEventJobPayloadHeadInfo = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

export const UserEventJobPayload268Provider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
} as const;
export type UserEventJobPayload268Provider = ClosedEnum<
  typeof UserEventJobPayload268Provider
>;

export type Job4 = {
  repoPushedAt: number | null;
  commitInfo?: CommitInfo | undefined;
  forced?: boolean | undefined;
  type: "push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  /**
   * Since December 2022 All project ids associated to this job. Think monorepo. This job will be for one of these project.
   */
  jobProjectIds?: Array<string> | undefined;
  /**
   * Since December 2022 Pairs of projects and owner ids to build for this build request.
   */
  jobPairs?: Array<Array<string>> | undefined;
  /**
   * Since June 2024 Pairs of projects and owner ids to immediately finish (without building) because we want to create them in a skipped state.
   */
  skippedJobPairs?: Array<Array<string>> | undefined;
  /**
   * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
   */
  gitHashtagVercel?: Array<UserEventJobGitHashtagVercel> | undefined;
  /**
   * Since April 2023 Cached count of how many projects are connected to the repo. Saves a few Cosmos queries down the road in the main flow.
   */
  connectedProjectCount?: number | undefined;
  /**
   * Since April 2023 If set then it is a cached result of asking the remote for the PR ID the commit that triggered this Job. Or zero if it was not a PR. This prevents a few git round trips by the git updater.
   */
  prIdOrZero?: number | undefined;
  /**
   * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
   */
  gitComments?: UserEventJobPayloadGitComments | undefined;
  /**
   * Since 28 Feb 2024 If set to true, identifies that the git job was created for a manual git deployment
   */
  isManualGitDeploy?: boolean | undefined;
  /**
   * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
   */
  commitVerification?: UserEventJobCommitVerification | undefined;
  /**
   * Remote account id of the committer details (github id etc, not vercel). Note that the committer name/email are user input verbatim and not verified. Github does appear to resolve the given email to the username so we can trust that. If the username matches that of the sender, which is verified info, then we can use the account id and account type. See api-incoming, where we determine and set this property Note that even with that, the account may still have been spoofed.
   */
  committerGitUserId?: number | undefined;
  /**
   * Remote account type of the committer details (github type etc, not vercel). Note that the committer name/email are user input verbatim and not verified. Github does appear to resolve the given email to the username so we can trust that. If the username matches that of the sender, which is verified info, then we can use the account id and account type. See api-incoming, where we determine and set this property Note that even with that, the account may still have been spoofed.
   */
  committerGitUserType?: string | undefined;
  createdAt?: number | undefined;
  forceNew?: boolean | undefined;
  deploymentId?: string | undefined;
  deployHook?: UserEventJobPayloadDeployHook | undefined;
  beforeSha?: string | undefined;
  defaultBranch?: string | undefined;
  eventful?: boolean | undefined;
  githubDeploymentId?: string | undefined;
  /**
   * Information about the head commit/branch for a GitHub repository
   */
  headInfo: UserEventJobPayloadHeadInfo;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  prId: number | null;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  repo: string;
  repoId: number;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: UserEventJobPayload268Provider;
  customHost?: string | undefined;
};

/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export const JobGitHashtagVercel = {
  NumberVERCELSDDJBEFOREBUILDJOBQUEUEDERROR:
    "#VERCEL_SDDJ_BEFORE_BUILD_JOB_QUEUED_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCEERROR:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_CANCEL",
  NumberVERCELSDDJAFTERVERIFYFORCEERROR:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_ERROR",
  NumberVERCELSDDJAFTERVERIFYFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_CANCEL",
  NumberVERCELSDDJFORCEGITFORKERROR: "#VERCEL_SDDJ_FORCE_GIT_FORK_ERROR",
  NumberVERCELBUILDPRIO1: "#VERCEL_BUILD_PRIO_1",
  NumberVERCELBUILDPRIO2: "#VERCEL_BUILD_PRIO_2",
  NumberVERCELBUILDPRIO3: "#VERCEL_BUILD_PRIO_3",
  NumberVERCELBUILDPRIO4: "#VERCEL_BUILD_PRIO_4",
  NumberVERCELBUILDPRIO5: "#VERCEL_BUILD_PRIO_5",
  NumberVERCELBUILDPRIO6: "#VERCEL_BUILD_PRIO_6",
  NumberVERCELBUILDPRIO7: "#VERCEL_BUILD_PRIO_7",
  NumberVERCELBUILDPRIO8: "#VERCEL_BUILD_PRIO_8",
  NumberVERCELBUILDPRIO9: "#VERCEL_BUILD_PRIO_9",
  NumberVERCELBUILDPRIO10: "#VERCEL_BUILD_PRIO_10",
  NumberVERCELSKIP: "#VERCEL_SKIP",
  NumberVERCELV0MESSAGE: "#VERCEL_V0_MESSAGE",
} as const;
/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export type JobGitHashtagVercel = ClosedEnum<typeof JobGitHashtagVercel>;

/**
 * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
 */
export type UserEventJobGitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export const JobCommitVerification = {
  Unknown: "unknown",
  Verified: "verified",
  Unverified: "unverified",
} as const;
/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export type JobCommitVerification = ClosedEnum<typeof JobCommitVerification>;

export type UserEventJobDeployHook = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/**
 * Information about the head commit/branch for a GitHub repository
 */
export type UserEventJobHeadInfo = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

export const UserEventJobPayloadProvider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
} as const;
export type UserEventJobPayloadProvider = ClosedEnum<
  typeof UserEventJobPayloadProvider
>;

export type Job3 = {
  prId: number;
  type: "pr";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  /**
   * Since December 2022 All project ids associated to this job. Think monorepo. This job will be for one of these project.
   */
  jobProjectIds?: Array<string> | undefined;
  /**
   * Since December 2022 Pairs of projects and owner ids to build for this build request.
   */
  jobPairs?: Array<Array<string>> | undefined;
  /**
   * Since June 2024 Pairs of projects and owner ids to immediately finish (without building) because we want to create them in a skipped state.
   */
  skippedJobPairs?: Array<Array<string>> | undefined;
  /**
   * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
   */
  gitHashtagVercel?: Array<JobGitHashtagVercel> | undefined;
  /**
   * Since April 2023 Cached count of how many projects are connected to the repo. Saves a few Cosmos queries down the road in the main flow.
   */
  connectedProjectCount?: number | undefined;
  /**
   * Since April 2023 If set then it is a cached result of asking the remote for the PR ID the commit that triggered this Job. Or zero if it was not a PR. This prevents a few git round trips by the git updater.
   */
  prIdOrZero?: number | undefined;
  /**
   * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
   */
  gitComments?: UserEventJobGitComments | undefined;
  /**
   * Since 28 Feb 2024 If set to true, identifies that the git job was created for a manual git deployment
   */
  isManualGitDeploy?: boolean | undefined;
  /**
   * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
   */
  commitVerification?: JobCommitVerification | undefined;
  /**
   * Remote account id of the committer details (github id etc, not vercel). Note that the committer name/email are user input verbatim and not verified. Github does appear to resolve the given email to the username so we can trust that. If the username matches that of the sender, which is verified info, then we can use the account id and account type. See api-incoming, where we determine and set this property Note that even with that, the account may still have been spoofed.
   */
  committerGitUserId?: number | undefined;
  /**
   * Remote account type of the committer details (github type etc, not vercel). Note that the committer name/email are user input verbatim and not verified. Github does appear to resolve the given email to the username so we can trust that. If the username matches that of the sender, which is verified info, then we can use the account id and account type. See api-incoming, where we determine and set this property Note that even with that, the account may still have been spoofed.
   */
  committerGitUserType?: string | undefined;
  createdAt?: number | undefined;
  forceNew?: boolean | undefined;
  deploymentId?: string | undefined;
  deployHook?: UserEventJobDeployHook | undefined;
  beforeSha?: string | undefined;
  defaultBranch?: string | undefined;
  eventful?: boolean | undefined;
  githubDeploymentId?: string | undefined;
  /**
   * Information about the head commit/branch for a GitHub repository
   */
  headInfo: UserEventJobHeadInfo;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  repo: string;
  repoId: number;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: UserEventJobPayloadProvider;
  customHost?: string | undefined;
};

export type JobHeadInfo = {
  owner: string;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
};

export type JobGitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

export const UserEventJobProvider = {
  Bitbucket: "bitbucket",
} as const;
export type UserEventJobProvider = ClosedEnum<typeof UserEventJobProvider>;

/**
 * Represents the payload for a Bitbucket comment job This interface defines the structure of data needed when creating a job to handle comments on Bitbucket pull requests or commits.
 */
export type Job2 = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  headInfo: JobHeadInfo;
  linkedProjectId?: string | undefined;
  name: string;
  owner: string;
  prId: number;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
  type: "bitbucket-now-comment";
  workspaceUuid: string;
  gitComments?: JobGitComments | undefined;
  provider: UserEventJobProvider;
};

/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export const GitHashtagVercel = {
  NumberVERCELSDDJBEFOREBUILDJOBQUEUEDERROR:
    "#VERCEL_SDDJ_BEFORE_BUILD_JOB_QUEUED_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCEERROR:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_ERROR",
  NumberVERCELSDDJAFTERGETREPOFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_GET_REPO_FORCE_CANCEL",
  NumberVERCELSDDJAFTERVERIFYFORCEERROR:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_ERROR",
  NumberVERCELSDDJAFTERVERIFYFORCECANCEL:
    "#VERCEL_SDDJ_AFTER_VERIFY_FORCE_CANCEL",
  NumberVERCELSDDJFORCEGITFORKERROR: "#VERCEL_SDDJ_FORCE_GIT_FORK_ERROR",
  NumberVERCELBUILDPRIO1: "#VERCEL_BUILD_PRIO_1",
  NumberVERCELBUILDPRIO2: "#VERCEL_BUILD_PRIO_2",
  NumberVERCELBUILDPRIO3: "#VERCEL_BUILD_PRIO_3",
  NumberVERCELBUILDPRIO4: "#VERCEL_BUILD_PRIO_4",
  NumberVERCELBUILDPRIO5: "#VERCEL_BUILD_PRIO_5",
  NumberVERCELBUILDPRIO6: "#VERCEL_BUILD_PRIO_6",
  NumberVERCELBUILDPRIO7: "#VERCEL_BUILD_PRIO_7",
  NumberVERCELBUILDPRIO8: "#VERCEL_BUILD_PRIO_8",
  NumberVERCELBUILDPRIO9: "#VERCEL_BUILD_PRIO_9",
  NumberVERCELBUILDPRIO10: "#VERCEL_BUILD_PRIO_10",
  NumberVERCELSKIP: "#VERCEL_SKIP",
  NumberVERCELV0MESSAGE: "#VERCEL_V0_MESSAGE",
} as const;
/**
 * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
 */
export type GitHashtagVercel = ClosedEnum<typeof GitHashtagVercel>;

/**
 * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
 */
export type GitComments = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export const CommitVerification = {
  Unknown: "unknown",
  Verified: "verified",
  Unverified: "unverified",
} as const;
/**
 * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
 */
export type CommitVerification = ClosedEnum<typeof CommitVerification>;

export type JobDeployHook = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

export type HeadInfo = {
  owner: string;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
};

export const JobProvider = {
  Bitbucket: "bitbucket",
} as const;
export type JobProvider = ClosedEnum<typeof JobProvider>;

export type Job1 = {
  type: "bitbucket-push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  /**
   * Since December 2022 All project ids associated to this job. Think monorepo. This job will be for one of these project.
   */
  jobProjectIds?: Array<string> | undefined;
  /**
   * Since December 2022 Pairs of projects and owner ids to build for this build request.
   */
  jobPairs?: Array<Array<string>> | undefined;
  /**
   * Since June 2024 Pairs of projects and owner ids to immediately finish (without building) because we want to create them in a skipped state.
   */
  skippedJobPairs?: Array<Array<string>> | undefined;
  /**
   * Since February 2022 All the hashtag-vercel tags found in the commit message triggering the deploy. For example, #VERCEL_DO_SOMETHING
   */
  gitHashtagVercel?: Array<GitHashtagVercel> | undefined;
  /**
   * Since April 2023 Cached count of how many projects are connected to the repo. Saves a few Cosmos queries down the road in the main flow.
   */
  connectedProjectCount?: number | undefined;
  /**
   * Since April 2023 If set then it is a cached result of asking the remote for the PR ID the commit that triggered this Job. Or zero if it was not a PR. This prevents a few git round trips by the git updater.
   */
  prIdOrZero?: number | undefined;
  /**
   * Since June 2023 Determines if comments should be posted to the git host. Replaces `github.silent` in the vercel.json.
   */
  gitComments?: GitComments | undefined;
  /**
   * Since 28 Feb 2024 If set to true, identifies that the git job was created for a manual git deployment
   */
  isManualGitDeploy?: boolean | undefined;
  /**
   * Since 6 Nov 2025 The verification status of the commit. - 'verified' if the commit is verified - 'unverified' if the commit is not verified - 'unknown' if the commit verification status is unknown or not supported
   */
  commitVerification?: CommitVerification | undefined;
  createdAt?: number | undefined;
  deploymentId?: string | undefined;
  deployHook?: JobDeployHook | undefined;
  eventful?: boolean | undefined;
  forceNew?: boolean | undefined;
  headInfo: HeadInfo;
  linkedProjectId?: string | undefined;
  name: string;
  owner: string;
  prId?: number | undefined;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoPushedAt?: number | null | undefined;
  repoUuid: string;
  sha: string;
  silent?: boolean | undefined;
  slug: string;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  workspaceUuid: string;
  provider: JobProvider;
};

export type PayloadJob = Job1 | Job2 | Job3 | Job4 | Job5 | Job6 | Job7;

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyEight = {
  job: Job1 | Job2 | Job3 | Job4 | Job5 | Job6 | Job7;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtySeven = {
  trialCreditsIssuedAt: number;
  expiresAt: string;
  amount: string;
  currency: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtySix = {
  inviteCode?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyFive = {
  emailDomain?: string | null | undefined;
};

export const PayloadPlan = {
  Pro: "pro",
  Enterprise: "enterprise",
  Hobby: "hobby",
} as const;
export type PayloadPlan = ClosedEnum<typeof PayloadPlan>;

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyFour = {
  invoiceId: string;
  convertedFromTrial: boolean;
  plan: PayloadPlan;
};

export const Plan = {
  Pro: "pro",
  Enterprise: "enterprise",
  Hobby: "hobby",
} as const;
export type Plan = ClosedEnum<typeof Plan>;

export type Trial = {
  start: number;
  end: number;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyThree = {
  plan: Plan;
  trial?: Trial | null | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyTwo = {
  projectId: string;
  projectName: string;
  target: string;
  domain: string;
  configuredBy?: string | null | undefined;
  prevConfiguredBy?: string | null | undefined;
};

export const UserEventPayload261Role = {
  Admin: "ADMIN",
  ProjectDeveloper: "PROJECT_DEVELOPER",
  ProjectViewer: "PROJECT_VIEWER",
  ProjectGuest: "PROJECT_GUEST",
} as const;
export type UserEventPayload261Role = ClosedEnum<
  typeof UserEventPayload261Role
>;

export type PayloadProjects = {
  projectId: string;
  role: UserEventPayload261Role;
  membershipCreatedAt: number;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixtyOne = {
  projects: Array<PayloadProjects>;
  uid: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndSixty = {
  projectId: string;
  projectName: string;
  domain: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyNine = {
  oldProjectId: string;
  oldProjectName: string;
  newProjectId: string;
  newProjectName: string;
  domain: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyEight = {
  projectId: string;
  projectName: string;
  domain: string;
  target: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftySeven = {
  projectId: string;
  projectName: string;
  domain: string;
  target: string;
  redirect: string | null;
  redirectStatusCode: number | null;
  gitBranch: string | null;
  configuredBy?: string | undefined;
};

export type EdgeConfig = {
  id: string;
  slug: string;
};

export const UserEventPayload256Type = {
  Team: "team",
  User: "user",
} as const;
export type UserEventPayload256Type = ClosedEnum<
  typeof UserEventPayload256Type
>;

export type FromAccount = {
  id: string;
  type: UserEventPayload256Type;
  slug?: string | undefined;
  username?: string | undefined;
};

export const UserEventPayload256ToAccountType = {
  Team: "team",
  User: "user",
} as const;
export type UserEventPayload256ToAccountType = ClosedEnum<
  typeof UserEventPayload256ToAccountType
>;

export type ToAccount = {
  id: string;
  type: UserEventPayload256ToAccountType;
  slug?: string | undefined;
  username?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftySix = {
  edgeConfig: EdgeConfig;
  fromAccount: FromAccount;
  toAccount: ToAccount;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyFive = {
  edgeConfigId: string;
  edgeConfigSlug: string;
  edgeConfigDigest?: string | undefined;
};

export type EdgeConfigSchema = {};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyFour = {
  edgeConfigId: string;
  edgeConfigSlug: string;
  edgeConfigSchema?: EdgeConfigSchema | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyThree = {
  ownerId: string;
  source: string;
  cause: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyTwo = {
  ownerId: string;
  source: string;
  cause: string;
  blockReason?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFiftyOne = {
  ownerId: string;
  source: string;
  cause: string;
  reason?: string | null | undefined;
};

export type SiftRoute = {
  name: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFifty = {
  ownerId: string;
  source: string;
  cause: string;
  blockReason?: string | undefined;
  siftRoute?: SiftRoute | undefined;
};

export type UserEventPayload249Previous = {
  sampleRatePercent: number | null;
  spendLimitInDollars: number | null;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyNine = {
  projectId?: string | undefined;
  projectName?: string | undefined;
  analyticsId?: string | undefined;
  sampleRatePercent: number | null;
  spendLimitInDollars: number | null;
  previous: UserEventPayload249Previous;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyEight = {
  ruleName: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortySeven = {
  fileId: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortySix = {
  exportId: string;
  from: number;
  to: number;
  format: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyFive = {
  domain: string;
  ips: Array<string>;
};

export const Previous2 = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type Previous2 = ClosedEnum<typeof Previous2>;

export type Previous1 = {
  accessGroupId: string;
};

export type UserEventPayload244Previous = Previous1 | Previous2;

export const Next2 = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type Next2 = ClosedEnum<typeof Next2>;

export type Next1 = {
  accessGroupId: string;
};

export type UserEventPayload244Next = Next1 | Next2;

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyFour = {
  previous?: { [k: string]: Previous1 | Previous2 } | undefined;
  next?: { [k: string]: Next1 | Next2 } | undefined;
};

export const Scope = {
  Dashboard: "dashboard",
  LogDrains: "log-drains",
} as const;
export type Scope = ClosedEnum<typeof Scope>;

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyThree = {
  enabled: boolean;
  scope: Scope;
};

export const PayloadEnabled = {
  Default: "default",
  On: "on",
  Off: "off",
} as const;
export type PayloadEnabled = ClosedEnum<typeof PayloadEnabled>;

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyTwo = {
  enabled: PayloadEnabled;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndFortyOne = {
  id: string;
  url: string;
};

export type UserEventPayload240Team = {
  id: string;
  name: string;
};

export type UserEventPayload240Configuration = {
  id: string;
  name?: string | undefined;
};

export type UserEventPayloadPeering = {
  id: string;
  name?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndForty = {
  team: UserEventPayload240Team;
  configuration: UserEventPayload240Configuration;
  peering: UserEventPayloadPeering;
  newName?: string | undefined;
};

export type UserEventPayload239Team = {
  id: string;
  name: string;
};

export type UserEventPayload239Configuration = {
  id: string;
  name?: string | undefined;
};

export type PayloadPeering = {
  id: string;
  name?: string | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndThirtyNine = {
  team: UserEventPayload239Team;
  configuration: UserEventPayload239Configuration;
  peering: PayloadPeering;
};

export type UserEventPayload238Team = {
  id: string;
  name: string;
};

export type UserEventPayload238Configuration = {
  id: string;
  name?: string | undefined;
};

export type Peering = {
  id: string;
  accountId: string;
  region: string;
  vpcId: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndThirtyEight = {
  team: UserEventPayload238Team;
  configuration: UserEventPayload238Configuration;
  peering: Peering;
};

/**
 * Note that not all historical events have this field.
 */
export type App = {
  /**
   * The App's ID.
   */
  id: string;
  /**
   * The App's name at the moment this even was published (it may have changed since then).
   */
  name: string;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndThirtySeven = {
  /**
   * The App's name at the moment this even was published (it may have changed since then).
   */
  appName: string;
  /**
   * The App's ID. Note that not all historical events have this field.
   */
  appId?: string | undefined;
  /**
   * Note that not all historical events have this field.
   */
  app?: App | undefined;
  /**
   * UNIX timestamp in seconds. Tokens issued before this timestamp will be revoked. Note that not all historical events have this field.
   */
  issuedBefore?: number | undefined;
};

export const UserEventPayload236Type = {
  List: "list",
} as const;
export type UserEventPayload236Type = ClosedEnum<
  typeof UserEventPayload236Type
>;

export const UserEventPayload236BeforeType = {
  String: "string",
} as const;
export type UserEventPayload236BeforeType = ClosedEnum<
  typeof UserEventPayload236BeforeType
>;

export type PayloadItems = {
  type: UserEventPayload236BeforeType;
};

export type UserEventPayloadProjectIds = {
  type: UserEventPayload236Type;
  required: boolean;
  items: PayloadItems;
};

export type PayloadResources = {
  projectIds: UserEventPayloadProjectIds;
};

export const UserEventPayloadPermissions = {
  ReadDomain: "read:domain",
  ReadWriteDomain: "read-write:domain",
  ReadTeam: "read:team",
  ReadBilling: "read:billing",
  ReadWriteAiGatewayApiKey: "read-write:ai-gateway-api-key",
  ReadProject: "read:project",
  ReadWriteProject: "read-write:project",
  ReadDeployment: "read:deployment",
  ReadWriteDeployment: "read-write:deployment",
} as const;
export type UserEventPayloadPermissions = ClosedEnum<
  typeof UserEventPayloadPermissions
>;

export type Before = {
  resources?: PayloadResources | undefined;
  permissions?: Array<UserEventPayloadPermissions> | undefined;
};

export const UserEventPayload236AfterType = {
  List: "list",
} as const;
export type UserEventPayload236AfterType = ClosedEnum<
  typeof UserEventPayload236AfterType
>;

export const UserEventPayload236AfterResourcesType = {
  String: "string",
} as const;
export type UserEventPayload236AfterResourcesType = ClosedEnum<
  typeof UserEventPayload236AfterResourcesType
>;

export type UserEventPayloadItems = {
  type: UserEventPayload236AfterResourcesType;
};

export type UserEventPayload236ProjectIds = {
  type: UserEventPayload236AfterType;
  required: boolean;
  items: UserEventPayloadItems;
};

export type UserEventPayloadResources = {
  projectIds: UserEventPayload236ProjectIds;
};

export const UserEventPayload236Permissions = {
  ReadDomain: "read:domain",
  ReadWriteDomain: "read-write:domain",
  ReadTeam: "read:team",
  ReadBilling: "read:billing",
  ReadWriteAiGatewayApiKey: "read-write:ai-gateway-api-key",
  ReadProject: "read:project",
  ReadWriteProject: "read-write:project",
  ReadDeployment: "read:deployment",
  ReadWriteDeployment: "read-write:deployment",
} as const;
export type UserEventPayload236Permissions = ClosedEnum<
  typeof UserEventPayload236Permissions
>;

export type After = {
  resources?: UserEventPayloadResources | undefined;
  permissions?: Array<UserEventPayload236Permissions> | undefined;
};

/**
 * The payload of the event, if requested.
 */
export type TwoHundredAndThirtySix = {
  appName: string;
  appId?: string | undefined;
  installationId?: string | undefined;
  before?: Before | undefined;
  after?: After | undefined;
};

export const UserEventPayload235Type = {
  List: "list",
} as const;
export type UserEventPayload235Type = ClosedEnum<
  typeof UserEventPayload235Type
>;

export const UserEventPayload235ResourcesType = {
  String: "string",
} as const;
export type UserEventPayload235ResourcesType = ClosedEnum<
  typeof UserEventPayload235ResourcesType
>;

export type Items = {
  type: UserEventPayload235ResourcesType;
};

export type PayloadProjectIds = {
  type: UserEventPayload235Type;
  required: boolean;
  items: Items;
};

/** @internal */
export const UserEventType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventType
> = z.nativeEnum(UserEventType);
/** @internal */
export const UserEventType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventType
> = UserEventType$inboundSchema;

/** @internal */
export const Entities$inboundSchema: z.ZodType<
  Entities,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventType$inboundSchema,
  start: types.number(),
  end: types.number(),
});
/** @internal */
export type Entities$Outbound = {
  type: string;
  start: number;
  end: number;
};

/** @internal */
export const Entities$outboundSchema: z.ZodType<
  Entities$Outbound,
  z.ZodTypeDef,
  Entities
> = z.object({
  type: UserEventType$outboundSchema,
  start: z.number(),
  end: z.number(),
});

export function entitiesToJSON(entities: Entities): string {
  return JSON.stringify(Entities$outboundSchema.parse(entities));
}
export function entitiesFromJSON(
  jsonString: string,
): SafeParseResult<Entities, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entities$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entities' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);
/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/** @internal */
export const User$inboundSchema: z.ZodType<User, z.ZodTypeDef, unknown> = z
  .object({
    username: types.string(),
    avatar: types.string(),
    email: types.string(),
    slug: types.optional(types.string()),
    uid: types.string(),
  });
/** @internal */
export type User$Outbound = {
  username: string;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
};

/** @internal */
export const User$outboundSchema: z.ZodType<User$Outbound, z.ZodTypeDef, User> =
  z.object({
    username: z.string(),
    avatar: z.string(),
    email: z.string(),
    slug: z.string().optional(),
    uid: z.string(),
  });

export function userToJSON(user: User): string {
  return JSON.stringify(User$outboundSchema.parse(user));
}
export function userFromJSON(
  jsonString: string,
): SafeParseResult<User, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => User$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'User' from JSON`,
  );
}

/** @internal */
export const UserEventPrincipalType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPrincipalType
> = z.nativeEnum(UserEventPrincipalType);
/** @internal */
export const UserEventPrincipalType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPrincipalType
> = UserEventPrincipalType$inboundSchema;

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z
  .object({
    type: UserEventPrincipalType$inboundSchema,
    clientId: types.string(),
    name: types.string(),
  });
/** @internal */
export type Two$Outbound = {
  type: string;
  clientId: string;
  name: string;
};

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .object({
    type: UserEventPrincipalType$outboundSchema,
    clientId: z.string(),
    name: z.string(),
  });

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}
export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const PrincipalType$inboundSchema: z.ZodNativeEnum<
  typeof PrincipalType
> = z.nativeEnum(PrincipalType);
/** @internal */
export const PrincipalType$outboundSchema: z.ZodNativeEnum<
  typeof PrincipalType
> = PrincipalType$inboundSchema;

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: types.optional(PrincipalType$inboundSchema),
    avatar: types.string(),
    email: types.string(),
    slug: types.optional(types.string()),
    uid: types.string(),
    username: types.string(),
  });
/** @internal */
export type One$Outbound = {
  type?: string | undefined;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
  username: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: PrincipalType$outboundSchema.optional(),
    avatar: z.string(),
    email: z.string(),
    slug: z.string().optional(),
    uid: z.string(),
    username: z.string(),
  });

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}
export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const Principal$inboundSchema: z.ZodType<
  Principal,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => One$inboundSchema),
  z.lazy(() => Two$inboundSchema),
]);
/** @internal */
export type Principal$Outbound = One$Outbound | Two$Outbound;

/** @internal */
export const Principal$outboundSchema: z.ZodType<
  Principal$Outbound,
  z.ZodTypeDef,
  Principal
> = smartUnion([
  z.lazy(() => One$outboundSchema),
  z.lazy(() => Two$outboundSchema),
]);

export function principalToJSON(principal: Principal): string {
  return JSON.stringify(Principal$outboundSchema.parse(principal));
}
export function principalFromJSON(
  jsonString: string,
): SafeParseResult<Principal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Principal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Principal' from JSON`,
  );
}

/** @internal */
export const UserEventViaType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventViaType
> = z.nativeEnum(UserEventViaType);
/** @internal */
export const UserEventViaType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventViaType
> = UserEventViaType$inboundSchema;

/** @internal */
export const Via2$inboundSchema: z.ZodType<Via2, z.ZodTypeDef, unknown> = z
  .object({
    type: UserEventViaType$inboundSchema,
    clientId: types.string(),
    name: types.string(),
  });
/** @internal */
export type Via2$Outbound = {
  type: string;
  clientId: string;
  name: string;
};

/** @internal */
export const Via2$outboundSchema: z.ZodType<Via2$Outbound, z.ZodTypeDef, Via2> =
  z.object({
    type: UserEventViaType$outboundSchema,
    clientId: z.string(),
    name: z.string(),
  });

export function via2ToJSON(via2: Via2): string {
  return JSON.stringify(Via2$outboundSchema.parse(via2));
}
export function via2FromJSON(
  jsonString: string,
): SafeParseResult<Via2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Via2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Via2' from JSON`,
  );
}

/** @internal */
export const ViaType$inboundSchema: z.ZodNativeEnum<typeof ViaType> = z
  .nativeEnum(ViaType);
/** @internal */
export const ViaType$outboundSchema: z.ZodNativeEnum<typeof ViaType> =
  ViaType$inboundSchema;

/** @internal */
export const Via1$inboundSchema: z.ZodType<Via1, z.ZodTypeDef, unknown> = z
  .object({
    type: types.optional(ViaType$inboundSchema),
    avatar: types.string(),
    email: types.string(),
    slug: types.optional(types.string()),
    uid: types.string(),
    username: types.string(),
  });
/** @internal */
export type Via1$Outbound = {
  type?: string | undefined;
  avatar: string;
  email: string;
  slug?: string | undefined;
  uid: string;
  username: string;
};

/** @internal */
export const Via1$outboundSchema: z.ZodType<Via1$Outbound, z.ZodTypeDef, Via1> =
  z.object({
    type: ViaType$outboundSchema.optional(),
    avatar: z.string(),
    email: z.string(),
    slug: z.string().optional(),
    uid: z.string(),
    username: z.string(),
  });

export function via1ToJSON(via1: Via1): string {
  return JSON.stringify(Via1$outboundSchema.parse(via1));
}
export function via1FromJSON(
  jsonString: string,
): SafeParseResult<Via1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Via1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Via1' from JSON`,
  );
}

/** @internal */
export const Via$inboundSchema: z.ZodType<Via, z.ZodTypeDef, unknown> =
  smartUnion([
    z.lazy(() => Via1$inboundSchema),
    z.lazy(() => Via2$inboundSchema),
  ]);
/** @internal */
export type Via$Outbound = Via1$Outbound | Via2$Outbound;

/** @internal */
export const Via$outboundSchema: z.ZodType<Via$Outbound, z.ZodTypeDef, Via> =
  smartUnion([
    z.lazy(() => Via1$outboundSchema),
    z.lazy(() => Via2$outboundSchema),
  ]);

export function viaToJSON(via: Via): string {
  return JSON.stringify(Via$outboundSchema.parse(via));
}
export function viaFromJSON(
  jsonString: string,
): SafeParseResult<Via, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Via$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Via' from JSON`,
  );
}

/** @internal */
export const GrantType$inboundSchema: z.ZodNativeEnum<typeof GrantType> = z
  .nativeEnum(GrantType);
/** @internal */
export const GrantType$outboundSchema: z.ZodNativeEnum<typeof GrantType> =
  GrantType$inboundSchema;

/** @internal */
export const AuthMethod$inboundSchema: z.ZodNativeEnum<typeof AuthMethod> = z
  .nativeEnum(AuthMethod);
/** @internal */
export const AuthMethod$outboundSchema: z.ZodNativeEnum<typeof AuthMethod> =
  AuthMethod$inboundSchema;

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);
/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/** @internal */
export const ClientAuthenticationUsed$inboundSchema: z.ZodType<
  ClientAuthenticationUsed,
  z.ZodTypeDef,
  unknown
> = z.object({
  method: Method$inboundSchema,
  secretId: types.optional(types.string()),
});
/** @internal */
export type ClientAuthenticationUsed$Outbound = {
  method: string;
  secretId?: string | undefined;
};

/** @internal */
export const ClientAuthenticationUsed$outboundSchema: z.ZodType<
  ClientAuthenticationUsed$Outbound,
  z.ZodTypeDef,
  ClientAuthenticationUsed
> = z.object({
  method: Method$outboundSchema,
  secretId: z.string().optional(),
});

export function clientAuthenticationUsedToJSON(
  clientAuthenticationUsed: ClientAuthenticationUsed,
): string {
  return JSON.stringify(
    ClientAuthenticationUsed$outboundSchema.parse(clientAuthenticationUsed),
  );
}
export function clientAuthenticationUsedFromJSON(
  jsonString: string,
): SafeParseResult<ClientAuthenticationUsed, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ClientAuthenticationUsed$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ClientAuthenticationUsed' from JSON`,
  );
}

/** @internal */
export const PayloadApp$inboundSchema: z.ZodType<
  PayloadApp,
  z.ZodTypeDef,
  unknown
> = z.object({
  clientId: types.string(),
  name: types.string(),
  clientAuthenticationUsed: z.lazy(() =>
    ClientAuthenticationUsed$inboundSchema
  ),
});
/** @internal */
export type PayloadApp$Outbound = {
  clientId: string;
  name: string;
  clientAuthenticationUsed: ClientAuthenticationUsed$Outbound;
};

/** @internal */
export const PayloadApp$outboundSchema: z.ZodType<
  PayloadApp$Outbound,
  z.ZodTypeDef,
  PayloadApp
> = z.object({
  clientId: z.string(),
  name: z.string(),
  clientAuthenticationUsed: z.lazy(() =>
    ClientAuthenticationUsed$outboundSchema
  ),
});

export function payloadAppToJSON(payloadApp: PayloadApp): string {
  return JSON.stringify(PayloadApp$outboundSchema.parse(payloadApp));
}
export function payloadAppFromJSON(
  jsonString: string,
): SafeParseResult<PayloadApp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadApp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadApp' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSeventy$inboundSchema: z.ZodType<
  TwoHundredAndSeventy,
  z.ZodTypeDef,
  unknown
> = z.object({
  grantType: GrantType$inboundSchema,
  appName: types.string(),
  atTTL: types.number(),
  rtTTL: types.optional(types.number()),
  scope: types.string(),
  authMethod: AuthMethod$inboundSchema,
  app: types.optional(z.lazy(() => PayloadApp$inboundSchema)),
  includesRefreshToken: types.optional(types.boolean()),
  publicId: types.optional(types.string()),
  sessionId: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndSeventy$Outbound = {
  grantType: string;
  appName: string;
  atTTL: number;
  rtTTL?: number | undefined;
  scope: string;
  authMethod: string;
  app?: PayloadApp$Outbound | undefined;
  includesRefreshToken?: boolean | undefined;
  publicId?: string | undefined;
  sessionId?: string | undefined;
};

/** @internal */
export const TwoHundredAndSeventy$outboundSchema: z.ZodType<
  TwoHundredAndSeventy$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSeventy
> = z.object({
  grantType: GrantType$outboundSchema,
  appName: z.string(),
  atTTL: z.number(),
  rtTTL: z.number().optional(),
  scope: z.string(),
  authMethod: AuthMethod$outboundSchema,
  app: z.lazy(() => PayloadApp$outboundSchema).optional(),
  includesRefreshToken: z.boolean().optional(),
  publicId: z.string().optional(),
  sessionId: z.string().optional(),
});

export function twoHundredAndSeventyToJSON(
  twoHundredAndSeventy: TwoHundredAndSeventy,
): string {
  return JSON.stringify(
    TwoHundredAndSeventy$outboundSchema.parse(twoHundredAndSeventy),
  );
}
export function twoHundredAndSeventyFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSeventy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSeventy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSeventy' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyNine$inboundSchema: z.ZodType<
  TwoHundredAndSixtyNine,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentId: types.string(),
  projectId: types.string(),
  runId: types.string(),
});
/** @internal */
export type TwoHundredAndSixtyNine$Outbound = {
  deploymentId: string;
  projectId: string;
  runId: string;
};

/** @internal */
export const TwoHundredAndSixtyNine$outboundSchema: z.ZodType<
  TwoHundredAndSixtyNine$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyNine
> = z.object({
  deploymentId: z.string(),
  projectId: z.string(),
  runId: z.string(),
});

export function twoHundredAndSixtyNineToJSON(
  twoHundredAndSixtyNine: TwoHundredAndSixtyNine,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyNine$outboundSchema.parse(twoHundredAndSixtyNine),
  );
}
export function twoHundredAndSixtyNineFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyNine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyNine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyNine' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayloadProject$inboundSchema: z.ZodType<
  UserEventJobPayloadProject,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultBranch: z.nullable(types.string()).optional(),
  id: types.string(),
  name: z.nullable(types.string()).optional(),
  namespace: z.nullable(types.string()).optional(),
  path: z.nullable(types.string()).optional(),
  url: z.nullable(types.string()).optional(),
});
/** @internal */
export type UserEventJobPayloadProject$Outbound = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/** @internal */
export const UserEventJobPayloadProject$outboundSchema: z.ZodType<
  UserEventJobPayloadProject$Outbound,
  z.ZodTypeDef,
  UserEventJobPayloadProject
> = z.object({
  defaultBranch: z.nullable(z.string()).optional(),
  id: z.string(),
  name: z.nullable(z.string()).optional(),
  namespace: z.nullable(z.string()).optional(),
  path: z.nullable(z.string()).optional(),
  url: z.nullable(z.string()).optional(),
});

export function userEventJobPayloadProjectToJSON(
  userEventJobPayloadProject: UserEventJobPayloadProject,
): string {
  return JSON.stringify(
    UserEventJobPayloadProject$outboundSchema.parse(userEventJobPayloadProject),
  );
}
export function userEventJobPayloadProjectFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayloadProject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayloadProject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayloadProject' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2687HeadInfo$inboundSchema: z.ZodType<
  UserEventJobPayload2687HeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  project: z.lazy(() => UserEventJobPayloadProject$inboundSchema),
  ref: types.string(),
  sha: types.string(),
});
/** @internal */
export type UserEventJobPayload2687HeadInfo$Outbound = {
  project: UserEventJobPayloadProject$Outbound;
  ref: string;
  sha: string;
};

/** @internal */
export const UserEventJobPayload2687HeadInfo$outboundSchema: z.ZodType<
  UserEventJobPayload2687HeadInfo$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload2687HeadInfo
> = z.object({
  project: z.lazy(() => UserEventJobPayloadProject$outboundSchema),
  ref: z.string(),
  sha: z.string(),
});

export function userEventJobPayload2687HeadInfoToJSON(
  userEventJobPayload2687HeadInfo: UserEventJobPayload2687HeadInfo,
): string {
  return JSON.stringify(
    UserEventJobPayload2687HeadInfo$outboundSchema.parse(
      userEventJobPayload2687HeadInfo,
    ),
  );
}
export function userEventJobPayload2687HeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload2687HeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload2687HeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload2687HeadInfo' from JSON`,
  );
}

/** @internal */
export const UserEventJobProject$inboundSchema: z.ZodType<
  UserEventJobProject,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultBranch: z.nullable(types.string()).optional(),
  id: types.string(),
  name: z.nullable(types.string()).optional(),
  namespace: z.nullable(types.string()).optional(),
  path: z.nullable(types.string()).optional(),
  url: z.nullable(types.string()).optional(),
});
/** @internal */
export type UserEventJobProject$Outbound = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/** @internal */
export const UserEventJobProject$outboundSchema: z.ZodType<
  UserEventJobProject$Outbound,
  z.ZodTypeDef,
  UserEventJobProject
> = z.object({
  defaultBranch: z.nullable(z.string()).optional(),
  id: z.string(),
  name: z.nullable(z.string()).optional(),
  namespace: z.nullable(z.string()).optional(),
  path: z.nullable(z.string()).optional(),
  url: z.nullable(z.string()).optional(),
});

export function userEventJobProjectToJSON(
  userEventJobProject: UserEventJobProject,
): string {
  return JSON.stringify(
    UserEventJobProject$outboundSchema.parse(userEventJobProject),
  );
}
export function userEventJobProjectFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobProject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobProject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobProject' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2687GitComments$inboundSchema: z.ZodType<
  UserEventJobPayload2687GitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type UserEventJobPayload2687GitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const UserEventJobPayload2687GitComments$outboundSchema: z.ZodType<
  UserEventJobPayload2687GitComments$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload2687GitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function userEventJobPayload2687GitCommentsToJSON(
  userEventJobPayload2687GitComments: UserEventJobPayload2687GitComments,
): string {
  return JSON.stringify(
    UserEventJobPayload2687GitComments$outboundSchema.parse(
      userEventJobPayload2687GitComments,
    ),
  );
}
export function userEventJobPayload2687GitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload2687GitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UserEventJobPayload2687GitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload2687GitComments' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2687Provider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2687Provider
> = z.nativeEnum(UserEventJobPayload2687Provider);
/** @internal */
export const UserEventJobPayload2687Provider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2687Provider
> = UserEventJobPayload2687Provider$inboundSchema;

/** @internal */
export const Job7$inboundSchema: z.ZodType<Job7, z.ZodTypeDef, unknown> = z
  .object({
    createdAt: types.optional(types.number()),
    eventful: types.optional(types.boolean()),
    headInfo: z.lazy(() => UserEventJobPayload2687HeadInfo$inboundSchema),
    linkedProjectId: types.optional(types.string()),
    prId: types.number(),
    project: z.lazy(() => UserEventJobProject$inboundSchema),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    ref: types.string(),
    sha: types.string(),
    type: types.literal("gitlab-now-comment"),
    gitComments: types.optional(
      z.lazy(() => UserEventJobPayload2687GitComments$inboundSchema),
    ),
    provider: UserEventJobPayload2687Provider$inboundSchema,
  });
/** @internal */
export type Job7$Outbound = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  headInfo: UserEventJobPayload2687HeadInfo$Outbound;
  linkedProjectId?: string | undefined;
  prId: number;
  project: UserEventJobProject$Outbound;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  sha: string;
  type: "gitlab-now-comment";
  gitComments?: UserEventJobPayload2687GitComments$Outbound | undefined;
  provider: string;
};

/** @internal */
export const Job7$outboundSchema: z.ZodType<Job7$Outbound, z.ZodTypeDef, Job7> =
  z.object({
    createdAt: z.number().optional(),
    eventful: z.boolean().optional(),
    headInfo: z.lazy(() => UserEventJobPayload2687HeadInfo$outboundSchema),
    linkedProjectId: z.string().optional(),
    prId: z.number(),
    project: z.lazy(() => UserEventJobProject$outboundSchema),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    ref: z.string(),
    sha: z.string(),
    type: z.literal("gitlab-now-comment"),
    gitComments: z.lazy(() => UserEventJobPayload2687GitComments$outboundSchema)
      .optional(),
    provider: UserEventJobPayload2687Provider$outboundSchema,
  });

export function job7ToJSON(job7: Job7): string {
  return JSON.stringify(Job7$outboundSchema.parse(job7));
}
export function job7FromJSON(
  jsonString: string,
): SafeParseResult<Job7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job7' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayloadGitHashtagVercel$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayloadGitHashtagVercel
> = z.nativeEnum(UserEventJobPayloadGitHashtagVercel);
/** @internal */
export const UserEventJobPayloadGitHashtagVercel$outboundSchema:
  z.ZodNativeEnum<typeof UserEventJobPayloadGitHashtagVercel> =
    UserEventJobPayloadGitHashtagVercel$inboundSchema;

/** @internal */
export const UserEventJobPayload2686GitComments$inboundSchema: z.ZodType<
  UserEventJobPayload2686GitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type UserEventJobPayload2686GitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const UserEventJobPayload2686GitComments$outboundSchema: z.ZodType<
  UserEventJobPayload2686GitComments$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload2686GitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function userEventJobPayload2686GitCommentsToJSON(
  userEventJobPayload2686GitComments: UserEventJobPayload2686GitComments,
): string {
  return JSON.stringify(
    UserEventJobPayload2686GitComments$outboundSchema.parse(
      userEventJobPayload2686GitComments,
    ),
  );
}
export function userEventJobPayload2686GitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload2686GitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UserEventJobPayload2686GitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload2686GitComments' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayloadCommitVerification$inboundSchema:
  z.ZodNativeEnum<typeof UserEventJobPayloadCommitVerification> = z.nativeEnum(
    UserEventJobPayloadCommitVerification,
  );
/** @internal */
export const UserEventJobPayloadCommitVerification$outboundSchema:
  z.ZodNativeEnum<typeof UserEventJobPayloadCommitVerification> =
    UserEventJobPayloadCommitVerification$inboundSchema;

/** @internal */
export const Commit$inboundSchema: z.ZodType<Commit, z.ZodTypeDef, unknown> = z
  .object({
    id: types.string(),
    authorAvatar: z.nullable(types.string()).optional(),
    authorEmail: z.nullable(types.string()).optional(),
    authorId: z.nullable(types.number()).optional(),
    authorLogin: z.nullable(types.string()).optional(),
    authorName: z.nullable(types.string()).optional(),
  });
/** @internal */
export type Commit$Outbound = {
  id: string;
  authorAvatar?: string | null | undefined;
  authorEmail?: string | null | undefined;
  authorId?: number | null | undefined;
  authorLogin?: string | null | undefined;
  authorName?: string | null | undefined;
};

/** @internal */
export const Commit$outboundSchema: z.ZodType<
  Commit$Outbound,
  z.ZodTypeDef,
  Commit
> = z.object({
  id: z.string(),
  authorAvatar: z.nullable(z.string()).optional(),
  authorEmail: z.nullable(z.string()).optional(),
  authorId: z.nullable(z.number()).optional(),
  authorLogin: z.nullable(z.string()).optional(),
  authorName: z.nullable(z.string()).optional(),
});

export function commitToJSON(commit: Commit): string {
  return JSON.stringify(Commit$outboundSchema.parse(commit));
}
export function commitFromJSON(
  jsonString: string,
): SafeParseResult<Commit, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Commit$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Commit' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload268DeployHook$inboundSchema: z.ZodType<
  UserEventJobPayload268DeployHook,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: types.number(),
  id: types.string(),
  name: types.string(),
  ref: types.string(),
});
/** @internal */
export type UserEventJobPayload268DeployHook$Outbound = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/** @internal */
export const UserEventJobPayload268DeployHook$outboundSchema: z.ZodType<
  UserEventJobPayload268DeployHook$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload268DeployHook
> = z.object({
  createdAt: z.number(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
});

export function userEventJobPayload268DeployHookToJSON(
  userEventJobPayload268DeployHook: UserEventJobPayload268DeployHook,
): string {
  return JSON.stringify(
    UserEventJobPayload268DeployHook$outboundSchema.parse(
      userEventJobPayload268DeployHook,
    ),
  );
}
export function userEventJobPayload268DeployHookFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload268DeployHook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload268DeployHook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload268DeployHook' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload268Project$inboundSchema: z.ZodType<
  UserEventJobPayload268Project,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultBranch: z.nullable(types.string()).optional(),
  id: types.string(),
  name: z.nullable(types.string()).optional(),
  namespace: z.nullable(types.string()).optional(),
  path: z.nullable(types.string()).optional(),
  url: z.nullable(types.string()).optional(),
});
/** @internal */
export type UserEventJobPayload268Project$Outbound = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/** @internal */
export const UserEventJobPayload268Project$outboundSchema: z.ZodType<
  UserEventJobPayload268Project$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload268Project
> = z.object({
  defaultBranch: z.nullable(z.string()).optional(),
  id: z.string(),
  name: z.nullable(z.string()).optional(),
  namespace: z.nullable(z.string()).optional(),
  path: z.nullable(z.string()).optional(),
  url: z.nullable(z.string()).optional(),
});

export function userEventJobPayload268ProjectToJSON(
  userEventJobPayload268Project: UserEventJobPayload268Project,
): string {
  return JSON.stringify(
    UserEventJobPayload268Project$outboundSchema.parse(
      userEventJobPayload268Project,
    ),
  );
}
export function userEventJobPayload268ProjectFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload268Project, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload268Project$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload268Project' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2686HeadInfo$inboundSchema: z.ZodType<
  UserEventJobPayload2686HeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  project: z.lazy(() => UserEventJobPayload268Project$inboundSchema),
  ref: types.string(),
  sha: types.string(),
});
/** @internal */
export type UserEventJobPayload2686HeadInfo$Outbound = {
  project: UserEventJobPayload268Project$Outbound;
  ref: string;
  sha: string;
};

/** @internal */
export const UserEventJobPayload2686HeadInfo$outboundSchema: z.ZodType<
  UserEventJobPayload2686HeadInfo$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload2686HeadInfo
> = z.object({
  project: z.lazy(() => UserEventJobPayload268Project$outboundSchema),
  ref: z.string(),
  sha: z.string(),
});

export function userEventJobPayload2686HeadInfoToJSON(
  userEventJobPayload2686HeadInfo: UserEventJobPayload2686HeadInfo,
): string {
  return JSON.stringify(
    UserEventJobPayload2686HeadInfo$outboundSchema.parse(
      userEventJobPayload2686HeadInfo,
    ),
  );
}
export function userEventJobPayload2686HeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload2686HeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload2686HeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload2686HeadInfo' from JSON`,
  );
}

/** @internal */
export const JobProject$inboundSchema: z.ZodType<
  JobProject,
  z.ZodTypeDef,
  unknown
> = z.object({
  defaultBranch: z.nullable(types.string()).optional(),
  id: types.string(),
  name: z.nullable(types.string()).optional(),
  namespace: z.nullable(types.string()).optional(),
  path: z.nullable(types.string()).optional(),
  url: z.nullable(types.string()).optional(),
});
/** @internal */
export type JobProject$Outbound = {
  defaultBranch?: string | null | undefined;
  id: string;
  name?: string | null | undefined;
  namespace?: string | null | undefined;
  path?: string | null | undefined;
  url?: string | null | undefined;
};

/** @internal */
export const JobProject$outboundSchema: z.ZodType<
  JobProject$Outbound,
  z.ZodTypeDef,
  JobProject
> = z.object({
  defaultBranch: z.nullable(z.string()).optional(),
  id: z.string(),
  name: z.nullable(z.string()).optional(),
  namespace: z.nullable(z.string()).optional(),
  path: z.nullable(z.string()).optional(),
  url: z.nullable(z.string()).optional(),
});

export function jobProjectToJSON(jobProject: JobProject): string {
  return JSON.stringify(JobProject$outboundSchema.parse(jobProject));
}
export function jobProjectFromJSON(
  jsonString: string,
): SafeParseResult<JobProject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobProject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobProject' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2686Provider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2686Provider
> = z.nativeEnum(UserEventJobPayload2686Provider);
/** @internal */
export const UserEventJobPayload2686Provider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2686Provider
> = UserEventJobPayload2686Provider$inboundSchema;

/** @internal */
export const Job6$inboundSchema: z.ZodType<Job6, z.ZodTypeDef, unknown> = z
  .object({
    type: types.literal("gitlab-push"),
    authorized: types.optional(types.boolean()),
    authorizedBy: types.optional(types.string()),
    jobProjectIds: types.optional(z.array(types.string())),
    jobPairs: types.optional(z.array(z.array(types.string()))),
    skippedJobPairs: types.optional(z.array(z.array(types.string()))),
    gitHashtagVercel: types.optional(
      z.array(UserEventJobPayloadGitHashtagVercel$inboundSchema),
    ),
    connectedProjectCount: types.optional(types.number()),
    prIdOrZero: types.optional(types.number()),
    gitComments: types.optional(
      z.lazy(() => UserEventJobPayload2686GitComments$inboundSchema),
    ),
    isManualGitDeploy: types.optional(types.boolean()),
    commitVerification: types.optional(
      UserEventJobPayloadCommitVerification$inboundSchema,
    ),
    commit: types.optional(z.lazy(() => Commit$inboundSchema)),
    createdAt: types.optional(types.number()),
    deployHook: types.optional(
      z.lazy(() => UserEventJobPayload268DeployHook$inboundSchema),
    ),
    deploymentId: types.optional(types.string()),
    eventful: types.optional(types.boolean()),
    forceNew: types.optional(types.boolean()),
    headInfo: z.lazy(() => UserEventJobPayload2686HeadInfo$inboundSchema),
    linkedProjectId: types.optional(types.string()),
    prId: types.optional(types.number()),
    project: z.lazy(() => JobProject$inboundSchema),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    ref: types.string(),
    repoPushedAt: z.nullable(types.number()).optional(),
    sha: types.string(),
    silent: types.optional(types.boolean()),
    target: z.nullable(types.string()).optional(),
    url: types.optional(types.string()),
    withCache: types.optional(types.boolean()),
    provider: UserEventJobPayload2686Provider$inboundSchema,
  });
/** @internal */
export type Job6$Outbound = {
  type: "gitlab-push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  jobProjectIds?: Array<string> | undefined;
  jobPairs?: Array<Array<string>> | undefined;
  skippedJobPairs?: Array<Array<string>> | undefined;
  gitHashtagVercel?: Array<string> | undefined;
  connectedProjectCount?: number | undefined;
  prIdOrZero?: number | undefined;
  gitComments?: UserEventJobPayload2686GitComments$Outbound | undefined;
  isManualGitDeploy?: boolean | undefined;
  commitVerification?: string | undefined;
  commit?: Commit$Outbound | undefined;
  createdAt?: number | undefined;
  deployHook?: UserEventJobPayload268DeployHook$Outbound | undefined;
  deploymentId?: string | undefined;
  eventful?: boolean | undefined;
  forceNew?: boolean | undefined;
  headInfo: UserEventJobPayload2686HeadInfo$Outbound;
  linkedProjectId?: string | undefined;
  prId?: number | undefined;
  project: JobProject$Outbound;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoPushedAt?: number | null | undefined;
  sha: string;
  silent?: boolean | undefined;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: string;
};

/** @internal */
export const Job6$outboundSchema: z.ZodType<Job6$Outbound, z.ZodTypeDef, Job6> =
  z.object({
    type: z.literal("gitlab-push"),
    authorized: z.boolean().optional(),
    authorizedBy: z.string().optional(),
    jobProjectIds: z.array(z.string()).optional(),
    jobPairs: z.array(z.array(z.string())).optional(),
    skippedJobPairs: z.array(z.array(z.string())).optional(),
    gitHashtagVercel: z.array(
      UserEventJobPayloadGitHashtagVercel$outboundSchema,
    ).optional(),
    connectedProjectCount: z.number().optional(),
    prIdOrZero: z.number().optional(),
    gitComments: z.lazy(() => UserEventJobPayload2686GitComments$outboundSchema)
      .optional(),
    isManualGitDeploy: z.boolean().optional(),
    commitVerification: UserEventJobPayloadCommitVerification$outboundSchema
      .optional(),
    commit: z.lazy(() => Commit$outboundSchema).optional(),
    createdAt: z.number().optional(),
    deployHook: z.lazy(() => UserEventJobPayload268DeployHook$outboundSchema)
      .optional(),
    deploymentId: z.string().optional(),
    eventful: z.boolean().optional(),
    forceNew: z.boolean().optional(),
    headInfo: z.lazy(() => UserEventJobPayload2686HeadInfo$outboundSchema),
    linkedProjectId: z.string().optional(),
    prId: z.number().optional(),
    project: z.lazy(() => JobProject$outboundSchema),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    ref: z.string(),
    repoPushedAt: z.nullable(z.number()).optional(),
    sha: z.string(),
    silent: z.boolean().optional(),
    target: z.nullable(z.string()).optional(),
    url: z.string().optional(),
    withCache: z.boolean().optional(),
    provider: UserEventJobPayload2686Provider$outboundSchema,
  });

export function job6ToJSON(job6: Job6): string {
  return JSON.stringify(Job6$outboundSchema.parse(job6));
}
export function job6FromJSON(
  jsonString: string,
): SafeParseResult<Job6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job6' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload268HeadInfo$inboundSchema: z.ZodType<
  UserEventJobPayload268HeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  ref: types.string(),
  repo: types.string(),
  repoId: types.number(),
  sha: types.string(),
});
/** @internal */
export type UserEventJobPayload268HeadInfo$Outbound = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

/** @internal */
export const UserEventJobPayload268HeadInfo$outboundSchema: z.ZodType<
  UserEventJobPayload268HeadInfo$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload268HeadInfo
> = z.object({
  org: z.string(),
  ref: z.string(),
  repo: z.string(),
  repoId: z.number(),
  sha: z.string(),
});

export function userEventJobPayload268HeadInfoToJSON(
  userEventJobPayload268HeadInfo: UserEventJobPayload268HeadInfo,
): string {
  return JSON.stringify(
    UserEventJobPayload268HeadInfo$outboundSchema.parse(
      userEventJobPayload268HeadInfo,
    ),
  );
}
export function userEventJobPayload268HeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload268HeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload268HeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload268HeadInfo' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload268GitComments$inboundSchema: z.ZodType<
  UserEventJobPayload268GitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type UserEventJobPayload268GitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const UserEventJobPayload268GitComments$outboundSchema: z.ZodType<
  UserEventJobPayload268GitComments$Outbound,
  z.ZodTypeDef,
  UserEventJobPayload268GitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function userEventJobPayload268GitCommentsToJSON(
  userEventJobPayload268GitComments: UserEventJobPayload268GitComments,
): string {
  return JSON.stringify(
    UserEventJobPayload268GitComments$outboundSchema.parse(
      userEventJobPayload268GitComments,
    ),
  );
}
export function userEventJobPayload268GitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayload268GitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayload268GitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayload268GitComments' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload2685Provider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2685Provider
> = z.nativeEnum(UserEventJobPayload2685Provider);
/** @internal */
export const UserEventJobPayload2685Provider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload2685Provider
> = UserEventJobPayload2685Provider$inboundSchema;

/** @internal */
export const Job5$inboundSchema: z.ZodType<Job5, z.ZodTypeDef, unknown> = z
  .object({
    createdAt: types.optional(types.number()),
    eventful: types.optional(types.boolean()),
    headInfo: z.lazy(() => UserEventJobPayload268HeadInfo$inboundSchema),
    beforeSha: types.optional(types.string()),
    installationId: types.number(),
    isPrivate: types.boolean(),
    linkedProjectId: types.optional(types.string()),
    org: types.string(),
    prId: types.number(),
    projectId: z.nullable(z.any()).optional(),
    customEnvId: z.nullable(z.any()).optional(),
    repo: types.string(),
    repoId: types.number(),
    type: types.literal("now-comment"),
    gitComments: types.optional(
      z.lazy(() => UserEventJobPayload268GitComments$inboundSchema),
    ),
    provider: UserEventJobPayload2685Provider$inboundSchema,
    customHost: types.optional(types.string()),
  });
/** @internal */
export type Job5$Outbound = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  headInfo: UserEventJobPayload268HeadInfo$Outbound;
  beforeSha?: string | undefined;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  prId: number;
  projectId?: any | null | undefined;
  customEnvId?: any | null | undefined;
  repo: string;
  repoId: number;
  type: "now-comment";
  gitComments?: UserEventJobPayload268GitComments$Outbound | undefined;
  provider: string;
  customHost?: string | undefined;
};

/** @internal */
export const Job5$outboundSchema: z.ZodType<Job5$Outbound, z.ZodTypeDef, Job5> =
  z.object({
    createdAt: z.number().optional(),
    eventful: z.boolean().optional(),
    headInfo: z.lazy(() => UserEventJobPayload268HeadInfo$outboundSchema),
    beforeSha: z.string().optional(),
    installationId: z.number(),
    isPrivate: z.boolean(),
    linkedProjectId: z.string().optional(),
    org: z.string(),
    prId: z.number(),
    projectId: z.nullable(z.any()).optional(),
    customEnvId: z.nullable(z.any()).optional(),
    repo: z.string(),
    repoId: z.number(),
    type: z.literal("now-comment"),
    gitComments: z.lazy(() => UserEventJobPayload268GitComments$outboundSchema)
      .optional(),
    provider: UserEventJobPayload2685Provider$outboundSchema,
    customHost: z.string().optional(),
  });

export function job5ToJSON(job5: Job5): string {
  return JSON.stringify(Job5$outboundSchema.parse(job5));
}
export function job5FromJSON(
  jsonString: string,
): SafeParseResult<Job5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job5' from JSON`,
  );
}

/** @internal */
export const CommitInfo$inboundSchema: z.ZodType<
  CommitInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  total: types.number(),
  earliestSha: types.optional(types.string()),
});
/** @internal */
export type CommitInfo$Outbound = {
  total: number;
  earliestSha?: string | undefined;
};

/** @internal */
export const CommitInfo$outboundSchema: z.ZodType<
  CommitInfo$Outbound,
  z.ZodTypeDef,
  CommitInfo
> = z.object({
  total: z.number(),
  earliestSha: z.string().optional(),
});

export function commitInfoToJSON(commitInfo: CommitInfo): string {
  return JSON.stringify(CommitInfo$outboundSchema.parse(commitInfo));
}
export function commitInfoFromJSON(
  jsonString: string,
): SafeParseResult<CommitInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CommitInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CommitInfo' from JSON`,
  );
}

/** @internal */
export const UserEventJobGitHashtagVercel$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobGitHashtagVercel
> = z.nativeEnum(UserEventJobGitHashtagVercel);
/** @internal */
export const UserEventJobGitHashtagVercel$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobGitHashtagVercel
> = UserEventJobGitHashtagVercel$inboundSchema;

/** @internal */
export const UserEventJobPayloadGitComments$inboundSchema: z.ZodType<
  UserEventJobPayloadGitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type UserEventJobPayloadGitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const UserEventJobPayloadGitComments$outboundSchema: z.ZodType<
  UserEventJobPayloadGitComments$Outbound,
  z.ZodTypeDef,
  UserEventJobPayloadGitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function userEventJobPayloadGitCommentsToJSON(
  userEventJobPayloadGitComments: UserEventJobPayloadGitComments,
): string {
  return JSON.stringify(
    UserEventJobPayloadGitComments$outboundSchema.parse(
      userEventJobPayloadGitComments,
    ),
  );
}
export function userEventJobPayloadGitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayloadGitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayloadGitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayloadGitComments' from JSON`,
  );
}

/** @internal */
export const UserEventJobCommitVerification$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobCommitVerification
> = z.nativeEnum(UserEventJobCommitVerification);
/** @internal */
export const UserEventJobCommitVerification$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobCommitVerification
> = UserEventJobCommitVerification$inboundSchema;

/** @internal */
export const UserEventJobPayloadDeployHook$inboundSchema: z.ZodType<
  UserEventJobPayloadDeployHook,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: types.number(),
  id: types.string(),
  name: types.string(),
  ref: types.string(),
});
/** @internal */
export type UserEventJobPayloadDeployHook$Outbound = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/** @internal */
export const UserEventJobPayloadDeployHook$outboundSchema: z.ZodType<
  UserEventJobPayloadDeployHook$Outbound,
  z.ZodTypeDef,
  UserEventJobPayloadDeployHook
> = z.object({
  createdAt: z.number(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
});

export function userEventJobPayloadDeployHookToJSON(
  userEventJobPayloadDeployHook: UserEventJobPayloadDeployHook,
): string {
  return JSON.stringify(
    UserEventJobPayloadDeployHook$outboundSchema.parse(
      userEventJobPayloadDeployHook,
    ),
  );
}
export function userEventJobPayloadDeployHookFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayloadDeployHook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayloadDeployHook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayloadDeployHook' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayloadHeadInfo$inboundSchema: z.ZodType<
  UserEventJobPayloadHeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  ref: types.string(),
  repo: types.string(),
  repoId: types.number(),
  sha: types.string(),
});
/** @internal */
export type UserEventJobPayloadHeadInfo$Outbound = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

/** @internal */
export const UserEventJobPayloadHeadInfo$outboundSchema: z.ZodType<
  UserEventJobPayloadHeadInfo$Outbound,
  z.ZodTypeDef,
  UserEventJobPayloadHeadInfo
> = z.object({
  org: z.string(),
  ref: z.string(),
  repo: z.string(),
  repoId: z.number(),
  sha: z.string(),
});

export function userEventJobPayloadHeadInfoToJSON(
  userEventJobPayloadHeadInfo: UserEventJobPayloadHeadInfo,
): string {
  return JSON.stringify(
    UserEventJobPayloadHeadInfo$outboundSchema.parse(
      userEventJobPayloadHeadInfo,
    ),
  );
}
export function userEventJobPayloadHeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobPayloadHeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobPayloadHeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobPayloadHeadInfo' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayload268Provider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload268Provider
> = z.nativeEnum(UserEventJobPayload268Provider);
/** @internal */
export const UserEventJobPayload268Provider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayload268Provider
> = UserEventJobPayload268Provider$inboundSchema;

/** @internal */
export const Job4$inboundSchema: z.ZodType<Job4, z.ZodTypeDef, unknown> = z
  .object({
    repoPushedAt: types.nullable(types.number()),
    commitInfo: types.optional(z.lazy(() => CommitInfo$inboundSchema)),
    forced: types.optional(types.boolean()),
    type: types.literal("push"),
    authorized: types.optional(types.boolean()),
    authorizedBy: types.optional(types.string()),
    jobProjectIds: types.optional(z.array(types.string())),
    jobPairs: types.optional(z.array(z.array(types.string()))),
    skippedJobPairs: types.optional(z.array(z.array(types.string()))),
    gitHashtagVercel: types.optional(
      z.array(UserEventJobGitHashtagVercel$inboundSchema),
    ),
    connectedProjectCount: types.optional(types.number()),
    prIdOrZero: types.optional(types.number()),
    gitComments: types.optional(
      z.lazy(() => UserEventJobPayloadGitComments$inboundSchema),
    ),
    isManualGitDeploy: types.optional(types.boolean()),
    commitVerification: types.optional(
      UserEventJobCommitVerification$inboundSchema,
    ),
    committerGitUserId: types.optional(types.number()),
    committerGitUserType: types.optional(types.string()),
    createdAt: types.optional(types.number()),
    forceNew: types.optional(types.boolean()),
    deploymentId: types.optional(types.string()),
    deployHook: types.optional(
      z.lazy(() => UserEventJobPayloadDeployHook$inboundSchema),
    ),
    beforeSha: types.optional(types.string()),
    defaultBranch: types.optional(types.string()),
    eventful: types.optional(types.boolean()),
    githubDeploymentId: types.optional(types.string()),
    headInfo: z.lazy(() => UserEventJobPayloadHeadInfo$inboundSchema),
    installationId: types.number(),
    isPrivate: types.boolean(),
    linkedProjectId: types.optional(types.string()),
    org: types.string(),
    prId: types.nullable(types.number()),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    repo: types.string(),
    repoId: types.number(),
    target: z.nullable(types.string()).optional(),
    url: types.optional(types.string()),
    withCache: types.optional(types.boolean()),
    provider: UserEventJobPayload268Provider$inboundSchema,
    customHost: types.optional(types.string()),
  });
/** @internal */
export type Job4$Outbound = {
  repoPushedAt: number | null;
  commitInfo?: CommitInfo$Outbound | undefined;
  forced?: boolean | undefined;
  type: "push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  jobProjectIds?: Array<string> | undefined;
  jobPairs?: Array<Array<string>> | undefined;
  skippedJobPairs?: Array<Array<string>> | undefined;
  gitHashtagVercel?: Array<string> | undefined;
  connectedProjectCount?: number | undefined;
  prIdOrZero?: number | undefined;
  gitComments?: UserEventJobPayloadGitComments$Outbound | undefined;
  isManualGitDeploy?: boolean | undefined;
  commitVerification?: string | undefined;
  committerGitUserId?: number | undefined;
  committerGitUserType?: string | undefined;
  createdAt?: number | undefined;
  forceNew?: boolean | undefined;
  deploymentId?: string | undefined;
  deployHook?: UserEventJobPayloadDeployHook$Outbound | undefined;
  beforeSha?: string | undefined;
  defaultBranch?: string | undefined;
  eventful?: boolean | undefined;
  githubDeploymentId?: string | undefined;
  headInfo: UserEventJobPayloadHeadInfo$Outbound;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  prId: number | null;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  repo: string;
  repoId: number;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: string;
  customHost?: string | undefined;
};

/** @internal */
export const Job4$outboundSchema: z.ZodType<Job4$Outbound, z.ZodTypeDef, Job4> =
  z.object({
    repoPushedAt: z.nullable(z.number()),
    commitInfo: z.lazy(() => CommitInfo$outboundSchema).optional(),
    forced: z.boolean().optional(),
    type: z.literal("push"),
    authorized: z.boolean().optional(),
    authorizedBy: z.string().optional(),
    jobProjectIds: z.array(z.string()).optional(),
    jobPairs: z.array(z.array(z.string())).optional(),
    skippedJobPairs: z.array(z.array(z.string())).optional(),
    gitHashtagVercel: z.array(UserEventJobGitHashtagVercel$outboundSchema)
      .optional(),
    connectedProjectCount: z.number().optional(),
    prIdOrZero: z.number().optional(),
    gitComments: z.lazy(() => UserEventJobPayloadGitComments$outboundSchema)
      .optional(),
    isManualGitDeploy: z.boolean().optional(),
    commitVerification: UserEventJobCommitVerification$outboundSchema
      .optional(),
    committerGitUserId: z.number().optional(),
    committerGitUserType: z.string().optional(),
    createdAt: z.number().optional(),
    forceNew: z.boolean().optional(),
    deploymentId: z.string().optional(),
    deployHook: z.lazy(() => UserEventJobPayloadDeployHook$outboundSchema)
      .optional(),
    beforeSha: z.string().optional(),
    defaultBranch: z.string().optional(),
    eventful: z.boolean().optional(),
    githubDeploymentId: z.string().optional(),
    headInfo: z.lazy(() => UserEventJobPayloadHeadInfo$outboundSchema),
    installationId: z.number(),
    isPrivate: z.boolean(),
    linkedProjectId: z.string().optional(),
    org: z.string(),
    prId: z.nullable(z.number()),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    repo: z.string(),
    repoId: z.number(),
    target: z.nullable(z.string()).optional(),
    url: z.string().optional(),
    withCache: z.boolean().optional(),
    provider: UserEventJobPayload268Provider$outboundSchema,
    customHost: z.string().optional(),
  });

export function job4ToJSON(job4: Job4): string {
  return JSON.stringify(Job4$outboundSchema.parse(job4));
}
export function job4FromJSON(
  jsonString: string,
): SafeParseResult<Job4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job4' from JSON`,
  );
}

/** @internal */
export const JobGitHashtagVercel$inboundSchema: z.ZodNativeEnum<
  typeof JobGitHashtagVercel
> = z.nativeEnum(JobGitHashtagVercel);
/** @internal */
export const JobGitHashtagVercel$outboundSchema: z.ZodNativeEnum<
  typeof JobGitHashtagVercel
> = JobGitHashtagVercel$inboundSchema;

/** @internal */
export const UserEventJobGitComments$inboundSchema: z.ZodType<
  UserEventJobGitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type UserEventJobGitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const UserEventJobGitComments$outboundSchema: z.ZodType<
  UserEventJobGitComments$Outbound,
  z.ZodTypeDef,
  UserEventJobGitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function userEventJobGitCommentsToJSON(
  userEventJobGitComments: UserEventJobGitComments,
): string {
  return JSON.stringify(
    UserEventJobGitComments$outboundSchema.parse(userEventJobGitComments),
  );
}
export function userEventJobGitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobGitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobGitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobGitComments' from JSON`,
  );
}

/** @internal */
export const JobCommitVerification$inboundSchema: z.ZodNativeEnum<
  typeof JobCommitVerification
> = z.nativeEnum(JobCommitVerification);
/** @internal */
export const JobCommitVerification$outboundSchema: z.ZodNativeEnum<
  typeof JobCommitVerification
> = JobCommitVerification$inboundSchema;

/** @internal */
export const UserEventJobDeployHook$inboundSchema: z.ZodType<
  UserEventJobDeployHook,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: types.number(),
  id: types.string(),
  name: types.string(),
  ref: types.string(),
});
/** @internal */
export type UserEventJobDeployHook$Outbound = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/** @internal */
export const UserEventJobDeployHook$outboundSchema: z.ZodType<
  UserEventJobDeployHook$Outbound,
  z.ZodTypeDef,
  UserEventJobDeployHook
> = z.object({
  createdAt: z.number(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
});

export function userEventJobDeployHookToJSON(
  userEventJobDeployHook: UserEventJobDeployHook,
): string {
  return JSON.stringify(
    UserEventJobDeployHook$outboundSchema.parse(userEventJobDeployHook),
  );
}
export function userEventJobDeployHookFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobDeployHook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobDeployHook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobDeployHook' from JSON`,
  );
}

/** @internal */
export const UserEventJobHeadInfo$inboundSchema: z.ZodType<
  UserEventJobHeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  org: types.string(),
  ref: types.string(),
  repo: types.string(),
  repoId: types.number(),
  sha: types.string(),
});
/** @internal */
export type UserEventJobHeadInfo$Outbound = {
  org: string;
  ref: string;
  repo: string;
  repoId: number;
  sha: string;
};

/** @internal */
export const UserEventJobHeadInfo$outboundSchema: z.ZodType<
  UserEventJobHeadInfo$Outbound,
  z.ZodTypeDef,
  UserEventJobHeadInfo
> = z.object({
  org: z.string(),
  ref: z.string(),
  repo: z.string(),
  repoId: z.number(),
  sha: z.string(),
});

export function userEventJobHeadInfoToJSON(
  userEventJobHeadInfo: UserEventJobHeadInfo,
): string {
  return JSON.stringify(
    UserEventJobHeadInfo$outboundSchema.parse(userEventJobHeadInfo),
  );
}
export function userEventJobHeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<UserEventJobHeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventJobHeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventJobHeadInfo' from JSON`,
  );
}

/** @internal */
export const UserEventJobPayloadProvider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayloadProvider
> = z.nativeEnum(UserEventJobPayloadProvider);
/** @internal */
export const UserEventJobPayloadProvider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobPayloadProvider
> = UserEventJobPayloadProvider$inboundSchema;

/** @internal */
export const Job3$inboundSchema: z.ZodType<Job3, z.ZodTypeDef, unknown> = z
  .object({
    prId: types.number(),
    type: types.literal("pr"),
    authorized: types.optional(types.boolean()),
    authorizedBy: types.optional(types.string()),
    jobProjectIds: types.optional(z.array(types.string())),
    jobPairs: types.optional(z.array(z.array(types.string()))),
    skippedJobPairs: types.optional(z.array(z.array(types.string()))),
    gitHashtagVercel: types.optional(
      z.array(JobGitHashtagVercel$inboundSchema),
    ),
    connectedProjectCount: types.optional(types.number()),
    prIdOrZero: types.optional(types.number()),
    gitComments: types.optional(
      z.lazy(() => UserEventJobGitComments$inboundSchema),
    ),
    isManualGitDeploy: types.optional(types.boolean()),
    commitVerification: types.optional(JobCommitVerification$inboundSchema),
    committerGitUserId: types.optional(types.number()),
    committerGitUserType: types.optional(types.string()),
    createdAt: types.optional(types.number()),
    forceNew: types.optional(types.boolean()),
    deploymentId: types.optional(types.string()),
    deployHook: types.optional(
      z.lazy(() => UserEventJobDeployHook$inboundSchema),
    ),
    beforeSha: types.optional(types.string()),
    defaultBranch: types.optional(types.string()),
    eventful: types.optional(types.boolean()),
    githubDeploymentId: types.optional(types.string()),
    headInfo: z.lazy(() => UserEventJobHeadInfo$inboundSchema),
    installationId: types.number(),
    isPrivate: types.boolean(),
    linkedProjectId: types.optional(types.string()),
    org: types.string(),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    repo: types.string(),
    repoId: types.number(),
    target: z.nullable(types.string()).optional(),
    url: types.optional(types.string()),
    withCache: types.optional(types.boolean()),
    provider: UserEventJobPayloadProvider$inboundSchema,
    customHost: types.optional(types.string()),
  });
/** @internal */
export type Job3$Outbound = {
  prId: number;
  type: "pr";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  jobProjectIds?: Array<string> | undefined;
  jobPairs?: Array<Array<string>> | undefined;
  skippedJobPairs?: Array<Array<string>> | undefined;
  gitHashtagVercel?: Array<string> | undefined;
  connectedProjectCount?: number | undefined;
  prIdOrZero?: number | undefined;
  gitComments?: UserEventJobGitComments$Outbound | undefined;
  isManualGitDeploy?: boolean | undefined;
  commitVerification?: string | undefined;
  committerGitUserId?: number | undefined;
  committerGitUserType?: string | undefined;
  createdAt?: number | undefined;
  forceNew?: boolean | undefined;
  deploymentId?: string | undefined;
  deployHook?: UserEventJobDeployHook$Outbound | undefined;
  beforeSha?: string | undefined;
  defaultBranch?: string | undefined;
  eventful?: boolean | undefined;
  githubDeploymentId?: string | undefined;
  headInfo: UserEventJobHeadInfo$Outbound;
  installationId: number;
  isPrivate: boolean;
  linkedProjectId?: string | undefined;
  org: string;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  repo: string;
  repoId: number;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  provider: string;
  customHost?: string | undefined;
};

/** @internal */
export const Job3$outboundSchema: z.ZodType<Job3$Outbound, z.ZodTypeDef, Job3> =
  z.object({
    prId: z.number(),
    type: z.literal("pr"),
    authorized: z.boolean().optional(),
    authorizedBy: z.string().optional(),
    jobProjectIds: z.array(z.string()).optional(),
    jobPairs: z.array(z.array(z.string())).optional(),
    skippedJobPairs: z.array(z.array(z.string())).optional(),
    gitHashtagVercel: z.array(JobGitHashtagVercel$outboundSchema).optional(),
    connectedProjectCount: z.number().optional(),
    prIdOrZero: z.number().optional(),
    gitComments: z.lazy(() => UserEventJobGitComments$outboundSchema)
      .optional(),
    isManualGitDeploy: z.boolean().optional(),
    commitVerification: JobCommitVerification$outboundSchema.optional(),
    committerGitUserId: z.number().optional(),
    committerGitUserType: z.string().optional(),
    createdAt: z.number().optional(),
    forceNew: z.boolean().optional(),
    deploymentId: z.string().optional(),
    deployHook: z.lazy(() => UserEventJobDeployHook$outboundSchema).optional(),
    beforeSha: z.string().optional(),
    defaultBranch: z.string().optional(),
    eventful: z.boolean().optional(),
    githubDeploymentId: z.string().optional(),
    headInfo: z.lazy(() => UserEventJobHeadInfo$outboundSchema),
    installationId: z.number(),
    isPrivate: z.boolean(),
    linkedProjectId: z.string().optional(),
    org: z.string(),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    repo: z.string(),
    repoId: z.number(),
    target: z.nullable(z.string()).optional(),
    url: z.string().optional(),
    withCache: z.boolean().optional(),
    provider: UserEventJobPayloadProvider$outboundSchema,
    customHost: z.string().optional(),
  });

export function job3ToJSON(job3: Job3): string {
  return JSON.stringify(Job3$outboundSchema.parse(job3));
}
export function job3FromJSON(
  jsonString: string,
): SafeParseResult<Job3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job3' from JSON`,
  );
}

/** @internal */
export const JobHeadInfo$inboundSchema: z.ZodType<
  JobHeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  owner: types.string(),
  ref: types.string(),
  repoUuid: types.string(),
  sha: types.string(),
  slug: types.string(),
});
/** @internal */
export type JobHeadInfo$Outbound = {
  owner: string;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
};

/** @internal */
export const JobHeadInfo$outboundSchema: z.ZodType<
  JobHeadInfo$Outbound,
  z.ZodTypeDef,
  JobHeadInfo
> = z.object({
  owner: z.string(),
  ref: z.string(),
  repoUuid: z.string(),
  sha: z.string(),
  slug: z.string(),
});

export function jobHeadInfoToJSON(jobHeadInfo: JobHeadInfo): string {
  return JSON.stringify(JobHeadInfo$outboundSchema.parse(jobHeadInfo));
}
export function jobHeadInfoFromJSON(
  jsonString: string,
): SafeParseResult<JobHeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobHeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobHeadInfo' from JSON`,
  );
}

/** @internal */
export const JobGitComments$inboundSchema: z.ZodType<
  JobGitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type JobGitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const JobGitComments$outboundSchema: z.ZodType<
  JobGitComments$Outbound,
  z.ZodTypeDef,
  JobGitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function jobGitCommentsToJSON(jobGitComments: JobGitComments): string {
  return JSON.stringify(JobGitComments$outboundSchema.parse(jobGitComments));
}
export function jobGitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<JobGitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobGitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobGitComments' from JSON`,
  );
}

/** @internal */
export const UserEventJobProvider$inboundSchema: z.ZodNativeEnum<
  typeof UserEventJobProvider
> = z.nativeEnum(UserEventJobProvider);
/** @internal */
export const UserEventJobProvider$outboundSchema: z.ZodNativeEnum<
  typeof UserEventJobProvider
> = UserEventJobProvider$inboundSchema;

/** @internal */
export const Job2$inboundSchema: z.ZodType<Job2, z.ZodTypeDef, unknown> = z
  .object({
    createdAt: types.optional(types.number()),
    eventful: types.optional(types.boolean()),
    headInfo: z.lazy(() => JobHeadInfo$inboundSchema),
    linkedProjectId: types.optional(types.string()),
    name: types.string(),
    owner: types.string(),
    prId: types.number(),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    ref: types.string(),
    repoUuid: types.string(),
    sha: types.string(),
    slug: types.string(),
    type: types.literal("bitbucket-now-comment"),
    workspaceUuid: types.string(),
    gitComments: types.optional(z.lazy(() => JobGitComments$inboundSchema)),
    provider: UserEventJobProvider$inboundSchema,
  });
/** @internal */
export type Job2$Outbound = {
  createdAt?: number | undefined;
  eventful?: boolean | undefined;
  headInfo: JobHeadInfo$Outbound;
  linkedProjectId?: string | undefined;
  name: string;
  owner: string;
  prId: number;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
  type: "bitbucket-now-comment";
  workspaceUuid: string;
  gitComments?: JobGitComments$Outbound | undefined;
  provider: string;
};

/** @internal */
export const Job2$outboundSchema: z.ZodType<Job2$Outbound, z.ZodTypeDef, Job2> =
  z.object({
    createdAt: z.number().optional(),
    eventful: z.boolean().optional(),
    headInfo: z.lazy(() => JobHeadInfo$outboundSchema),
    linkedProjectId: z.string().optional(),
    name: z.string(),
    owner: z.string(),
    prId: z.number(),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    ref: z.string(),
    repoUuid: z.string(),
    sha: z.string(),
    slug: z.string(),
    type: z.literal("bitbucket-now-comment"),
    workspaceUuid: z.string(),
    gitComments: z.lazy(() => JobGitComments$outboundSchema).optional(),
    provider: UserEventJobProvider$outboundSchema,
  });

export function job2ToJSON(job2: Job2): string {
  return JSON.stringify(Job2$outboundSchema.parse(job2));
}
export function job2FromJSON(
  jsonString: string,
): SafeParseResult<Job2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job2' from JSON`,
  );
}

/** @internal */
export const GitHashtagVercel$inboundSchema: z.ZodNativeEnum<
  typeof GitHashtagVercel
> = z.nativeEnum(GitHashtagVercel);
/** @internal */
export const GitHashtagVercel$outboundSchema: z.ZodNativeEnum<
  typeof GitHashtagVercel
> = GitHashtagVercel$inboundSchema;

/** @internal */
export const GitComments$inboundSchema: z.ZodType<
  GitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: types.boolean(),
  onCommit: types.boolean(),
});
/** @internal */
export type GitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const GitComments$outboundSchema: z.ZodType<
  GitComments$Outbound,
  z.ZodTypeDef,
  GitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function gitCommentsToJSON(gitComments: GitComments): string {
  return JSON.stringify(GitComments$outboundSchema.parse(gitComments));
}
export function gitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<GitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitComments' from JSON`,
  );
}

/** @internal */
export const CommitVerification$inboundSchema: z.ZodNativeEnum<
  typeof CommitVerification
> = z.nativeEnum(CommitVerification);
/** @internal */
export const CommitVerification$outboundSchema: z.ZodNativeEnum<
  typeof CommitVerification
> = CommitVerification$inboundSchema;

/** @internal */
export const JobDeployHook$inboundSchema: z.ZodType<
  JobDeployHook,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: types.number(),
  id: types.string(),
  name: types.string(),
  ref: types.string(),
});
/** @internal */
export type JobDeployHook$Outbound = {
  createdAt: number;
  id: string;
  name: string;
  ref: string;
};

/** @internal */
export const JobDeployHook$outboundSchema: z.ZodType<
  JobDeployHook$Outbound,
  z.ZodTypeDef,
  JobDeployHook
> = z.object({
  createdAt: z.number(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
});

export function jobDeployHookToJSON(jobDeployHook: JobDeployHook): string {
  return JSON.stringify(JobDeployHook$outboundSchema.parse(jobDeployHook));
}
export function jobDeployHookFromJSON(
  jsonString: string,
): SafeParseResult<JobDeployHook, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JobDeployHook$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JobDeployHook' from JSON`,
  );
}

/** @internal */
export const HeadInfo$inboundSchema: z.ZodType<
  HeadInfo,
  z.ZodTypeDef,
  unknown
> = z.object({
  owner: types.string(),
  ref: types.string(),
  repoUuid: types.string(),
  sha: types.string(),
  slug: types.string(),
});
/** @internal */
export type HeadInfo$Outbound = {
  owner: string;
  ref: string;
  repoUuid: string;
  sha: string;
  slug: string;
};

/** @internal */
export const HeadInfo$outboundSchema: z.ZodType<
  HeadInfo$Outbound,
  z.ZodTypeDef,
  HeadInfo
> = z.object({
  owner: z.string(),
  ref: z.string(),
  repoUuid: z.string(),
  sha: z.string(),
  slug: z.string(),
});

export function headInfoToJSON(headInfo: HeadInfo): string {
  return JSON.stringify(HeadInfo$outboundSchema.parse(headInfo));
}
export function headInfoFromJSON(
  jsonString: string,
): SafeParseResult<HeadInfo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HeadInfo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HeadInfo' from JSON`,
  );
}

/** @internal */
export const JobProvider$inboundSchema: z.ZodNativeEnum<typeof JobProvider> = z
  .nativeEnum(JobProvider);
/** @internal */
export const JobProvider$outboundSchema: z.ZodNativeEnum<typeof JobProvider> =
  JobProvider$inboundSchema;

/** @internal */
export const Job1$inboundSchema: z.ZodType<Job1, z.ZodTypeDef, unknown> = z
  .object({
    type: types.literal("bitbucket-push"),
    authorized: types.optional(types.boolean()),
    authorizedBy: types.optional(types.string()),
    jobProjectIds: types.optional(z.array(types.string())),
    jobPairs: types.optional(z.array(z.array(types.string()))),
    skippedJobPairs: types.optional(z.array(z.array(types.string()))),
    gitHashtagVercel: types.optional(z.array(GitHashtagVercel$inboundSchema)),
    connectedProjectCount: types.optional(types.number()),
    prIdOrZero: types.optional(types.number()),
    gitComments: types.optional(z.lazy(() => GitComments$inboundSchema)),
    isManualGitDeploy: types.optional(types.boolean()),
    commitVerification: types.optional(CommitVerification$inboundSchema),
    createdAt: types.optional(types.number()),
    deploymentId: types.optional(types.string()),
    deployHook: types.optional(z.lazy(() => JobDeployHook$inboundSchema)),
    eventful: types.optional(types.boolean()),
    forceNew: types.optional(types.boolean()),
    headInfo: z.lazy(() => HeadInfo$inboundSchema),
    linkedProjectId: types.optional(types.string()),
    name: types.string(),
    owner: types.string(),
    prId: types.optional(types.number()),
    projectId: types.optional(types.string()),
    customEnvId: z.nullable(types.string()).optional(),
    ref: types.string(),
    repoPushedAt: z.nullable(types.number()).optional(),
    repoUuid: types.string(),
    sha: types.string(),
    silent: types.optional(types.boolean()),
    slug: types.string(),
    target: z.nullable(types.string()).optional(),
    url: types.optional(types.string()),
    withCache: types.optional(types.boolean()),
    workspaceUuid: types.string(),
    provider: JobProvider$inboundSchema,
  });
/** @internal */
export type Job1$Outbound = {
  type: "bitbucket-push";
  authorized?: boolean | undefined;
  authorizedBy?: string | undefined;
  jobProjectIds?: Array<string> | undefined;
  jobPairs?: Array<Array<string>> | undefined;
  skippedJobPairs?: Array<Array<string>> | undefined;
  gitHashtagVercel?: Array<string> | undefined;
  connectedProjectCount?: number | undefined;
  prIdOrZero?: number | undefined;
  gitComments?: GitComments$Outbound | undefined;
  isManualGitDeploy?: boolean | undefined;
  commitVerification?: string | undefined;
  createdAt?: number | undefined;
  deploymentId?: string | undefined;
  deployHook?: JobDeployHook$Outbound | undefined;
  eventful?: boolean | undefined;
  forceNew?: boolean | undefined;
  headInfo: HeadInfo$Outbound;
  linkedProjectId?: string | undefined;
  name: string;
  owner: string;
  prId?: number | undefined;
  projectId?: string | undefined;
  customEnvId?: string | null | undefined;
  ref: string;
  repoPushedAt?: number | null | undefined;
  repoUuid: string;
  sha: string;
  silent?: boolean | undefined;
  slug: string;
  target?: string | null | undefined;
  url?: string | undefined;
  withCache?: boolean | undefined;
  workspaceUuid: string;
  provider: string;
};

/** @internal */
export const Job1$outboundSchema: z.ZodType<Job1$Outbound, z.ZodTypeDef, Job1> =
  z.object({
    type: z.literal("bitbucket-push"),
    authorized: z.boolean().optional(),
    authorizedBy: z.string().optional(),
    jobProjectIds: z.array(z.string()).optional(),
    jobPairs: z.array(z.array(z.string())).optional(),
    skippedJobPairs: z.array(z.array(z.string())).optional(),
    gitHashtagVercel: z.array(GitHashtagVercel$outboundSchema).optional(),
    connectedProjectCount: z.number().optional(),
    prIdOrZero: z.number().optional(),
    gitComments: z.lazy(() => GitComments$outboundSchema).optional(),
    isManualGitDeploy: z.boolean().optional(),
    commitVerification: CommitVerification$outboundSchema.optional(),
    createdAt: z.number().optional(),
    deploymentId: z.string().optional(),
    deployHook: z.lazy(() => JobDeployHook$outboundSchema).optional(),
    eventful: z.boolean().optional(),
    forceNew: z.boolean().optional(),
    headInfo: z.lazy(() => HeadInfo$outboundSchema),
    linkedProjectId: z.string().optional(),
    name: z.string(),
    owner: z.string(),
    prId: z.number().optional(),
    projectId: z.string().optional(),
    customEnvId: z.nullable(z.string()).optional(),
    ref: z.string(),
    repoPushedAt: z.nullable(z.number()).optional(),
    repoUuid: z.string(),
    sha: z.string(),
    silent: z.boolean().optional(),
    slug: z.string(),
    target: z.nullable(z.string()).optional(),
    url: z.string().optional(),
    withCache: z.boolean().optional(),
    workspaceUuid: z.string(),
    provider: JobProvider$outboundSchema,
  });

export function job1ToJSON(job1: Job1): string {
  return JSON.stringify(Job1$outboundSchema.parse(job1));
}
export function job1FromJSON(
  jsonString: string,
): SafeParseResult<Job1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Job1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Job1' from JSON`,
  );
}

/** @internal */
export const PayloadJob$inboundSchema: z.ZodType<
  PayloadJob,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Job1$inboundSchema),
  z.lazy(() => Job2$inboundSchema),
  z.lazy(() => Job3$inboundSchema),
  z.lazy(() => Job4$inboundSchema),
  z.lazy(() => Job5$inboundSchema),
  z.lazy(() => Job6$inboundSchema),
  z.lazy(() => Job7$inboundSchema),
]);
/** @internal */
export type PayloadJob$Outbound =
  | Job1$Outbound
  | Job2$Outbound
  | Job3$Outbound
  | Job4$Outbound
  | Job5$Outbound
  | Job6$Outbound
  | Job7$Outbound;

/** @internal */
export const PayloadJob$outboundSchema: z.ZodType<
  PayloadJob$Outbound,
  z.ZodTypeDef,
  PayloadJob
> = z.union([
  z.lazy(() => Job1$outboundSchema),
  z.lazy(() => Job2$outboundSchema),
  z.lazy(() => Job3$outboundSchema),
  z.lazy(() => Job4$outboundSchema),
  z.lazy(() => Job5$outboundSchema),
  z.lazy(() => Job6$outboundSchema),
  z.lazy(() => Job7$outboundSchema),
]);

export function payloadJobToJSON(payloadJob: PayloadJob): string {
  return JSON.stringify(PayloadJob$outboundSchema.parse(payloadJob));
}
export function payloadJobFromJSON(
  jsonString: string,
): SafeParseResult<PayloadJob, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadJob$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadJob' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyEight$inboundSchema: z.ZodType<
  TwoHundredAndSixtyEight,
  z.ZodTypeDef,
  unknown
> = z.object({
  job: z.union([
    z.lazy(() => Job1$inboundSchema),
    z.lazy(() => Job2$inboundSchema),
    z.lazy(() => Job3$inboundSchema),
    z.lazy(() => Job4$inboundSchema),
    z.lazy(() => Job5$inboundSchema),
    z.lazy(() => Job6$inboundSchema),
    z.lazy(() => Job7$inboundSchema),
  ]),
});
/** @internal */
export type TwoHundredAndSixtyEight$Outbound = {
  job:
    | Job1$Outbound
    | Job2$Outbound
    | Job3$Outbound
    | Job4$Outbound
    | Job5$Outbound
    | Job6$Outbound
    | Job7$Outbound;
};

/** @internal */
export const TwoHundredAndSixtyEight$outboundSchema: z.ZodType<
  TwoHundredAndSixtyEight$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyEight
> = z.object({
  job: z.union([
    z.lazy(() => Job1$outboundSchema),
    z.lazy(() => Job2$outboundSchema),
    z.lazy(() => Job3$outboundSchema),
    z.lazy(() => Job4$outboundSchema),
    z.lazy(() => Job5$outboundSchema),
    z.lazy(() => Job6$outboundSchema),
    z.lazy(() => Job7$outboundSchema),
  ]),
});

export function twoHundredAndSixtyEightToJSON(
  twoHundredAndSixtyEight: TwoHundredAndSixtyEight,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyEight$outboundSchema.parse(twoHundredAndSixtyEight),
  );
}
export function twoHundredAndSixtyEightFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyEight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyEight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyEight' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtySeven$inboundSchema: z.ZodType<
  TwoHundredAndSixtySeven,
  z.ZodTypeDef,
  unknown
> = z.object({
  trialCreditsIssuedAt: types.number(),
  expiresAt: types.string(),
  amount: types.string(),
  currency: types.string(),
});
/** @internal */
export type TwoHundredAndSixtySeven$Outbound = {
  trialCreditsIssuedAt: number;
  expiresAt: string;
  amount: string;
  currency: string;
};

/** @internal */
export const TwoHundredAndSixtySeven$outboundSchema: z.ZodType<
  TwoHundredAndSixtySeven$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtySeven
> = z.object({
  trialCreditsIssuedAt: z.number(),
  expiresAt: z.string(),
  amount: z.string(),
  currency: z.string(),
});

export function twoHundredAndSixtySevenToJSON(
  twoHundredAndSixtySeven: TwoHundredAndSixtySeven,
): string {
  return JSON.stringify(
    TwoHundredAndSixtySeven$outboundSchema.parse(twoHundredAndSixtySeven),
  );
}
export function twoHundredAndSixtySevenFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtySeven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtySeven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtySeven' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtySix$inboundSchema: z.ZodType<
  TwoHundredAndSixtySix,
  z.ZodTypeDef,
  unknown
> = z.object({
  inviteCode: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndSixtySix$Outbound = {
  inviteCode?: string | undefined;
};

/** @internal */
export const TwoHundredAndSixtySix$outboundSchema: z.ZodType<
  TwoHundredAndSixtySix$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtySix
> = z.object({
  inviteCode: z.string().optional(),
});

export function twoHundredAndSixtySixToJSON(
  twoHundredAndSixtySix: TwoHundredAndSixtySix,
): string {
  return JSON.stringify(
    TwoHundredAndSixtySix$outboundSchema.parse(twoHundredAndSixtySix),
  );
}
export function twoHundredAndSixtySixFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtySix, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtySix$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtySix' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyFive$inboundSchema: z.ZodType<
  TwoHundredAndSixtyFive,
  z.ZodTypeDef,
  unknown
> = z.object({
  emailDomain: z.nullable(types.string()).optional(),
});
/** @internal */
export type TwoHundredAndSixtyFive$Outbound = {
  emailDomain?: string | null | undefined;
};

/** @internal */
export const TwoHundredAndSixtyFive$outboundSchema: z.ZodType<
  TwoHundredAndSixtyFive$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyFive
> = z.object({
  emailDomain: z.nullable(z.string()).optional(),
});

export function twoHundredAndSixtyFiveToJSON(
  twoHundredAndSixtyFive: TwoHundredAndSixtyFive,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyFive$outboundSchema.parse(twoHundredAndSixtyFive),
  );
}
export function twoHundredAndSixtyFiveFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyFive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyFive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyFive' from JSON`,
  );
}

/** @internal */
export const PayloadPlan$inboundSchema: z.ZodNativeEnum<typeof PayloadPlan> = z
  .nativeEnum(PayloadPlan);
/** @internal */
export const PayloadPlan$outboundSchema: z.ZodNativeEnum<typeof PayloadPlan> =
  PayloadPlan$inboundSchema;

/** @internal */
export const TwoHundredAndSixtyFour$inboundSchema: z.ZodType<
  TwoHundredAndSixtyFour,
  z.ZodTypeDef,
  unknown
> = z.object({
  invoiceId: types.string(),
  convertedFromTrial: types.boolean(),
  plan: PayloadPlan$inboundSchema,
});
/** @internal */
export type TwoHundredAndSixtyFour$Outbound = {
  invoiceId: string;
  convertedFromTrial: boolean;
  plan: string;
};

/** @internal */
export const TwoHundredAndSixtyFour$outboundSchema: z.ZodType<
  TwoHundredAndSixtyFour$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyFour
> = z.object({
  invoiceId: z.string(),
  convertedFromTrial: z.boolean(),
  plan: PayloadPlan$outboundSchema,
});

export function twoHundredAndSixtyFourToJSON(
  twoHundredAndSixtyFour: TwoHundredAndSixtyFour,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyFour$outboundSchema.parse(twoHundredAndSixtyFour),
  );
}
export function twoHundredAndSixtyFourFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyFour, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyFour$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyFour' from JSON`,
  );
}

/** @internal */
export const Plan$inboundSchema: z.ZodNativeEnum<typeof Plan> = z.nativeEnum(
  Plan,
);
/** @internal */
export const Plan$outboundSchema: z.ZodNativeEnum<typeof Plan> =
  Plan$inboundSchema;

/** @internal */
export const Trial$inboundSchema: z.ZodType<Trial, z.ZodTypeDef, unknown> = z
  .object({
    start: types.number(),
    end: types.number(),
  });
/** @internal */
export type Trial$Outbound = {
  start: number;
  end: number;
};

/** @internal */
export const Trial$outboundSchema: z.ZodType<
  Trial$Outbound,
  z.ZodTypeDef,
  Trial
> = z.object({
  start: z.number(),
  end: z.number(),
});

export function trialToJSON(trial: Trial): string {
  return JSON.stringify(Trial$outboundSchema.parse(trial));
}
export function trialFromJSON(
  jsonString: string,
): SafeParseResult<Trial, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Trial$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Trial' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyThree$inboundSchema: z.ZodType<
  TwoHundredAndSixtyThree,
  z.ZodTypeDef,
  unknown
> = z.object({
  plan: Plan$inboundSchema,
  trial: z.nullable(z.lazy(() => Trial$inboundSchema)).optional(),
});
/** @internal */
export type TwoHundredAndSixtyThree$Outbound = {
  plan: string;
  trial?: Trial$Outbound | null | undefined;
};

/** @internal */
export const TwoHundredAndSixtyThree$outboundSchema: z.ZodType<
  TwoHundredAndSixtyThree$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyThree
> = z.object({
  plan: Plan$outboundSchema,
  trial: z.nullable(z.lazy(() => Trial$outboundSchema)).optional(),
});

export function twoHundredAndSixtyThreeToJSON(
  twoHundredAndSixtyThree: TwoHundredAndSixtyThree,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyThree$outboundSchema.parse(twoHundredAndSixtyThree),
  );
}
export function twoHundredAndSixtyThreeFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyThree, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyThree$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyThree' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyTwo$inboundSchema: z.ZodType<
  TwoHundredAndSixtyTwo,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  projectName: types.string(),
  target: types.string(),
  domain: types.string(),
  configuredBy: z.nullable(types.string()).optional(),
  prevConfiguredBy: z.nullable(types.string()).optional(),
});
/** @internal */
export type TwoHundredAndSixtyTwo$Outbound = {
  projectId: string;
  projectName: string;
  target: string;
  domain: string;
  configuredBy?: string | null | undefined;
  prevConfiguredBy?: string | null | undefined;
};

/** @internal */
export const TwoHundredAndSixtyTwo$outboundSchema: z.ZodType<
  TwoHundredAndSixtyTwo$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyTwo
> = z.object({
  projectId: z.string(),
  projectName: z.string(),
  target: z.string(),
  domain: z.string(),
  configuredBy: z.nullable(z.string()).optional(),
  prevConfiguredBy: z.nullable(z.string()).optional(),
});

export function twoHundredAndSixtyTwoToJSON(
  twoHundredAndSixtyTwo: TwoHundredAndSixtyTwo,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyTwo$outboundSchema.parse(twoHundredAndSixtyTwo),
  );
}
export function twoHundredAndSixtyTwoFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyTwo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyTwo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyTwo' from JSON`,
  );
}

/** @internal */
export const UserEventPayload261Role$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload261Role
> = z.nativeEnum(UserEventPayload261Role);
/** @internal */
export const UserEventPayload261Role$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload261Role
> = UserEventPayload261Role$inboundSchema;

/** @internal */
export const PayloadProjects$inboundSchema: z.ZodType<
  PayloadProjects,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  role: UserEventPayload261Role$inboundSchema,
  membershipCreatedAt: types.number(),
});
/** @internal */
export type PayloadProjects$Outbound = {
  projectId: string;
  role: string;
  membershipCreatedAt: number;
};

/** @internal */
export const PayloadProjects$outboundSchema: z.ZodType<
  PayloadProjects$Outbound,
  z.ZodTypeDef,
  PayloadProjects
> = z.object({
  projectId: z.string(),
  role: UserEventPayload261Role$outboundSchema,
  membershipCreatedAt: z.number(),
});

export function payloadProjectsToJSON(
  payloadProjects: PayloadProjects,
): string {
  return JSON.stringify(PayloadProjects$outboundSchema.parse(payloadProjects));
}
export function payloadProjectsFromJSON(
  jsonString: string,
): SafeParseResult<PayloadProjects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadProjects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadProjects' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixtyOne$inboundSchema: z.ZodType<
  TwoHundredAndSixtyOne,
  z.ZodTypeDef,
  unknown
> = z.object({
  projects: z.array(z.lazy(() => PayloadProjects$inboundSchema)),
  uid: types.string(),
});
/** @internal */
export type TwoHundredAndSixtyOne$Outbound = {
  projects: Array<PayloadProjects$Outbound>;
  uid: string;
};

/** @internal */
export const TwoHundredAndSixtyOne$outboundSchema: z.ZodType<
  TwoHundredAndSixtyOne$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixtyOne
> = z.object({
  projects: z.array(z.lazy(() => PayloadProjects$outboundSchema)),
  uid: z.string(),
});

export function twoHundredAndSixtyOneToJSON(
  twoHundredAndSixtyOne: TwoHundredAndSixtyOne,
): string {
  return JSON.stringify(
    TwoHundredAndSixtyOne$outboundSchema.parse(twoHundredAndSixtyOne),
  );
}
export function twoHundredAndSixtyOneFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixtyOne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixtyOne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixtyOne' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndSixty$inboundSchema: z.ZodType<
  TwoHundredAndSixty,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  projectName: types.string(),
  domain: types.string(),
  redirect: z.nullable(types.string()).optional(),
  redirectStatusCode: z.nullable(types.number()).optional(),
});
/** @internal */
export type TwoHundredAndSixty$Outbound = {
  projectId: string;
  projectName: string;
  domain: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
};

/** @internal */
export const TwoHundredAndSixty$outboundSchema: z.ZodType<
  TwoHundredAndSixty$Outbound,
  z.ZodTypeDef,
  TwoHundredAndSixty
> = z.object({
  projectId: z.string(),
  projectName: z.string(),
  domain: z.string(),
  redirect: z.nullable(z.string()).optional(),
  redirectStatusCode: z.nullable(z.number()).optional(),
});

export function twoHundredAndSixtyToJSON(
  twoHundredAndSixty: TwoHundredAndSixty,
): string {
  return JSON.stringify(
    TwoHundredAndSixty$outboundSchema.parse(twoHundredAndSixty),
  );
}
export function twoHundredAndSixtyFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndSixty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndSixty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndSixty' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyNine$inboundSchema: z.ZodType<
  TwoHundredAndFiftyNine,
  z.ZodTypeDef,
  unknown
> = z.object({
  oldProjectId: types.string(),
  oldProjectName: types.string(),
  newProjectId: types.string(),
  newProjectName: types.string(),
  domain: types.string(),
});
/** @internal */
export type TwoHundredAndFiftyNine$Outbound = {
  oldProjectId: string;
  oldProjectName: string;
  newProjectId: string;
  newProjectName: string;
  domain: string;
};

/** @internal */
export const TwoHundredAndFiftyNine$outboundSchema: z.ZodType<
  TwoHundredAndFiftyNine$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyNine
> = z.object({
  oldProjectId: z.string(),
  oldProjectName: z.string(),
  newProjectId: z.string(),
  newProjectName: z.string(),
  domain: z.string(),
});

export function twoHundredAndFiftyNineToJSON(
  twoHundredAndFiftyNine: TwoHundredAndFiftyNine,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyNine$outboundSchema.parse(twoHundredAndFiftyNine),
  );
}
export function twoHundredAndFiftyNineFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyNine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyNine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyNine' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyEight$inboundSchema: z.ZodType<
  TwoHundredAndFiftyEight,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  projectName: types.string(),
  domain: types.string(),
  target: types.string(),
  redirect: z.nullable(types.string()).optional(),
  redirectStatusCode: z.nullable(types.number()).optional(),
});
/** @internal */
export type TwoHundredAndFiftyEight$Outbound = {
  projectId: string;
  projectName: string;
  domain: string;
  target: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
};

/** @internal */
export const TwoHundredAndFiftyEight$outboundSchema: z.ZodType<
  TwoHundredAndFiftyEight$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyEight
> = z.object({
  projectId: z.string(),
  projectName: z.string(),
  domain: z.string(),
  target: z.string(),
  redirect: z.nullable(z.string()).optional(),
  redirectStatusCode: z.nullable(z.number()).optional(),
});

export function twoHundredAndFiftyEightToJSON(
  twoHundredAndFiftyEight: TwoHundredAndFiftyEight,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyEight$outboundSchema.parse(twoHundredAndFiftyEight),
  );
}
export function twoHundredAndFiftyEightFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyEight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyEight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyEight' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftySeven$inboundSchema: z.ZodType<
  TwoHundredAndFiftySeven,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  projectName: types.string(),
  domain: types.string(),
  target: types.string(),
  redirect: types.nullable(types.string()),
  redirectStatusCode: types.nullable(types.number()),
  gitBranch: types.nullable(types.string()),
  configuredBy: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndFiftySeven$Outbound = {
  projectId: string;
  projectName: string;
  domain: string;
  target: string;
  redirect: string | null;
  redirectStatusCode: number | null;
  gitBranch: string | null;
  configuredBy?: string | undefined;
};

/** @internal */
export const TwoHundredAndFiftySeven$outboundSchema: z.ZodType<
  TwoHundredAndFiftySeven$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftySeven
> = z.object({
  projectId: z.string(),
  projectName: z.string(),
  domain: z.string(),
  target: z.string(),
  redirect: z.nullable(z.string()),
  redirectStatusCode: z.nullable(z.number()),
  gitBranch: z.nullable(z.string()),
  configuredBy: z.string().optional(),
});

export function twoHundredAndFiftySevenToJSON(
  twoHundredAndFiftySeven: TwoHundredAndFiftySeven,
): string {
  return JSON.stringify(
    TwoHundredAndFiftySeven$outboundSchema.parse(twoHundredAndFiftySeven),
  );
}
export function twoHundredAndFiftySevenFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftySeven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftySeven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftySeven' from JSON`,
  );
}

/** @internal */
export const EdgeConfig$inboundSchema: z.ZodType<
  EdgeConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  slug: types.string(),
});
/** @internal */
export type EdgeConfig$Outbound = {
  id: string;
  slug: string;
};

/** @internal */
export const EdgeConfig$outboundSchema: z.ZodType<
  EdgeConfig$Outbound,
  z.ZodTypeDef,
  EdgeConfig
> = z.object({
  id: z.string(),
  slug: z.string(),
});

export function edgeConfigToJSON(edgeConfig: EdgeConfig): string {
  return JSON.stringify(EdgeConfig$outboundSchema.parse(edgeConfig));
}
export function edgeConfigFromJSON(
  jsonString: string,
): SafeParseResult<EdgeConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EdgeConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EdgeConfig' from JSON`,
  );
}

/** @internal */
export const UserEventPayload256Type$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload256Type
> = z.nativeEnum(UserEventPayload256Type);
/** @internal */
export const UserEventPayload256Type$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload256Type
> = UserEventPayload256Type$inboundSchema;

/** @internal */
export const FromAccount$inboundSchema: z.ZodType<
  FromAccount,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  type: UserEventPayload256Type$inboundSchema,
  slug: types.optional(types.string()),
  username: types.optional(types.string()),
});
/** @internal */
export type FromAccount$Outbound = {
  id: string;
  type: string;
  slug?: string | undefined;
  username?: string | undefined;
};

/** @internal */
export const FromAccount$outboundSchema: z.ZodType<
  FromAccount$Outbound,
  z.ZodTypeDef,
  FromAccount
> = z.object({
  id: z.string(),
  type: UserEventPayload256Type$outboundSchema,
  slug: z.string().optional(),
  username: z.string().optional(),
});

export function fromAccountToJSON(fromAccount: FromAccount): string {
  return JSON.stringify(FromAccount$outboundSchema.parse(fromAccount));
}
export function fromAccountFromJSON(
  jsonString: string,
): SafeParseResult<FromAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FromAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FromAccount' from JSON`,
  );
}

/** @internal */
export const UserEventPayload256ToAccountType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload256ToAccountType
> = z.nativeEnum(UserEventPayload256ToAccountType);
/** @internal */
export const UserEventPayload256ToAccountType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload256ToAccountType
> = UserEventPayload256ToAccountType$inboundSchema;

/** @internal */
export const ToAccount$inboundSchema: z.ZodType<
  ToAccount,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  type: UserEventPayload256ToAccountType$inboundSchema,
  slug: types.optional(types.string()),
  username: types.optional(types.string()),
});
/** @internal */
export type ToAccount$Outbound = {
  id: string;
  type: string;
  slug?: string | undefined;
  username?: string | undefined;
};

/** @internal */
export const ToAccount$outboundSchema: z.ZodType<
  ToAccount$Outbound,
  z.ZodTypeDef,
  ToAccount
> = z.object({
  id: z.string(),
  type: UserEventPayload256ToAccountType$outboundSchema,
  slug: z.string().optional(),
  username: z.string().optional(),
});

export function toAccountToJSON(toAccount: ToAccount): string {
  return JSON.stringify(ToAccount$outboundSchema.parse(toAccount));
}
export function toAccountFromJSON(
  jsonString: string,
): SafeParseResult<ToAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToAccount' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftySix$inboundSchema: z.ZodType<
  TwoHundredAndFiftySix,
  z.ZodTypeDef,
  unknown
> = z.object({
  edgeConfig: z.lazy(() => EdgeConfig$inboundSchema),
  fromAccount: z.lazy(() => FromAccount$inboundSchema),
  toAccount: z.lazy(() => ToAccount$inboundSchema),
});
/** @internal */
export type TwoHundredAndFiftySix$Outbound = {
  edgeConfig: EdgeConfig$Outbound;
  fromAccount: FromAccount$Outbound;
  toAccount: ToAccount$Outbound;
};

/** @internal */
export const TwoHundredAndFiftySix$outboundSchema: z.ZodType<
  TwoHundredAndFiftySix$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftySix
> = z.object({
  edgeConfig: z.lazy(() => EdgeConfig$outboundSchema),
  fromAccount: z.lazy(() => FromAccount$outboundSchema),
  toAccount: z.lazy(() => ToAccount$outboundSchema),
});

export function twoHundredAndFiftySixToJSON(
  twoHundredAndFiftySix: TwoHundredAndFiftySix,
): string {
  return JSON.stringify(
    TwoHundredAndFiftySix$outboundSchema.parse(twoHundredAndFiftySix),
  );
}
export function twoHundredAndFiftySixFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftySix, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftySix$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftySix' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyFive$inboundSchema: z.ZodType<
  TwoHundredAndFiftyFive,
  z.ZodTypeDef,
  unknown
> = z.object({
  edgeConfigId: types.string(),
  edgeConfigSlug: types.string(),
  edgeConfigDigest: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndFiftyFive$Outbound = {
  edgeConfigId: string;
  edgeConfigSlug: string;
  edgeConfigDigest?: string | undefined;
};

/** @internal */
export const TwoHundredAndFiftyFive$outboundSchema: z.ZodType<
  TwoHundredAndFiftyFive$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyFive
> = z.object({
  edgeConfigId: z.string(),
  edgeConfigSlug: z.string(),
  edgeConfigDigest: z.string().optional(),
});

export function twoHundredAndFiftyFiveToJSON(
  twoHundredAndFiftyFive: TwoHundredAndFiftyFive,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyFive$outboundSchema.parse(twoHundredAndFiftyFive),
  );
}
export function twoHundredAndFiftyFiveFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyFive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyFive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyFive' from JSON`,
  );
}

/** @internal */
export const EdgeConfigSchema$inboundSchema: z.ZodType<
  EdgeConfigSchema,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type EdgeConfigSchema$Outbound = {};

/** @internal */
export const EdgeConfigSchema$outboundSchema: z.ZodType<
  EdgeConfigSchema$Outbound,
  z.ZodTypeDef,
  EdgeConfigSchema
> = z.object({});

export function edgeConfigSchemaToJSON(
  edgeConfigSchema: EdgeConfigSchema,
): string {
  return JSON.stringify(
    EdgeConfigSchema$outboundSchema.parse(edgeConfigSchema),
  );
}
export function edgeConfigSchemaFromJSON(
  jsonString: string,
): SafeParseResult<EdgeConfigSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => EdgeConfigSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'EdgeConfigSchema' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyFour$inboundSchema: z.ZodType<
  TwoHundredAndFiftyFour,
  z.ZodTypeDef,
  unknown
> = z.object({
  edgeConfigId: types.string(),
  edgeConfigSlug: types.string(),
  edgeConfigSchema: types.optional(
    z.lazy(() => EdgeConfigSchema$inboundSchema),
  ),
});
/** @internal */
export type TwoHundredAndFiftyFour$Outbound = {
  edgeConfigId: string;
  edgeConfigSlug: string;
  edgeConfigSchema?: EdgeConfigSchema$Outbound | undefined;
};

/** @internal */
export const TwoHundredAndFiftyFour$outboundSchema: z.ZodType<
  TwoHundredAndFiftyFour$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyFour
> = z.object({
  edgeConfigId: z.string(),
  edgeConfigSlug: z.string(),
  edgeConfigSchema: z.lazy(() => EdgeConfigSchema$outboundSchema).optional(),
});

export function twoHundredAndFiftyFourToJSON(
  twoHundredAndFiftyFour: TwoHundredAndFiftyFour,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyFour$outboundSchema.parse(twoHundredAndFiftyFour),
  );
}
export function twoHundredAndFiftyFourFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyFour, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyFour$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyFour' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyThree$inboundSchema: z.ZodType<
  TwoHundredAndFiftyThree,
  z.ZodTypeDef,
  unknown
> = z.object({
  ownerId: types.string(),
  source: types.string(),
  cause: types.string(),
});
/** @internal */
export type TwoHundredAndFiftyThree$Outbound = {
  ownerId: string;
  source: string;
  cause: string;
};

/** @internal */
export const TwoHundredAndFiftyThree$outboundSchema: z.ZodType<
  TwoHundredAndFiftyThree$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyThree
> = z.object({
  ownerId: z.string(),
  source: z.string(),
  cause: z.string(),
});

export function twoHundredAndFiftyThreeToJSON(
  twoHundredAndFiftyThree: TwoHundredAndFiftyThree,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyThree$outboundSchema.parse(twoHundredAndFiftyThree),
  );
}
export function twoHundredAndFiftyThreeFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyThree, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyThree$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyThree' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyTwo$inboundSchema: z.ZodType<
  TwoHundredAndFiftyTwo,
  z.ZodTypeDef,
  unknown
> = z.object({
  ownerId: types.string(),
  source: types.string(),
  cause: types.string(),
  blockReason: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndFiftyTwo$Outbound = {
  ownerId: string;
  source: string;
  cause: string;
  blockReason?: string | undefined;
};

/** @internal */
export const TwoHundredAndFiftyTwo$outboundSchema: z.ZodType<
  TwoHundredAndFiftyTwo$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyTwo
> = z.object({
  ownerId: z.string(),
  source: z.string(),
  cause: z.string(),
  blockReason: z.string().optional(),
});

export function twoHundredAndFiftyTwoToJSON(
  twoHundredAndFiftyTwo: TwoHundredAndFiftyTwo,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyTwo$outboundSchema.parse(twoHundredAndFiftyTwo),
  );
}
export function twoHundredAndFiftyTwoFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyTwo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyTwo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyTwo' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFiftyOne$inboundSchema: z.ZodType<
  TwoHundredAndFiftyOne,
  z.ZodTypeDef,
  unknown
> = z.object({
  ownerId: types.string(),
  source: types.string(),
  cause: types.string(),
  reason: z.nullable(types.string()).optional(),
});
/** @internal */
export type TwoHundredAndFiftyOne$Outbound = {
  ownerId: string;
  source: string;
  cause: string;
  reason?: string | null | undefined;
};

/** @internal */
export const TwoHundredAndFiftyOne$outboundSchema: z.ZodType<
  TwoHundredAndFiftyOne$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFiftyOne
> = z.object({
  ownerId: z.string(),
  source: z.string(),
  cause: z.string(),
  reason: z.nullable(z.string()).optional(),
});

export function twoHundredAndFiftyOneToJSON(
  twoHundredAndFiftyOne: TwoHundredAndFiftyOne,
): string {
  return JSON.stringify(
    TwoHundredAndFiftyOne$outboundSchema.parse(twoHundredAndFiftyOne),
  );
}
export function twoHundredAndFiftyOneFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFiftyOne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFiftyOne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFiftyOne' from JSON`,
  );
}

/** @internal */
export const SiftRoute$inboundSchema: z.ZodType<
  SiftRoute,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: types.string(),
});
/** @internal */
export type SiftRoute$Outbound = {
  name: string;
};

/** @internal */
export const SiftRoute$outboundSchema: z.ZodType<
  SiftRoute$Outbound,
  z.ZodTypeDef,
  SiftRoute
> = z.object({
  name: z.string(),
});

export function siftRouteToJSON(siftRoute: SiftRoute): string {
  return JSON.stringify(SiftRoute$outboundSchema.parse(siftRoute));
}
export function siftRouteFromJSON(
  jsonString: string,
): SafeParseResult<SiftRoute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SiftRoute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SiftRoute' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFifty$inboundSchema: z.ZodType<
  TwoHundredAndFifty,
  z.ZodTypeDef,
  unknown
> = z.object({
  ownerId: types.string(),
  source: types.string(),
  cause: types.string(),
  blockReason: types.optional(types.string()),
  siftRoute: types.optional(z.lazy(() => SiftRoute$inboundSchema)),
});
/** @internal */
export type TwoHundredAndFifty$Outbound = {
  ownerId: string;
  source: string;
  cause: string;
  blockReason?: string | undefined;
  siftRoute?: SiftRoute$Outbound | undefined;
};

/** @internal */
export const TwoHundredAndFifty$outboundSchema: z.ZodType<
  TwoHundredAndFifty$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFifty
> = z.object({
  ownerId: z.string(),
  source: z.string(),
  cause: z.string(),
  blockReason: z.string().optional(),
  siftRoute: z.lazy(() => SiftRoute$outboundSchema).optional(),
});

export function twoHundredAndFiftyToJSON(
  twoHundredAndFifty: TwoHundredAndFifty,
): string {
  return JSON.stringify(
    TwoHundredAndFifty$outboundSchema.parse(twoHundredAndFifty),
  );
}
export function twoHundredAndFiftyFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFifty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFifty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFifty' from JSON`,
  );
}

/** @internal */
export const UserEventPayload249Previous$inboundSchema: z.ZodType<
  UserEventPayload249Previous,
  z.ZodTypeDef,
  unknown
> = z.object({
  sampleRatePercent: types.nullable(types.number()),
  spendLimitInDollars: types.nullable(types.number()),
});
/** @internal */
export type UserEventPayload249Previous$Outbound = {
  sampleRatePercent: number | null;
  spendLimitInDollars: number | null;
};

/** @internal */
export const UserEventPayload249Previous$outboundSchema: z.ZodType<
  UserEventPayload249Previous$Outbound,
  z.ZodTypeDef,
  UserEventPayload249Previous
> = z.object({
  sampleRatePercent: z.nullable(z.number()),
  spendLimitInDollars: z.nullable(z.number()),
});

export function userEventPayload249PreviousToJSON(
  userEventPayload249Previous: UserEventPayload249Previous,
): string {
  return JSON.stringify(
    UserEventPayload249Previous$outboundSchema.parse(
      userEventPayload249Previous,
    ),
  );
}
export function userEventPayload249PreviousFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload249Previous, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload249Previous$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload249Previous' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortyNine$inboundSchema: z.ZodType<
  TwoHundredAndFortyNine,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.optional(types.string()),
  projectName: types.optional(types.string()),
  analyticsId: types.optional(types.string()),
  sampleRatePercent: types.nullable(types.number()),
  spendLimitInDollars: types.nullable(types.number()),
  previous: z.lazy(() => UserEventPayload249Previous$inboundSchema),
});
/** @internal */
export type TwoHundredAndFortyNine$Outbound = {
  projectId?: string | undefined;
  projectName?: string | undefined;
  analyticsId?: string | undefined;
  sampleRatePercent: number | null;
  spendLimitInDollars: number | null;
  previous: UserEventPayload249Previous$Outbound;
};

/** @internal */
export const TwoHundredAndFortyNine$outboundSchema: z.ZodType<
  TwoHundredAndFortyNine$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyNine
> = z.object({
  projectId: z.string().optional(),
  projectName: z.string().optional(),
  analyticsId: z.string().optional(),
  sampleRatePercent: z.nullable(z.number()),
  spendLimitInDollars: z.nullable(z.number()),
  previous: z.lazy(() => UserEventPayload249Previous$outboundSchema),
});

export function twoHundredAndFortyNineToJSON(
  twoHundredAndFortyNine: TwoHundredAndFortyNine,
): string {
  return JSON.stringify(
    TwoHundredAndFortyNine$outboundSchema.parse(twoHundredAndFortyNine),
  );
}
export function twoHundredAndFortyNineFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyNine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyNine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyNine' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortyEight$inboundSchema: z.ZodType<
  TwoHundredAndFortyEight,
  z.ZodTypeDef,
  unknown
> = z.object({
  ruleName: types.string(),
});
/** @internal */
export type TwoHundredAndFortyEight$Outbound = {
  ruleName: string;
};

/** @internal */
export const TwoHundredAndFortyEight$outboundSchema: z.ZodType<
  TwoHundredAndFortyEight$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyEight
> = z.object({
  ruleName: z.string(),
});

export function twoHundredAndFortyEightToJSON(
  twoHundredAndFortyEight: TwoHundredAndFortyEight,
): string {
  return JSON.stringify(
    TwoHundredAndFortyEight$outboundSchema.parse(twoHundredAndFortyEight),
  );
}
export function twoHundredAndFortyEightFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyEight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyEight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyEight' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortySeven$inboundSchema: z.ZodType<
  TwoHundredAndFortySeven,
  z.ZodTypeDef,
  unknown
> = z.object({
  fileId: types.string(),
});
/** @internal */
export type TwoHundredAndFortySeven$Outbound = {
  fileId: string;
};

/** @internal */
export const TwoHundredAndFortySeven$outboundSchema: z.ZodType<
  TwoHundredAndFortySeven$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortySeven
> = z.object({
  fileId: z.string(),
});

export function twoHundredAndFortySevenToJSON(
  twoHundredAndFortySeven: TwoHundredAndFortySeven,
): string {
  return JSON.stringify(
    TwoHundredAndFortySeven$outboundSchema.parse(twoHundredAndFortySeven),
  );
}
export function twoHundredAndFortySevenFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortySeven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortySeven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortySeven' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortySix$inboundSchema: z.ZodType<
  TwoHundredAndFortySix,
  z.ZodTypeDef,
  unknown
> = z.object({
  exportId: types.string(),
  from: types.number(),
  to: types.number(),
  format: types.string(),
});
/** @internal */
export type TwoHundredAndFortySix$Outbound = {
  exportId: string;
  from: number;
  to: number;
  format: string;
};

/** @internal */
export const TwoHundredAndFortySix$outboundSchema: z.ZodType<
  TwoHundredAndFortySix$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortySix
> = z.object({
  exportId: z.string(),
  from: z.number(),
  to: z.number(),
  format: z.string(),
});

export function twoHundredAndFortySixToJSON(
  twoHundredAndFortySix: TwoHundredAndFortySix,
): string {
  return JSON.stringify(
    TwoHundredAndFortySix$outboundSchema.parse(twoHundredAndFortySix),
  );
}
export function twoHundredAndFortySixFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortySix, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortySix$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortySix' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortyFive$inboundSchema: z.ZodType<
  TwoHundredAndFortyFive,
  z.ZodTypeDef,
  unknown
> = z.object({
  domain: types.string(),
  ips: z.array(types.string()),
});
/** @internal */
export type TwoHundredAndFortyFive$Outbound = {
  domain: string;
  ips: Array<string>;
};

/** @internal */
export const TwoHundredAndFortyFive$outboundSchema: z.ZodType<
  TwoHundredAndFortyFive$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyFive
> = z.object({
  domain: z.string(),
  ips: z.array(z.string()),
});

export function twoHundredAndFortyFiveToJSON(
  twoHundredAndFortyFive: TwoHundredAndFortyFive,
): string {
  return JSON.stringify(
    TwoHundredAndFortyFive$outboundSchema.parse(twoHundredAndFortyFive),
  );
}
export function twoHundredAndFortyFiveFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyFive, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyFive$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyFive' from JSON`,
  );
}

/** @internal */
export const Previous2$inboundSchema: z.ZodNativeEnum<typeof Previous2> = z
  .nativeEnum(Previous2);
/** @internal */
export const Previous2$outboundSchema: z.ZodNativeEnum<typeof Previous2> =
  Previous2$inboundSchema;

/** @internal */
export const Previous1$inboundSchema: z.ZodType<
  Previous1,
  z.ZodTypeDef,
  unknown
> = z.object({
  accessGroupId: types.string(),
});
/** @internal */
export type Previous1$Outbound = {
  accessGroupId: string;
};

/** @internal */
export const Previous1$outboundSchema: z.ZodType<
  Previous1$Outbound,
  z.ZodTypeDef,
  Previous1
> = z.object({
  accessGroupId: z.string(),
});

export function previous1ToJSON(previous1: Previous1): string {
  return JSON.stringify(Previous1$outboundSchema.parse(previous1));
}
export function previous1FromJSON(
  jsonString: string,
): SafeParseResult<Previous1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Previous1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Previous1' from JSON`,
  );
}

/** @internal */
export const UserEventPayload244Previous$inboundSchema: z.ZodType<
  UserEventPayload244Previous,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => Previous1$inboundSchema),
  Previous2$inboundSchema,
]);
/** @internal */
export type UserEventPayload244Previous$Outbound = Previous1$Outbound | string;

/** @internal */
export const UserEventPayload244Previous$outboundSchema: z.ZodType<
  UserEventPayload244Previous$Outbound,
  z.ZodTypeDef,
  UserEventPayload244Previous
> = smartUnion([
  z.lazy(() => Previous1$outboundSchema),
  Previous2$outboundSchema,
]);

export function userEventPayload244PreviousToJSON(
  userEventPayload244Previous: UserEventPayload244Previous,
): string {
  return JSON.stringify(
    UserEventPayload244Previous$outboundSchema.parse(
      userEventPayload244Previous,
    ),
  );
}
export function userEventPayload244PreviousFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload244Previous, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload244Previous$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload244Previous' from JSON`,
  );
}

/** @internal */
export const Next2$inboundSchema: z.ZodNativeEnum<typeof Next2> = z.nativeEnum(
  Next2,
);
/** @internal */
export const Next2$outboundSchema: z.ZodNativeEnum<typeof Next2> =
  Next2$inboundSchema;

/** @internal */
export const Next1$inboundSchema: z.ZodType<Next1, z.ZodTypeDef, unknown> = z
  .object({
    accessGroupId: types.string(),
  });
/** @internal */
export type Next1$Outbound = {
  accessGroupId: string;
};

/** @internal */
export const Next1$outboundSchema: z.ZodType<
  Next1$Outbound,
  z.ZodTypeDef,
  Next1
> = z.object({
  accessGroupId: z.string(),
});

export function next1ToJSON(next1: Next1): string {
  return JSON.stringify(Next1$outboundSchema.parse(next1));
}
export function next1FromJSON(
  jsonString: string,
): SafeParseResult<Next1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Next1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Next1' from JSON`,
  );
}

/** @internal */
export const UserEventPayload244Next$inboundSchema: z.ZodType<
  UserEventPayload244Next,
  z.ZodTypeDef,
  unknown
> = smartUnion([z.lazy(() => Next1$inboundSchema), Next2$inboundSchema]);
/** @internal */
export type UserEventPayload244Next$Outbound = Next1$Outbound | string;

/** @internal */
export const UserEventPayload244Next$outboundSchema: z.ZodType<
  UserEventPayload244Next$Outbound,
  z.ZodTypeDef,
  UserEventPayload244Next
> = smartUnion([z.lazy(() => Next1$outboundSchema), Next2$outboundSchema]);

export function userEventPayload244NextToJSON(
  userEventPayload244Next: UserEventPayload244Next,
): string {
  return JSON.stringify(
    UserEventPayload244Next$outboundSchema.parse(userEventPayload244Next),
  );
}
export function userEventPayload244NextFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload244Next, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload244Next$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload244Next' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortyFour$inboundSchema: z.ZodType<
  TwoHundredAndFortyFour,
  z.ZodTypeDef,
  unknown
> = z.object({
  previous: types.optional(
    z.record(smartUnion([
      z.lazy(() => Previous1$inboundSchema),
      Previous2$inboundSchema,
    ])),
  ),
  next: types.optional(
    z.record(
      smartUnion([z.lazy(() => Next1$inboundSchema), Next2$inboundSchema]),
    ),
  ),
});
/** @internal */
export type TwoHundredAndFortyFour$Outbound = {
  previous?: { [k: string]: Previous1$Outbound | string } | undefined;
  next?: { [k: string]: Next1$Outbound | string } | undefined;
};

/** @internal */
export const TwoHundredAndFortyFour$outboundSchema: z.ZodType<
  TwoHundredAndFortyFour$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyFour
> = z.object({
  previous: z.record(
    smartUnion([
      z.lazy(() => Previous1$outboundSchema),
      Previous2$outboundSchema,
    ]),
  ).optional(),
  next: z.record(
    smartUnion([z.lazy(() => Next1$outboundSchema), Next2$outboundSchema]),
  ).optional(),
});

export function twoHundredAndFortyFourToJSON(
  twoHundredAndFortyFour: TwoHundredAndFortyFour,
): string {
  return JSON.stringify(
    TwoHundredAndFortyFour$outboundSchema.parse(twoHundredAndFortyFour),
  );
}
export function twoHundredAndFortyFourFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyFour, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyFour$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyFour' from JSON`,
  );
}

/** @internal */
export const Scope$inboundSchema: z.ZodNativeEnum<typeof Scope> = z.nativeEnum(
  Scope,
);
/** @internal */
export const Scope$outboundSchema: z.ZodNativeEnum<typeof Scope> =
  Scope$inboundSchema;

/** @internal */
export const TwoHundredAndFortyThree$inboundSchema: z.ZodType<
  TwoHundredAndFortyThree,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.boolean(),
  scope: Scope$inboundSchema,
});
/** @internal */
export type TwoHundredAndFortyThree$Outbound = {
  enabled: boolean;
  scope: string;
};

/** @internal */
export const TwoHundredAndFortyThree$outboundSchema: z.ZodType<
  TwoHundredAndFortyThree$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyThree
> = z.object({
  enabled: z.boolean(),
  scope: Scope$outboundSchema,
});

export function twoHundredAndFortyThreeToJSON(
  twoHundredAndFortyThree: TwoHundredAndFortyThree,
): string {
  return JSON.stringify(
    TwoHundredAndFortyThree$outboundSchema.parse(twoHundredAndFortyThree),
  );
}
export function twoHundredAndFortyThreeFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyThree, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyThree$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyThree' from JSON`,
  );
}

/** @internal */
export const PayloadEnabled$inboundSchema: z.ZodNativeEnum<
  typeof PayloadEnabled
> = z.nativeEnum(PayloadEnabled);
/** @internal */
export const PayloadEnabled$outboundSchema: z.ZodNativeEnum<
  typeof PayloadEnabled
> = PayloadEnabled$inboundSchema;

/** @internal */
export const TwoHundredAndFortyTwo$inboundSchema: z.ZodType<
  TwoHundredAndFortyTwo,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: PayloadEnabled$inboundSchema,
});
/** @internal */
export type TwoHundredAndFortyTwo$Outbound = {
  enabled: string;
};

/** @internal */
export const TwoHundredAndFortyTwo$outboundSchema: z.ZodType<
  TwoHundredAndFortyTwo$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyTwo
> = z.object({
  enabled: PayloadEnabled$outboundSchema,
});

export function twoHundredAndFortyTwoToJSON(
  twoHundredAndFortyTwo: TwoHundredAndFortyTwo,
): string {
  return JSON.stringify(
    TwoHundredAndFortyTwo$outboundSchema.parse(twoHundredAndFortyTwo),
  );
}
export function twoHundredAndFortyTwoFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyTwo, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyTwo$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyTwo' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndFortyOne$inboundSchema: z.ZodType<
  TwoHundredAndFortyOne,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  url: types.string(),
});
/** @internal */
export type TwoHundredAndFortyOne$Outbound = {
  id: string;
  url: string;
};

/** @internal */
export const TwoHundredAndFortyOne$outboundSchema: z.ZodType<
  TwoHundredAndFortyOne$Outbound,
  z.ZodTypeDef,
  TwoHundredAndFortyOne
> = z.object({
  id: z.string(),
  url: z.string(),
});

export function twoHundredAndFortyOneToJSON(
  twoHundredAndFortyOne: TwoHundredAndFortyOne,
): string {
  return JSON.stringify(
    TwoHundredAndFortyOne$outboundSchema.parse(twoHundredAndFortyOne),
  );
}
export function twoHundredAndFortyOneFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndFortyOne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndFortyOne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndFortyOne' from JSON`,
  );
}

/** @internal */
export const UserEventPayload240Team$inboundSchema: z.ZodType<
  UserEventPayload240Team,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
});
/** @internal */
export type UserEventPayload240Team$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const UserEventPayload240Team$outboundSchema: z.ZodType<
  UserEventPayload240Team$Outbound,
  z.ZodTypeDef,
  UserEventPayload240Team
> = z.object({
  id: z.string(),
  name: z.string(),
});

export function userEventPayload240TeamToJSON(
  userEventPayload240Team: UserEventPayload240Team,
): string {
  return JSON.stringify(
    UserEventPayload240Team$outboundSchema.parse(userEventPayload240Team),
  );
}
export function userEventPayload240TeamFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload240Team, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload240Team$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload240Team' from JSON`,
  );
}

/** @internal */
export const UserEventPayload240Configuration$inboundSchema: z.ZodType<
  UserEventPayload240Configuration,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.optional(types.string()),
});
/** @internal */
export type UserEventPayload240Configuration$Outbound = {
  id: string;
  name?: string | undefined;
};

/** @internal */
export const UserEventPayload240Configuration$outboundSchema: z.ZodType<
  UserEventPayload240Configuration$Outbound,
  z.ZodTypeDef,
  UserEventPayload240Configuration
> = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export function userEventPayload240ConfigurationToJSON(
  userEventPayload240Configuration: UserEventPayload240Configuration,
): string {
  return JSON.stringify(
    UserEventPayload240Configuration$outboundSchema.parse(
      userEventPayload240Configuration,
    ),
  );
}
export function userEventPayload240ConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload240Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload240Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload240Configuration' from JSON`,
  );
}

/** @internal */
export const UserEventPayloadPeering$inboundSchema: z.ZodType<
  UserEventPayloadPeering,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.optional(types.string()),
});
/** @internal */
export type UserEventPayloadPeering$Outbound = {
  id: string;
  name?: string | undefined;
};

/** @internal */
export const UserEventPayloadPeering$outboundSchema: z.ZodType<
  UserEventPayloadPeering$Outbound,
  z.ZodTypeDef,
  UserEventPayloadPeering
> = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export function userEventPayloadPeeringToJSON(
  userEventPayloadPeering: UserEventPayloadPeering,
): string {
  return JSON.stringify(
    UserEventPayloadPeering$outboundSchema.parse(userEventPayloadPeering),
  );
}
export function userEventPayloadPeeringFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayloadPeering, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayloadPeering$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayloadPeering' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndForty$inboundSchema: z.ZodType<
  TwoHundredAndForty,
  z.ZodTypeDef,
  unknown
> = z.object({
  team: z.lazy(() => UserEventPayload240Team$inboundSchema),
  configuration: z.lazy(() => UserEventPayload240Configuration$inboundSchema),
  peering: z.lazy(() => UserEventPayloadPeering$inboundSchema),
  newName: types.optional(types.string()),
});
/** @internal */
export type TwoHundredAndForty$Outbound = {
  team: UserEventPayload240Team$Outbound;
  configuration: UserEventPayload240Configuration$Outbound;
  peering: UserEventPayloadPeering$Outbound;
  newName?: string | undefined;
};

/** @internal */
export const TwoHundredAndForty$outboundSchema: z.ZodType<
  TwoHundredAndForty$Outbound,
  z.ZodTypeDef,
  TwoHundredAndForty
> = z.object({
  team: z.lazy(() => UserEventPayload240Team$outboundSchema),
  configuration: z.lazy(() => UserEventPayload240Configuration$outboundSchema),
  peering: z.lazy(() => UserEventPayloadPeering$outboundSchema),
  newName: z.string().optional(),
});

export function twoHundredAndFortyToJSON(
  twoHundredAndForty: TwoHundredAndForty,
): string {
  return JSON.stringify(
    TwoHundredAndForty$outboundSchema.parse(twoHundredAndForty),
  );
}
export function twoHundredAndFortyFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndForty, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndForty$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndForty' from JSON`,
  );
}

/** @internal */
export const UserEventPayload239Team$inboundSchema: z.ZodType<
  UserEventPayload239Team,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
});
/** @internal */
export type UserEventPayload239Team$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const UserEventPayload239Team$outboundSchema: z.ZodType<
  UserEventPayload239Team$Outbound,
  z.ZodTypeDef,
  UserEventPayload239Team
> = z.object({
  id: z.string(),
  name: z.string(),
});

export function userEventPayload239TeamToJSON(
  userEventPayload239Team: UserEventPayload239Team,
): string {
  return JSON.stringify(
    UserEventPayload239Team$outboundSchema.parse(userEventPayload239Team),
  );
}
export function userEventPayload239TeamFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload239Team, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload239Team$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload239Team' from JSON`,
  );
}

/** @internal */
export const UserEventPayload239Configuration$inboundSchema: z.ZodType<
  UserEventPayload239Configuration,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.optional(types.string()),
});
/** @internal */
export type UserEventPayload239Configuration$Outbound = {
  id: string;
  name?: string | undefined;
};

/** @internal */
export const UserEventPayload239Configuration$outboundSchema: z.ZodType<
  UserEventPayload239Configuration$Outbound,
  z.ZodTypeDef,
  UserEventPayload239Configuration
> = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export function userEventPayload239ConfigurationToJSON(
  userEventPayload239Configuration: UserEventPayload239Configuration,
): string {
  return JSON.stringify(
    UserEventPayload239Configuration$outboundSchema.parse(
      userEventPayload239Configuration,
    ),
  );
}
export function userEventPayload239ConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload239Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload239Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload239Configuration' from JSON`,
  );
}

/** @internal */
export const PayloadPeering$inboundSchema: z.ZodType<
  PayloadPeering,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.optional(types.string()),
});
/** @internal */
export type PayloadPeering$Outbound = {
  id: string;
  name?: string | undefined;
};

/** @internal */
export const PayloadPeering$outboundSchema: z.ZodType<
  PayloadPeering$Outbound,
  z.ZodTypeDef,
  PayloadPeering
> = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export function payloadPeeringToJSON(payloadPeering: PayloadPeering): string {
  return JSON.stringify(PayloadPeering$outboundSchema.parse(payloadPeering));
}
export function payloadPeeringFromJSON(
  jsonString: string,
): SafeParseResult<PayloadPeering, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadPeering$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadPeering' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndThirtyNine$inboundSchema: z.ZodType<
  TwoHundredAndThirtyNine,
  z.ZodTypeDef,
  unknown
> = z.object({
  team: z.lazy(() => UserEventPayload239Team$inboundSchema),
  configuration: z.lazy(() => UserEventPayload239Configuration$inboundSchema),
  peering: z.lazy(() => PayloadPeering$inboundSchema),
});
/** @internal */
export type TwoHundredAndThirtyNine$Outbound = {
  team: UserEventPayload239Team$Outbound;
  configuration: UserEventPayload239Configuration$Outbound;
  peering: PayloadPeering$Outbound;
};

/** @internal */
export const TwoHundredAndThirtyNine$outboundSchema: z.ZodType<
  TwoHundredAndThirtyNine$Outbound,
  z.ZodTypeDef,
  TwoHundredAndThirtyNine
> = z.object({
  team: z.lazy(() => UserEventPayload239Team$outboundSchema),
  configuration: z.lazy(() => UserEventPayload239Configuration$outboundSchema),
  peering: z.lazy(() => PayloadPeering$outboundSchema),
});

export function twoHundredAndThirtyNineToJSON(
  twoHundredAndThirtyNine: TwoHundredAndThirtyNine,
): string {
  return JSON.stringify(
    TwoHundredAndThirtyNine$outboundSchema.parse(twoHundredAndThirtyNine),
  );
}
export function twoHundredAndThirtyNineFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndThirtyNine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndThirtyNine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndThirtyNine' from JSON`,
  );
}

/** @internal */
export const UserEventPayload238Team$inboundSchema: z.ZodType<
  UserEventPayload238Team,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
});
/** @internal */
export type UserEventPayload238Team$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const UserEventPayload238Team$outboundSchema: z.ZodType<
  UserEventPayload238Team$Outbound,
  z.ZodTypeDef,
  UserEventPayload238Team
> = z.object({
  id: z.string(),
  name: z.string(),
});

export function userEventPayload238TeamToJSON(
  userEventPayload238Team: UserEventPayload238Team,
): string {
  return JSON.stringify(
    UserEventPayload238Team$outboundSchema.parse(userEventPayload238Team),
  );
}
export function userEventPayload238TeamFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload238Team, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload238Team$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload238Team' from JSON`,
  );
}

/** @internal */
export const UserEventPayload238Configuration$inboundSchema: z.ZodType<
  UserEventPayload238Configuration,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.optional(types.string()),
});
/** @internal */
export type UserEventPayload238Configuration$Outbound = {
  id: string;
  name?: string | undefined;
};

/** @internal */
export const UserEventPayload238Configuration$outboundSchema: z.ZodType<
  UserEventPayload238Configuration$Outbound,
  z.ZodTypeDef,
  UserEventPayload238Configuration
> = z.object({
  id: z.string(),
  name: z.string().optional(),
});

export function userEventPayload238ConfigurationToJSON(
  userEventPayload238Configuration: UserEventPayload238Configuration,
): string {
  return JSON.stringify(
    UserEventPayload238Configuration$outboundSchema.parse(
      userEventPayload238Configuration,
    ),
  );
}
export function userEventPayload238ConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload238Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload238Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload238Configuration' from JSON`,
  );
}

/** @internal */
export const Peering$inboundSchema: z.ZodType<Peering, z.ZodTypeDef, unknown> =
  z.object({
    id: types.string(),
    accountId: types.string(),
    region: types.string(),
    vpcId: types.string(),
  });
/** @internal */
export type Peering$Outbound = {
  id: string;
  accountId: string;
  region: string;
  vpcId: string;
};

/** @internal */
export const Peering$outboundSchema: z.ZodType<
  Peering$Outbound,
  z.ZodTypeDef,
  Peering
> = z.object({
  id: z.string(),
  accountId: z.string(),
  region: z.string(),
  vpcId: z.string(),
});

export function peeringToJSON(peering: Peering): string {
  return JSON.stringify(Peering$outboundSchema.parse(peering));
}
export function peeringFromJSON(
  jsonString: string,
): SafeParseResult<Peering, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Peering$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Peering' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndThirtyEight$inboundSchema: z.ZodType<
  TwoHundredAndThirtyEight,
  z.ZodTypeDef,
  unknown
> = z.object({
  team: z.lazy(() => UserEventPayload238Team$inboundSchema),
  configuration: z.lazy(() => UserEventPayload238Configuration$inboundSchema),
  peering: z.lazy(() => Peering$inboundSchema),
});
/** @internal */
export type TwoHundredAndThirtyEight$Outbound = {
  team: UserEventPayload238Team$Outbound;
  configuration: UserEventPayload238Configuration$Outbound;
  peering: Peering$Outbound;
};

/** @internal */
export const TwoHundredAndThirtyEight$outboundSchema: z.ZodType<
  TwoHundredAndThirtyEight$Outbound,
  z.ZodTypeDef,
  TwoHundredAndThirtyEight
> = z.object({
  team: z.lazy(() => UserEventPayload238Team$outboundSchema),
  configuration: z.lazy(() => UserEventPayload238Configuration$outboundSchema),
  peering: z.lazy(() => Peering$outboundSchema),
});

export function twoHundredAndThirtyEightToJSON(
  twoHundredAndThirtyEight: TwoHundredAndThirtyEight,
): string {
  return JSON.stringify(
    TwoHundredAndThirtyEight$outboundSchema.parse(twoHundredAndThirtyEight),
  );
}
export function twoHundredAndThirtyEightFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndThirtyEight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndThirtyEight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndThirtyEight' from JSON`,
  );
}

/** @internal */
export const App$inboundSchema: z.ZodType<App, z.ZodTypeDef, unknown> = z
  .object({
    id: types.string(),
    name: types.string(),
  });
/** @internal */
export type App$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const App$outboundSchema: z.ZodType<App$Outbound, z.ZodTypeDef, App> = z
  .object({
    id: z.string(),
    name: z.string(),
  });

export function appToJSON(app: App): string {
  return JSON.stringify(App$outboundSchema.parse(app));
}
export function appFromJSON(
  jsonString: string,
): SafeParseResult<App, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => App$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'App' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndThirtySeven$inboundSchema: z.ZodType<
  TwoHundredAndThirtySeven,
  z.ZodTypeDef,
  unknown
> = z.object({
  appName: types.string(),
  appId: types.optional(types.string()),
  app: types.optional(z.lazy(() => App$inboundSchema)),
  issuedBefore: types.optional(types.number()),
});
/** @internal */
export type TwoHundredAndThirtySeven$Outbound = {
  appName: string;
  appId?: string | undefined;
  app?: App$Outbound | undefined;
  issuedBefore?: number | undefined;
};

/** @internal */
export const TwoHundredAndThirtySeven$outboundSchema: z.ZodType<
  TwoHundredAndThirtySeven$Outbound,
  z.ZodTypeDef,
  TwoHundredAndThirtySeven
> = z.object({
  appName: z.string(),
  appId: z.string().optional(),
  app: z.lazy(() => App$outboundSchema).optional(),
  issuedBefore: z.number().optional(),
});

export function twoHundredAndThirtySevenToJSON(
  twoHundredAndThirtySeven: TwoHundredAndThirtySeven,
): string {
  return JSON.stringify(
    TwoHundredAndThirtySeven$outboundSchema.parse(twoHundredAndThirtySeven),
  );
}
export function twoHundredAndThirtySevenFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndThirtySeven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndThirtySeven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndThirtySeven' from JSON`,
  );
}

/** @internal */
export const UserEventPayload236Type$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236Type
> = z.nativeEnum(UserEventPayload236Type);
/** @internal */
export const UserEventPayload236Type$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236Type
> = UserEventPayload236Type$inboundSchema;

/** @internal */
export const UserEventPayload236BeforeType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236BeforeType
> = z.nativeEnum(UserEventPayload236BeforeType);
/** @internal */
export const UserEventPayload236BeforeType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236BeforeType
> = UserEventPayload236BeforeType$inboundSchema;

/** @internal */
export const PayloadItems$inboundSchema: z.ZodType<
  PayloadItems,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventPayload236BeforeType$inboundSchema,
});
/** @internal */
export type PayloadItems$Outbound = {
  type: string;
};

/** @internal */
export const PayloadItems$outboundSchema: z.ZodType<
  PayloadItems$Outbound,
  z.ZodTypeDef,
  PayloadItems
> = z.object({
  type: UserEventPayload236BeforeType$outboundSchema,
});

export function payloadItemsToJSON(payloadItems: PayloadItems): string {
  return JSON.stringify(PayloadItems$outboundSchema.parse(payloadItems));
}
export function payloadItemsFromJSON(
  jsonString: string,
): SafeParseResult<PayloadItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadItems' from JSON`,
  );
}

/** @internal */
export const UserEventPayloadProjectIds$inboundSchema: z.ZodType<
  UserEventPayloadProjectIds,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventPayload236Type$inboundSchema,
  required: types.boolean(),
  items: z.lazy(() => PayloadItems$inboundSchema),
});
/** @internal */
export type UserEventPayloadProjectIds$Outbound = {
  type: string;
  required: boolean;
  items: PayloadItems$Outbound;
};

/** @internal */
export const UserEventPayloadProjectIds$outboundSchema: z.ZodType<
  UserEventPayloadProjectIds$Outbound,
  z.ZodTypeDef,
  UserEventPayloadProjectIds
> = z.object({
  type: UserEventPayload236Type$outboundSchema,
  required: z.boolean(),
  items: z.lazy(() => PayloadItems$outboundSchema),
});

export function userEventPayloadProjectIdsToJSON(
  userEventPayloadProjectIds: UserEventPayloadProjectIds,
): string {
  return JSON.stringify(
    UserEventPayloadProjectIds$outboundSchema.parse(userEventPayloadProjectIds),
  );
}
export function userEventPayloadProjectIdsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayloadProjectIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayloadProjectIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayloadProjectIds' from JSON`,
  );
}

/** @internal */
export const PayloadResources$inboundSchema: z.ZodType<
  PayloadResources,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIds: z.lazy(() => UserEventPayloadProjectIds$inboundSchema),
});
/** @internal */
export type PayloadResources$Outbound = {
  projectIds: UserEventPayloadProjectIds$Outbound;
};

/** @internal */
export const PayloadResources$outboundSchema: z.ZodType<
  PayloadResources$Outbound,
  z.ZodTypeDef,
  PayloadResources
> = z.object({
  projectIds: z.lazy(() => UserEventPayloadProjectIds$outboundSchema),
});

export function payloadResourcesToJSON(
  payloadResources: PayloadResources,
): string {
  return JSON.stringify(
    PayloadResources$outboundSchema.parse(payloadResources),
  );
}
export function payloadResourcesFromJSON(
  jsonString: string,
): SafeParseResult<PayloadResources, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadResources$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadResources' from JSON`,
  );
}

/** @internal */
export const UserEventPayloadPermissions$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayloadPermissions
> = z.nativeEnum(UserEventPayloadPermissions);
/** @internal */
export const UserEventPayloadPermissions$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayloadPermissions
> = UserEventPayloadPermissions$inboundSchema;

/** @internal */
export const Before$inboundSchema: z.ZodType<Before, z.ZodTypeDef, unknown> = z
  .object({
    resources: types.optional(z.lazy(() => PayloadResources$inboundSchema)),
    permissions: types.optional(
      z.array(UserEventPayloadPermissions$inboundSchema),
    ),
  });
/** @internal */
export type Before$Outbound = {
  resources?: PayloadResources$Outbound | undefined;
  permissions?: Array<string> | undefined;
};

/** @internal */
export const Before$outboundSchema: z.ZodType<
  Before$Outbound,
  z.ZodTypeDef,
  Before
> = z.object({
  resources: z.lazy(() => PayloadResources$outboundSchema).optional(),
  permissions: z.array(UserEventPayloadPermissions$outboundSchema).optional(),
});

export function beforeToJSON(before: Before): string {
  return JSON.stringify(Before$outboundSchema.parse(before));
}
export function beforeFromJSON(
  jsonString: string,
): SafeParseResult<Before, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Before$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Before' from JSON`,
  );
}

/** @internal */
export const UserEventPayload236AfterType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236AfterType
> = z.nativeEnum(UserEventPayload236AfterType);
/** @internal */
export const UserEventPayload236AfterType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236AfterType
> = UserEventPayload236AfterType$inboundSchema;

/** @internal */
export const UserEventPayload236AfterResourcesType$inboundSchema:
  z.ZodNativeEnum<typeof UserEventPayload236AfterResourcesType> = z.nativeEnum(
    UserEventPayload236AfterResourcesType,
  );
/** @internal */
export const UserEventPayload236AfterResourcesType$outboundSchema:
  z.ZodNativeEnum<typeof UserEventPayload236AfterResourcesType> =
    UserEventPayload236AfterResourcesType$inboundSchema;

/** @internal */
export const UserEventPayloadItems$inboundSchema: z.ZodType<
  UserEventPayloadItems,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventPayload236AfterResourcesType$inboundSchema,
});
/** @internal */
export type UserEventPayloadItems$Outbound = {
  type: string;
};

/** @internal */
export const UserEventPayloadItems$outboundSchema: z.ZodType<
  UserEventPayloadItems$Outbound,
  z.ZodTypeDef,
  UserEventPayloadItems
> = z.object({
  type: UserEventPayload236AfterResourcesType$outboundSchema,
});

export function userEventPayloadItemsToJSON(
  userEventPayloadItems: UserEventPayloadItems,
): string {
  return JSON.stringify(
    UserEventPayloadItems$outboundSchema.parse(userEventPayloadItems),
  );
}
export function userEventPayloadItemsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayloadItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayloadItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayloadItems' from JSON`,
  );
}

/** @internal */
export const UserEventPayload236ProjectIds$inboundSchema: z.ZodType<
  UserEventPayload236ProjectIds,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventPayload236AfterType$inboundSchema,
  required: types.boolean(),
  items: z.lazy(() => UserEventPayloadItems$inboundSchema),
});
/** @internal */
export type UserEventPayload236ProjectIds$Outbound = {
  type: string;
  required: boolean;
  items: UserEventPayloadItems$Outbound;
};

/** @internal */
export const UserEventPayload236ProjectIds$outboundSchema: z.ZodType<
  UserEventPayload236ProjectIds$Outbound,
  z.ZodTypeDef,
  UserEventPayload236ProjectIds
> = z.object({
  type: UserEventPayload236AfterType$outboundSchema,
  required: z.boolean(),
  items: z.lazy(() => UserEventPayloadItems$outboundSchema),
});

export function userEventPayload236ProjectIdsToJSON(
  userEventPayload236ProjectIds: UserEventPayload236ProjectIds,
): string {
  return JSON.stringify(
    UserEventPayload236ProjectIds$outboundSchema.parse(
      userEventPayload236ProjectIds,
    ),
  );
}
export function userEventPayload236ProjectIdsFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayload236ProjectIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayload236ProjectIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayload236ProjectIds' from JSON`,
  );
}

/** @internal */
export const UserEventPayloadResources$inboundSchema: z.ZodType<
  UserEventPayloadResources,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIds: z.lazy(() => UserEventPayload236ProjectIds$inboundSchema),
});
/** @internal */
export type UserEventPayloadResources$Outbound = {
  projectIds: UserEventPayload236ProjectIds$Outbound;
};

/** @internal */
export const UserEventPayloadResources$outboundSchema: z.ZodType<
  UserEventPayloadResources$Outbound,
  z.ZodTypeDef,
  UserEventPayloadResources
> = z.object({
  projectIds: z.lazy(() => UserEventPayload236ProjectIds$outboundSchema),
});

export function userEventPayloadResourcesToJSON(
  userEventPayloadResources: UserEventPayloadResources,
): string {
  return JSON.stringify(
    UserEventPayloadResources$outboundSchema.parse(userEventPayloadResources),
  );
}
export function userEventPayloadResourcesFromJSON(
  jsonString: string,
): SafeParseResult<UserEventPayloadResources, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserEventPayloadResources$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserEventPayloadResources' from JSON`,
  );
}

/** @internal */
export const UserEventPayload236Permissions$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236Permissions
> = z.nativeEnum(UserEventPayload236Permissions);
/** @internal */
export const UserEventPayload236Permissions$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload236Permissions
> = UserEventPayload236Permissions$inboundSchema;

/** @internal */
export const After$inboundSchema: z.ZodType<After, z.ZodTypeDef, unknown> = z
  .object({
    resources: types.optional(
      z.lazy(() => UserEventPayloadResources$inboundSchema),
    ),
    permissions: types.optional(
      z.array(UserEventPayload236Permissions$inboundSchema),
    ),
  });
/** @internal */
export type After$Outbound = {
  resources?: UserEventPayloadResources$Outbound | undefined;
  permissions?: Array<string> | undefined;
};

/** @internal */
export const After$outboundSchema: z.ZodType<
  After$Outbound,
  z.ZodTypeDef,
  After
> = z.object({
  resources: z.lazy(() => UserEventPayloadResources$outboundSchema).optional(),
  permissions: z.array(UserEventPayload236Permissions$outboundSchema)
    .optional(),
});

export function afterToJSON(after: After): string {
  return JSON.stringify(After$outboundSchema.parse(after));
}
export function afterFromJSON(
  jsonString: string,
): SafeParseResult<After, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => After$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'After' from JSON`,
  );
}

/** @internal */
export const TwoHundredAndThirtySix$inboundSchema: z.ZodType<
  TwoHundredAndThirtySix,
  z.ZodTypeDef,
  unknown
> = z.object({
  appName: types.string(),
  appId: types.optional(types.string()),
  installationId: types.optional(types.string()),
  before: types.optional(z.lazy(() => Before$inboundSchema)),
  after: types.optional(z.lazy(() => After$inboundSchema)),
});
/** @internal */
export type TwoHundredAndThirtySix$Outbound = {
  appName: string;
  appId?: string | undefined;
  installationId?: string | undefined;
  before?: Before$Outbound | undefined;
  after?: After$Outbound | undefined;
};

/** @internal */
export const TwoHundredAndThirtySix$outboundSchema: z.ZodType<
  TwoHundredAndThirtySix$Outbound,
  z.ZodTypeDef,
  TwoHundredAndThirtySix
> = z.object({
  appName: z.string(),
  appId: z.string().optional(),
  installationId: z.string().optional(),
  before: z.lazy(() => Before$outboundSchema).optional(),
  after: z.lazy(() => After$outboundSchema).optional(),
});

export function twoHundredAndThirtySixToJSON(
  twoHundredAndThirtySix: TwoHundredAndThirtySix,
): string {
  return JSON.stringify(
    TwoHundredAndThirtySix$outboundSchema.parse(twoHundredAndThirtySix),
  );
}
export function twoHundredAndThirtySixFromJSON(
  jsonString: string,
): SafeParseResult<TwoHundredAndThirtySix, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoHundredAndThirtySix$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoHundredAndThirtySix' from JSON`,
  );
}

/** @internal */
export const UserEventPayload235Type$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload235Type
> = z.nativeEnum(UserEventPayload235Type);
/** @internal */
export const UserEventPayload235Type$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload235Type
> = UserEventPayload235Type$inboundSchema;

/** @internal */
export const UserEventPayload235ResourcesType$inboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload235ResourcesType
> = z.nativeEnum(UserEventPayload235ResourcesType);
/** @internal */
export const UserEventPayload235ResourcesType$outboundSchema: z.ZodNativeEnum<
  typeof UserEventPayload235ResourcesType
> = UserEventPayload235ResourcesType$inboundSchema;

/** @internal */
export const Items$inboundSchema: z.ZodType<Items, z.ZodTypeDef, unknown> = z
  .object({
    type: UserEventPayload235ResourcesType$inboundSchema,
  });
/** @internal */
export type Items$Outbound = {
  type: string;
};

/** @internal */
export const Items$outboundSchema: z.ZodType<
  Items$Outbound,
  z.ZodTypeDef,
  Items
> = z.object({
  type: UserEventPayload235ResourcesType$outboundSchema,
});

export function itemsToJSON(items: Items): string {
  return JSON.stringify(Items$outboundSchema.parse(items));
}
export function itemsFromJSON(
  jsonString: string,
): SafeParseResult<Items, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Items$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Items' from JSON`,
  );
}

/** @internal */
export const PayloadProjectIds$inboundSchema: z.ZodType<
  PayloadProjectIds,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UserEventPayload235Type$inboundSchema,
  required: types.boolean(),
  items: z.lazy(() => Items$inboundSchema),
});
/** @internal */
export type PayloadProjectIds$Outbound = {
  type: string;
  required: boolean;
  items: Items$Outbound;
};

/** @internal */
export const PayloadProjectIds$outboundSchema: z.ZodType<
  PayloadProjectIds$Outbound,
  z.ZodTypeDef,
  PayloadProjectIds
> = z.object({
  type: UserEventPayload235Type$outboundSchema,
  required: z.boolean(),
  items: z.lazy(() => Items$outboundSchema),
});

export function payloadProjectIdsToJSON(
  payloadProjectIds: PayloadProjectIds,
): string {
  return JSON.stringify(
    PayloadProjectIds$outboundSchema.parse(payloadProjectIds),
  );
}
export function payloadProjectIdsFromJSON(
  jsonString: string,
): SafeParseResult<PayloadProjectIds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PayloadProjectIds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PayloadProjectIds' from JSON`,
  );
}
