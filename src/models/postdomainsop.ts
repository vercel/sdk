/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * transfer-in
 */
export type RequestBody3 = {
  /**
   * The domain name you want to add.
   */
  name: string;
  /**
   * The domain operation to perform. It can be either `add` or `transfer-in`.
   */
  method: string;
  /**
   * The authorization code assigned to the domain.
   */
  authCode?: string | undefined;
  /**
   * The price you expect to be charged for the required 1 year renewal.
   */
  expectedPrice?: number | undefined;
};

/**
 * move-in
 */
export type RequestBody2 = {
  /**
   * The domain name you want to add.
   */
  name: string;
  /**
   * The domain operation to perform. It can be either `add` or `transfer-in`.
   */
  method: string;
  /**
   * The move-in token from Move Requested email.
   */
  token?: string | undefined;
};

/**
 * add
 */
export type RequestBody1 = {
  /**
   * The domain name you want to add.
   */
  name: string;
  /**
   * Whether the domain has the Vercel Edge Network enabled or not.
   */
  cdnEnabled?: boolean | undefined;
  zone?: boolean | undefined;
  /**
   * The domain operation to perform. It can be either `add` or `transfer-in`.
   */
  method?: string | undefined;
};

export type PostDomainsRequestBody = RequestBody2 | RequestBody1 | RequestBody3;

/**
 * An object containing information of the domain creator, including the user's id, username, and email.
 */
export type PostDomainsCreator = {
  username: string;
  email: string;
  customerId?: string | null | undefined;
  isDomainReseller?: boolean | undefined;
  id: string;
};

/**
 * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
 */
export const ServiceType = {
  ZeitWorld: "zeit.world",
  External: "external",
  Na: "na",
} as const;
/**
 * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
 */
export type ServiceType = ClosedEnum<typeof ServiceType>;

export type PostDomainsDomain = {
  /**
   * If the domain has the ownership verified.
   */
  verified: boolean;
  /**
   * A list of the current nameservers of the domain.
   */
  nameservers: Array<string>;
  /**
   * A list of the intended nameservers for the domain to point to Vercel DNS.
   */
  intendedNameservers: Array<string>;
  /**
   * A list of custom nameservers for the domain to point to. Only applies to domains purchased with Vercel.
   */
  customNameservers?: Array<string> | undefined;
  /**
   * An object containing information of the domain creator, including the user's id, username, and email.
   */
  creator: PostDomainsCreator;
  /**
   * The domain name.
   */
  name: string;
  /**
   * If it was purchased through Vercel, the timestamp in milliseconds when it was purchased.
   */
  boughtAt: number | null;
  /**
   * Timestamp in milliseconds when the domain was created in the registry.
   */
  createdAt: number;
  /**
   * Timestamp in milliseconds at which the domain is set to expire. `null` if not bought with Vercel.
   */
  expiresAt: number | null;
  /**
   * The unique identifier of the domain.
   */
  id: string;
  /**
   * Timestamp in milliseconds at which the domain was ordered.
   */
  orderedAt?: number | undefined;
  /**
   * Indicates whether the domain is set to automatically renew.
   */
  renew?: boolean | undefined;
  /**
   * The type of service the domain is handled by. `external` if the DNS is externally handled, `zeit.world` if handled with Vercel, or `na` if the service is not available.
   */
  serviceType: ServiceType;
  /**
   * Timestamp in milliseconds at which the domain was successfully transferred into Vercel. `null` if the transfer is still processing or was never transferred in.
   */
  transferredAt?: number | null | undefined;
  /**
   * If transferred into Vercel, timestamp in milliseconds when the domain transfer was initiated.
   */
  transferStartedAt?: number | undefined;
  userId: string;
  teamId: string | null;
};

export type PostDomainsResponseBody = {
  domain: PostDomainsDomain;
};

/** @internal */
export const RequestBody3$inboundSchema: z.ZodType<
  RequestBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  method: z.string(),
  authCode: z.string().optional(),
  expectedPrice: z.number().optional(),
});

/** @internal */
export type RequestBody3$Outbound = {
  name: string;
  method: string;
  authCode?: string | undefined;
  expectedPrice?: number | undefined;
};

/** @internal */
export const RequestBody3$outboundSchema: z.ZodType<
  RequestBody3$Outbound,
  z.ZodTypeDef,
  RequestBody3
> = z.object({
  name: z.string(),
  method: z.string(),
  authCode: z.string().optional(),
  expectedPrice: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody3$ {
  /** @deprecated use `RequestBody3$inboundSchema` instead. */
  export const inboundSchema = RequestBody3$inboundSchema;
  /** @deprecated use `RequestBody3$outboundSchema` instead. */
  export const outboundSchema = RequestBody3$outboundSchema;
  /** @deprecated use `RequestBody3$Outbound` instead. */
  export type Outbound = RequestBody3$Outbound;
}

export function requestBody3ToJSON(requestBody3: RequestBody3): string {
  return JSON.stringify(RequestBody3$outboundSchema.parse(requestBody3));
}

export function requestBody3FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody3' from JSON`,
  );
}

/** @internal */
export const RequestBody2$inboundSchema: z.ZodType<
  RequestBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  method: z.string(),
  token: z.string().optional(),
});

/** @internal */
export type RequestBody2$Outbound = {
  name: string;
  method: string;
  token?: string | undefined;
};

/** @internal */
export const RequestBody2$outboundSchema: z.ZodType<
  RequestBody2$Outbound,
  z.ZodTypeDef,
  RequestBody2
> = z.object({
  name: z.string(),
  method: z.string(),
  token: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody2$ {
  /** @deprecated use `RequestBody2$inboundSchema` instead. */
  export const inboundSchema = RequestBody2$inboundSchema;
  /** @deprecated use `RequestBody2$outboundSchema` instead. */
  export const outboundSchema = RequestBody2$outboundSchema;
  /** @deprecated use `RequestBody2$Outbound` instead. */
  export type Outbound = RequestBody2$Outbound;
}

export function requestBody2ToJSON(requestBody2: RequestBody2): string {
  return JSON.stringify(RequestBody2$outboundSchema.parse(requestBody2));
}

export function requestBody2FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody2' from JSON`,
  );
}

/** @internal */
export const RequestBody1$inboundSchema: z.ZodType<
  RequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  cdnEnabled: z.boolean().optional(),
  zone: z.boolean().optional(),
  method: z.string().optional(),
});

/** @internal */
export type RequestBody1$Outbound = {
  name: string;
  cdnEnabled?: boolean | undefined;
  zone?: boolean | undefined;
  method?: string | undefined;
};

/** @internal */
export const RequestBody1$outboundSchema: z.ZodType<
  RequestBody1$Outbound,
  z.ZodTypeDef,
  RequestBody1
> = z.object({
  name: z.string(),
  cdnEnabled: z.boolean().optional(),
  zone: z.boolean().optional(),
  method: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody1$ {
  /** @deprecated use `RequestBody1$inboundSchema` instead. */
  export const inboundSchema = RequestBody1$inboundSchema;
  /** @deprecated use `RequestBody1$outboundSchema` instead. */
  export const outboundSchema = RequestBody1$outboundSchema;
  /** @deprecated use `RequestBody1$Outbound` instead. */
  export type Outbound = RequestBody1$Outbound;
}

export function requestBody1ToJSON(requestBody1: RequestBody1): string {
  return JSON.stringify(RequestBody1$outboundSchema.parse(requestBody1));
}

export function requestBody1FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody1' from JSON`,
  );
}

/** @internal */
export const PostDomainsRequestBody$inboundSchema: z.ZodType<
  PostDomainsRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBody2$inboundSchema),
  z.lazy(() => RequestBody1$inboundSchema),
  z.lazy(() => RequestBody3$inboundSchema),
]);

/** @internal */
export type PostDomainsRequestBody$Outbound =
  | RequestBody2$Outbound
  | RequestBody1$Outbound
  | RequestBody3$Outbound;

/** @internal */
export const PostDomainsRequestBody$outboundSchema: z.ZodType<
  PostDomainsRequestBody$Outbound,
  z.ZodTypeDef,
  PostDomainsRequestBody
> = z.union([
  z.lazy(() => RequestBody2$outboundSchema),
  z.lazy(() => RequestBody1$outboundSchema),
  z.lazy(() => RequestBody3$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostDomainsRequestBody$ {
  /** @deprecated use `PostDomainsRequestBody$inboundSchema` instead. */
  export const inboundSchema = PostDomainsRequestBody$inboundSchema;
  /** @deprecated use `PostDomainsRequestBody$outboundSchema` instead. */
  export const outboundSchema = PostDomainsRequestBody$outboundSchema;
  /** @deprecated use `PostDomainsRequestBody$Outbound` instead. */
  export type Outbound = PostDomainsRequestBody$Outbound;
}

export function postDomainsRequestBodyToJSON(
  postDomainsRequestBody: PostDomainsRequestBody,
): string {
  return JSON.stringify(
    PostDomainsRequestBody$outboundSchema.parse(postDomainsRequestBody),
  );
}

export function postDomainsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<PostDomainsRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostDomainsRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostDomainsRequestBody' from JSON`,
  );
}

/** @internal */
export const PostDomainsCreator$inboundSchema: z.ZodType<
  PostDomainsCreator,
  z.ZodTypeDef,
  unknown
> = z.object({
  username: z.string(),
  email: z.string(),
  customerId: z.nullable(z.string()).optional(),
  isDomainReseller: z.boolean().optional(),
  id: z.string(),
});

/** @internal */
export type PostDomainsCreator$Outbound = {
  username: string;
  email: string;
  customerId?: string | null | undefined;
  isDomainReseller?: boolean | undefined;
  id: string;
};

/** @internal */
export const PostDomainsCreator$outboundSchema: z.ZodType<
  PostDomainsCreator$Outbound,
  z.ZodTypeDef,
  PostDomainsCreator
> = z.object({
  username: z.string(),
  email: z.string(),
  customerId: z.nullable(z.string()).optional(),
  isDomainReseller: z.boolean().optional(),
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostDomainsCreator$ {
  /** @deprecated use `PostDomainsCreator$inboundSchema` instead. */
  export const inboundSchema = PostDomainsCreator$inboundSchema;
  /** @deprecated use `PostDomainsCreator$outboundSchema` instead. */
  export const outboundSchema = PostDomainsCreator$outboundSchema;
  /** @deprecated use `PostDomainsCreator$Outbound` instead. */
  export type Outbound = PostDomainsCreator$Outbound;
}

export function postDomainsCreatorToJSON(
  postDomainsCreator: PostDomainsCreator,
): string {
  return JSON.stringify(
    PostDomainsCreator$outboundSchema.parse(postDomainsCreator),
  );
}

export function postDomainsCreatorFromJSON(
  jsonString: string,
): SafeParseResult<PostDomainsCreator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostDomainsCreator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostDomainsCreator' from JSON`,
  );
}

/** @internal */
export const ServiceType$inboundSchema: z.ZodNativeEnum<typeof ServiceType> = z
  .nativeEnum(ServiceType);

/** @internal */
export const ServiceType$outboundSchema: z.ZodNativeEnum<typeof ServiceType> =
  ServiceType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServiceType$ {
  /** @deprecated use `ServiceType$inboundSchema` instead. */
  export const inboundSchema = ServiceType$inboundSchema;
  /** @deprecated use `ServiceType$outboundSchema` instead. */
  export const outboundSchema = ServiceType$outboundSchema;
}

/** @internal */
export const PostDomainsDomain$inboundSchema: z.ZodType<
  PostDomainsDomain,
  z.ZodTypeDef,
  unknown
> = z.object({
  verified: z.boolean(),
  nameservers: z.array(z.string()),
  intendedNameservers: z.array(z.string()),
  customNameservers: z.array(z.string()).optional(),
  creator: z.lazy(() => PostDomainsCreator$inboundSchema),
  name: z.string(),
  boughtAt: z.nullable(z.number()),
  createdAt: z.number(),
  expiresAt: z.nullable(z.number()),
  id: z.string(),
  orderedAt: z.number().optional(),
  renew: z.boolean().optional(),
  serviceType: ServiceType$inboundSchema,
  transferredAt: z.nullable(z.number()).optional(),
  transferStartedAt: z.number().optional(),
  userId: z.string(),
  teamId: z.nullable(z.string()),
});

/** @internal */
export type PostDomainsDomain$Outbound = {
  verified: boolean;
  nameservers: Array<string>;
  intendedNameservers: Array<string>;
  customNameservers?: Array<string> | undefined;
  creator: PostDomainsCreator$Outbound;
  name: string;
  boughtAt: number | null;
  createdAt: number;
  expiresAt: number | null;
  id: string;
  orderedAt?: number | undefined;
  renew?: boolean | undefined;
  serviceType: string;
  transferredAt?: number | null | undefined;
  transferStartedAt?: number | undefined;
  userId: string;
  teamId: string | null;
};

/** @internal */
export const PostDomainsDomain$outboundSchema: z.ZodType<
  PostDomainsDomain$Outbound,
  z.ZodTypeDef,
  PostDomainsDomain
> = z.object({
  verified: z.boolean(),
  nameservers: z.array(z.string()),
  intendedNameservers: z.array(z.string()),
  customNameservers: z.array(z.string()).optional(),
  creator: z.lazy(() => PostDomainsCreator$outboundSchema),
  name: z.string(),
  boughtAt: z.nullable(z.number()),
  createdAt: z.number(),
  expiresAt: z.nullable(z.number()),
  id: z.string(),
  orderedAt: z.number().optional(),
  renew: z.boolean().optional(),
  serviceType: ServiceType$outboundSchema,
  transferredAt: z.nullable(z.number()).optional(),
  transferStartedAt: z.number().optional(),
  userId: z.string(),
  teamId: z.nullable(z.string()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostDomainsDomain$ {
  /** @deprecated use `PostDomainsDomain$inboundSchema` instead. */
  export const inboundSchema = PostDomainsDomain$inboundSchema;
  /** @deprecated use `PostDomainsDomain$outboundSchema` instead. */
  export const outboundSchema = PostDomainsDomain$outboundSchema;
  /** @deprecated use `PostDomainsDomain$Outbound` instead. */
  export type Outbound = PostDomainsDomain$Outbound;
}

export function postDomainsDomainToJSON(
  postDomainsDomain: PostDomainsDomain,
): string {
  return JSON.stringify(
    PostDomainsDomain$outboundSchema.parse(postDomainsDomain),
  );
}

export function postDomainsDomainFromJSON(
  jsonString: string,
): SafeParseResult<PostDomainsDomain, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostDomainsDomain$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostDomainsDomain' from JSON`,
  );
}

/** @internal */
export const PostDomainsResponseBody$inboundSchema: z.ZodType<
  PostDomainsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  domain: z.lazy(() => PostDomainsDomain$inboundSchema),
});

/** @internal */
export type PostDomainsResponseBody$Outbound = {
  domain: PostDomainsDomain$Outbound;
};

/** @internal */
export const PostDomainsResponseBody$outboundSchema: z.ZodType<
  PostDomainsResponseBody$Outbound,
  z.ZodTypeDef,
  PostDomainsResponseBody
> = z.object({
  domain: z.lazy(() => PostDomainsDomain$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostDomainsResponseBody$ {
  /** @deprecated use `PostDomainsResponseBody$inboundSchema` instead. */
  export const inboundSchema = PostDomainsResponseBody$inboundSchema;
  /** @deprecated use `PostDomainsResponseBody$outboundSchema` instead. */
  export const outboundSchema = PostDomainsResponseBody$outboundSchema;
  /** @deprecated use `PostDomainsResponseBody$Outbound` instead. */
  export type Outbound = PostDomainsResponseBody$Outbound;
}

export function postDomainsResponseBodyToJSON(
  postDomainsResponseBody: PostDomainsResponseBody,
): string {
  return JSON.stringify(
    PostDomainsResponseBody$outboundSchema.parse(postDomainsResponseBody),
  );
}

export function postDomainsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<PostDomainsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostDomainsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostDomainsResponseBody' from JSON`,
  );
}
