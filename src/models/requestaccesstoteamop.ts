/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * The origin of the request.
 */
export const RequestAccessToTeamOrigin = {
  Import: "import",
  Teams: "teams",
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Feedback: "feedback",
  OrganizationTeams: "organization-teams",
} as const;
/**
 * The origin of the request.
 */
export type RequestAccessToTeamOrigin = ClosedEnum<
  typeof RequestAccessToTeamOrigin
>;

/**
 * The ID of the Git account of the user who requests access.
 */
export type RequestAccessToTeamGitUserId = string | number;

export type RequestAccessToTeamJoinedFrom = {
  /**
   * The origin of the request.
   */
  origin: RequestAccessToTeamOrigin;
  /**
   * The commit sha if the origin is a git provider.
   */
  commitId?: string | undefined;
  /**
   * The ID of the repository for the given Git provider.
   */
  repoId?: string | undefined;
  /**
   * The path to the repository for the given Git provider.
   */
  repoPath?: string | undefined;
  /**
   * The ID of the Git account of the user who requests access.
   */
  gitUserId?: string | number | undefined;
  /**
   * The login name for the Git account of the user who requests access.
   */
  gitUserLogin?: string | undefined;
};

export type RequestAccessToTeamRequestBody = {
  joinedFrom: RequestAccessToTeamJoinedFrom;
};

export type RequestAccessToTeamRequest = {
  teamId: string;
  requestBody: RequestAccessToTeamRequestBody;
};

export const RequestAccessToTeamTeamsOrigin = {
  Teams: "teams",
  Link: "link",
  Import: "import",
  Mail: "mail",
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Saml: "saml",
  Dsync: "dsync",
  Feedback: "feedback",
  OrganizationTeams: "organization-teams",
  NsnbAutoApprove: "nsnb-auto-approve",
  NsnbRequestAccess: "nsnb-request-access",
  NsnbViewerUpgrade: "nsnb-viewer-upgrade",
  NsnbInvite: "nsnb-invite",
  NsnbRedeploy: "nsnb-redeploy",
} as const;
export type RequestAccessToTeamTeamsOrigin = ClosedEnum<
  typeof RequestAccessToTeamTeamsOrigin
>;

export type RequestAccessToTeamTeamsGitUserId = string | number;

export type RequestAccessToTeamTeamsJoinedFrom = {
  origin: RequestAccessToTeamTeamsOrigin;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

export type Github = {
  login?: string | undefined;
};

export type Gitlab = {
  login?: string | undefined;
};

export type Bitbucket = {
  login?: string | undefined;
};

/**
 * Successfuly requested access to the team.
 */
export type RequestAccessToTeamResponseBody = {
  teamSlug: string;
  teamName: string;
  confirmed?: boolean | undefined;
  joinedFrom?: RequestAccessToTeamTeamsJoinedFrom | undefined;
  accessRequestedAt?: number | undefined;
  github: Github | null;
  gitlab: Gitlab | null;
  bitbucket: Bitbucket | null;
};

/** @internal */
export const RequestAccessToTeamOrigin$inboundSchema: z.ZodNativeEnum<
  typeof RequestAccessToTeamOrigin
> = z.nativeEnum(RequestAccessToTeamOrigin);
/** @internal */
export const RequestAccessToTeamOrigin$outboundSchema: z.ZodNativeEnum<
  typeof RequestAccessToTeamOrigin
> = RequestAccessToTeamOrigin$inboundSchema;

/** @internal */
export const RequestAccessToTeamGitUserId$inboundSchema: z.ZodType<
  RequestAccessToTeamGitUserId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type RequestAccessToTeamGitUserId$Outbound = string | number;

/** @internal */
export const RequestAccessToTeamGitUserId$outboundSchema: z.ZodType<
  RequestAccessToTeamGitUserId$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamGitUserId
> = smartUnion([z.string(), z.number()]);

export function requestAccessToTeamGitUserIdToJSON(
  requestAccessToTeamGitUserId: RequestAccessToTeamGitUserId,
): string {
  return JSON.stringify(
    RequestAccessToTeamGitUserId$outboundSchema.parse(
      requestAccessToTeamGitUserId,
    ),
  );
}
export function requestAccessToTeamGitUserIdFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamGitUserId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamGitUserId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamGitUserId' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamJoinedFrom$inboundSchema: z.ZodType<
  RequestAccessToTeamJoinedFrom,
  z.ZodTypeDef,
  unknown
> = z.object({
  origin: RequestAccessToTeamOrigin$inboundSchema,
  commitId: types.optional(types.string()),
  repoId: types.optional(types.string()),
  repoPath: types.optional(types.string()),
  gitUserId: types.optional(smartUnion([types.string(), types.number()])),
  gitUserLogin: types.optional(types.string()),
});
/** @internal */
export type RequestAccessToTeamJoinedFrom$Outbound = {
  origin: string;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
};

/** @internal */
export const RequestAccessToTeamJoinedFrom$outboundSchema: z.ZodType<
  RequestAccessToTeamJoinedFrom$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamJoinedFrom
> = z.object({
  origin: RequestAccessToTeamOrigin$outboundSchema,
  commitId: z.string().optional(),
  repoId: z.string().optional(),
  repoPath: z.string().optional(),
  gitUserId: smartUnion([z.string(), z.number()]).optional(),
  gitUserLogin: z.string().optional(),
});

export function requestAccessToTeamJoinedFromToJSON(
  requestAccessToTeamJoinedFrom: RequestAccessToTeamJoinedFrom,
): string {
  return JSON.stringify(
    RequestAccessToTeamJoinedFrom$outboundSchema.parse(
      requestAccessToTeamJoinedFrom,
    ),
  );
}
export function requestAccessToTeamJoinedFromFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamJoinedFrom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamJoinedFrom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamJoinedFrom' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamRequestBody$inboundSchema: z.ZodType<
  RequestAccessToTeamRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  joinedFrom: z.lazy(() => RequestAccessToTeamJoinedFrom$inboundSchema),
});
/** @internal */
export type RequestAccessToTeamRequestBody$Outbound = {
  joinedFrom: RequestAccessToTeamJoinedFrom$Outbound;
};

/** @internal */
export const RequestAccessToTeamRequestBody$outboundSchema: z.ZodType<
  RequestAccessToTeamRequestBody$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamRequestBody
> = z.object({
  joinedFrom: z.lazy(() => RequestAccessToTeamJoinedFrom$outboundSchema),
});

export function requestAccessToTeamRequestBodyToJSON(
  requestAccessToTeamRequestBody: RequestAccessToTeamRequestBody,
): string {
  return JSON.stringify(
    RequestAccessToTeamRequestBody$outboundSchema.parse(
      requestAccessToTeamRequestBody,
    ),
  );
}
export function requestAccessToTeamRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamRequestBody' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamRequest$inboundSchema: z.ZodType<
  RequestAccessToTeamRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamId: types.string(),
  RequestBody: z.lazy(() => RequestAccessToTeamRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type RequestAccessToTeamRequest$Outbound = {
  teamId: string;
  RequestBody: RequestAccessToTeamRequestBody$Outbound;
};

/** @internal */
export const RequestAccessToTeamRequest$outboundSchema: z.ZodType<
  RequestAccessToTeamRequest$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamRequest
> = z.object({
  teamId: z.string(),
  requestBody: z.lazy(() => RequestAccessToTeamRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function requestAccessToTeamRequestToJSON(
  requestAccessToTeamRequest: RequestAccessToTeamRequest,
): string {
  return JSON.stringify(
    RequestAccessToTeamRequest$outboundSchema.parse(requestAccessToTeamRequest),
  );
}
export function requestAccessToTeamRequestFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamRequest' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamTeamsOrigin$inboundSchema: z.ZodNativeEnum<
  typeof RequestAccessToTeamTeamsOrigin
> = z.nativeEnum(RequestAccessToTeamTeamsOrigin);
/** @internal */
export const RequestAccessToTeamTeamsOrigin$outboundSchema: z.ZodNativeEnum<
  typeof RequestAccessToTeamTeamsOrigin
> = RequestAccessToTeamTeamsOrigin$inboundSchema;

/** @internal */
export const RequestAccessToTeamTeamsGitUserId$inboundSchema: z.ZodType<
  RequestAccessToTeamTeamsGitUserId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type RequestAccessToTeamTeamsGitUserId$Outbound = string | number;

/** @internal */
export const RequestAccessToTeamTeamsGitUserId$outboundSchema: z.ZodType<
  RequestAccessToTeamTeamsGitUserId$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamTeamsGitUserId
> = smartUnion([z.string(), z.number()]);

export function requestAccessToTeamTeamsGitUserIdToJSON(
  requestAccessToTeamTeamsGitUserId: RequestAccessToTeamTeamsGitUserId,
): string {
  return JSON.stringify(
    RequestAccessToTeamTeamsGitUserId$outboundSchema.parse(
      requestAccessToTeamTeamsGitUserId,
    ),
  );
}
export function requestAccessToTeamTeamsGitUserIdFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamTeamsGitUserId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamTeamsGitUserId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamTeamsGitUserId' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamTeamsJoinedFrom$inboundSchema: z.ZodType<
  RequestAccessToTeamTeamsJoinedFrom,
  z.ZodTypeDef,
  unknown
> = z.object({
  origin: RequestAccessToTeamTeamsOrigin$inboundSchema,
  commitId: types.optional(types.string()),
  repoId: types.optional(types.string()),
  repoPath: types.optional(types.string()),
  gitUserId: types.optional(smartUnion([types.string(), types.number()])),
  gitUserLogin: types.optional(types.string()),
  ssoUserId: types.optional(types.string()),
  ssoConnectedAt: types.optional(types.number()),
  idpUserId: types.optional(types.string()),
  dsyncUserId: types.optional(types.string()),
  dsyncConnectedAt: types.optional(types.number()),
});
/** @internal */
export type RequestAccessToTeamTeamsJoinedFrom$Outbound = {
  origin: string;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

/** @internal */
export const RequestAccessToTeamTeamsJoinedFrom$outboundSchema: z.ZodType<
  RequestAccessToTeamTeamsJoinedFrom$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamTeamsJoinedFrom
> = z.object({
  origin: RequestAccessToTeamTeamsOrigin$outboundSchema,
  commitId: z.string().optional(),
  repoId: z.string().optional(),
  repoPath: z.string().optional(),
  gitUserId: smartUnion([z.string(), z.number()]).optional(),
  gitUserLogin: z.string().optional(),
  ssoUserId: z.string().optional(),
  ssoConnectedAt: z.number().optional(),
  idpUserId: z.string().optional(),
  dsyncUserId: z.string().optional(),
  dsyncConnectedAt: z.number().optional(),
});

export function requestAccessToTeamTeamsJoinedFromToJSON(
  requestAccessToTeamTeamsJoinedFrom: RequestAccessToTeamTeamsJoinedFrom,
): string {
  return JSON.stringify(
    RequestAccessToTeamTeamsJoinedFrom$outboundSchema.parse(
      requestAccessToTeamTeamsJoinedFrom,
    ),
  );
}
export function requestAccessToTeamTeamsJoinedFromFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamTeamsJoinedFrom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RequestAccessToTeamTeamsJoinedFrom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamTeamsJoinedFrom' from JSON`,
  );
}

/** @internal */
export const Github$inboundSchema: z.ZodType<Github, z.ZodTypeDef, unknown> = z
  .object({
    login: types.optional(types.string()),
  });
/** @internal */
export type Github$Outbound = {
  login?: string | undefined;
};

/** @internal */
export const Github$outboundSchema: z.ZodType<
  Github$Outbound,
  z.ZodTypeDef,
  Github
> = z.object({
  login: z.string().optional(),
});

export function githubToJSON(github: Github): string {
  return JSON.stringify(Github$outboundSchema.parse(github));
}
export function githubFromJSON(
  jsonString: string,
): SafeParseResult<Github, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Github$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Github' from JSON`,
  );
}

/** @internal */
export const Gitlab$inboundSchema: z.ZodType<Gitlab, z.ZodTypeDef, unknown> = z
  .object({
    login: types.optional(types.string()),
  });
/** @internal */
export type Gitlab$Outbound = {
  login?: string | undefined;
};

/** @internal */
export const Gitlab$outboundSchema: z.ZodType<
  Gitlab$Outbound,
  z.ZodTypeDef,
  Gitlab
> = z.object({
  login: z.string().optional(),
});

export function gitlabToJSON(gitlab: Gitlab): string {
  return JSON.stringify(Gitlab$outboundSchema.parse(gitlab));
}
export function gitlabFromJSON(
  jsonString: string,
): SafeParseResult<Gitlab, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gitlab$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gitlab' from JSON`,
  );
}

/** @internal */
export const Bitbucket$inboundSchema: z.ZodType<
  Bitbucket,
  z.ZodTypeDef,
  unknown
> = z.object({
  login: types.optional(types.string()),
});
/** @internal */
export type Bitbucket$Outbound = {
  login?: string | undefined;
};

/** @internal */
export const Bitbucket$outboundSchema: z.ZodType<
  Bitbucket$Outbound,
  z.ZodTypeDef,
  Bitbucket
> = z.object({
  login: z.string().optional(),
});

export function bitbucketToJSON(bitbucket: Bitbucket): string {
  return JSON.stringify(Bitbucket$outboundSchema.parse(bitbucket));
}
export function bitbucketFromJSON(
  jsonString: string,
): SafeParseResult<Bitbucket, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Bitbucket$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Bitbucket' from JSON`,
  );
}

/** @internal */
export const RequestAccessToTeamResponseBody$inboundSchema: z.ZodType<
  RequestAccessToTeamResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamSlug: types.string(),
  teamName: types.string(),
  confirmed: types.optional(types.boolean()),
  joinedFrom: types.optional(
    z.lazy(() => RequestAccessToTeamTeamsJoinedFrom$inboundSchema),
  ),
  accessRequestedAt: types.optional(types.number()),
  github: types.nullable(z.lazy(() => Github$inboundSchema)),
  gitlab: types.nullable(z.lazy(() => Gitlab$inboundSchema)),
  bitbucket: types.nullable(z.lazy(() => Bitbucket$inboundSchema)),
});
/** @internal */
export type RequestAccessToTeamResponseBody$Outbound = {
  teamSlug: string;
  teamName: string;
  confirmed?: boolean | undefined;
  joinedFrom?: RequestAccessToTeamTeamsJoinedFrom$Outbound | undefined;
  accessRequestedAt?: number | undefined;
  github: Github$Outbound | null;
  gitlab: Gitlab$Outbound | null;
  bitbucket: Bitbucket$Outbound | null;
};

/** @internal */
export const RequestAccessToTeamResponseBody$outboundSchema: z.ZodType<
  RequestAccessToTeamResponseBody$Outbound,
  z.ZodTypeDef,
  RequestAccessToTeamResponseBody
> = z.object({
  teamSlug: z.string(),
  teamName: z.string(),
  confirmed: z.boolean().optional(),
  joinedFrom: z.lazy(() => RequestAccessToTeamTeamsJoinedFrom$outboundSchema)
    .optional(),
  accessRequestedAt: z.number().optional(),
  github: z.nullable(z.lazy(() => Github$outboundSchema)),
  gitlab: z.nullable(z.lazy(() => Gitlab$outboundSchema)),
  bitbucket: z.nullable(z.lazy(() => Bitbucket$outboundSchema)),
});

export function requestAccessToTeamResponseBodyToJSON(
  requestAccessToTeamResponseBody: RequestAccessToTeamResponseBody,
): string {
  return JSON.stringify(
    RequestAccessToTeamResponseBody$outboundSchema.parse(
      requestAccessToTeamResponseBody,
    ),
  );
}
export function requestAccessToTeamResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RequestAccessToTeamResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestAccessToTeamResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestAccessToTeamResponseBody' from JSON`,
  );
}
