/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { JsonLStream } from "../lib/jsonl.js";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import {
  SandboxCommand,
  SandboxCommand$inboundSchema,
  SandboxCommand$Outbound,
  SandboxCommand$outboundSchema,
} from "./sandboxcommand.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type RunCommandRequestBody = {
  /**
   * The executable or shell command to run. This is the program name without arguments.
   */
  command: string;
  /**
   * Arguments to pass to the command. Each argument should be a separate array element.
   */
  args?: Array<string> | undefined;
  /**
   * The working directory in which to execute the command. Defaults to the sandbox home directory if not specified.
   */
  cwd?: string | undefined;
  /**
   * Additional environment variables to set for this command. These are merged with the sandbox environment.
   */
  env?: { [k: string]: string } | undefined;
  /**
   * Execute the command with root (superuser) privileges.
   */
  sudo?: boolean | undefined;
  /**
   * If true, returns an ND-JSON stream that emits the command status when started and again when finished. Useful for synchronously waiting for command completion.
   */
  wait?: boolean | undefined;
};

export type RunCommandRequest = {
  /**
   * The unique identifier of the sandbox in which to execute the command.
   */
  sandboxId: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: RunCommandRequestBody | undefined;
};

export type RunCommandSandboxesResponseBody = {
  /**
   * This object represents command run in a Vercel Sandbox.
   */
  command: SandboxCommand;
};

export type RunCommandResponseBody = {
  /**
   * This object represents command run in a Vercel Sandbox.
   */
  command: SandboxCommand;
};

export type RunCommandResponse =
  | RunCommandResponseBody
  | JsonLStream<RunCommandSandboxesResponseBody>;

/** @internal */
export const RunCommandRequestBody$inboundSchema: z.ZodType<
  RunCommandRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  command: types.string(),
  args: types.optional(z.array(types.string())),
  cwd: types.optional(types.string()),
  env: types.optional(z.record(types.string())),
  sudo: types.boolean().default(false),
  wait: types.boolean().default(false),
});
/** @internal */
export type RunCommandRequestBody$Outbound = {
  command: string;
  args?: Array<string> | undefined;
  cwd?: string | undefined;
  env?: { [k: string]: string } | undefined;
  sudo: boolean;
  wait: boolean;
};

/** @internal */
export const RunCommandRequestBody$outboundSchema: z.ZodType<
  RunCommandRequestBody$Outbound,
  z.ZodTypeDef,
  RunCommandRequestBody
> = z.object({
  command: z.string(),
  args: z.array(z.string()).optional(),
  cwd: z.string().optional(),
  env: z.record(z.string()).optional(),
  sudo: z.boolean().default(false),
  wait: z.boolean().default(false),
});

export function runCommandRequestBodyToJSON(
  runCommandRequestBody: RunCommandRequestBody,
): string {
  return JSON.stringify(
    RunCommandRequestBody$outboundSchema.parse(runCommandRequestBody),
  );
}
export function runCommandRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunCommandRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunCommandRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunCommandRequestBody' from JSON`,
  );
}

/** @internal */
export const RunCommandRequest$inboundSchema: z.ZodType<
  RunCommandRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  sandboxId: types.string(),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: types.optional(
    z.lazy(() => RunCommandRequestBody$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type RunCommandRequest$Outbound = {
  sandboxId: string;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: RunCommandRequestBody$Outbound | undefined;
};

/** @internal */
export const RunCommandRequest$outboundSchema: z.ZodType<
  RunCommandRequest$Outbound,
  z.ZodTypeDef,
  RunCommandRequest
> = z.object({
  sandboxId: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => RunCommandRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function runCommandRequestToJSON(
  runCommandRequest: RunCommandRequest,
): string {
  return JSON.stringify(
    RunCommandRequest$outboundSchema.parse(runCommandRequest),
  );
}
export function runCommandRequestFromJSON(
  jsonString: string,
): SafeParseResult<RunCommandRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunCommandRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunCommandRequest' from JSON`,
  );
}

/** @internal */
export const RunCommandSandboxesResponseBody$inboundSchema: z.ZodType<
  RunCommandSandboxesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  command: SandboxCommand$inboundSchema,
});
/** @internal */
export type RunCommandSandboxesResponseBody$Outbound = {
  command: SandboxCommand$Outbound;
};

/** @internal */
export const RunCommandSandboxesResponseBody$outboundSchema: z.ZodType<
  RunCommandSandboxesResponseBody$Outbound,
  z.ZodTypeDef,
  RunCommandSandboxesResponseBody
> = z.object({
  command: SandboxCommand$outboundSchema,
});

export function runCommandSandboxesResponseBodyToJSON(
  runCommandSandboxesResponseBody: RunCommandSandboxesResponseBody,
): string {
  return JSON.stringify(
    RunCommandSandboxesResponseBody$outboundSchema.parse(
      runCommandSandboxesResponseBody,
    ),
  );
}
export function runCommandSandboxesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunCommandSandboxesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunCommandSandboxesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunCommandSandboxesResponseBody' from JSON`,
  );
}

/** @internal */
export const RunCommandResponseBody$inboundSchema: z.ZodType<
  RunCommandResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  command: SandboxCommand$inboundSchema,
});
/** @internal */
export type RunCommandResponseBody$Outbound = {
  command: SandboxCommand$Outbound;
};

/** @internal */
export const RunCommandResponseBody$outboundSchema: z.ZodType<
  RunCommandResponseBody$Outbound,
  z.ZodTypeDef,
  RunCommandResponseBody
> = z.object({
  command: SandboxCommand$outboundSchema,
});

export function runCommandResponseBodyToJSON(
  runCommandResponseBody: RunCommandResponseBody,
): string {
  return JSON.stringify(
    RunCommandResponseBody$outboundSchema.parse(runCommandResponseBody),
  );
}
export function runCommandResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunCommandResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunCommandResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunCommandResponseBody' from JSON`,
  );
}

/** @internal */
export const RunCommandResponse$inboundSchema: z.ZodType<
  RunCommandResponse,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => RunCommandResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>).transform(stream => {
    return new JsonLStream({
      stream,
      decoder(rawEvent) {
        const schema = z.lazy(() =>
          RunCommandSandboxesResponseBody$inboundSchema
        );
        return schema.parse(rawEvent);
      },
    });
  }),
]);
/** @internal */
export type RunCommandResponse$Outbound =
  | RunCommandResponseBody$Outbound
  | never;

/** @internal */
export const RunCommandResponse$outboundSchema: z.ZodType<
  RunCommandResponse$Outbound,
  z.ZodTypeDef,
  RunCommandResponse
> = smartUnion([
  z.lazy(() => RunCommandResponseBody$outboundSchema),
  z.never(),
]);

export function runCommandResponseToJSON(
  runCommandResponse: RunCommandResponse,
): string {
  return JSON.stringify(
    RunCommandResponse$outboundSchema.parse(runCommandResponse),
  );
}
export function runCommandResponseFromJSON(
  jsonString: string,
): SafeParseResult<RunCommandResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunCommandResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunCommandResponse' from JSON`,
  );
}
