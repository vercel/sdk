/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  SandboxInjectionRule,
  SandboxInjectionRule$inboundSchema,
  SandboxInjectionRule$Outbound,
  SandboxInjectionRule$outboundSchema,
} from "./sandboxinjectionrule.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * The network policy mode. - 'allow-all': All traffic is allowed. - 'deny-all': All traffic is blocked. - 'custom': Traffic is controlled by explicit allow/deny rules.
 */
export const Mode = {
  AllowAll: "allow-all",
  DenyAll: "deny-all",
  Custom: "custom",
} as const;
/**
 * The network policy mode. - 'allow-all': All traffic is allowed. - 'deny-all': All traffic is blocked. - 'custom': Traffic is controlled by explicit allow/deny rules.
 */
export type Mode = ClosedEnum<typeof Mode>;

/**
 * The network policy applied to this sandbox, if any.
 */
export type SandboxNetworkPolicy = {
  /**
   * The network policy mode. - 'allow-all': All traffic is allowed. - 'deny-all': All traffic is blocked. - 'custom': Traffic is controlled by explicit allow/deny rules.
   */
  mode: Mode;
  /**
   * List of domain names the sandbox is allowed to connect to. Supports wildcard patterns (e.g., "*.vercel.com" matches all subdomains).
   */
  allowedDomains?: Array<string> | undefined;
  /**
   * List of IP address ranges (in CIDR notation) the sandbox is allowed to connect to.
   */
  allowedCIDRs?: Array<string> | undefined;
  /**
   * List of IP address ranges (in CIDR notation) the sandbox is blocked from connecting to. These rules take precedence over all allowed rules.
   */
  deniedCIDRs?: Array<string> | undefined;
  /**
   * HTTP header injection rules for outgoing requests matching specific domains.
   */
  injectionRules?: Array<SandboxInjectionRule> | undefined;
};

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);
/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/** @internal */
export const SandboxNetworkPolicy$inboundSchema: z.ZodType<
  SandboxNetworkPolicy,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: Mode$inboundSchema,
  allowedDomains: types.optional(z.array(types.string())),
  allowedCIDRs: types.optional(z.array(types.string())),
  deniedCIDRs: types.optional(z.array(types.string())),
  injectionRules: types.optional(z.array(SandboxInjectionRule$inboundSchema)),
});
/** @internal */
export type SandboxNetworkPolicy$Outbound = {
  mode: string;
  allowedDomains?: Array<string> | undefined;
  allowedCIDRs?: Array<string> | undefined;
  deniedCIDRs?: Array<string> | undefined;
  injectionRules?: Array<SandboxInjectionRule$Outbound> | undefined;
};

/** @internal */
export const SandboxNetworkPolicy$outboundSchema: z.ZodType<
  SandboxNetworkPolicy$Outbound,
  z.ZodTypeDef,
  SandboxNetworkPolicy
> = z.object({
  mode: Mode$outboundSchema,
  allowedDomains: z.array(z.string()).optional(),
  allowedCIDRs: z.array(z.string()).optional(),
  deniedCIDRs: z.array(z.string()).optional(),
  injectionRules: z.array(SandboxInjectionRule$outboundSchema).optional(),
});

export function sandboxNetworkPolicyToJSON(
  sandboxNetworkPolicy: SandboxNetworkPolicy,
): string {
  return JSON.stringify(
    SandboxNetworkPolicy$outboundSchema.parse(sandboxNetworkPolicy),
  );
}
export function sandboxNetworkPolicyFromJSON(
  jsonString: string,
): SafeParseResult<SandboxNetworkPolicy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SandboxNetworkPolicy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SandboxNetworkPolicy' from JSON`,
  );
}
