/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type NamespaceId = string | number;

export const QueryParamProvider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
} as const;
export type QueryParamProvider = ClosedEnum<typeof QueryParamProvider>;

export type SearchRepoRequest = {
  query?: string | undefined;
  namespaceId?: string | number | null | undefined;
  provider?: QueryParamProvider | undefined;
  installationId?: string | undefined;
  /**
   * The custom Git host if using a custom Git provider, like GitHub Enterprise Server
   */
  host?: string | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
};

export const ResponseBodyProvider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
} as const;
export type ResponseBodyProvider = ClosedEnum<typeof ResponseBodyProvider>;

export type ResponseBodyNamespaceId = string | number;

export type GitAccount = {
  provider: ResponseBodyProvider;
  namespaceId: string | number | null;
};

export type ResponseBodyId = string | number;

export const SearchRepoResponseBodyProvider = {
  Github: "github",
  GithubLimited: "github-limited",
  GithubCustomHost: "github-custom-host",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
} as const;
export type SearchRepoResponseBodyProvider = ClosedEnum<
  typeof SearchRepoResponseBodyProvider
>;

export type SearchRepoResponseBodyId = string | number;

export type Owner = {
  id: string | number;
  name: string;
};

export const ResponseBodyOwnerType = {
  User: "user",
  Team: "team",
} as const;
export type ResponseBodyOwnerType = ClosedEnum<typeof ResponseBodyOwnerType>;

export type Repos = {
  id: string | number;
  provider: SearchRepoResponseBodyProvider;
  url: string;
  name: string;
  slug: string;
  namespace: string;
  owner: Owner;
  ownerType: ResponseBodyOwnerType;
  private: boolean;
  defaultBranch: string;
  updatedAt: number;
};

export type SearchRepoResponseBody2 = {
  gitAccount: GitAccount;
  repos: Array<Repos>;
};

export type SearchRepoResponseBody1 = {};

export type SearchRepoResponseBody =
  | SearchRepoResponseBody2
  | SearchRepoResponseBody1;

/** @internal */
export const NamespaceId$inboundSchema: z.ZodType<
  NamespaceId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type NamespaceId$Outbound = string | number;

/** @internal */
export const NamespaceId$outboundSchema: z.ZodType<
  NamespaceId$Outbound,
  z.ZodTypeDef,
  NamespaceId
> = smartUnion([z.string(), z.number()]);

export function namespaceIdToJSON(namespaceId: NamespaceId): string {
  return JSON.stringify(NamespaceId$outboundSchema.parse(namespaceId));
}
export function namespaceIdFromJSON(
  jsonString: string,
): SafeParseResult<NamespaceId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NamespaceId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NamespaceId' from JSON`,
  );
}

/** @internal */
export const QueryParamProvider$inboundSchema: z.ZodNativeEnum<
  typeof QueryParamProvider
> = z.nativeEnum(QueryParamProvider);
/** @internal */
export const QueryParamProvider$outboundSchema: z.ZodNativeEnum<
  typeof QueryParamProvider
> = QueryParamProvider$inboundSchema;

/** @internal */
export const SearchRepoRequest$inboundSchema: z.ZodType<
  SearchRepoRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  query: types.optional(types.string()),
  namespaceId: z.nullable(smartUnion([types.string(), types.number()]))
    .optional(),
  provider: types.optional(QueryParamProvider$inboundSchema),
  installationId: types.optional(types.string()),
  host: types.optional(types.string()),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
});
/** @internal */
export type SearchRepoRequest$Outbound = {
  query?: string | undefined;
  namespaceId?: string | number | null | undefined;
  provider?: string | undefined;
  installationId?: string | undefined;
  host?: string | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
};

/** @internal */
export const SearchRepoRequest$outboundSchema: z.ZodType<
  SearchRepoRequest$Outbound,
  z.ZodTypeDef,
  SearchRepoRequest
> = z.object({
  query: z.string().optional(),
  namespaceId: z.nullable(smartUnion([z.string(), z.number()])).optional(),
  provider: QueryParamProvider$outboundSchema.optional(),
  installationId: z.string().optional(),
  host: z.string().optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
});

export function searchRepoRequestToJSON(
  searchRepoRequest: SearchRepoRequest,
): string {
  return JSON.stringify(
    SearchRepoRequest$outboundSchema.parse(searchRepoRequest),
  );
}
export function searchRepoRequestFromJSON(
  jsonString: string,
): SafeParseResult<SearchRepoRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchRepoRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchRepoRequest' from JSON`,
  );
}

/** @internal */
export const ResponseBodyProvider$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyProvider
> = z.nativeEnum(ResponseBodyProvider);
/** @internal */
export const ResponseBodyProvider$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyProvider
> = ResponseBodyProvider$inboundSchema;

/** @internal */
export const ResponseBodyNamespaceId$inboundSchema: z.ZodType<
  ResponseBodyNamespaceId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type ResponseBodyNamespaceId$Outbound = string | number;

/** @internal */
export const ResponseBodyNamespaceId$outboundSchema: z.ZodType<
  ResponseBodyNamespaceId$Outbound,
  z.ZodTypeDef,
  ResponseBodyNamespaceId
> = smartUnion([z.string(), z.number()]);

export function responseBodyNamespaceIdToJSON(
  responseBodyNamespaceId: ResponseBodyNamespaceId,
): string {
  return JSON.stringify(
    ResponseBodyNamespaceId$outboundSchema.parse(responseBodyNamespaceId),
  );
}
export function responseBodyNamespaceIdFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyNamespaceId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyNamespaceId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyNamespaceId' from JSON`,
  );
}

/** @internal */
export const GitAccount$inboundSchema: z.ZodType<
  GitAccount,
  z.ZodTypeDef,
  unknown
> = z.object({
  provider: ResponseBodyProvider$inboundSchema,
  namespaceId: types.nullable(smartUnion([types.string(), types.number()])),
});
/** @internal */
export type GitAccount$Outbound = {
  provider: string;
  namespaceId: string | number | null;
};

/** @internal */
export const GitAccount$outboundSchema: z.ZodType<
  GitAccount$Outbound,
  z.ZodTypeDef,
  GitAccount
> = z.object({
  provider: ResponseBodyProvider$outboundSchema,
  namespaceId: z.nullable(smartUnion([z.string(), z.number()])),
});

export function gitAccountToJSON(gitAccount: GitAccount): string {
  return JSON.stringify(GitAccount$outboundSchema.parse(gitAccount));
}
export function gitAccountFromJSON(
  jsonString: string,
): SafeParseResult<GitAccount, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitAccount$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitAccount' from JSON`,
  );
}

/** @internal */
export const ResponseBodyId$inboundSchema: z.ZodType<
  ResponseBodyId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type ResponseBodyId$Outbound = string | number;

/** @internal */
export const ResponseBodyId$outboundSchema: z.ZodType<
  ResponseBodyId$Outbound,
  z.ZodTypeDef,
  ResponseBodyId
> = smartUnion([z.string(), z.number()]);

export function responseBodyIdToJSON(responseBodyId: ResponseBodyId): string {
  return JSON.stringify(ResponseBodyId$outboundSchema.parse(responseBodyId));
}
export function responseBodyIdFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyId' from JSON`,
  );
}

/** @internal */
export const SearchRepoResponseBodyProvider$inboundSchema: z.ZodNativeEnum<
  typeof SearchRepoResponseBodyProvider
> = z.nativeEnum(SearchRepoResponseBodyProvider);
/** @internal */
export const SearchRepoResponseBodyProvider$outboundSchema: z.ZodNativeEnum<
  typeof SearchRepoResponseBodyProvider
> = SearchRepoResponseBodyProvider$inboundSchema;

/** @internal */
export const SearchRepoResponseBodyId$inboundSchema: z.ZodType<
  SearchRepoResponseBodyId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type SearchRepoResponseBodyId$Outbound = string | number;

/** @internal */
export const SearchRepoResponseBodyId$outboundSchema: z.ZodType<
  SearchRepoResponseBodyId$Outbound,
  z.ZodTypeDef,
  SearchRepoResponseBodyId
> = smartUnion([z.string(), z.number()]);

export function searchRepoResponseBodyIdToJSON(
  searchRepoResponseBodyId: SearchRepoResponseBodyId,
): string {
  return JSON.stringify(
    SearchRepoResponseBodyId$outboundSchema.parse(searchRepoResponseBodyId),
  );
}
export function searchRepoResponseBodyIdFromJSON(
  jsonString: string,
): SafeParseResult<SearchRepoResponseBodyId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchRepoResponseBodyId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchRepoResponseBodyId' from JSON`,
  );
}

/** @internal */
export const Owner$inboundSchema: z.ZodType<Owner, z.ZodTypeDef, unknown> = z
  .object({
    id: smartUnion([types.string(), types.number()]),
    name: types.string(),
  });
/** @internal */
export type Owner$Outbound = {
  id: string | number;
  name: string;
};

/** @internal */
export const Owner$outboundSchema: z.ZodType<
  Owner$Outbound,
  z.ZodTypeDef,
  Owner
> = z.object({
  id: smartUnion([z.string(), z.number()]),
  name: z.string(),
});

export function ownerToJSON(owner: Owner): string {
  return JSON.stringify(Owner$outboundSchema.parse(owner));
}
export function ownerFromJSON(
  jsonString: string,
): SafeParseResult<Owner, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Owner$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Owner' from JSON`,
  );
}

/** @internal */
export const ResponseBodyOwnerType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyOwnerType
> = z.nativeEnum(ResponseBodyOwnerType);
/** @internal */
export const ResponseBodyOwnerType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyOwnerType
> = ResponseBodyOwnerType$inboundSchema;

/** @internal */
export const Repos$inboundSchema: z.ZodType<Repos, z.ZodTypeDef, unknown> = z
  .object({
    id: smartUnion([types.string(), types.number()]),
    provider: SearchRepoResponseBodyProvider$inboundSchema,
    url: types.string(),
    name: types.string(),
    slug: types.string(),
    namespace: types.string(),
    owner: z.lazy(() => Owner$inboundSchema),
    ownerType: ResponseBodyOwnerType$inboundSchema,
    private: types.boolean(),
    defaultBranch: types.string(),
    updatedAt: types.number(),
  });
/** @internal */
export type Repos$Outbound = {
  id: string | number;
  provider: string;
  url: string;
  name: string;
  slug: string;
  namespace: string;
  owner: Owner$Outbound;
  ownerType: string;
  private: boolean;
  defaultBranch: string;
  updatedAt: number;
};

/** @internal */
export const Repos$outboundSchema: z.ZodType<
  Repos$Outbound,
  z.ZodTypeDef,
  Repos
> = z.object({
  id: smartUnion([z.string(), z.number()]),
  provider: SearchRepoResponseBodyProvider$outboundSchema,
  url: z.string(),
  name: z.string(),
  slug: z.string(),
  namespace: z.string(),
  owner: z.lazy(() => Owner$outboundSchema),
  ownerType: ResponseBodyOwnerType$outboundSchema,
  private: z.boolean(),
  defaultBranch: z.string(),
  updatedAt: z.number(),
});

export function reposToJSON(repos: Repos): string {
  return JSON.stringify(Repos$outboundSchema.parse(repos));
}
export function reposFromJSON(
  jsonString: string,
): SafeParseResult<Repos, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Repos$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Repos' from JSON`,
  );
}

/** @internal */
export const SearchRepoResponseBody2$inboundSchema: z.ZodType<
  SearchRepoResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  gitAccount: z.lazy(() => GitAccount$inboundSchema),
  repos: z.array(z.lazy(() => Repos$inboundSchema)),
});
/** @internal */
export type SearchRepoResponseBody2$Outbound = {
  gitAccount: GitAccount$Outbound;
  repos: Array<Repos$Outbound>;
};

/** @internal */
export const SearchRepoResponseBody2$outboundSchema: z.ZodType<
  SearchRepoResponseBody2$Outbound,
  z.ZodTypeDef,
  SearchRepoResponseBody2
> = z.object({
  gitAccount: z.lazy(() => GitAccount$outboundSchema),
  repos: z.array(z.lazy(() => Repos$outboundSchema)),
});

export function searchRepoResponseBody2ToJSON(
  searchRepoResponseBody2: SearchRepoResponseBody2,
): string {
  return JSON.stringify(
    SearchRepoResponseBody2$outboundSchema.parse(searchRepoResponseBody2),
  );
}
export function searchRepoResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<SearchRepoResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchRepoResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchRepoResponseBody2' from JSON`,
  );
}

/** @internal */
export const SearchRepoResponseBody1$inboundSchema: z.ZodType<
  SearchRepoResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type SearchRepoResponseBody1$Outbound = {};

/** @internal */
export const SearchRepoResponseBody1$outboundSchema: z.ZodType<
  SearchRepoResponseBody1$Outbound,
  z.ZodTypeDef,
  SearchRepoResponseBody1
> = z.object({});

export function searchRepoResponseBody1ToJSON(
  searchRepoResponseBody1: SearchRepoResponseBody1,
): string {
  return JSON.stringify(
    SearchRepoResponseBody1$outboundSchema.parse(searchRepoResponseBody1),
  );
}
export function searchRepoResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<SearchRepoResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchRepoResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchRepoResponseBody1' from JSON`,
  );
}

/** @internal */
export const SearchRepoResponseBody$inboundSchema: z.ZodType<
  SearchRepoResponseBody,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => SearchRepoResponseBody2$inboundSchema),
  z.lazy(() => SearchRepoResponseBody1$inboundSchema),
]);
/** @internal */
export type SearchRepoResponseBody$Outbound =
  | SearchRepoResponseBody2$Outbound
  | SearchRepoResponseBody1$Outbound;

/** @internal */
export const SearchRepoResponseBody$outboundSchema: z.ZodType<
  SearchRepoResponseBody$Outbound,
  z.ZodTypeDef,
  SearchRepoResponseBody
> = smartUnion([
  z.lazy(() => SearchRepoResponseBody2$outboundSchema),
  z.lazy(() => SearchRepoResponseBody1$outboundSchema),
]);

export function searchRepoResponseBodyToJSON(
  searchRepoResponseBody: SearchRepoResponseBody,
): string {
  return JSON.stringify(
    SearchRepoResponseBody$outboundSchema.parse(searchRepoResponseBody),
  );
}
export function searchRepoResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<SearchRepoResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchRepoResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchRepoResponseBody' from JSON`,
  );
}
