/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const SegmentTypeName = {
  Segment: "segment",
} as const;
export type SegmentTypeName = ClosedEnum<typeof SegmentTypeName>;

export const SegmentOutcomeDataRulesType = {
  Entity: "entity",
} as const;
export type SegmentOutcomeDataRulesType = ClosedEnum<
  typeof SegmentOutcomeDataRulesType
>;

export type SegmentOutcomeBase = {
  type: SegmentOutcomeDataRulesType;
  kind: string;
  attribute: string;
};

export type SegmentOutcome2 = {
  type: "split";
  base: SegmentOutcomeBase;
  passPromille: number;
};

export type SegmentOutcome1 = {
  type: "all";
};

export type SegmentOutcome = SegmentOutcome1 | SegmentOutcome2;

export const SegmentRhsDataType = {
  Regex: "regex",
} as const;
export type SegmentRhsDataType = ClosedEnum<typeof SegmentRhsDataType>;

export type SegmentRhs4 = {
  type: SegmentRhsDataType;
  pattern: string;
  flags: string;
};

export const SegmentRhsType = {
  ListInline: "list/inline",
  List: "list",
} as const;
export type SegmentRhsType = ClosedEnum<typeof SegmentRhsType>;

export type SegmentItems2 = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

export type SegmentItems1 = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

export type SegmentRhsItems = SegmentItems1 | SegmentItems2;

export type SegmentRhs3 = {
  type: SegmentRhsType;
  items: Array<SegmentItems1 | SegmentItems2>;
};

export type SegmentRhs = SegmentRhs4 | SegmentRhs3 | string | number | boolean;

export type SegmentLhs2 = {
  type: "entity";
  kind: string;
  attribute: string;
};

export type SegmentLhs1 = {
  type: "segment";
};

export type SegmentLhs = SegmentLhs1 | SegmentLhs2;

export const SegmentCmp = {
  Eq: "eq",
  NotEq: "!eq",
  OneOf: "oneOf",
  NotOneOf: "!oneOf",
  ContainsAllOf: "containsAllOf",
  ContainsAnyOf: "containsAnyOf",
  ContainsNoneOf: "containsNoneOf",
  StartsWith: "startsWith",
  NotStartsWith: "!startsWith",
  EndsWith: "endsWith",
  NotEndsWith: "!endsWith",
  Ex: "ex",
  NotEx: "!ex",
  Gt: "gt",
  Gte: "gte",
  Lt: "lt",
  Lte: "lte",
  Regex: "regex",
  NotRegex: "!regex",
  Before: "before",
  After: "after",
} as const;
export type SegmentCmp = ClosedEnum<typeof SegmentCmp>;

export type SegmentConditions = {
  rhs?: SegmentRhs4 | SegmentRhs3 | string | number | boolean | undefined;
  lhs: SegmentLhs1 | SegmentLhs2;
  cmp: SegmentCmp;
};

export type SegmentRules = {
  id: string;
  outcome: SegmentOutcome1 | SegmentOutcome2;
  conditions: Array<SegmentConditions>;
};

export type Include = {
  note?: string | undefined;
  value: string;
};

export type ExcludeT = {
  note?: string | undefined;
  value: string;
};

export type Data = {
  rules?: Array<SegmentRules> | undefined;
  include?: { [k: string]: { [k: string]: Array<Include> } } | undefined;
  exclude?: { [k: string]: { [k: string]: Array<ExcludeT> } } | undefined;
};

export type SegmentCreator = {
  id: string;
  name: string;
};

export type SegmentMetadata = {
  creator?: SegmentCreator | undefined;
};

export type Segment = {
  description?: string | undefined;
  createdBy?: string | undefined;
  usedByFlags?: Array<string> | undefined;
  usedBySegments?: Array<string> | undefined;
  id: string;
  label: string;
  slug: string;
  createdAt: number;
  updatedAt: number;
  projectId: string;
  typeName: SegmentTypeName;
  data: Data;
  hint: string;
  metadata?: SegmentMetadata | undefined;
};

/** @internal */
export const SegmentTypeName$inboundSchema: z.ZodNativeEnum<
  typeof SegmentTypeName
> = z.nativeEnum(SegmentTypeName);
/** @internal */
export const SegmentTypeName$outboundSchema: z.ZodNativeEnum<
  typeof SegmentTypeName
> = SegmentTypeName$inboundSchema;

/** @internal */
export const SegmentOutcomeDataRulesType$inboundSchema: z.ZodNativeEnum<
  typeof SegmentOutcomeDataRulesType
> = z.nativeEnum(SegmentOutcomeDataRulesType);
/** @internal */
export const SegmentOutcomeDataRulesType$outboundSchema: z.ZodNativeEnum<
  typeof SegmentOutcomeDataRulesType
> = SegmentOutcomeDataRulesType$inboundSchema;

/** @internal */
export const SegmentOutcomeBase$inboundSchema: z.ZodType<
  SegmentOutcomeBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: SegmentOutcomeDataRulesType$inboundSchema,
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type SegmentOutcomeBase$Outbound = {
  type: string;
  kind: string;
  attribute: string;
};

/** @internal */
export const SegmentOutcomeBase$outboundSchema: z.ZodType<
  SegmentOutcomeBase$Outbound,
  z.ZodTypeDef,
  SegmentOutcomeBase
> = z.object({
  type: SegmentOutcomeDataRulesType$outboundSchema,
  kind: z.string(),
  attribute: z.string(),
});

export function segmentOutcomeBaseToJSON(
  segmentOutcomeBase: SegmentOutcomeBase,
): string {
  return JSON.stringify(
    SegmentOutcomeBase$outboundSchema.parse(segmentOutcomeBase),
  );
}
export function segmentOutcomeBaseFromJSON(
  jsonString: string,
): SafeParseResult<SegmentOutcomeBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentOutcomeBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentOutcomeBase' from JSON`,
  );
}

/** @internal */
export const SegmentOutcome2$inboundSchema: z.ZodType<
  SegmentOutcome2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("split"),
  base: z.lazy(() => SegmentOutcomeBase$inboundSchema),
  passPromille: types.number(),
});
/** @internal */
export type SegmentOutcome2$Outbound = {
  type: "split";
  base: SegmentOutcomeBase$Outbound;
  passPromille: number;
};

/** @internal */
export const SegmentOutcome2$outboundSchema: z.ZodType<
  SegmentOutcome2$Outbound,
  z.ZodTypeDef,
  SegmentOutcome2
> = z.object({
  type: z.literal("split"),
  base: z.lazy(() => SegmentOutcomeBase$outboundSchema),
  passPromille: z.number(),
});

export function segmentOutcome2ToJSON(
  segmentOutcome2: SegmentOutcome2,
): string {
  return JSON.stringify(SegmentOutcome2$outboundSchema.parse(segmentOutcome2));
}
export function segmentOutcome2FromJSON(
  jsonString: string,
): SafeParseResult<SegmentOutcome2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentOutcome2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentOutcome2' from JSON`,
  );
}

/** @internal */
export const SegmentOutcome1$inboundSchema: z.ZodType<
  SegmentOutcome1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("all"),
});
/** @internal */
export type SegmentOutcome1$Outbound = {
  type: "all";
};

/** @internal */
export const SegmentOutcome1$outboundSchema: z.ZodType<
  SegmentOutcome1$Outbound,
  z.ZodTypeDef,
  SegmentOutcome1
> = z.object({
  type: z.literal("all"),
});

export function segmentOutcome1ToJSON(
  segmentOutcome1: SegmentOutcome1,
): string {
  return JSON.stringify(SegmentOutcome1$outboundSchema.parse(segmentOutcome1));
}
export function segmentOutcome1FromJSON(
  jsonString: string,
): SafeParseResult<SegmentOutcome1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentOutcome1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentOutcome1' from JSON`,
  );
}

/** @internal */
export const SegmentOutcome$inboundSchema: z.ZodType<
  SegmentOutcome,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SegmentOutcome1$inboundSchema),
  z.lazy(() => SegmentOutcome2$inboundSchema),
]);
/** @internal */
export type SegmentOutcome$Outbound =
  | SegmentOutcome1$Outbound
  | SegmentOutcome2$Outbound;

/** @internal */
export const SegmentOutcome$outboundSchema: z.ZodType<
  SegmentOutcome$Outbound,
  z.ZodTypeDef,
  SegmentOutcome
> = z.union([
  z.lazy(() => SegmentOutcome1$outboundSchema),
  z.lazy(() => SegmentOutcome2$outboundSchema),
]);

export function segmentOutcomeToJSON(segmentOutcome: SegmentOutcome): string {
  return JSON.stringify(SegmentOutcome$outboundSchema.parse(segmentOutcome));
}
export function segmentOutcomeFromJSON(
  jsonString: string,
): SafeParseResult<SegmentOutcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentOutcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentOutcome' from JSON`,
  );
}

/** @internal */
export const SegmentRhsDataType$inboundSchema: z.ZodNativeEnum<
  typeof SegmentRhsDataType
> = z.nativeEnum(SegmentRhsDataType);
/** @internal */
export const SegmentRhsDataType$outboundSchema: z.ZodNativeEnum<
  typeof SegmentRhsDataType
> = SegmentRhsDataType$inboundSchema;

/** @internal */
export const SegmentRhs4$inboundSchema: z.ZodType<
  SegmentRhs4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: SegmentRhsDataType$inboundSchema,
  pattern: types.string(),
  flags: types.string(),
});
/** @internal */
export type SegmentRhs4$Outbound = {
  type: string;
  pattern: string;
  flags: string;
};

/** @internal */
export const SegmentRhs4$outboundSchema: z.ZodType<
  SegmentRhs4$Outbound,
  z.ZodTypeDef,
  SegmentRhs4
> = z.object({
  type: SegmentRhsDataType$outboundSchema,
  pattern: z.string(),
  flags: z.string(),
});

export function segmentRhs4ToJSON(segmentRhs4: SegmentRhs4): string {
  return JSON.stringify(SegmentRhs4$outboundSchema.parse(segmentRhs4));
}
export function segmentRhs4FromJSON(
  jsonString: string,
): SafeParseResult<SegmentRhs4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentRhs4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentRhs4' from JSON`,
  );
}

/** @internal */
export const SegmentRhsType$inboundSchema: z.ZodNativeEnum<
  typeof SegmentRhsType
> = z.nativeEnum(SegmentRhsType);
/** @internal */
export const SegmentRhsType$outboundSchema: z.ZodNativeEnum<
  typeof SegmentRhsType
> = SegmentRhsType$inboundSchema;

/** @internal */
export const SegmentItems2$inboundSchema: z.ZodType<
  SegmentItems2,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type SegmentItems2$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

/** @internal */
export const SegmentItems2$outboundSchema: z.ZodType<
  SegmentItems2$Outbound,
  z.ZodTypeDef,
  SegmentItems2
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.string(),
});

export function segmentItems2ToJSON(segmentItems2: SegmentItems2): string {
  return JSON.stringify(SegmentItems2$outboundSchema.parse(segmentItems2));
}
export function segmentItems2FromJSON(
  jsonString: string,
): SafeParseResult<SegmentItems2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentItems2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentItems2' from JSON`,
  );
}

/** @internal */
export const SegmentItems1$inboundSchema: z.ZodType<
  SegmentItems1,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.number(),
});
/** @internal */
export type SegmentItems1$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

/** @internal */
export const SegmentItems1$outboundSchema: z.ZodType<
  SegmentItems1$Outbound,
  z.ZodTypeDef,
  SegmentItems1
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.number(),
});

export function segmentItems1ToJSON(segmentItems1: SegmentItems1): string {
  return JSON.stringify(SegmentItems1$outboundSchema.parse(segmentItems1));
}
export function segmentItems1FromJSON(
  jsonString: string,
): SafeParseResult<SegmentItems1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentItems1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentItems1' from JSON`,
  );
}

/** @internal */
export const SegmentRhsItems$inboundSchema: z.ZodType<
  SegmentRhsItems,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => SegmentItems1$inboundSchema),
  z.lazy(() => SegmentItems2$inboundSchema),
]);
/** @internal */
export type SegmentRhsItems$Outbound =
  | SegmentItems1$Outbound
  | SegmentItems2$Outbound;

/** @internal */
export const SegmentRhsItems$outboundSchema: z.ZodType<
  SegmentRhsItems$Outbound,
  z.ZodTypeDef,
  SegmentRhsItems
> = smartUnion([
  z.lazy(() => SegmentItems1$outboundSchema),
  z.lazy(() => SegmentItems2$outboundSchema),
]);

export function segmentRhsItemsToJSON(
  segmentRhsItems: SegmentRhsItems,
): string {
  return JSON.stringify(SegmentRhsItems$outboundSchema.parse(segmentRhsItems));
}
export function segmentRhsItemsFromJSON(
  jsonString: string,
): SafeParseResult<SegmentRhsItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentRhsItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentRhsItems' from JSON`,
  );
}

/** @internal */
export const SegmentRhs3$inboundSchema: z.ZodType<
  SegmentRhs3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: SegmentRhsType$inboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => SegmentItems1$inboundSchema),
      z.lazy(() => SegmentItems2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type SegmentRhs3$Outbound = {
  type: string;
  items: Array<SegmentItems1$Outbound | SegmentItems2$Outbound>;
};

/** @internal */
export const SegmentRhs3$outboundSchema: z.ZodType<
  SegmentRhs3$Outbound,
  z.ZodTypeDef,
  SegmentRhs3
> = z.object({
  type: SegmentRhsType$outboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => SegmentItems1$outboundSchema),
      z.lazy(() => SegmentItems2$outboundSchema),
    ]),
  ),
});

export function segmentRhs3ToJSON(segmentRhs3: SegmentRhs3): string {
  return JSON.stringify(SegmentRhs3$outboundSchema.parse(segmentRhs3));
}
export function segmentRhs3FromJSON(
  jsonString: string,
): SafeParseResult<SegmentRhs3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentRhs3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentRhs3' from JSON`,
  );
}

/** @internal */
export const SegmentRhs$inboundSchema: z.ZodType<
  SegmentRhs,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => SegmentRhs4$inboundSchema),
  z.lazy(() => SegmentRhs3$inboundSchema),
  types.string(),
  types.number(),
  types.boolean(),
]);
/** @internal */
export type SegmentRhs$Outbound =
  | SegmentRhs4$Outbound
  | SegmentRhs3$Outbound
  | string
  | number
  | boolean;

/** @internal */
export const SegmentRhs$outboundSchema: z.ZodType<
  SegmentRhs$Outbound,
  z.ZodTypeDef,
  SegmentRhs
> = smartUnion([
  z.lazy(() => SegmentRhs4$outboundSchema),
  z.lazy(() => SegmentRhs3$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
]);

export function segmentRhsToJSON(segmentRhs: SegmentRhs): string {
  return JSON.stringify(SegmentRhs$outboundSchema.parse(segmentRhs));
}
export function segmentRhsFromJSON(
  jsonString: string,
): SafeParseResult<SegmentRhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentRhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentRhs' from JSON`,
  );
}

/** @internal */
export const SegmentLhs2$inboundSchema: z.ZodType<
  SegmentLhs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("entity"),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type SegmentLhs2$Outbound = {
  type: "entity";
  kind: string;
  attribute: string;
};

/** @internal */
export const SegmentLhs2$outboundSchema: z.ZodType<
  SegmentLhs2$Outbound,
  z.ZodTypeDef,
  SegmentLhs2
> = z.object({
  type: z.literal("entity"),
  kind: z.string(),
  attribute: z.string(),
});

export function segmentLhs2ToJSON(segmentLhs2: SegmentLhs2): string {
  return JSON.stringify(SegmentLhs2$outboundSchema.parse(segmentLhs2));
}
export function segmentLhs2FromJSON(
  jsonString: string,
): SafeParseResult<SegmentLhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentLhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentLhs2' from JSON`,
  );
}

/** @internal */
export const SegmentLhs1$inboundSchema: z.ZodType<
  SegmentLhs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.literal("segment"),
});
/** @internal */
export type SegmentLhs1$Outbound = {
  type: "segment";
};

/** @internal */
export const SegmentLhs1$outboundSchema: z.ZodType<
  SegmentLhs1$Outbound,
  z.ZodTypeDef,
  SegmentLhs1
> = z.object({
  type: z.literal("segment"),
});

export function segmentLhs1ToJSON(segmentLhs1: SegmentLhs1): string {
  return JSON.stringify(SegmentLhs1$outboundSchema.parse(segmentLhs1));
}
export function segmentLhs1FromJSON(
  jsonString: string,
): SafeParseResult<SegmentLhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentLhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentLhs1' from JSON`,
  );
}

/** @internal */
export const SegmentLhs$inboundSchema: z.ZodType<
  SegmentLhs,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SegmentLhs1$inboundSchema),
  z.lazy(() => SegmentLhs2$inboundSchema),
]);
/** @internal */
export type SegmentLhs$Outbound = SegmentLhs1$Outbound | SegmentLhs2$Outbound;

/** @internal */
export const SegmentLhs$outboundSchema: z.ZodType<
  SegmentLhs$Outbound,
  z.ZodTypeDef,
  SegmentLhs
> = z.union([
  z.lazy(() => SegmentLhs1$outboundSchema),
  z.lazy(() => SegmentLhs2$outboundSchema),
]);

export function segmentLhsToJSON(segmentLhs: SegmentLhs): string {
  return JSON.stringify(SegmentLhs$outboundSchema.parse(segmentLhs));
}
export function segmentLhsFromJSON(
  jsonString: string,
): SafeParseResult<SegmentLhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentLhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentLhs' from JSON`,
  );
}

/** @internal */
export const SegmentCmp$inboundSchema: z.ZodNativeEnum<typeof SegmentCmp> = z
  .nativeEnum(SegmentCmp);
/** @internal */
export const SegmentCmp$outboundSchema: z.ZodNativeEnum<typeof SegmentCmp> =
  SegmentCmp$inboundSchema;

/** @internal */
export const SegmentConditions$inboundSchema: z.ZodType<
  SegmentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  rhs: types.optional(
    smartUnion([
      z.lazy(() => SegmentRhs4$inboundSchema),
      z.lazy(() => SegmentRhs3$inboundSchema),
      types.string(),
      types.number(),
      types.boolean(),
    ]),
  ),
  lhs: z.union([
    z.lazy(() => SegmentLhs1$inboundSchema),
    z.lazy(() => SegmentLhs2$inboundSchema),
  ]),
  cmp: SegmentCmp$inboundSchema,
});
/** @internal */
export type SegmentConditions$Outbound = {
  rhs?:
    | SegmentRhs4$Outbound
    | SegmentRhs3$Outbound
    | string
    | number
    | boolean
    | undefined;
  lhs: SegmentLhs1$Outbound | SegmentLhs2$Outbound;
  cmp: string;
};

/** @internal */
export const SegmentConditions$outboundSchema: z.ZodType<
  SegmentConditions$Outbound,
  z.ZodTypeDef,
  SegmentConditions
> = z.object({
  rhs: smartUnion([
    z.lazy(() => SegmentRhs4$outboundSchema),
    z.lazy(() => SegmentRhs3$outboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
  ]).optional(),
  lhs: z.union([
    z.lazy(() => SegmentLhs1$outboundSchema),
    z.lazy(() => SegmentLhs2$outboundSchema),
  ]),
  cmp: SegmentCmp$outboundSchema,
});

export function segmentConditionsToJSON(
  segmentConditions: SegmentConditions,
): string {
  return JSON.stringify(
    SegmentConditions$outboundSchema.parse(segmentConditions),
  );
}
export function segmentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<SegmentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentConditions' from JSON`,
  );
}

/** @internal */
export const SegmentRules$inboundSchema: z.ZodType<
  SegmentRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  outcome: z.union([
    z.lazy(() => SegmentOutcome1$inboundSchema),
    z.lazy(() => SegmentOutcome2$inboundSchema),
  ]),
  conditions: z.array(z.lazy(() => SegmentConditions$inboundSchema)),
});
/** @internal */
export type SegmentRules$Outbound = {
  id: string;
  outcome: SegmentOutcome1$Outbound | SegmentOutcome2$Outbound;
  conditions: Array<SegmentConditions$Outbound>;
};

/** @internal */
export const SegmentRules$outboundSchema: z.ZodType<
  SegmentRules$Outbound,
  z.ZodTypeDef,
  SegmentRules
> = z.object({
  id: z.string(),
  outcome: z.union([
    z.lazy(() => SegmentOutcome1$outboundSchema),
    z.lazy(() => SegmentOutcome2$outboundSchema),
  ]),
  conditions: z.array(z.lazy(() => SegmentConditions$outboundSchema)),
});

export function segmentRulesToJSON(segmentRules: SegmentRules): string {
  return JSON.stringify(SegmentRules$outboundSchema.parse(segmentRules));
}
export function segmentRulesFromJSON(
  jsonString: string,
): SafeParseResult<SegmentRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentRules' from JSON`,
  );
}

/** @internal */
export const Include$inboundSchema: z.ZodType<Include, z.ZodTypeDef, unknown> =
  z.object({
    note: types.optional(types.string()),
    value: types.string(),
  });
/** @internal */
export type Include$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const Include$outboundSchema: z.ZodType<
  Include$Outbound,
  z.ZodTypeDef,
  Include
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function includeToJSON(include: Include): string {
  return JSON.stringify(Include$outboundSchema.parse(include));
}
export function includeFromJSON(
  jsonString: string,
): SafeParseResult<Include, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Include$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Include' from JSON`,
  );
}

/** @internal */
export const ExcludeT$inboundSchema: z.ZodType<
  ExcludeT,
  z.ZodTypeDef,
  unknown
> = z.object({
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type ExcludeT$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const ExcludeT$outboundSchema: z.ZodType<
  ExcludeT$Outbound,
  z.ZodTypeDef,
  ExcludeT
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function excludeToJSON(excludeT: ExcludeT): string {
  return JSON.stringify(ExcludeT$outboundSchema.parse(excludeT));
}
export function excludeFromJSON(
  jsonString: string,
): SafeParseResult<ExcludeT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExcludeT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExcludeT' from JSON`,
  );
}

/** @internal */
export const Data$inboundSchema: z.ZodType<Data, z.ZodTypeDef, unknown> = z
  .object({
    rules: types.optional(z.array(z.lazy(() => SegmentRules$inboundSchema))),
    include: types.optional(
      z.record(z.record(z.array(z.lazy(() => Include$inboundSchema)))),
    ),
    exclude: types.optional(
      z.record(z.record(z.array(z.lazy(() => ExcludeT$inboundSchema)))),
    ),
  });
/** @internal */
export type Data$Outbound = {
  rules?: Array<SegmentRules$Outbound> | undefined;
  include?:
    | { [k: string]: { [k: string]: Array<Include$Outbound> } }
    | undefined;
  exclude?:
    | { [k: string]: { [k: string]: Array<ExcludeT$Outbound> } }
    | undefined;
};

/** @internal */
export const Data$outboundSchema: z.ZodType<Data$Outbound, z.ZodTypeDef, Data> =
  z.object({
    rules: z.array(z.lazy(() => SegmentRules$outboundSchema)).optional(),
    include: z.record(z.record(z.array(z.lazy(() => Include$outboundSchema))))
      .optional(),
    exclude: z.record(z.record(z.array(z.lazy(() => ExcludeT$outboundSchema))))
      .optional(),
  });

export function dataToJSON(data: Data): string {
  return JSON.stringify(Data$outboundSchema.parse(data));
}
export function dataFromJSON(
  jsonString: string,
): SafeParseResult<Data, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data' from JSON`,
  );
}

/** @internal */
export const SegmentCreator$inboundSchema: z.ZodType<
  SegmentCreator,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  name: types.string(),
});
/** @internal */
export type SegmentCreator$Outbound = {
  id: string;
  name: string;
};

/** @internal */
export const SegmentCreator$outboundSchema: z.ZodType<
  SegmentCreator$Outbound,
  z.ZodTypeDef,
  SegmentCreator
> = z.object({
  id: z.string(),
  name: z.string(),
});

export function segmentCreatorToJSON(segmentCreator: SegmentCreator): string {
  return JSON.stringify(SegmentCreator$outboundSchema.parse(segmentCreator));
}
export function segmentCreatorFromJSON(
  jsonString: string,
): SafeParseResult<SegmentCreator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentCreator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentCreator' from JSON`,
  );
}

/** @internal */
export const SegmentMetadata$inboundSchema: z.ZodType<
  SegmentMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  creator: types.optional(z.lazy(() => SegmentCreator$inboundSchema)),
});
/** @internal */
export type SegmentMetadata$Outbound = {
  creator?: SegmentCreator$Outbound | undefined;
};

/** @internal */
export const SegmentMetadata$outboundSchema: z.ZodType<
  SegmentMetadata$Outbound,
  z.ZodTypeDef,
  SegmentMetadata
> = z.object({
  creator: z.lazy(() => SegmentCreator$outboundSchema).optional(),
});

export function segmentMetadataToJSON(
  segmentMetadata: SegmentMetadata,
): string {
  return JSON.stringify(SegmentMetadata$outboundSchema.parse(segmentMetadata));
}
export function segmentMetadataFromJSON(
  jsonString: string,
): SafeParseResult<SegmentMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SegmentMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SegmentMetadata' from JSON`,
  );
}

/** @internal */
export const Segment$inboundSchema: z.ZodType<Segment, z.ZodTypeDef, unknown> =
  z.object({
    description: types.optional(types.string()),
    createdBy: types.optional(types.string()),
    usedByFlags: types.optional(z.array(types.string())),
    usedBySegments: types.optional(z.array(types.string())),
    id: types.string(),
    label: types.string(),
    slug: types.string(),
    createdAt: types.number(),
    updatedAt: types.number(),
    projectId: types.string(),
    typeName: SegmentTypeName$inboundSchema,
    data: z.lazy(() => Data$inboundSchema),
    hint: types.string(),
    metadata: types.optional(z.lazy(() => SegmentMetadata$inboundSchema)),
  });
/** @internal */
export type Segment$Outbound = {
  description?: string | undefined;
  createdBy?: string | undefined;
  usedByFlags?: Array<string> | undefined;
  usedBySegments?: Array<string> | undefined;
  id: string;
  label: string;
  slug: string;
  createdAt: number;
  updatedAt: number;
  projectId: string;
  typeName: string;
  data: Data$Outbound;
  hint: string;
  metadata?: SegmentMetadata$Outbound | undefined;
};

/** @internal */
export const Segment$outboundSchema: z.ZodType<
  Segment$Outbound,
  z.ZodTypeDef,
  Segment
> = z.object({
  description: z.string().optional(),
  createdBy: z.string().optional(),
  usedByFlags: z.array(z.string()).optional(),
  usedBySegments: z.array(z.string()).optional(),
  id: z.string(),
  label: z.string(),
  slug: z.string(),
  createdAt: z.number(),
  updatedAt: z.number(),
  projectId: z.string(),
  typeName: SegmentTypeName$outboundSchema,
  data: z.lazy(() => Data$outboundSchema),
  hint: z.string(),
  metadata: z.lazy(() => SegmentMetadata$outboundSchema).optional(),
});

export function segmentToJSON(segment: Segment): string {
  return JSON.stringify(Segment$outboundSchema.parse(segment));
}
export function segmentFromJSON(
  jsonString: string,
): SafeParseResult<Segment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Segment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Segment' from JSON`,
  );
}
