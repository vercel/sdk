/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type StatusCode = number | string;

export type Redirects = {
  source: string;
  destination: string;
  statusCode?: number | string | undefined;
  permanent?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  preserveQueryParams?: boolean | undefined;
};

export type StageRedirectsRequestBody = {
  projectId: string;
  teamId: string;
  overwrite?: boolean | undefined;
  name?: string | undefined;
  redirects?: Array<Redirects> | undefined;
};

export type StageRedirectsRequest = {
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: StageRedirectsRequestBody | undefined;
};

export type StageRedirectsVersion = {
  /**
   * The unique identifier for the version.
   */
  id: string;
  /**
   * The key of the version. The key may be duplicated across versions if the contents are the same as a different version.
   */
  key: string;
  lastModified: number;
  createdBy: string;
  /**
   * Optional name for the version. If not provided, defaults to an ISO timestamp string.
   */
  name?: string | undefined;
  /**
   * Whether this version has not been promoted to production yet and is not serving end users.
   */
  isStaging?: boolean | undefined;
  /**
   * Whether this version is currently live in production.
   */
  isLive?: boolean | undefined;
  /**
   * The number of redirects in this version.
   */
  redirectCount?: number | undefined;
  /**
   * The staging link for previewing redirects in this version.
   */
  alias?: string | undefined;
};

export type StageRedirectsResponseBody = {
  alias: string | null;
  version: StageRedirectsVersion;
};

/** @internal */
export const StatusCode$inboundSchema: z.ZodType<
  StatusCode,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.number(), types.string()]);
/** @internal */
export type StatusCode$Outbound = number | string;

/** @internal */
export const StatusCode$outboundSchema: z.ZodType<
  StatusCode$Outbound,
  z.ZodTypeDef,
  StatusCode
> = smartUnion([z.number(), z.string()]);

export function statusCodeToJSON(statusCode: StatusCode): string {
  return JSON.stringify(StatusCode$outboundSchema.parse(statusCode));
}
export function statusCodeFromJSON(
  jsonString: string,
): SafeParseResult<StatusCode, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StatusCode$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StatusCode' from JSON`,
  );
}

/** @internal */
export const Redirects$inboundSchema: z.ZodType<
  Redirects,
  z.ZodTypeDef,
  unknown
> = z.object({
  source: types.string(),
  destination: types.string(),
  statusCode: types.optional(smartUnion([types.number(), types.string()])),
  permanent: types.optional(types.boolean()),
  caseSensitive: types.optional(types.boolean()),
  query: types.optional(types.boolean()),
  preserveQueryParams: types.optional(types.boolean()),
});
/** @internal */
export type Redirects$Outbound = {
  source: string;
  destination: string;
  statusCode?: number | string | undefined;
  permanent?: boolean | undefined;
  caseSensitive?: boolean | undefined;
  query?: boolean | undefined;
  preserveQueryParams?: boolean | undefined;
};

/** @internal */
export const Redirects$outboundSchema: z.ZodType<
  Redirects$Outbound,
  z.ZodTypeDef,
  Redirects
> = z.object({
  source: z.string(),
  destination: z.string(),
  statusCode: smartUnion([z.number(), z.string()]).optional(),
  permanent: z.boolean().optional(),
  caseSensitive: z.boolean().optional(),
  query: z.boolean().optional(),
  preserveQueryParams: z.boolean().optional(),
});

export function redirectsToJSON(redirects: Redirects): string {
  return JSON.stringify(Redirects$outboundSchema.parse(redirects));
}
export function redirectsFromJSON(
  jsonString: string,
): SafeParseResult<Redirects, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Redirects$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Redirects' from JSON`,
  );
}

/** @internal */
export const StageRedirectsRequestBody$inboundSchema: z.ZodType<
  StageRedirectsRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: types.string(),
  teamId: types.string(),
  overwrite: types.optional(types.boolean()),
  name: types.optional(types.string()),
  redirects: types.optional(z.array(z.lazy(() => Redirects$inboundSchema))),
});
/** @internal */
export type StageRedirectsRequestBody$Outbound = {
  projectId: string;
  teamId: string;
  overwrite?: boolean | undefined;
  name?: string | undefined;
  redirects?: Array<Redirects$Outbound> | undefined;
};

/** @internal */
export const StageRedirectsRequestBody$outboundSchema: z.ZodType<
  StageRedirectsRequestBody$Outbound,
  z.ZodTypeDef,
  StageRedirectsRequestBody
> = z.object({
  projectId: z.string(),
  teamId: z.string(),
  overwrite: z.boolean().optional(),
  name: z.string().optional(),
  redirects: z.array(z.lazy(() => Redirects$outboundSchema)).optional(),
});

export function stageRedirectsRequestBodyToJSON(
  stageRedirectsRequestBody: StageRedirectsRequestBody,
): string {
  return JSON.stringify(
    StageRedirectsRequestBody$outboundSchema.parse(stageRedirectsRequestBody),
  );
}
export function stageRedirectsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StageRedirectsRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StageRedirectsRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StageRedirectsRequestBody' from JSON`,
  );
}

/** @internal */
export const StageRedirectsRequest$inboundSchema: z.ZodType<
  StageRedirectsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: types.optional(
    z.lazy(() => StageRedirectsRequestBody$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type StageRedirectsRequest$Outbound = {
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: StageRedirectsRequestBody$Outbound | undefined;
};

/** @internal */
export const StageRedirectsRequest$outboundSchema: z.ZodType<
  StageRedirectsRequest$Outbound,
  z.ZodTypeDef,
  StageRedirectsRequest
> = z.object({
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => StageRedirectsRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function stageRedirectsRequestToJSON(
  stageRedirectsRequest: StageRedirectsRequest,
): string {
  return JSON.stringify(
    StageRedirectsRequest$outboundSchema.parse(stageRedirectsRequest),
  );
}
export function stageRedirectsRequestFromJSON(
  jsonString: string,
): SafeParseResult<StageRedirectsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StageRedirectsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StageRedirectsRequest' from JSON`,
  );
}

/** @internal */
export const StageRedirectsVersion$inboundSchema: z.ZodType<
  StageRedirectsVersion,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  key: types.string(),
  lastModified: types.number(),
  createdBy: types.string(),
  name: types.optional(types.string()),
  isStaging: types.optional(types.boolean()),
  isLive: types.optional(types.boolean()),
  redirectCount: types.optional(types.number()),
  alias: types.optional(types.string()),
});
/** @internal */
export type StageRedirectsVersion$Outbound = {
  id: string;
  key: string;
  lastModified: number;
  createdBy: string;
  name?: string | undefined;
  isStaging?: boolean | undefined;
  isLive?: boolean | undefined;
  redirectCount?: number | undefined;
  alias?: string | undefined;
};

/** @internal */
export const StageRedirectsVersion$outboundSchema: z.ZodType<
  StageRedirectsVersion$Outbound,
  z.ZodTypeDef,
  StageRedirectsVersion
> = z.object({
  id: z.string(),
  key: z.string(),
  lastModified: z.number(),
  createdBy: z.string(),
  name: z.string().optional(),
  isStaging: z.boolean().optional(),
  isLive: z.boolean().optional(),
  redirectCount: z.number().optional(),
  alias: z.string().optional(),
});

export function stageRedirectsVersionToJSON(
  stageRedirectsVersion: StageRedirectsVersion,
): string {
  return JSON.stringify(
    StageRedirectsVersion$outboundSchema.parse(stageRedirectsVersion),
  );
}
export function stageRedirectsVersionFromJSON(
  jsonString: string,
): SafeParseResult<StageRedirectsVersion, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StageRedirectsVersion$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StageRedirectsVersion' from JSON`,
  );
}

/** @internal */
export const StageRedirectsResponseBody$inboundSchema: z.ZodType<
  StageRedirectsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  alias: types.nullable(types.string()),
  version: z.lazy(() => StageRedirectsVersion$inboundSchema),
});
/** @internal */
export type StageRedirectsResponseBody$Outbound = {
  alias: string | null;
  version: StageRedirectsVersion$Outbound;
};

/** @internal */
export const StageRedirectsResponseBody$outboundSchema: z.ZodType<
  StageRedirectsResponseBody$Outbound,
  z.ZodTypeDef,
  StageRedirectsResponseBody
> = z.object({
  alias: z.nullable(z.string()),
  version: z.lazy(() => StageRedirectsVersion$outboundSchema),
});

export function stageRedirectsResponseBodyToJSON(
  stageRedirectsResponseBody: StageRedirectsResponseBody,
): string {
  return JSON.stringify(
    StageRedirectsResponseBody$outboundSchema.parse(stageRedirectsResponseBody),
  );
}
export function stageRedirectsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StageRedirectsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StageRedirectsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StageRedirectsResponseBody' from JSON`,
  );
}
