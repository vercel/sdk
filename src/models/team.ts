/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type Connect = {
  enabled?: boolean | undefined;
};

/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export const SyncState = {
  Setup: "SETUP",
  Active: "ACTIVE",
} as const;
/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export type SyncState = ClosedEnum<typeof SyncState>;

/**
 * Information for the SAML Single Sign-On configuration.
 */
export type Connection = {
  /**
   * The Identity Provider "type", for example Okta.
   */
  type: string;
  /**
   * Current status of the connection.
   */
  status: string;
  /**
   * Current state of the connection.
   */
  state: string;
  /**
   * Timestamp (in milliseconds) of when the configuration was connected.
   */
  connectedAt: number;
  /**
   * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
   */
  lastReceivedWebhookEvent?: number | undefined;
  /**
   * Timestamp (in milliseconds) of when the last directory sync was performed.
   */
  lastSyncedAt?: number | undefined;
  /**
   * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
   */
  syncState?: SyncState | undefined;
};

/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export const TeamSyncState = {
  Setup: "SETUP",
  Active: "ACTIVE",
} as const;
/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export type TeamSyncState = ClosedEnum<typeof TeamSyncState>;

/**
 * Information for the Directory Sync configuration.
 */
export type Directory = {
  /**
   * The Identity Provider "type", for example Okta.
   */
  type: string;
  /**
   * Current state of the connection.
   */
  state: string;
  /**
   * Timestamp (in milliseconds) of when the configuration was connected.
   */
  connectedAt: number;
  /**
   * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
   */
  lastReceivedWebhookEvent?: number | undefined;
  /**
   * Timestamp (in milliseconds) of when the last directory sync was performed.
   */
  lastSyncedAt?: number | undefined;
  /**
   * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
   */
  syncState?: TeamSyncState | undefined;
};

/**
 * The default redirect URI to use after successful SAML authentication.
 */
export const DefaultRedirectUri = {
  VercelCom: "vercel.com",
  V0Dev: "v0.dev",
  V0App: "v0.app",
} as const;
/**
 * The default redirect URI to use after successful SAML authentication.
 */
export type DefaultRedirectUri = ClosedEnum<typeof DefaultRedirectUri>;

export const Roles2 = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type Roles2 = ClosedEnum<typeof Roles2>;

/**
 * When "Directory Sync" is configured, this object contains a mapping of which Directory Group (by ID) should be assigned to which Vercel Team "role".
 */
export type Roles1 = {
  accessGroupId: string;
};

export type Roles = Roles1 | Roles2;

/**
 * When "Single Sign-On (SAML)" is configured, this object contains information regarding the configuration of the Identity Provider (IdP).
 */
export type Saml = {
  /**
   * Information for the SAML Single Sign-On configuration.
   */
  connection?: Connection | undefined;
  /**
   * Information for the Directory Sync configuration.
   */
  directory?: Directory | undefined;
  /**
   * When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
   */
  enforced: boolean;
  /**
   * The default redirect URI to use after successful SAML authentication.
   */
  defaultRedirectUri?: DefaultRedirectUri | undefined;
  /**
   * When "Directory Sync" is configured, this object contains a mapping of which Directory Group (by ID) should be assigned to which Vercel Team "role".
   */
  roles?: { [k: string]: Roles1 | Roles2 } | undefined;
};

export const TeamTeamRoles = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type TeamTeamRoles = ClosedEnum<typeof TeamTeamRoles>;

export const TeamTeamPermissions = {
  IntegrationManager: "IntegrationManager",
  CreateProject: "CreateProject",
  FullProductionDeployment: "FullProductionDeployment",
  UsageViewer: "UsageViewer",
  EnvVariableManager: "EnvVariableManager",
  EnvironmentManager: "EnvironmentManager",
  V0Builder: "V0Builder",
  V0Chatter: "V0Chatter",
  V0Viewer: "V0Viewer",
} as const;
export type TeamTeamPermissions = ClosedEnum<typeof TeamTeamPermissions>;

/**
 * Default roles for the team.
 */
export type DefaultRoles = {
  teamRoles?: Array<TeamTeamRoles> | undefined;
  teamPermissions?: Array<TeamTeamPermissions> | undefined;
};

export type BuildEntitlements = {
  enhancedBuilds?: boolean | undefined;
};

/**
 * Default build machine type for new builds
 */
export const Default = {
  Standard: "standard",
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
/**
 * Default build machine type for new builds
 */
export type Default = ClosedEnum<typeof Default>;

/**
 * Build machine configuration
 */
export type BuildMachine = {
  /**
   * Default build machine type for new builds
   */
  default?: Default | undefined;
};

export type ResourceConfig = {
  /**
   * The total amount of concurrent builds that can be used.
   */
  concurrentBuilds?: number | undefined;
  /**
   * Whether every build for this team / user has elastic concurrency enabled automatically.
   */
  elasticConcurrencyEnabled?: boolean | undefined;
  /**
   * The maximum size in kilobytes of an Edge Config. Only specified if a custom limit is set.
   */
  edgeConfigSize?: number | undefined;
  /**
   * The maximum number of edge configs an account can create.
   */
  edgeConfigs?: number | undefined;
  /**
   * The maximum number of kv databases an account can create.
   */
  kvDatabases?: number | undefined;
  /**
   * The maximum number of blob stores an account can create.
   */
  blobStores?: number | undefined;
  /**
   * The maximum number of postgres databases an account can create.
   */
  postgresDatabases?: number | undefined;
  buildEntitlements?: BuildEntitlements | undefined;
  /**
   * Build machine configuration
   */
  buildMachine?: BuildMachine | undefined;
};

export type DisableHardAutoBlocks = number | boolean;

/**
 * Is remote caching enabled for this team
 */
export type RemoteCaching = {
  enabled?: boolean | undefined;
};

export type PasswordProtection = {
  deploymentType: string;
};

export type SsoProtection = {
  deploymentType: string;
};

/**
 * Default deployment protection for this team null indicates protection is disabled
 */
export type DefaultDeploymentProtection = {
  passwordProtection?: PasswordProtection | null | undefined;
  ssoProtection?: SsoProtection | null | undefined;
};

/**
 * Default deployment expiration settings for this team
 */
export type DefaultExpirationSettings = {
  /**
   * Number of days to keep non-production deployments (mostly preview deployments) before soft deletion.
   */
  expirationDays?: number | undefined;
  /**
   * Number of days to keep production deployments before soft deletion.
   */
  expirationDaysProduction?: number | undefined;
  /**
   * Number of days to keep canceled deployments before soft deletion.
   */
  expirationDaysCanceled?: number | undefined;
  /**
   * Number of days to keep errored deployments before soft deletion.
   */
  expirationDaysErrored?: number | undefined;
  /**
   * Minimum number of production deployments to keep for this project, even if they are over the production expiration limit.
   */
  deploymentsToKeep?: number | undefined;
};

/**
 * Whether toolbar is enabled on preview deployments
 */
export const EnablePreviewFeedback = {
  Default: "default",
  On: "on",
  Off: "off",
  OnForce: "on-force",
  OffForce: "off-force",
  DefaultForce: "default-force",
} as const;
/**
 * Whether toolbar is enabled on preview deployments
 */
export type EnablePreviewFeedback = ClosedEnum<typeof EnablePreviewFeedback>;

/**
 * Whether toolbar is enabled on production deployments
 */
export const EnableProductionFeedback = {
  Default: "default",
  On: "on",
  Off: "off",
  OnForce: "on-force",
  OffForce: "off-force",
  DefaultForce: "default-force",
} as const;
/**
 * Whether toolbar is enabled on production deployments
 */
export type EnableProductionFeedback = ClosedEnum<
  typeof EnableProductionFeedback
>;

/**
 * Sensitive environment variable policy for this team
 */
export const SensitiveEnvironmentVariablePolicy = {
  Default: "default",
  On: "on",
  Off: "off",
} as const;
/**
 * Sensitive environment variable policy for this team
 */
export type SensitiveEnvironmentVariablePolicy = ClosedEnum<
  typeof SensitiveEnvironmentVariablePolicy
>;

export type IpBuckets = {
  bucket: string;
  supportUntil?: number | undefined;
};

/**
 * When enabled, deployment protection settings require stricter permissions (owner-only).
 */
export type StrictDeploymentProtectionSettings = {
  enabled: boolean;
  updatedAt: number;
};

export const Preference = {
  AutoApproval: "auto-approval",
  ManualApproval: "manual-approval",
  Block: "block",
} as const;
export type Preference = ClosedEnum<typeof Preference>;

/**
 * NSNB configuration for the team.
 */
export type NsnbConfig = {
  preference: Preference;
};

export type Entitlements = {
  entitlement: string;
};

export const TeamRole = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type TeamRole = ClosedEnum<typeof TeamRole>;

export const TeamMembershipTeamRoles = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type TeamMembershipTeamRoles = ClosedEnum<
  typeof TeamMembershipTeamRoles
>;

export const TeamMembershipTeamPermissions = {
  IntegrationManager: "IntegrationManager",
  CreateProject: "CreateProject",
  FullProductionDeployment: "FullProductionDeployment",
  UsageViewer: "UsageViewer",
  EnvVariableManager: "EnvVariableManager",
  EnvironmentManager: "EnvironmentManager",
  V0Builder: "V0Builder",
  V0Chatter: "V0Chatter",
  V0Viewer: "V0Viewer",
} as const;
export type TeamMembershipTeamPermissions = ClosedEnum<
  typeof TeamMembershipTeamPermissions
>;

export const Origin = {
  Link: "link",
  Saml: "saml",
  Mail: "mail",
  Import: "import",
  Teams: "teams",
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Dsync: "dsync",
  Feedback: "feedback",
  OrganizationTeams: "organization-teams",
  NsnbAutoApprove: "nsnb-auto-approve",
  NsnbRequestAccess: "nsnb-request-access",
  NsnbViewerUpgrade: "nsnb-viewer-upgrade",
  NsnbInvite: "nsnb-invite",
  NsnbRedeploy: "nsnb-redeploy",
} as const;
export type Origin = ClosedEnum<typeof Origin>;

export type GitUserId = string | number;

export type JoinedFrom = {
  origin: Origin;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

/**
 * The membership of the authenticated User in relation to the Team.
 */
export type Membership = {
  uid?: string | undefined;
  entitlements?: Array<Entitlements> | undefined;
  teamId?: string | undefined;
  confirmed: boolean;
  accessRequestedAt?: number | undefined;
  role: TeamRole;
  teamRoles?: Array<TeamMembershipTeamRoles> | undefined;
  teamPermissions?: Array<TeamMembershipTeamPermissions> | undefined;
  createdAt: number;
  created: number;
  joinedFrom?: JoinedFrom | undefined;
};

/**
 * Data representing a Team.
 */
export type Team = {
  connect?: Connect | undefined;
  /**
   * The ID of the user who created the Team.
   */
  creatorId: string;
  /**
   * Timestamp (in milliseconds) of when the Team was last updated.
   */
  updatedAt: number;
  /**
   * Hostname that'll be matched with emails on sign-up to automatically join the Team.
   */
  emailDomain?: string | null | undefined;
  /**
   * When "Single Sign-On (SAML)" is configured, this object contains information regarding the configuration of the Identity Provider (IdP).
   */
  saml?: Saml | undefined;
  /**
   * Code that can be used to join this Team. Only visible to Team owners.
   */
  inviteCode?: string | undefined;
  /**
   * A short description of the Team.
   */
  description: string | null;
  /**
   * Default roles for the team.
   */
  defaultRoles?: DefaultRoles | undefined;
  /**
   * The prefix that is prepended to automatic aliases.
   */
  stagingPrefix: string;
  resourceConfig?: ResourceConfig | undefined;
  /**
   * The hostname that is current set as preview deployment suffix.
   */
  previewDeploymentSuffix?: string | null | undefined;
  /**
   * Whether the team is a platform team.
   */
  platform?: boolean | undefined;
  disableHardAutoBlocks?: number | boolean | undefined;
  /**
   * Is remote caching enabled for this team
   */
  remoteCaching?: RemoteCaching | undefined;
  /**
   * Default deployment protection for this team null indicates protection is disabled
   */
  defaultDeploymentProtection?: DefaultDeploymentProtection | undefined;
  /**
   * Default deployment expiration settings for this team
   */
  defaultExpirationSettings?: DefaultExpirationSettings | undefined;
  /**
   * Whether toolbar is enabled on preview deployments
   */
  enablePreviewFeedback?: EnablePreviewFeedback | null | undefined;
  /**
   * Whether toolbar is enabled on production deployments
   */
  enableProductionFeedback?: EnableProductionFeedback | null | undefined;
  /**
   * Sensitive environment variable policy for this team
   */
  sensitiveEnvironmentVariablePolicy?:
    | SensitiveEnvironmentVariablePolicy
    | null
    | undefined;
  /**
   * Indicates if IP addresses should be accessible in observability (o11y) tooling
   */
  hideIpAddresses?: boolean | null | undefined;
  /**
   * Indicates if IP addresses should be accessible in log drains
   */
  hideIpAddressesInLogDrains?: boolean | null | undefined;
  ipBuckets?: Array<IpBuckets> | undefined;
  /**
   * When enabled, deployment protection settings require stricter permissions (owner-only).
   */
  strictDeploymentProtectionSettings?:
    | StrictDeploymentProtectionSettings
    | undefined;
  /**
   * NSNB configuration for the team.
   */
  nsnbConfig?: NsnbConfig | undefined;
  /**
   * The Team's unique identifier.
   */
  id: string;
  /**
   * The Team's slug, which is unique across the Vercel platform.
   */
  slug: string;
  /**
   * Name associated with the Team account, or `null` if none has been provided.
   */
  name: string | null;
  /**
   * The ID of the file used as avatar for this Team.
   */
  avatar: string | null;
  /**
   * The membership of the authenticated User in relation to the Team.
   */
  membership: Membership;
  /**
   * UNIX timestamp (in milliseconds) when the Team was created.
   */
  createdAt: number;
  additionalProperties?: { [k: string]: any } | undefined;
};

/** @internal */
export const Connect$inboundSchema: z.ZodType<Connect, z.ZodTypeDef, unknown> =
  z.object({
    enabled: types.optional(types.boolean()),
  });
/** @internal */
export type Connect$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const Connect$outboundSchema: z.ZodType<
  Connect$Outbound,
  z.ZodTypeDef,
  Connect
> = z.object({
  enabled: z.boolean().optional(),
});

export function connectToJSON(connect: Connect): string {
  return JSON.stringify(Connect$outboundSchema.parse(connect));
}
export function connectFromJSON(
  jsonString: string,
): SafeParseResult<Connect, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Connect$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Connect' from JSON`,
  );
}

/** @internal */
export const SyncState$inboundSchema: z.ZodNativeEnum<typeof SyncState> = z
  .nativeEnum(SyncState);
/** @internal */
export const SyncState$outboundSchema: z.ZodNativeEnum<typeof SyncState> =
  SyncState$inboundSchema;

/** @internal */
export const Connection$inboundSchema: z.ZodType<
  Connection,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.string(),
  status: types.string(),
  state: types.string(),
  connectedAt: types.number(),
  lastReceivedWebhookEvent: types.optional(types.number()),
  lastSyncedAt: types.optional(types.number()),
  syncState: types.optional(SyncState$inboundSchema),
});
/** @internal */
export type Connection$Outbound = {
  type: string;
  status: string;
  state: string;
  connectedAt: number;
  lastReceivedWebhookEvent?: number | undefined;
  lastSyncedAt?: number | undefined;
  syncState?: string | undefined;
};

/** @internal */
export const Connection$outboundSchema: z.ZodType<
  Connection$Outbound,
  z.ZodTypeDef,
  Connection
> = z.object({
  type: z.string(),
  status: z.string(),
  state: z.string(),
  connectedAt: z.number(),
  lastReceivedWebhookEvent: z.number().optional(),
  lastSyncedAt: z.number().optional(),
  syncState: SyncState$outboundSchema.optional(),
});

export function connectionToJSON(connection: Connection): string {
  return JSON.stringify(Connection$outboundSchema.parse(connection));
}
export function connectionFromJSON(
  jsonString: string,
): SafeParseResult<Connection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Connection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Connection' from JSON`,
  );
}

/** @internal */
export const TeamSyncState$inboundSchema: z.ZodNativeEnum<
  typeof TeamSyncState
> = z.nativeEnum(TeamSyncState);
/** @internal */
export const TeamSyncState$outboundSchema: z.ZodNativeEnum<
  typeof TeamSyncState
> = TeamSyncState$inboundSchema;

/** @internal */
export const Directory$inboundSchema: z.ZodType<
  Directory,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.string(),
  state: types.string(),
  connectedAt: types.number(),
  lastReceivedWebhookEvent: types.optional(types.number()),
  lastSyncedAt: types.optional(types.number()),
  syncState: types.optional(TeamSyncState$inboundSchema),
});
/** @internal */
export type Directory$Outbound = {
  type: string;
  state: string;
  connectedAt: number;
  lastReceivedWebhookEvent?: number | undefined;
  lastSyncedAt?: number | undefined;
  syncState?: string | undefined;
};

/** @internal */
export const Directory$outboundSchema: z.ZodType<
  Directory$Outbound,
  z.ZodTypeDef,
  Directory
> = z.object({
  type: z.string(),
  state: z.string(),
  connectedAt: z.number(),
  lastReceivedWebhookEvent: z.number().optional(),
  lastSyncedAt: z.number().optional(),
  syncState: TeamSyncState$outboundSchema.optional(),
});

export function directoryToJSON(directory: Directory): string {
  return JSON.stringify(Directory$outboundSchema.parse(directory));
}
export function directoryFromJSON(
  jsonString: string,
): SafeParseResult<Directory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Directory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Directory' from JSON`,
  );
}

/** @internal */
export const DefaultRedirectUri$inboundSchema: z.ZodNativeEnum<
  typeof DefaultRedirectUri
> = z.nativeEnum(DefaultRedirectUri);
/** @internal */
export const DefaultRedirectUri$outboundSchema: z.ZodNativeEnum<
  typeof DefaultRedirectUri
> = DefaultRedirectUri$inboundSchema;

/** @internal */
export const Roles2$inboundSchema: z.ZodNativeEnum<typeof Roles2> = z
  .nativeEnum(Roles2);
/** @internal */
export const Roles2$outboundSchema: z.ZodNativeEnum<typeof Roles2> =
  Roles2$inboundSchema;

/** @internal */
export const Roles1$inboundSchema: z.ZodType<Roles1, z.ZodTypeDef, unknown> = z
  .object({
    accessGroupId: types.string(),
  });
/** @internal */
export type Roles1$Outbound = {
  accessGroupId: string;
};

/** @internal */
export const Roles1$outboundSchema: z.ZodType<
  Roles1$Outbound,
  z.ZodTypeDef,
  Roles1
> = z.object({
  accessGroupId: z.string(),
});

export function roles1ToJSON(roles1: Roles1): string {
  return JSON.stringify(Roles1$outboundSchema.parse(roles1));
}
export function roles1FromJSON(
  jsonString: string,
): SafeParseResult<Roles1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Roles1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Roles1' from JSON`,
  );
}

/** @internal */
export const Roles$inboundSchema: z.ZodType<Roles, z.ZodTypeDef, unknown> =
  smartUnion([z.lazy(() => Roles1$inboundSchema), Roles2$inboundSchema]);
/** @internal */
export type Roles$Outbound = Roles1$Outbound | string;

/** @internal */
export const Roles$outboundSchema: z.ZodType<
  Roles$Outbound,
  z.ZodTypeDef,
  Roles
> = smartUnion([z.lazy(() => Roles1$outboundSchema), Roles2$outboundSchema]);

export function rolesToJSON(roles: Roles): string {
  return JSON.stringify(Roles$outboundSchema.parse(roles));
}
export function rolesFromJSON(
  jsonString: string,
): SafeParseResult<Roles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Roles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Roles' from JSON`,
  );
}

/** @internal */
export const Saml$inboundSchema: z.ZodType<Saml, z.ZodTypeDef, unknown> = z
  .object({
    connection: types.optional(z.lazy(() => Connection$inboundSchema)),
    directory: types.optional(z.lazy(() => Directory$inboundSchema)),
    enforced: types.boolean(),
    defaultRedirectUri: types.optional(DefaultRedirectUri$inboundSchema),
    roles: types.optional(
      z.record(smartUnion([
        z.lazy(() => Roles1$inboundSchema),
        Roles2$inboundSchema,
      ])),
    ),
  });
/** @internal */
export type Saml$Outbound = {
  connection?: Connection$Outbound | undefined;
  directory?: Directory$Outbound | undefined;
  enforced: boolean;
  defaultRedirectUri?: string | undefined;
  roles?: { [k: string]: Roles1$Outbound | string } | undefined;
};

/** @internal */
export const Saml$outboundSchema: z.ZodType<Saml$Outbound, z.ZodTypeDef, Saml> =
  z.object({
    connection: z.lazy(() => Connection$outboundSchema).optional(),
    directory: z.lazy(() => Directory$outboundSchema).optional(),
    enforced: z.boolean(),
    defaultRedirectUri: DefaultRedirectUri$outboundSchema.optional(),
    roles: z.record(
      smartUnion([z.lazy(() => Roles1$outboundSchema), Roles2$outboundSchema]),
    ).optional(),
  });

export function samlToJSON(saml: Saml): string {
  return JSON.stringify(Saml$outboundSchema.parse(saml));
}
export function samlFromJSON(
  jsonString: string,
): SafeParseResult<Saml, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Saml$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Saml' from JSON`,
  );
}

/** @internal */
export const TeamTeamRoles$inboundSchema: z.ZodNativeEnum<
  typeof TeamTeamRoles
> = z.nativeEnum(TeamTeamRoles);
/** @internal */
export const TeamTeamRoles$outboundSchema: z.ZodNativeEnum<
  typeof TeamTeamRoles
> = TeamTeamRoles$inboundSchema;

/** @internal */
export const TeamTeamPermissions$inboundSchema: z.ZodNativeEnum<
  typeof TeamTeamPermissions
> = z.nativeEnum(TeamTeamPermissions);
/** @internal */
export const TeamTeamPermissions$outboundSchema: z.ZodNativeEnum<
  typeof TeamTeamPermissions
> = TeamTeamPermissions$inboundSchema;

/** @internal */
export const DefaultRoles$inboundSchema: z.ZodType<
  DefaultRoles,
  z.ZodTypeDef,
  unknown
> = z.object({
  teamRoles: types.optional(z.array(TeamTeamRoles$inboundSchema)),
  teamPermissions: types.optional(z.array(TeamTeamPermissions$inboundSchema)),
});
/** @internal */
export type DefaultRoles$Outbound = {
  teamRoles?: Array<string> | undefined;
  teamPermissions?: Array<string> | undefined;
};

/** @internal */
export const DefaultRoles$outboundSchema: z.ZodType<
  DefaultRoles$Outbound,
  z.ZodTypeDef,
  DefaultRoles
> = z.object({
  teamRoles: z.array(TeamTeamRoles$outboundSchema).optional(),
  teamPermissions: z.array(TeamTeamPermissions$outboundSchema).optional(),
});

export function defaultRolesToJSON(defaultRoles: DefaultRoles): string {
  return JSON.stringify(DefaultRoles$outboundSchema.parse(defaultRoles));
}
export function defaultRolesFromJSON(
  jsonString: string,
): SafeParseResult<DefaultRoles, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultRoles$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultRoles' from JSON`,
  );
}

/** @internal */
export const BuildEntitlements$inboundSchema: z.ZodType<
  BuildEntitlements,
  z.ZodTypeDef,
  unknown
> = z.object({
  enhancedBuilds: types.optional(types.boolean()),
});
/** @internal */
export type BuildEntitlements$Outbound = {
  enhancedBuilds?: boolean | undefined;
};

/** @internal */
export const BuildEntitlements$outboundSchema: z.ZodType<
  BuildEntitlements$Outbound,
  z.ZodTypeDef,
  BuildEntitlements
> = z.object({
  enhancedBuilds: z.boolean().optional(),
});

export function buildEntitlementsToJSON(
  buildEntitlements: BuildEntitlements,
): string {
  return JSON.stringify(
    BuildEntitlements$outboundSchema.parse(buildEntitlements),
  );
}
export function buildEntitlementsFromJSON(
  jsonString: string,
): SafeParseResult<BuildEntitlements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BuildEntitlements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BuildEntitlements' from JSON`,
  );
}

/** @internal */
export const Default$inboundSchema: z.ZodNativeEnum<typeof Default> = z
  .nativeEnum(Default);
/** @internal */
export const Default$outboundSchema: z.ZodNativeEnum<typeof Default> =
  Default$inboundSchema;

/** @internal */
export const BuildMachine$inboundSchema: z.ZodType<
  BuildMachine,
  z.ZodTypeDef,
  unknown
> = z.object({
  default: types.optional(Default$inboundSchema),
});
/** @internal */
export type BuildMachine$Outbound = {
  default?: string | undefined;
};

/** @internal */
export const BuildMachine$outboundSchema: z.ZodType<
  BuildMachine$Outbound,
  z.ZodTypeDef,
  BuildMachine
> = z.object({
  default: Default$outboundSchema.optional(),
});

export function buildMachineToJSON(buildMachine: BuildMachine): string {
  return JSON.stringify(BuildMachine$outboundSchema.parse(buildMachine));
}
export function buildMachineFromJSON(
  jsonString: string,
): SafeParseResult<BuildMachine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BuildMachine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BuildMachine' from JSON`,
  );
}

/** @internal */
export const ResourceConfig$inboundSchema: z.ZodType<
  ResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  concurrentBuilds: types.optional(types.number()),
  elasticConcurrencyEnabled: types.optional(types.boolean()),
  edgeConfigSize: types.optional(types.number()),
  edgeConfigs: types.optional(types.number()),
  kvDatabases: types.optional(types.number()),
  blobStores: types.optional(types.number()),
  postgresDatabases: types.optional(types.number()),
  buildEntitlements: types.optional(
    z.lazy(() => BuildEntitlements$inboundSchema),
  ),
  buildMachine: types.optional(z.lazy(() => BuildMachine$inboundSchema)),
});
/** @internal */
export type ResourceConfig$Outbound = {
  concurrentBuilds?: number | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  edgeConfigSize?: number | undefined;
  edgeConfigs?: number | undefined;
  kvDatabases?: number | undefined;
  blobStores?: number | undefined;
  postgresDatabases?: number | undefined;
  buildEntitlements?: BuildEntitlements$Outbound | undefined;
  buildMachine?: BuildMachine$Outbound | undefined;
};

/** @internal */
export const ResourceConfig$outboundSchema: z.ZodType<
  ResourceConfig$Outbound,
  z.ZodTypeDef,
  ResourceConfig
> = z.object({
  concurrentBuilds: z.number().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  edgeConfigSize: z.number().optional(),
  edgeConfigs: z.number().optional(),
  kvDatabases: z.number().optional(),
  blobStores: z.number().optional(),
  postgresDatabases: z.number().optional(),
  buildEntitlements: z.lazy(() => BuildEntitlements$outboundSchema).optional(),
  buildMachine: z.lazy(() => BuildMachine$outboundSchema).optional(),
});

export function resourceConfigToJSON(resourceConfig: ResourceConfig): string {
  return JSON.stringify(ResourceConfig$outboundSchema.parse(resourceConfig));
}
export function resourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<ResourceConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResourceConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResourceConfig' from JSON`,
  );
}

/** @internal */
export const DisableHardAutoBlocks$inboundSchema: z.ZodType<
  DisableHardAutoBlocks,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.number(), types.boolean()]);
/** @internal */
export type DisableHardAutoBlocks$Outbound = number | boolean;

/** @internal */
export const DisableHardAutoBlocks$outboundSchema: z.ZodType<
  DisableHardAutoBlocks$Outbound,
  z.ZodTypeDef,
  DisableHardAutoBlocks
> = smartUnion([z.number(), z.boolean()]);

export function disableHardAutoBlocksToJSON(
  disableHardAutoBlocks: DisableHardAutoBlocks,
): string {
  return JSON.stringify(
    DisableHardAutoBlocks$outboundSchema.parse(disableHardAutoBlocks),
  );
}
export function disableHardAutoBlocksFromJSON(
  jsonString: string,
): SafeParseResult<DisableHardAutoBlocks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DisableHardAutoBlocks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DisableHardAutoBlocks' from JSON`,
  );
}

/** @internal */
export const RemoteCaching$inboundSchema: z.ZodType<
  RemoteCaching,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.optional(types.boolean()),
});
/** @internal */
export type RemoteCaching$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const RemoteCaching$outboundSchema: z.ZodType<
  RemoteCaching$Outbound,
  z.ZodTypeDef,
  RemoteCaching
> = z.object({
  enabled: z.boolean().optional(),
});

export function remoteCachingToJSON(remoteCaching: RemoteCaching): string {
  return JSON.stringify(RemoteCaching$outboundSchema.parse(remoteCaching));
}
export function remoteCachingFromJSON(
  jsonString: string,
): SafeParseResult<RemoteCaching, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RemoteCaching$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RemoteCaching' from JSON`,
  );
}

/** @internal */
export const PasswordProtection$inboundSchema: z.ZodType<
  PasswordProtection,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: types.string(),
});
/** @internal */
export type PasswordProtection$Outbound = {
  deploymentType: string;
};

/** @internal */
export const PasswordProtection$outboundSchema: z.ZodType<
  PasswordProtection$Outbound,
  z.ZodTypeDef,
  PasswordProtection
> = z.object({
  deploymentType: z.string(),
});

export function passwordProtectionToJSON(
  passwordProtection: PasswordProtection,
): string {
  return JSON.stringify(
    PasswordProtection$outboundSchema.parse(passwordProtection),
  );
}
export function passwordProtectionFromJSON(
  jsonString: string,
): SafeParseResult<PasswordProtection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PasswordProtection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PasswordProtection' from JSON`,
  );
}

/** @internal */
export const SsoProtection$inboundSchema: z.ZodType<
  SsoProtection,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: types.string(),
});
/** @internal */
export type SsoProtection$Outbound = {
  deploymentType: string;
};

/** @internal */
export const SsoProtection$outboundSchema: z.ZodType<
  SsoProtection$Outbound,
  z.ZodTypeDef,
  SsoProtection
> = z.object({
  deploymentType: z.string(),
});

export function ssoProtectionToJSON(ssoProtection: SsoProtection): string {
  return JSON.stringify(SsoProtection$outboundSchema.parse(ssoProtection));
}
export function ssoProtectionFromJSON(
  jsonString: string,
): SafeParseResult<SsoProtection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SsoProtection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SsoProtection' from JSON`,
  );
}

/** @internal */
export const DefaultDeploymentProtection$inboundSchema: z.ZodType<
  DefaultDeploymentProtection,
  z.ZodTypeDef,
  unknown
> = z.object({
  passwordProtection: z.nullable(z.lazy(() => PasswordProtection$inboundSchema))
    .optional(),
  ssoProtection: z.nullable(z.lazy(() => SsoProtection$inboundSchema))
    .optional(),
});
/** @internal */
export type DefaultDeploymentProtection$Outbound = {
  passwordProtection?: PasswordProtection$Outbound | null | undefined;
  ssoProtection?: SsoProtection$Outbound | null | undefined;
};

/** @internal */
export const DefaultDeploymentProtection$outboundSchema: z.ZodType<
  DefaultDeploymentProtection$Outbound,
  z.ZodTypeDef,
  DefaultDeploymentProtection
> = z.object({
  passwordProtection: z.nullable(
    z.lazy(() => PasswordProtection$outboundSchema),
  ).optional(),
  ssoProtection: z.nullable(z.lazy(() => SsoProtection$outboundSchema))
    .optional(),
});

export function defaultDeploymentProtectionToJSON(
  defaultDeploymentProtection: DefaultDeploymentProtection,
): string {
  return JSON.stringify(
    DefaultDeploymentProtection$outboundSchema.parse(
      defaultDeploymentProtection,
    ),
  );
}
export function defaultDeploymentProtectionFromJSON(
  jsonString: string,
): SafeParseResult<DefaultDeploymentProtection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultDeploymentProtection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultDeploymentProtection' from JSON`,
  );
}

/** @internal */
export const DefaultExpirationSettings$inboundSchema: z.ZodType<
  DefaultExpirationSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  expirationDays: types.optional(types.number()),
  expirationDaysProduction: types.optional(types.number()),
  expirationDaysCanceled: types.optional(types.number()),
  expirationDaysErrored: types.optional(types.number()),
  deploymentsToKeep: types.optional(types.number()),
});
/** @internal */
export type DefaultExpirationSettings$Outbound = {
  expirationDays?: number | undefined;
  expirationDaysProduction?: number | undefined;
  expirationDaysCanceled?: number | undefined;
  expirationDaysErrored?: number | undefined;
  deploymentsToKeep?: number | undefined;
};

/** @internal */
export const DefaultExpirationSettings$outboundSchema: z.ZodType<
  DefaultExpirationSettings$Outbound,
  z.ZodTypeDef,
  DefaultExpirationSettings
> = z.object({
  expirationDays: z.number().optional(),
  expirationDaysProduction: z.number().optional(),
  expirationDaysCanceled: z.number().optional(),
  expirationDaysErrored: z.number().optional(),
  deploymentsToKeep: z.number().optional(),
});

export function defaultExpirationSettingsToJSON(
  defaultExpirationSettings: DefaultExpirationSettings,
): string {
  return JSON.stringify(
    DefaultExpirationSettings$outboundSchema.parse(defaultExpirationSettings),
  );
}
export function defaultExpirationSettingsFromJSON(
  jsonString: string,
): SafeParseResult<DefaultExpirationSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultExpirationSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultExpirationSettings' from JSON`,
  );
}

/** @internal */
export const EnablePreviewFeedback$inboundSchema: z.ZodNativeEnum<
  typeof EnablePreviewFeedback
> = z.nativeEnum(EnablePreviewFeedback);
/** @internal */
export const EnablePreviewFeedback$outboundSchema: z.ZodNativeEnum<
  typeof EnablePreviewFeedback
> = EnablePreviewFeedback$inboundSchema;

/** @internal */
export const EnableProductionFeedback$inboundSchema: z.ZodNativeEnum<
  typeof EnableProductionFeedback
> = z.nativeEnum(EnableProductionFeedback);
/** @internal */
export const EnableProductionFeedback$outboundSchema: z.ZodNativeEnum<
  typeof EnableProductionFeedback
> = EnableProductionFeedback$inboundSchema;

/** @internal */
export const SensitiveEnvironmentVariablePolicy$inboundSchema: z.ZodNativeEnum<
  typeof SensitiveEnvironmentVariablePolicy
> = z.nativeEnum(SensitiveEnvironmentVariablePolicy);
/** @internal */
export const SensitiveEnvironmentVariablePolicy$outboundSchema: z.ZodNativeEnum<
  typeof SensitiveEnvironmentVariablePolicy
> = SensitiveEnvironmentVariablePolicy$inboundSchema;

/** @internal */
export const IpBuckets$inboundSchema: z.ZodType<
  IpBuckets,
  z.ZodTypeDef,
  unknown
> = z.object({
  bucket: types.string(),
  supportUntil: types.optional(types.number()),
});
/** @internal */
export type IpBuckets$Outbound = {
  bucket: string;
  supportUntil?: number | undefined;
};

/** @internal */
export const IpBuckets$outboundSchema: z.ZodType<
  IpBuckets$Outbound,
  z.ZodTypeDef,
  IpBuckets
> = z.object({
  bucket: z.string(),
  supportUntil: z.number().optional(),
});

export function ipBucketsToJSON(ipBuckets: IpBuckets): string {
  return JSON.stringify(IpBuckets$outboundSchema.parse(ipBuckets));
}
export function ipBucketsFromJSON(
  jsonString: string,
): SafeParseResult<IpBuckets, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IpBuckets$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IpBuckets' from JSON`,
  );
}

/** @internal */
export const StrictDeploymentProtectionSettings$inboundSchema: z.ZodType<
  StrictDeploymentProtectionSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: types.boolean(),
  updatedAt: types.number(),
});
/** @internal */
export type StrictDeploymentProtectionSettings$Outbound = {
  enabled: boolean;
  updatedAt: number;
};

/** @internal */
export const StrictDeploymentProtectionSettings$outboundSchema: z.ZodType<
  StrictDeploymentProtectionSettings$Outbound,
  z.ZodTypeDef,
  StrictDeploymentProtectionSettings
> = z.object({
  enabled: z.boolean(),
  updatedAt: z.number(),
});

export function strictDeploymentProtectionSettingsToJSON(
  strictDeploymentProtectionSettings: StrictDeploymentProtectionSettings,
): string {
  return JSON.stringify(
    StrictDeploymentProtectionSettings$outboundSchema.parse(
      strictDeploymentProtectionSettings,
    ),
  );
}
export function strictDeploymentProtectionSettingsFromJSON(
  jsonString: string,
): SafeParseResult<StrictDeploymentProtectionSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StrictDeploymentProtectionSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StrictDeploymentProtectionSettings' from JSON`,
  );
}

/** @internal */
export const Preference$inboundSchema: z.ZodNativeEnum<typeof Preference> = z
  .nativeEnum(Preference);
/** @internal */
export const Preference$outboundSchema: z.ZodNativeEnum<typeof Preference> =
  Preference$inboundSchema;

/** @internal */
export const NsnbConfig$inboundSchema: z.ZodType<
  NsnbConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  preference: Preference$inboundSchema,
});
/** @internal */
export type NsnbConfig$Outbound = {
  preference: string;
};

/** @internal */
export const NsnbConfig$outboundSchema: z.ZodType<
  NsnbConfig$Outbound,
  z.ZodTypeDef,
  NsnbConfig
> = z.object({
  preference: Preference$outboundSchema,
});

export function nsnbConfigToJSON(nsnbConfig: NsnbConfig): string {
  return JSON.stringify(NsnbConfig$outboundSchema.parse(nsnbConfig));
}
export function nsnbConfigFromJSON(
  jsonString: string,
): SafeParseResult<NsnbConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => NsnbConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'NsnbConfig' from JSON`,
  );
}

/** @internal */
export const Entitlements$inboundSchema: z.ZodType<
  Entitlements,
  z.ZodTypeDef,
  unknown
> = z.object({
  entitlement: types.string(),
});
/** @internal */
export type Entitlements$Outbound = {
  entitlement: string;
};

/** @internal */
export const Entitlements$outboundSchema: z.ZodType<
  Entitlements$Outbound,
  z.ZodTypeDef,
  Entitlements
> = z.object({
  entitlement: z.string(),
});

export function entitlementsToJSON(entitlements: Entitlements): string {
  return JSON.stringify(Entitlements$outboundSchema.parse(entitlements));
}
export function entitlementsFromJSON(
  jsonString: string,
): SafeParseResult<Entitlements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Entitlements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Entitlements' from JSON`,
  );
}

/** @internal */
export const TeamRole$inboundSchema: z.ZodNativeEnum<typeof TeamRole> = z
  .nativeEnum(TeamRole);
/** @internal */
export const TeamRole$outboundSchema: z.ZodNativeEnum<typeof TeamRole> =
  TeamRole$inboundSchema;

/** @internal */
export const TeamMembershipTeamRoles$inboundSchema: z.ZodNativeEnum<
  typeof TeamMembershipTeamRoles
> = z.nativeEnum(TeamMembershipTeamRoles);
/** @internal */
export const TeamMembershipTeamRoles$outboundSchema: z.ZodNativeEnum<
  typeof TeamMembershipTeamRoles
> = TeamMembershipTeamRoles$inboundSchema;

/** @internal */
export const TeamMembershipTeamPermissions$inboundSchema: z.ZodNativeEnum<
  typeof TeamMembershipTeamPermissions
> = z.nativeEnum(TeamMembershipTeamPermissions);
/** @internal */
export const TeamMembershipTeamPermissions$outboundSchema: z.ZodNativeEnum<
  typeof TeamMembershipTeamPermissions
> = TeamMembershipTeamPermissions$inboundSchema;

/** @internal */
export const Origin$inboundSchema: z.ZodNativeEnum<typeof Origin> = z
  .nativeEnum(Origin);
/** @internal */
export const Origin$outboundSchema: z.ZodNativeEnum<typeof Origin> =
  Origin$inboundSchema;

/** @internal */
export const GitUserId$inboundSchema: z.ZodType<
  GitUserId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type GitUserId$Outbound = string | number;

/** @internal */
export const GitUserId$outboundSchema: z.ZodType<
  GitUserId$Outbound,
  z.ZodTypeDef,
  GitUserId
> = smartUnion([z.string(), z.number()]);

export function gitUserIdToJSON(gitUserId: GitUserId): string {
  return JSON.stringify(GitUserId$outboundSchema.parse(gitUserId));
}
export function gitUserIdFromJSON(
  jsonString: string,
): SafeParseResult<GitUserId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitUserId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitUserId' from JSON`,
  );
}

/** @internal */
export const JoinedFrom$inboundSchema: z.ZodType<
  JoinedFrom,
  z.ZodTypeDef,
  unknown
> = z.object({
  origin: Origin$inboundSchema,
  commitId: types.optional(types.string()),
  repoId: types.optional(types.string()),
  repoPath: types.optional(types.string()),
  gitUserId: types.optional(smartUnion([types.string(), types.number()])),
  gitUserLogin: types.optional(types.string()),
  ssoUserId: types.optional(types.string()),
  ssoConnectedAt: types.optional(types.number()),
  idpUserId: types.optional(types.string()),
  dsyncUserId: types.optional(types.string()),
  dsyncConnectedAt: types.optional(types.number()),
});
/** @internal */
export type JoinedFrom$Outbound = {
  origin: string;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

/** @internal */
export const JoinedFrom$outboundSchema: z.ZodType<
  JoinedFrom$Outbound,
  z.ZodTypeDef,
  JoinedFrom
> = z.object({
  origin: Origin$outboundSchema,
  commitId: z.string().optional(),
  repoId: z.string().optional(),
  repoPath: z.string().optional(),
  gitUserId: smartUnion([z.string(), z.number()]).optional(),
  gitUserLogin: z.string().optional(),
  ssoUserId: z.string().optional(),
  ssoConnectedAt: z.number().optional(),
  idpUserId: z.string().optional(),
  dsyncUserId: z.string().optional(),
  dsyncConnectedAt: z.number().optional(),
});

export function joinedFromToJSON(joinedFrom: JoinedFrom): string {
  return JSON.stringify(JoinedFrom$outboundSchema.parse(joinedFrom));
}
export function joinedFromFromJSON(
  jsonString: string,
): SafeParseResult<JoinedFrom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JoinedFrom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JoinedFrom' from JSON`,
  );
}

/** @internal */
export const Membership$inboundSchema: z.ZodType<
  Membership,
  z.ZodTypeDef,
  unknown
> = z.object({
  uid: types.optional(types.string()),
  entitlements: types.optional(
    z.array(z.lazy(() => Entitlements$inboundSchema)),
  ),
  teamId: types.optional(types.string()),
  confirmed: types.boolean(),
  accessRequestedAt: types.optional(types.number()),
  role: TeamRole$inboundSchema,
  teamRoles: types.optional(z.array(TeamMembershipTeamRoles$inboundSchema)),
  teamPermissions: types.optional(
    z.array(TeamMembershipTeamPermissions$inboundSchema),
  ),
  createdAt: types.number(),
  created: types.number(),
  joinedFrom: types.optional(z.lazy(() => JoinedFrom$inboundSchema)),
});
/** @internal */
export type Membership$Outbound = {
  uid?: string | undefined;
  entitlements?: Array<Entitlements$Outbound> | undefined;
  teamId?: string | undefined;
  confirmed: boolean;
  accessRequestedAt?: number | undefined;
  role: string;
  teamRoles?: Array<string> | undefined;
  teamPermissions?: Array<string> | undefined;
  createdAt: number;
  created: number;
  joinedFrom?: JoinedFrom$Outbound | undefined;
};

/** @internal */
export const Membership$outboundSchema: z.ZodType<
  Membership$Outbound,
  z.ZodTypeDef,
  Membership
> = z.object({
  uid: z.string().optional(),
  entitlements: z.array(z.lazy(() => Entitlements$outboundSchema)).optional(),
  teamId: z.string().optional(),
  confirmed: z.boolean(),
  accessRequestedAt: z.number().optional(),
  role: TeamRole$outboundSchema,
  teamRoles: z.array(TeamMembershipTeamRoles$outboundSchema).optional(),
  teamPermissions: z.array(TeamMembershipTeamPermissions$outboundSchema)
    .optional(),
  createdAt: z.number(),
  created: z.number(),
  joinedFrom: z.lazy(() => JoinedFrom$outboundSchema).optional(),
});

export function membershipToJSON(membership: Membership): string {
  return JSON.stringify(Membership$outboundSchema.parse(membership));
}
export function membershipFromJSON(
  jsonString: string,
): SafeParseResult<Membership, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Membership$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Membership' from JSON`,
  );
}

/** @internal */
export const Team$inboundSchema: z.ZodType<Team, z.ZodTypeDef, unknown> =
  collectExtraKeys$(
    z.object({
      connect: types.optional(z.lazy(() => Connect$inboundSchema)),
      creatorId: types.string(),
      updatedAt: types.number(),
      emailDomain: z.nullable(types.string()).optional(),
      saml: types.optional(z.lazy(() => Saml$inboundSchema)),
      inviteCode: types.optional(types.string()),
      description: types.nullable(types.string()),
      defaultRoles: types.optional(z.lazy(() => DefaultRoles$inboundSchema)),
      stagingPrefix: types.string(),
      resourceConfig: types.optional(
        z.lazy(() => ResourceConfig$inboundSchema),
      ),
      previewDeploymentSuffix: z.nullable(types.string()).optional(),
      platform: types.optional(types.boolean()),
      disableHardAutoBlocks: types.optional(
        smartUnion([types.number(), types.boolean()]),
      ),
      remoteCaching: types.optional(z.lazy(() => RemoteCaching$inboundSchema)),
      defaultDeploymentProtection: types.optional(
        z.lazy(() => DefaultDeploymentProtection$inboundSchema),
      ),
      defaultExpirationSettings: types.optional(
        z.lazy(() => DefaultExpirationSettings$inboundSchema),
      ),
      enablePreviewFeedback: z.nullable(EnablePreviewFeedback$inboundSchema)
        .optional(),
      enableProductionFeedback: z.nullable(
        EnableProductionFeedback$inboundSchema,
      ).optional(),
      sensitiveEnvironmentVariablePolicy: z.nullable(
        SensitiveEnvironmentVariablePolicy$inboundSchema,
      ).optional(),
      hideIpAddresses: z.nullable(types.boolean()).optional(),
      hideIpAddressesInLogDrains: z.nullable(types.boolean()).optional(),
      ipBuckets: types.optional(z.array(z.lazy(() => IpBuckets$inboundSchema))),
      strictDeploymentProtectionSettings: types.optional(
        z.lazy(() => StrictDeploymentProtectionSettings$inboundSchema),
      ),
      nsnbConfig: types.optional(z.lazy(() => NsnbConfig$inboundSchema)),
      id: types.string(),
      slug: types.string(),
      name: types.nullable(types.string()),
      avatar: types.nullable(types.string()),
      membership: z.lazy(() => Membership$inboundSchema),
      createdAt: types.number(),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  );
/** @internal */
export type Team$Outbound = {
  connect?: Connect$Outbound | undefined;
  creatorId: string;
  updatedAt: number;
  emailDomain?: string | null | undefined;
  saml?: Saml$Outbound | undefined;
  inviteCode?: string | undefined;
  description: string | null;
  defaultRoles?: DefaultRoles$Outbound | undefined;
  stagingPrefix: string;
  resourceConfig?: ResourceConfig$Outbound | undefined;
  previewDeploymentSuffix?: string | null | undefined;
  platform?: boolean | undefined;
  disableHardAutoBlocks?: number | boolean | undefined;
  remoteCaching?: RemoteCaching$Outbound | undefined;
  defaultDeploymentProtection?:
    | DefaultDeploymentProtection$Outbound
    | undefined;
  defaultExpirationSettings?: DefaultExpirationSettings$Outbound | undefined;
  enablePreviewFeedback?: string | null | undefined;
  enableProductionFeedback?: string | null | undefined;
  sensitiveEnvironmentVariablePolicy?: string | null | undefined;
  hideIpAddresses?: boolean | null | undefined;
  hideIpAddressesInLogDrains?: boolean | null | undefined;
  ipBuckets?: Array<IpBuckets$Outbound> | undefined;
  strictDeploymentProtectionSettings?:
    | StrictDeploymentProtectionSettings$Outbound
    | undefined;
  nsnbConfig?: NsnbConfig$Outbound | undefined;
  id: string;
  slug: string;
  name: string | null;
  avatar: string | null;
  membership: Membership$Outbound;
  createdAt: number;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const Team$outboundSchema: z.ZodType<Team$Outbound, z.ZodTypeDef, Team> =
  z.object({
    connect: z.lazy(() => Connect$outboundSchema).optional(),
    creatorId: z.string(),
    updatedAt: z.number(),
    emailDomain: z.nullable(z.string()).optional(),
    saml: z.lazy(() => Saml$outboundSchema).optional(),
    inviteCode: z.string().optional(),
    description: z.nullable(z.string()),
    defaultRoles: z.lazy(() => DefaultRoles$outboundSchema).optional(),
    stagingPrefix: z.string(),
    resourceConfig: z.lazy(() => ResourceConfig$outboundSchema).optional(),
    previewDeploymentSuffix: z.nullable(z.string()).optional(),
    platform: z.boolean().optional(),
    disableHardAutoBlocks: smartUnion([z.number(), z.boolean()]).optional(),
    remoteCaching: z.lazy(() => RemoteCaching$outboundSchema).optional(),
    defaultDeploymentProtection: z.lazy(() =>
      DefaultDeploymentProtection$outboundSchema
    ).optional(),
    defaultExpirationSettings: z.lazy(() =>
      DefaultExpirationSettings$outboundSchema
    ).optional(),
    enablePreviewFeedback: z.nullable(EnablePreviewFeedback$outboundSchema)
      .optional(),
    enableProductionFeedback: z.nullable(
      EnableProductionFeedback$outboundSchema,
    ).optional(),
    sensitiveEnvironmentVariablePolicy: z.nullable(
      SensitiveEnvironmentVariablePolicy$outboundSchema,
    ).optional(),
    hideIpAddresses: z.nullable(z.boolean()).optional(),
    hideIpAddressesInLogDrains: z.nullable(z.boolean()).optional(),
    ipBuckets: z.array(z.lazy(() => IpBuckets$outboundSchema)).optional(),
    strictDeploymentProtectionSettings: z.lazy(() =>
      StrictDeploymentProtectionSettings$outboundSchema
    ).optional(),
    nsnbConfig: z.lazy(() => NsnbConfig$outboundSchema).optional(),
    id: z.string(),
    slug: z.string(),
    name: z.nullable(z.string()),
    avatar: z.nullable(z.string()),
    membership: z.lazy(() => Membership$outboundSchema),
    createdAt: z.number(),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function teamToJSON(team: Team): string {
  return JSON.stringify(Team$outboundSchema.parse(team));
}
export function teamFromJSON(
  jsonString: string,
): SafeParseResult<Team, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Team$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Team' from JSON`,
  );
}
