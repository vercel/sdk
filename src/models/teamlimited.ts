/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const LimitedBy = {
  Mfa: "mfa",
  Scope: "scope",
} as const;
export type LimitedBy = ClosedEnum<typeof LimitedBy>;

/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export const TeamLimitedSyncState = {
  Setup: "SETUP",
  Active: "ACTIVE",
} as const;
/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export type TeamLimitedSyncState = ClosedEnum<typeof TeamLimitedSyncState>;

/**
 * Information for the SAML Single Sign-On configuration.
 */
export type TeamLimitedConnection = {
  /**
   * The Identity Provider "type", for example Okta.
   */
  type: string;
  /**
   * Current status of the connection.
   */
  status: string;
  /**
   * Current state of the connection.
   */
  state: string;
  /**
   * Timestamp (in milliseconds) of when the configuration was connected.
   */
  connectedAt: number;
  /**
   * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
   */
  lastReceivedWebhookEvent?: number | undefined;
  /**
   * Timestamp (in milliseconds) of when the last directory sync was performed.
   */
  lastSyncedAt?: number | undefined;
  /**
   * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
   */
  syncState?: TeamLimitedSyncState | undefined;
};

/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export const TeamLimitedSamlSyncState = {
  Setup: "SETUP",
  Active: "ACTIVE",
} as const;
/**
 * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
 */
export type TeamLimitedSamlSyncState = ClosedEnum<
  typeof TeamLimitedSamlSyncState
>;

/**
 * Information for the Directory Sync configuration.
 */
export type TeamLimitedDirectory = {
  /**
   * The Identity Provider "type", for example Okta.
   */
  type: string;
  /**
   * Current state of the connection.
   */
  state: string;
  /**
   * Timestamp (in milliseconds) of when the configuration was connected.
   */
  connectedAt: number;
  /**
   * Timestamp (in milliseconds) of when the last webhook event was received from WorkOS.
   */
  lastReceivedWebhookEvent?: number | undefined;
  /**
   * Timestamp (in milliseconds) of when the last directory sync was performed.
   */
  lastSyncedAt?: number | undefined;
  /**
   * Controls whether directory sync events are processed. - 'SETUP': Directory connected but role mappings not yet configured. Events are acknowledged but not processed. - 'ACTIVE': Fully configured. Events are processed normally. - undefined: Legacy directory (pre-feature), treat as 'ACTIVE' for backwards compatibility.
   */
  syncState?: TeamLimitedSamlSyncState | undefined;
};

/**
 * When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
 */
export type TeamLimitedSaml = {
  /**
   * Information for the SAML Single Sign-On configuration.
   */
  connection?: TeamLimitedConnection | undefined;
  /**
   * Information for the Directory Sync configuration.
   */
  directory?: TeamLimitedDirectory | undefined;
  /**
   * When `true`, interactions with the Team **must** be done with an authentication token that has been authenticated with the Team's SAML Single Sign-On provider.
   */
  enforced: boolean;
};

export type TeamLimitedEntitlements = {
  entitlement: string;
};

export const TeamLimitedRole = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type TeamLimitedRole = ClosedEnum<typeof TeamLimitedRole>;

export const TeamLimitedTeamRoles = {
  Owner: "OWNER",
  Member: "MEMBER",
  Developer: "DEVELOPER",
  Security: "SECURITY",
  Billing: "BILLING",
  Viewer: "VIEWER",
  ViewerForPlus: "VIEWER_FOR_PLUS",
  Contributor: "CONTRIBUTOR",
} as const;
export type TeamLimitedTeamRoles = ClosedEnum<typeof TeamLimitedTeamRoles>;

export const TeamLimitedTeamPermissions = {
  IntegrationManager: "IntegrationManager",
  CreateProject: "CreateProject",
  FullProductionDeployment: "FullProductionDeployment",
  UsageViewer: "UsageViewer",
  EnvVariableManager: "EnvVariableManager",
  EnvironmentManager: "EnvironmentManager",
  V0Builder: "V0Builder",
  V0Chatter: "V0Chatter",
  V0Viewer: "V0Viewer",
} as const;
export type TeamLimitedTeamPermissions = ClosedEnum<
  typeof TeamLimitedTeamPermissions
>;

export const TeamLimitedOrigin = {
  Link: "link",
  Saml: "saml",
  Mail: "mail",
  Import: "import",
  Teams: "teams",
  Github: "github",
  Gitlab: "gitlab",
  Bitbucket: "bitbucket",
  Dsync: "dsync",
  Feedback: "feedback",
  OrganizationTeams: "organization-teams",
  NsnbAutoApprove: "nsnb-auto-approve",
  NsnbRequestAccess: "nsnb-request-access",
  NsnbViewerUpgrade: "nsnb-viewer-upgrade",
  NsnbInvite: "nsnb-invite",
  NsnbRedeploy: "nsnb-redeploy",
} as const;
export type TeamLimitedOrigin = ClosedEnum<typeof TeamLimitedOrigin>;

export type TeamLimitedGitUserId = string | number;

export type TeamLimitedJoinedFrom = {
  origin: TeamLimitedOrigin;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

/**
 * The membership of the authenticated User in relation to the Team.
 */
export type TeamLimitedMembership = {
  uid?: string | undefined;
  entitlements?: Array<TeamLimitedEntitlements> | undefined;
  teamId?: string | undefined;
  confirmed: boolean;
  accessRequestedAt?: number | undefined;
  role: TeamLimitedRole;
  teamRoles?: Array<TeamLimitedTeamRoles> | undefined;
  teamPermissions?: Array<TeamLimitedTeamPermissions> | undefined;
  createdAt: number;
  created: number;
  joinedFrom?: TeamLimitedJoinedFrom | undefined;
};

/**
 * A limited form of data representing a Team, due to the authentication token missing privileges to read the full Team data.
 */
export type TeamLimited = {
  /**
   * Property indicating that this Team data contains only limited information, due to the authentication token missing privileges to read the full Team data or due to team having MFA enforced and the user not having MFA enabled. Re-login with the Team's configured SAML Single Sign-On provider in order to upgrade the authentication token with the necessary privileges.
   */
  limited: boolean;
  limitedBy: Array<LimitedBy>;
  /**
   * When "Single Sign-On (SAML)" is configured, this object contains information that allows the client-side to identify whether or not this Team has SAML enforced.
   */
  saml?: TeamLimitedSaml | undefined;
  /**
   * The Team's unique identifier.
   */
  id: string;
  /**
   * The Team's slug, which is unique across the Vercel platform.
   */
  slug: string;
  /**
   * Name associated with the Team account, or `null` if none has been provided.
   */
  name: string | null;
  /**
   * The ID of the file used as avatar for this Team.
   */
  avatar: string | null;
  /**
   * The membership of the authenticated User in relation to the Team.
   */
  membership: TeamLimitedMembership;
  /**
   * UNIX timestamp (in milliseconds) when the Team was created.
   */
  createdAt: number;
};

/** @internal */
export const LimitedBy$inboundSchema: z.ZodNativeEnum<typeof LimitedBy> = z
  .nativeEnum(LimitedBy);
/** @internal */
export const LimitedBy$outboundSchema: z.ZodNativeEnum<typeof LimitedBy> =
  LimitedBy$inboundSchema;

/** @internal */
export const TeamLimitedSyncState$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedSyncState
> = z.nativeEnum(TeamLimitedSyncState);
/** @internal */
export const TeamLimitedSyncState$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedSyncState
> = TeamLimitedSyncState$inboundSchema;

/** @internal */
export const TeamLimitedConnection$inboundSchema: z.ZodType<
  TeamLimitedConnection,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.string(),
  status: types.string(),
  state: types.string(),
  connectedAt: types.number(),
  lastReceivedWebhookEvent: types.optional(types.number()),
  lastSyncedAt: types.optional(types.number()),
  syncState: types.optional(TeamLimitedSyncState$inboundSchema),
});
/** @internal */
export type TeamLimitedConnection$Outbound = {
  type: string;
  status: string;
  state: string;
  connectedAt: number;
  lastReceivedWebhookEvent?: number | undefined;
  lastSyncedAt?: number | undefined;
  syncState?: string | undefined;
};

/** @internal */
export const TeamLimitedConnection$outboundSchema: z.ZodType<
  TeamLimitedConnection$Outbound,
  z.ZodTypeDef,
  TeamLimitedConnection
> = z.object({
  type: z.string(),
  status: z.string(),
  state: z.string(),
  connectedAt: z.number(),
  lastReceivedWebhookEvent: z.number().optional(),
  lastSyncedAt: z.number().optional(),
  syncState: TeamLimitedSyncState$outboundSchema.optional(),
});

export function teamLimitedConnectionToJSON(
  teamLimitedConnection: TeamLimitedConnection,
): string {
  return JSON.stringify(
    TeamLimitedConnection$outboundSchema.parse(teamLimitedConnection),
  );
}
export function teamLimitedConnectionFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedConnection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedConnection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedConnection' from JSON`,
  );
}

/** @internal */
export const TeamLimitedSamlSyncState$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedSamlSyncState
> = z.nativeEnum(TeamLimitedSamlSyncState);
/** @internal */
export const TeamLimitedSamlSyncState$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedSamlSyncState
> = TeamLimitedSamlSyncState$inboundSchema;

/** @internal */
export const TeamLimitedDirectory$inboundSchema: z.ZodType<
  TeamLimitedDirectory,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.string(),
  state: types.string(),
  connectedAt: types.number(),
  lastReceivedWebhookEvent: types.optional(types.number()),
  lastSyncedAt: types.optional(types.number()),
  syncState: types.optional(TeamLimitedSamlSyncState$inboundSchema),
});
/** @internal */
export type TeamLimitedDirectory$Outbound = {
  type: string;
  state: string;
  connectedAt: number;
  lastReceivedWebhookEvent?: number | undefined;
  lastSyncedAt?: number | undefined;
  syncState?: string | undefined;
};

/** @internal */
export const TeamLimitedDirectory$outboundSchema: z.ZodType<
  TeamLimitedDirectory$Outbound,
  z.ZodTypeDef,
  TeamLimitedDirectory
> = z.object({
  type: z.string(),
  state: z.string(),
  connectedAt: z.number(),
  lastReceivedWebhookEvent: z.number().optional(),
  lastSyncedAt: z.number().optional(),
  syncState: TeamLimitedSamlSyncState$outboundSchema.optional(),
});

export function teamLimitedDirectoryToJSON(
  teamLimitedDirectory: TeamLimitedDirectory,
): string {
  return JSON.stringify(
    TeamLimitedDirectory$outboundSchema.parse(teamLimitedDirectory),
  );
}
export function teamLimitedDirectoryFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedDirectory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedDirectory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedDirectory' from JSON`,
  );
}

/** @internal */
export const TeamLimitedSaml$inboundSchema: z.ZodType<
  TeamLimitedSaml,
  z.ZodTypeDef,
  unknown
> = z.object({
  connection: types.optional(z.lazy(() => TeamLimitedConnection$inboundSchema)),
  directory: types.optional(z.lazy(() => TeamLimitedDirectory$inboundSchema)),
  enforced: types.boolean(),
});
/** @internal */
export type TeamLimitedSaml$Outbound = {
  connection?: TeamLimitedConnection$Outbound | undefined;
  directory?: TeamLimitedDirectory$Outbound | undefined;
  enforced: boolean;
};

/** @internal */
export const TeamLimitedSaml$outboundSchema: z.ZodType<
  TeamLimitedSaml$Outbound,
  z.ZodTypeDef,
  TeamLimitedSaml
> = z.object({
  connection: z.lazy(() => TeamLimitedConnection$outboundSchema).optional(),
  directory: z.lazy(() => TeamLimitedDirectory$outboundSchema).optional(),
  enforced: z.boolean(),
});

export function teamLimitedSamlToJSON(
  teamLimitedSaml: TeamLimitedSaml,
): string {
  return JSON.stringify(TeamLimitedSaml$outboundSchema.parse(teamLimitedSaml));
}
export function teamLimitedSamlFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedSaml, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedSaml$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedSaml' from JSON`,
  );
}

/** @internal */
export const TeamLimitedEntitlements$inboundSchema: z.ZodType<
  TeamLimitedEntitlements,
  z.ZodTypeDef,
  unknown
> = z.object({
  entitlement: types.string(),
});
/** @internal */
export type TeamLimitedEntitlements$Outbound = {
  entitlement: string;
};

/** @internal */
export const TeamLimitedEntitlements$outboundSchema: z.ZodType<
  TeamLimitedEntitlements$Outbound,
  z.ZodTypeDef,
  TeamLimitedEntitlements
> = z.object({
  entitlement: z.string(),
});

export function teamLimitedEntitlementsToJSON(
  teamLimitedEntitlements: TeamLimitedEntitlements,
): string {
  return JSON.stringify(
    TeamLimitedEntitlements$outboundSchema.parse(teamLimitedEntitlements),
  );
}
export function teamLimitedEntitlementsFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedEntitlements, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedEntitlements$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedEntitlements' from JSON`,
  );
}

/** @internal */
export const TeamLimitedRole$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedRole
> = z.nativeEnum(TeamLimitedRole);
/** @internal */
export const TeamLimitedRole$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedRole
> = TeamLimitedRole$inboundSchema;

/** @internal */
export const TeamLimitedTeamRoles$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedTeamRoles
> = z.nativeEnum(TeamLimitedTeamRoles);
/** @internal */
export const TeamLimitedTeamRoles$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedTeamRoles
> = TeamLimitedTeamRoles$inboundSchema;

/** @internal */
export const TeamLimitedTeamPermissions$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedTeamPermissions
> = z.nativeEnum(TeamLimitedTeamPermissions);
/** @internal */
export const TeamLimitedTeamPermissions$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedTeamPermissions
> = TeamLimitedTeamPermissions$inboundSchema;

/** @internal */
export const TeamLimitedOrigin$inboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedOrigin
> = z.nativeEnum(TeamLimitedOrigin);
/** @internal */
export const TeamLimitedOrigin$outboundSchema: z.ZodNativeEnum<
  typeof TeamLimitedOrigin
> = TeamLimitedOrigin$inboundSchema;

/** @internal */
export const TeamLimitedGitUserId$inboundSchema: z.ZodType<
  TeamLimitedGitUserId,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number()]);
/** @internal */
export type TeamLimitedGitUserId$Outbound = string | number;

/** @internal */
export const TeamLimitedGitUserId$outboundSchema: z.ZodType<
  TeamLimitedGitUserId$Outbound,
  z.ZodTypeDef,
  TeamLimitedGitUserId
> = smartUnion([z.string(), z.number()]);

export function teamLimitedGitUserIdToJSON(
  teamLimitedGitUserId: TeamLimitedGitUserId,
): string {
  return JSON.stringify(
    TeamLimitedGitUserId$outboundSchema.parse(teamLimitedGitUserId),
  );
}
export function teamLimitedGitUserIdFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedGitUserId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedGitUserId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedGitUserId' from JSON`,
  );
}

/** @internal */
export const TeamLimitedJoinedFrom$inboundSchema: z.ZodType<
  TeamLimitedJoinedFrom,
  z.ZodTypeDef,
  unknown
> = z.object({
  origin: TeamLimitedOrigin$inboundSchema,
  commitId: types.optional(types.string()),
  repoId: types.optional(types.string()),
  repoPath: types.optional(types.string()),
  gitUserId: types.optional(smartUnion([types.string(), types.number()])),
  gitUserLogin: types.optional(types.string()),
  ssoUserId: types.optional(types.string()),
  ssoConnectedAt: types.optional(types.number()),
  idpUserId: types.optional(types.string()),
  dsyncUserId: types.optional(types.string()),
  dsyncConnectedAt: types.optional(types.number()),
});
/** @internal */
export type TeamLimitedJoinedFrom$Outbound = {
  origin: string;
  commitId?: string | undefined;
  repoId?: string | undefined;
  repoPath?: string | undefined;
  gitUserId?: string | number | undefined;
  gitUserLogin?: string | undefined;
  ssoUserId?: string | undefined;
  ssoConnectedAt?: number | undefined;
  idpUserId?: string | undefined;
  dsyncUserId?: string | undefined;
  dsyncConnectedAt?: number | undefined;
};

/** @internal */
export const TeamLimitedJoinedFrom$outboundSchema: z.ZodType<
  TeamLimitedJoinedFrom$Outbound,
  z.ZodTypeDef,
  TeamLimitedJoinedFrom
> = z.object({
  origin: TeamLimitedOrigin$outboundSchema,
  commitId: z.string().optional(),
  repoId: z.string().optional(),
  repoPath: z.string().optional(),
  gitUserId: smartUnion([z.string(), z.number()]).optional(),
  gitUserLogin: z.string().optional(),
  ssoUserId: z.string().optional(),
  ssoConnectedAt: z.number().optional(),
  idpUserId: z.string().optional(),
  dsyncUserId: z.string().optional(),
  dsyncConnectedAt: z.number().optional(),
});

export function teamLimitedJoinedFromToJSON(
  teamLimitedJoinedFrom: TeamLimitedJoinedFrom,
): string {
  return JSON.stringify(
    TeamLimitedJoinedFrom$outboundSchema.parse(teamLimitedJoinedFrom),
  );
}
export function teamLimitedJoinedFromFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedJoinedFrom, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedJoinedFrom$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedJoinedFrom' from JSON`,
  );
}

/** @internal */
export const TeamLimitedMembership$inboundSchema: z.ZodType<
  TeamLimitedMembership,
  z.ZodTypeDef,
  unknown
> = z.object({
  uid: types.optional(types.string()),
  entitlements: types.optional(
    z.array(z.lazy(() => TeamLimitedEntitlements$inboundSchema)),
  ),
  teamId: types.optional(types.string()),
  confirmed: types.boolean(),
  accessRequestedAt: types.optional(types.number()),
  role: TeamLimitedRole$inboundSchema,
  teamRoles: types.optional(z.array(TeamLimitedTeamRoles$inboundSchema)),
  teamPermissions: types.optional(
    z.array(TeamLimitedTeamPermissions$inboundSchema),
  ),
  createdAt: types.number(),
  created: types.number(),
  joinedFrom: types.optional(z.lazy(() => TeamLimitedJoinedFrom$inboundSchema)),
});
/** @internal */
export type TeamLimitedMembership$Outbound = {
  uid?: string | undefined;
  entitlements?: Array<TeamLimitedEntitlements$Outbound> | undefined;
  teamId?: string | undefined;
  confirmed: boolean;
  accessRequestedAt?: number | undefined;
  role: string;
  teamRoles?: Array<string> | undefined;
  teamPermissions?: Array<string> | undefined;
  createdAt: number;
  created: number;
  joinedFrom?: TeamLimitedJoinedFrom$Outbound | undefined;
};

/** @internal */
export const TeamLimitedMembership$outboundSchema: z.ZodType<
  TeamLimitedMembership$Outbound,
  z.ZodTypeDef,
  TeamLimitedMembership
> = z.object({
  uid: z.string().optional(),
  entitlements: z.array(z.lazy(() => TeamLimitedEntitlements$outboundSchema))
    .optional(),
  teamId: z.string().optional(),
  confirmed: z.boolean(),
  accessRequestedAt: z.number().optional(),
  role: TeamLimitedRole$outboundSchema,
  teamRoles: z.array(TeamLimitedTeamRoles$outboundSchema).optional(),
  teamPermissions: z.array(TeamLimitedTeamPermissions$outboundSchema)
    .optional(),
  createdAt: z.number(),
  created: z.number(),
  joinedFrom: z.lazy(() => TeamLimitedJoinedFrom$outboundSchema).optional(),
});

export function teamLimitedMembershipToJSON(
  teamLimitedMembership: TeamLimitedMembership,
): string {
  return JSON.stringify(
    TeamLimitedMembership$outboundSchema.parse(teamLimitedMembership),
  );
}
export function teamLimitedMembershipFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimitedMembership, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimitedMembership$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimitedMembership' from JSON`,
  );
}

/** @internal */
export const TeamLimited$inboundSchema: z.ZodType<
  TeamLimited,
  z.ZodTypeDef,
  unknown
> = z.object({
  limited: types.boolean(),
  limitedBy: z.array(LimitedBy$inboundSchema),
  saml: types.optional(z.lazy(() => TeamLimitedSaml$inboundSchema)),
  id: types.string(),
  slug: types.string(),
  name: types.nullable(types.string()),
  avatar: types.nullable(types.string()),
  membership: z.lazy(() => TeamLimitedMembership$inboundSchema),
  createdAt: types.number(),
});
/** @internal */
export type TeamLimited$Outbound = {
  limited: boolean;
  limitedBy: Array<string>;
  saml?: TeamLimitedSaml$Outbound | undefined;
  id: string;
  slug: string;
  name: string | null;
  avatar: string | null;
  membership: TeamLimitedMembership$Outbound;
  createdAt: number;
};

/** @internal */
export const TeamLimited$outboundSchema: z.ZodType<
  TeamLimited$Outbound,
  z.ZodTypeDef,
  TeamLimited
> = z.object({
  limited: z.boolean(),
  limitedBy: z.array(LimitedBy$outboundSchema),
  saml: z.lazy(() => TeamLimitedSaml$outboundSchema).optional(),
  id: z.string(),
  slug: z.string(),
  name: z.nullable(z.string()),
  avatar: z.nullable(z.string()),
  membership: z.lazy(() => TeamLimitedMembership$outboundSchema),
  createdAt: z.number(),
});

export function teamLimitedToJSON(teamLimited: TeamLimited): string {
  return JSON.stringify(TeamLimited$outboundSchema.parse(teamLimited));
}
export function teamLimitedFromJSON(
  jsonString: string,
): SafeParseResult<TeamLimited, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamLimited$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamLimited' from JSON`,
  );
}
