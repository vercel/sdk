/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type UpdateFlagValue = string | number | boolean;

export type UpdateFlagVariants = {
  /**
   * The id of the variant
   */
  id: string;
  /**
   * A label for the variant
   */
  label?: string | undefined;
  /**
   * A description of the variant
   */
  description?: string | undefined;
  value: string | number | boolean;
};

/**
 * Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
 */
export type UpdateFlagReuse = {
  /**
   * Whether the reuse is active or not
   */
  active: boolean;
  /**
   * The environment to link to
   */
  environment: string;
};

export type UpdateFlagTargets = {
  note?: string | undefined;
  value: string;
};

export type UpdateFlagPausedOutcome = {
  type?: any | undefined;
  variantId: string;
};

export type UpdateFlagLhs2 = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

export type UpdateFlagLhs1 = {
  type?: any | undefined;
};

export type UpdateFlagLhs = UpdateFlagLhs2 | UpdateFlagLhs1;

export const UpdateFlagCmp = {
  Eq: "eq",
  NotEq: "!eq",
  OneOf: "oneOf",
  NotOneOf: "!oneOf",
  ContainsAllOf: "containsAllOf",
  ContainsAnyOf: "containsAnyOf",
  ContainsNoneOf: "containsNoneOf",
  StartsWith: "startsWith",
  NotStartsWith: "!startsWith",
  EndsWith: "endsWith",
  NotEndsWith: "!endsWith",
  Ex: "ex",
  NotEx: "!ex",
  Gt: "gt",
  Gte: "gte",
  Lt: "lt",
  Lte: "lte",
  Regex: "regex",
  NotRegex: "!regex",
  Before: "before",
  After: "after",
} as const;
export type UpdateFlagCmp = ClosedEnum<typeof UpdateFlagCmp>;

export type UpdateFlagRhs2 = {
  type?: any | undefined;
  pattern: string;
  flags: string;
};

export const UpdateFlagRhsType = {
  ListInline: "list/inline",
  List: "list",
} as const;
export type UpdateFlagRhsType = ClosedEnum<typeof UpdateFlagRhsType>;

export type UpdateFlagItems2 = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

export type UpdateFlagItems1 = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

export type UpdateFlagRhsItems = UpdateFlagItems1 | UpdateFlagItems2;

export type UpdateFlagRhs1 = {
  type: UpdateFlagRhsType;
  items: Array<UpdateFlagItems1 | UpdateFlagItems2>;
};

export type UpdateFlagRhs =
  | UpdateFlagRhs2
  | UpdateFlagRhs1
  | string
  | number
  | boolean;

export type UpdateFlagConditions = {
  lhs: UpdateFlagLhs2 | UpdateFlagLhs1;
  cmp: UpdateFlagCmp;
  rhs?: UpdateFlagRhs2 | UpdateFlagRhs1 | string | number | boolean | undefined;
};

export type UpdateFlagOutcomeBase = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

export type UpdateFlagOutcome2 = {
  type?: any | undefined;
  base: UpdateFlagOutcomeBase;
  /**
   * The distribution for each variant
   */
  weights: { [k: string]: number };
  /**
   * This variant will be used when the base attribute does not exist
   */
  defaultVariantId: string;
};

export type UpdateFlagOutcome1 = {
  type?: any | undefined;
  variantId: string;
};

export type UpdateFlagOutcome = UpdateFlagOutcome2 | UpdateFlagOutcome1;

export type UpdateFlagRules = {
  id: string;
  conditions: Array<UpdateFlagConditions>;
  outcome: UpdateFlagOutcome2 | UpdateFlagOutcome1;
};

export type UpdateFlagFallthroughBase = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

export type UpdateFlagFallthrough2 = {
  type?: any | undefined;
  base: UpdateFlagFallthroughBase;
  /**
   * The distribution for each variant
   */
  weights: { [k: string]: number };
  /**
   * This variant will be used when the base attribute does not exist
   */
  defaultVariantId: string;
};

export type UpdateFlagFallthrough1 = {
  type?: any | undefined;
  variantId: string;
};

export type UpdateFlagFallthrough =
  | UpdateFlagFallthrough2
  | UpdateFlagFallthrough1;

export type UpdateFlagEnvironments = {
  active: boolean;
  /**
   * Allows linking this environment to another environment so this flag will be evaluated with the other flag's configuration
   */
  reuse?: UpdateFlagReuse | undefined;
  /**
   * Allows assigning targets to variants while bypassing the flag's rules
   */
  targets?: {
    [k: string]: { [k: string]: { [k: string]: Array<UpdateFlagTargets> } };
  } | undefined;
  pausedOutcome: UpdateFlagPausedOutcome;
  rules: Array<UpdateFlagRules>;
  fallthrough: UpdateFlagFallthrough2 | UpdateFlagFallthrough1;
  /**
   * The revision of the environment config
   */
  revision?: number | undefined;
};

export const UpdateFlagState = {
  Active: "active",
  Archived: "archived",
} as const;
export type UpdateFlagState = ClosedEnum<typeof UpdateFlagState>;

export type UpdateFlagRequestBody = {
  /**
   * The user who created this patch
   */
  createdBy?: string | undefined;
  /**
   * Additional message for this version
   */
  message?: string | undefined;
  /**
   * The variants of the flag
   */
  variants?: Array<UpdateFlagVariants> | undefined;
  /**
   * The configuration for the flag in different environments
   */
  environments?: { [k: string]: UpdateFlagEnvironments } | undefined;
  /**
   * A random seed to prevent split points in different flags from having the same targets
   */
  seed?: number | undefined;
  /**
   * A description of the flag
   */
  description?: string | undefined;
  state?: UpdateFlagState | undefined;
};

export type UpdateFlagRequest = {
  /**
   * The project id or name
   */
  projectIdOrName: string;
  /**
   * The flag id or name
   */
  flagIdOrSlug: string;
  /**
   * Etag to match, can be used interchangeably with the `if-match` header
   */
  ifMatch?: string | undefined;
  /**
   * Whether to include metadata in the response
   */
  withMetadata?: boolean | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: UpdateFlagRequestBody | undefined;
};

/** @internal */
export const UpdateFlagValue$inboundSchema: z.ZodType<
  UpdateFlagValue,
  z.ZodTypeDef,
  unknown
> = smartUnion([types.string(), types.number(), types.boolean()]);
/** @internal */
export type UpdateFlagValue$Outbound = string | number | boolean;

/** @internal */
export const UpdateFlagValue$outboundSchema: z.ZodType<
  UpdateFlagValue$Outbound,
  z.ZodTypeDef,
  UpdateFlagValue
> = smartUnion([z.string(), z.number(), z.boolean()]);

export function updateFlagValueToJSON(
  updateFlagValue: UpdateFlagValue,
): string {
  return JSON.stringify(UpdateFlagValue$outboundSchema.parse(updateFlagValue));
}
export function updateFlagValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagValue' from JSON`,
  );
}

/** @internal */
export const UpdateFlagVariants$inboundSchema: z.ZodType<
  UpdateFlagVariants,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  label: types.optional(types.string()),
  description: types.optional(types.string()),
  value: smartUnion([types.string(), types.number(), types.boolean()]),
});
/** @internal */
export type UpdateFlagVariants$Outbound = {
  id: string;
  label?: string | undefined;
  description?: string | undefined;
  value: string | number | boolean;
};

/** @internal */
export const UpdateFlagVariants$outboundSchema: z.ZodType<
  UpdateFlagVariants$Outbound,
  z.ZodTypeDef,
  UpdateFlagVariants
> = z.object({
  id: z.string(),
  label: z.string().optional(),
  description: z.string().optional(),
  value: smartUnion([z.string(), z.number(), z.boolean()]),
});

export function updateFlagVariantsToJSON(
  updateFlagVariants: UpdateFlagVariants,
): string {
  return JSON.stringify(
    UpdateFlagVariants$outboundSchema.parse(updateFlagVariants),
  );
}
export function updateFlagVariantsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagVariants, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagVariants$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagVariants' from JSON`,
  );
}

/** @internal */
export const UpdateFlagReuse$inboundSchema: z.ZodType<
  UpdateFlagReuse,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: types.boolean(),
  environment: types.string(),
});
/** @internal */
export type UpdateFlagReuse$Outbound = {
  active: boolean;
  environment: string;
};

/** @internal */
export const UpdateFlagReuse$outboundSchema: z.ZodType<
  UpdateFlagReuse$Outbound,
  z.ZodTypeDef,
  UpdateFlagReuse
> = z.object({
  active: z.boolean(),
  environment: z.string(),
});

export function updateFlagReuseToJSON(
  updateFlagReuse: UpdateFlagReuse,
): string {
  return JSON.stringify(UpdateFlagReuse$outboundSchema.parse(updateFlagReuse));
}
export function updateFlagReuseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagReuse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagReuse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagReuse' from JSON`,
  );
}

/** @internal */
export const UpdateFlagTargets$inboundSchema: z.ZodType<
  UpdateFlagTargets,
  z.ZodTypeDef,
  unknown
> = z.object({
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagTargets$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagTargets$outboundSchema: z.ZodType<
  UpdateFlagTargets$Outbound,
  z.ZodTypeDef,
  UpdateFlagTargets
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagTargetsToJSON(
  updateFlagTargets: UpdateFlagTargets,
): string {
  return JSON.stringify(
    UpdateFlagTargets$outboundSchema.parse(updateFlagTargets),
  );
}
export function updateFlagTargetsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagTargets, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagTargets$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagTargets' from JSON`,
  );
}

/** @internal */
export const UpdateFlagPausedOutcome$inboundSchema: z.ZodType<
  UpdateFlagPausedOutcome,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  variantId: types.string(),
});
/** @internal */
export type UpdateFlagPausedOutcome$Outbound = {
  type?: any | undefined;
  variantId: string;
};

/** @internal */
export const UpdateFlagPausedOutcome$outboundSchema: z.ZodType<
  UpdateFlagPausedOutcome$Outbound,
  z.ZodTypeDef,
  UpdateFlagPausedOutcome
> = z.object({
  type: z.any().optional(),
  variantId: z.string(),
});

export function updateFlagPausedOutcomeToJSON(
  updateFlagPausedOutcome: UpdateFlagPausedOutcome,
): string {
  return JSON.stringify(
    UpdateFlagPausedOutcome$outboundSchema.parse(updateFlagPausedOutcome),
  );
}
export function updateFlagPausedOutcomeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagPausedOutcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagPausedOutcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagPausedOutcome' from JSON`,
  );
}

/** @internal */
export const UpdateFlagLhs2$inboundSchema: z.ZodType<
  UpdateFlagLhs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type UpdateFlagLhs2$Outbound = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

/** @internal */
export const UpdateFlagLhs2$outboundSchema: z.ZodType<
  UpdateFlagLhs2$Outbound,
  z.ZodTypeDef,
  UpdateFlagLhs2
> = z.object({
  type: z.any().optional(),
  kind: z.string(),
  attribute: z.string(),
});

export function updateFlagLhs2ToJSON(updateFlagLhs2: UpdateFlagLhs2): string {
  return JSON.stringify(UpdateFlagLhs2$outboundSchema.parse(updateFlagLhs2));
}
export function updateFlagLhs2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagLhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagLhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagLhs2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagLhs1$inboundSchema: z.ZodType<
  UpdateFlagLhs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
});
/** @internal */
export type UpdateFlagLhs1$Outbound = {
  type?: any | undefined;
};

/** @internal */
export const UpdateFlagLhs1$outboundSchema: z.ZodType<
  UpdateFlagLhs1$Outbound,
  z.ZodTypeDef,
  UpdateFlagLhs1
> = z.object({
  type: z.any().optional(),
});

export function updateFlagLhs1ToJSON(updateFlagLhs1: UpdateFlagLhs1): string {
  return JSON.stringify(UpdateFlagLhs1$outboundSchema.parse(updateFlagLhs1));
}
export function updateFlagLhs1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagLhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagLhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagLhs1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagLhs$inboundSchema: z.ZodType<
  UpdateFlagLhs,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagLhs2$inboundSchema),
  z.lazy(() => UpdateFlagLhs1$inboundSchema),
]);
/** @internal */
export type UpdateFlagLhs$Outbound =
  | UpdateFlagLhs2$Outbound
  | UpdateFlagLhs1$Outbound;

/** @internal */
export const UpdateFlagLhs$outboundSchema: z.ZodType<
  UpdateFlagLhs$Outbound,
  z.ZodTypeDef,
  UpdateFlagLhs
> = smartUnion([
  z.lazy(() => UpdateFlagLhs2$outboundSchema),
  z.lazy(() => UpdateFlagLhs1$outboundSchema),
]);

export function updateFlagLhsToJSON(updateFlagLhs: UpdateFlagLhs): string {
  return JSON.stringify(UpdateFlagLhs$outboundSchema.parse(updateFlagLhs));
}
export function updateFlagLhsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagLhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagLhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagLhs' from JSON`,
  );
}

/** @internal */
export const UpdateFlagCmp$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagCmp
> = z.nativeEnum(UpdateFlagCmp);
/** @internal */
export const UpdateFlagCmp$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagCmp
> = UpdateFlagCmp$inboundSchema;

/** @internal */
export const UpdateFlagRhs2$inboundSchema: z.ZodType<
  UpdateFlagRhs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  pattern: types.string(),
  flags: types.string(),
});
/** @internal */
export type UpdateFlagRhs2$Outbound = {
  type?: any | undefined;
  pattern: string;
  flags: string;
};

/** @internal */
export const UpdateFlagRhs2$outboundSchema: z.ZodType<
  UpdateFlagRhs2$Outbound,
  z.ZodTypeDef,
  UpdateFlagRhs2
> = z.object({
  type: z.any().optional(),
  pattern: z.string(),
  flags: z.string(),
});

export function updateFlagRhs2ToJSON(updateFlagRhs2: UpdateFlagRhs2): string {
  return JSON.stringify(UpdateFlagRhs2$outboundSchema.parse(updateFlagRhs2));
}
export function updateFlagRhs2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRhs2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRhsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagRhsType
> = z.nativeEnum(UpdateFlagRhsType);
/** @internal */
export const UpdateFlagRhsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagRhsType
> = UpdateFlagRhsType$inboundSchema;

/** @internal */
export const UpdateFlagItems2$inboundSchema: z.ZodType<
  UpdateFlagItems2,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagItems2$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagItems2$outboundSchema: z.ZodType<
  UpdateFlagItems2$Outbound,
  z.ZodTypeDef,
  UpdateFlagItems2
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagItems2ToJSON(
  updateFlagItems2: UpdateFlagItems2,
): string {
  return JSON.stringify(
    UpdateFlagItems2$outboundSchema.parse(updateFlagItems2),
  );
}
export function updateFlagItems2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagItems2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagItems2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagItems2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagItems1$inboundSchema: z.ZodType<
  UpdateFlagItems1,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.number(),
});
/** @internal */
export type UpdateFlagItems1$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

/** @internal */
export const UpdateFlagItems1$outboundSchema: z.ZodType<
  UpdateFlagItems1$Outbound,
  z.ZodTypeDef,
  UpdateFlagItems1
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.number(),
});

export function updateFlagItems1ToJSON(
  updateFlagItems1: UpdateFlagItems1,
): string {
  return JSON.stringify(
    UpdateFlagItems1$outboundSchema.parse(updateFlagItems1),
  );
}
export function updateFlagItems1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagItems1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagItems1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagItems1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRhsItems$inboundSchema: z.ZodType<
  UpdateFlagRhsItems,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagItems1$inboundSchema),
  z.lazy(() => UpdateFlagItems2$inboundSchema),
]);
/** @internal */
export type UpdateFlagRhsItems$Outbound =
  | UpdateFlagItems1$Outbound
  | UpdateFlagItems2$Outbound;

/** @internal */
export const UpdateFlagRhsItems$outboundSchema: z.ZodType<
  UpdateFlagRhsItems$Outbound,
  z.ZodTypeDef,
  UpdateFlagRhsItems
> = smartUnion([
  z.lazy(() => UpdateFlagItems1$outboundSchema),
  z.lazy(() => UpdateFlagItems2$outboundSchema),
]);

export function updateFlagRhsItemsToJSON(
  updateFlagRhsItems: UpdateFlagRhsItems,
): string {
  return JSON.stringify(
    UpdateFlagRhsItems$outboundSchema.parse(updateFlagRhsItems),
  );
}
export function updateFlagRhsItemsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRhsItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRhsItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRhsItems' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRhs1$inboundSchema: z.ZodType<
  UpdateFlagRhs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateFlagRhsType$inboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => UpdateFlagItems1$inboundSchema),
      z.lazy(() => UpdateFlagItems2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type UpdateFlagRhs1$Outbound = {
  type: string;
  items: Array<UpdateFlagItems1$Outbound | UpdateFlagItems2$Outbound>;
};

/** @internal */
export const UpdateFlagRhs1$outboundSchema: z.ZodType<
  UpdateFlagRhs1$Outbound,
  z.ZodTypeDef,
  UpdateFlagRhs1
> = z.object({
  type: UpdateFlagRhsType$outboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => UpdateFlagItems1$outboundSchema),
      z.lazy(() => UpdateFlagItems2$outboundSchema),
    ]),
  ),
});

export function updateFlagRhs1ToJSON(updateFlagRhs1: UpdateFlagRhs1): string {
  return JSON.stringify(UpdateFlagRhs1$outboundSchema.parse(updateFlagRhs1));
}
export function updateFlagRhs1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRhs1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRhs$inboundSchema: z.ZodType<
  UpdateFlagRhs,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagRhs2$inboundSchema),
  z.lazy(() => UpdateFlagRhs1$inboundSchema),
  types.string(),
  types.number(),
  types.boolean(),
]);
/** @internal */
export type UpdateFlagRhs$Outbound =
  | UpdateFlagRhs2$Outbound
  | UpdateFlagRhs1$Outbound
  | string
  | number
  | boolean;

/** @internal */
export const UpdateFlagRhs$outboundSchema: z.ZodType<
  UpdateFlagRhs$Outbound,
  z.ZodTypeDef,
  UpdateFlagRhs
> = smartUnion([
  z.lazy(() => UpdateFlagRhs2$outboundSchema),
  z.lazy(() => UpdateFlagRhs1$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
]);

export function updateFlagRhsToJSON(updateFlagRhs: UpdateFlagRhs): string {
  return JSON.stringify(UpdateFlagRhs$outboundSchema.parse(updateFlagRhs));
}
export function updateFlagRhsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRhs' from JSON`,
  );
}

/** @internal */
export const UpdateFlagConditions$inboundSchema: z.ZodType<
  UpdateFlagConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  lhs: smartUnion([
    z.lazy(() => UpdateFlagLhs2$inboundSchema),
    z.lazy(() => UpdateFlagLhs1$inboundSchema),
  ]),
  cmp: UpdateFlagCmp$inboundSchema,
  rhs: types.optional(
    smartUnion([
      z.lazy(() => UpdateFlagRhs2$inboundSchema),
      z.lazy(() => UpdateFlagRhs1$inboundSchema),
      types.string(),
      types.number(),
      types.boolean(),
    ]),
  ),
});
/** @internal */
export type UpdateFlagConditions$Outbound = {
  lhs: UpdateFlagLhs2$Outbound | UpdateFlagLhs1$Outbound;
  cmp: string;
  rhs?:
    | UpdateFlagRhs2$Outbound
    | UpdateFlagRhs1$Outbound
    | string
    | number
    | boolean
    | undefined;
};

/** @internal */
export const UpdateFlagConditions$outboundSchema: z.ZodType<
  UpdateFlagConditions$Outbound,
  z.ZodTypeDef,
  UpdateFlagConditions
> = z.object({
  lhs: smartUnion([
    z.lazy(() => UpdateFlagLhs2$outboundSchema),
    z.lazy(() => UpdateFlagLhs1$outboundSchema),
  ]),
  cmp: UpdateFlagCmp$outboundSchema,
  rhs: smartUnion([
    z.lazy(() => UpdateFlagRhs2$outboundSchema),
    z.lazy(() => UpdateFlagRhs1$outboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
  ]).optional(),
});

export function updateFlagConditionsToJSON(
  updateFlagConditions: UpdateFlagConditions,
): string {
  return JSON.stringify(
    UpdateFlagConditions$outboundSchema.parse(updateFlagConditions),
  );
}
export function updateFlagConditionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagConditions' from JSON`,
  );
}

/** @internal */
export const UpdateFlagOutcomeBase$inboundSchema: z.ZodType<
  UpdateFlagOutcomeBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type UpdateFlagOutcomeBase$Outbound = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

/** @internal */
export const UpdateFlagOutcomeBase$outboundSchema: z.ZodType<
  UpdateFlagOutcomeBase$Outbound,
  z.ZodTypeDef,
  UpdateFlagOutcomeBase
> = z.object({
  type: z.any().optional(),
  kind: z.string(),
  attribute: z.string(),
});

export function updateFlagOutcomeBaseToJSON(
  updateFlagOutcomeBase: UpdateFlagOutcomeBase,
): string {
  return JSON.stringify(
    UpdateFlagOutcomeBase$outboundSchema.parse(updateFlagOutcomeBase),
  );
}
export function updateFlagOutcomeBaseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagOutcomeBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagOutcomeBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagOutcomeBase' from JSON`,
  );
}

/** @internal */
export const UpdateFlagOutcome2$inboundSchema: z.ZodType<
  UpdateFlagOutcome2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  base: z.lazy(() => UpdateFlagOutcomeBase$inboundSchema),
  weights: z.record(types.number()),
  defaultVariantId: types.string(),
});
/** @internal */
export type UpdateFlagOutcome2$Outbound = {
  type?: any | undefined;
  base: UpdateFlagOutcomeBase$Outbound;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

/** @internal */
export const UpdateFlagOutcome2$outboundSchema: z.ZodType<
  UpdateFlagOutcome2$Outbound,
  z.ZodTypeDef,
  UpdateFlagOutcome2
> = z.object({
  type: z.any().optional(),
  base: z.lazy(() => UpdateFlagOutcomeBase$outboundSchema),
  weights: z.record(z.number()),
  defaultVariantId: z.string(),
});

export function updateFlagOutcome2ToJSON(
  updateFlagOutcome2: UpdateFlagOutcome2,
): string {
  return JSON.stringify(
    UpdateFlagOutcome2$outboundSchema.parse(updateFlagOutcome2),
  );
}
export function updateFlagOutcome2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagOutcome2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagOutcome2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagOutcome2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagOutcome1$inboundSchema: z.ZodType<
  UpdateFlagOutcome1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  variantId: types.string(),
});
/** @internal */
export type UpdateFlagOutcome1$Outbound = {
  type?: any | undefined;
  variantId: string;
};

/** @internal */
export const UpdateFlagOutcome1$outboundSchema: z.ZodType<
  UpdateFlagOutcome1$Outbound,
  z.ZodTypeDef,
  UpdateFlagOutcome1
> = z.object({
  type: z.any().optional(),
  variantId: z.string(),
});

export function updateFlagOutcome1ToJSON(
  updateFlagOutcome1: UpdateFlagOutcome1,
): string {
  return JSON.stringify(
    UpdateFlagOutcome1$outboundSchema.parse(updateFlagOutcome1),
  );
}
export function updateFlagOutcome1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagOutcome1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagOutcome1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagOutcome1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagOutcome$inboundSchema: z.ZodType<
  UpdateFlagOutcome,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagOutcome2$inboundSchema),
  z.lazy(() => UpdateFlagOutcome1$inboundSchema),
]);
/** @internal */
export type UpdateFlagOutcome$Outbound =
  | UpdateFlagOutcome2$Outbound
  | UpdateFlagOutcome1$Outbound;

/** @internal */
export const UpdateFlagOutcome$outboundSchema: z.ZodType<
  UpdateFlagOutcome$Outbound,
  z.ZodTypeDef,
  UpdateFlagOutcome
> = smartUnion([
  z.lazy(() => UpdateFlagOutcome2$outboundSchema),
  z.lazy(() => UpdateFlagOutcome1$outboundSchema),
]);

export function updateFlagOutcomeToJSON(
  updateFlagOutcome: UpdateFlagOutcome,
): string {
  return JSON.stringify(
    UpdateFlagOutcome$outboundSchema.parse(updateFlagOutcome),
  );
}
export function updateFlagOutcomeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagOutcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagOutcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagOutcome' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRules$inboundSchema: z.ZodType<
  UpdateFlagRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  conditions: z.array(z.lazy(() => UpdateFlagConditions$inboundSchema)),
  outcome: smartUnion([
    z.lazy(() => UpdateFlagOutcome2$inboundSchema),
    z.lazy(() => UpdateFlagOutcome1$inboundSchema),
  ]),
});
/** @internal */
export type UpdateFlagRules$Outbound = {
  id: string;
  conditions: Array<UpdateFlagConditions$Outbound>;
  outcome: UpdateFlagOutcome2$Outbound | UpdateFlagOutcome1$Outbound;
};

/** @internal */
export const UpdateFlagRules$outboundSchema: z.ZodType<
  UpdateFlagRules$Outbound,
  z.ZodTypeDef,
  UpdateFlagRules
> = z.object({
  id: z.string(),
  conditions: z.array(z.lazy(() => UpdateFlagConditions$outboundSchema)),
  outcome: smartUnion([
    z.lazy(() => UpdateFlagOutcome2$outboundSchema),
    z.lazy(() => UpdateFlagOutcome1$outboundSchema),
  ]),
});

export function updateFlagRulesToJSON(
  updateFlagRules: UpdateFlagRules,
): string {
  return JSON.stringify(UpdateFlagRules$outboundSchema.parse(updateFlagRules));
}
export function updateFlagRulesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRules' from JSON`,
  );
}

/** @internal */
export const UpdateFlagFallthroughBase$inboundSchema: z.ZodType<
  UpdateFlagFallthroughBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type UpdateFlagFallthroughBase$Outbound = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

/** @internal */
export const UpdateFlagFallthroughBase$outboundSchema: z.ZodType<
  UpdateFlagFallthroughBase$Outbound,
  z.ZodTypeDef,
  UpdateFlagFallthroughBase
> = z.object({
  type: z.any().optional(),
  kind: z.string(),
  attribute: z.string(),
});

export function updateFlagFallthroughBaseToJSON(
  updateFlagFallthroughBase: UpdateFlagFallthroughBase,
): string {
  return JSON.stringify(
    UpdateFlagFallthroughBase$outboundSchema.parse(updateFlagFallthroughBase),
  );
}
export function updateFlagFallthroughBaseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagFallthroughBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagFallthroughBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagFallthroughBase' from JSON`,
  );
}

/** @internal */
export const UpdateFlagFallthrough2$inboundSchema: z.ZodType<
  UpdateFlagFallthrough2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  base: z.lazy(() => UpdateFlagFallthroughBase$inboundSchema),
  weights: z.record(types.number()),
  defaultVariantId: types.string(),
});
/** @internal */
export type UpdateFlagFallthrough2$Outbound = {
  type?: any | undefined;
  base: UpdateFlagFallthroughBase$Outbound;
  weights: { [k: string]: number };
  defaultVariantId: string;
};

/** @internal */
export const UpdateFlagFallthrough2$outboundSchema: z.ZodType<
  UpdateFlagFallthrough2$Outbound,
  z.ZodTypeDef,
  UpdateFlagFallthrough2
> = z.object({
  type: z.any().optional(),
  base: z.lazy(() => UpdateFlagFallthroughBase$outboundSchema),
  weights: z.record(z.number()),
  defaultVariantId: z.string(),
});

export function updateFlagFallthrough2ToJSON(
  updateFlagFallthrough2: UpdateFlagFallthrough2,
): string {
  return JSON.stringify(
    UpdateFlagFallthrough2$outboundSchema.parse(updateFlagFallthrough2),
  );
}
export function updateFlagFallthrough2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagFallthrough2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagFallthrough2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagFallthrough2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagFallthrough1$inboundSchema: z.ZodType<
  UpdateFlagFallthrough1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  variantId: types.string(),
});
/** @internal */
export type UpdateFlagFallthrough1$Outbound = {
  type?: any | undefined;
  variantId: string;
};

/** @internal */
export const UpdateFlagFallthrough1$outboundSchema: z.ZodType<
  UpdateFlagFallthrough1$Outbound,
  z.ZodTypeDef,
  UpdateFlagFallthrough1
> = z.object({
  type: z.any().optional(),
  variantId: z.string(),
});

export function updateFlagFallthrough1ToJSON(
  updateFlagFallthrough1: UpdateFlagFallthrough1,
): string {
  return JSON.stringify(
    UpdateFlagFallthrough1$outboundSchema.parse(updateFlagFallthrough1),
  );
}
export function updateFlagFallthrough1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagFallthrough1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagFallthrough1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagFallthrough1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagFallthrough$inboundSchema: z.ZodType<
  UpdateFlagFallthrough,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagFallthrough2$inboundSchema),
  z.lazy(() => UpdateFlagFallthrough1$inboundSchema),
]);
/** @internal */
export type UpdateFlagFallthrough$Outbound =
  | UpdateFlagFallthrough2$Outbound
  | UpdateFlagFallthrough1$Outbound;

/** @internal */
export const UpdateFlagFallthrough$outboundSchema: z.ZodType<
  UpdateFlagFallthrough$Outbound,
  z.ZodTypeDef,
  UpdateFlagFallthrough
> = smartUnion([
  z.lazy(() => UpdateFlagFallthrough2$outboundSchema),
  z.lazy(() => UpdateFlagFallthrough1$outboundSchema),
]);

export function updateFlagFallthroughToJSON(
  updateFlagFallthrough: UpdateFlagFallthrough,
): string {
  return JSON.stringify(
    UpdateFlagFallthrough$outboundSchema.parse(updateFlagFallthrough),
  );
}
export function updateFlagFallthroughFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagFallthrough, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagFallthrough$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagFallthrough' from JSON`,
  );
}

/** @internal */
export const UpdateFlagEnvironments$inboundSchema: z.ZodType<
  UpdateFlagEnvironments,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: types.boolean(),
  reuse: types.optional(z.lazy(() => UpdateFlagReuse$inboundSchema)),
  targets: types.optional(
    z.record(z.record(z.record(z.array(z.lazy(() =>
      UpdateFlagTargets$inboundSchema
    ))))),
  ),
  pausedOutcome: z.lazy(() => UpdateFlagPausedOutcome$inboundSchema),
  rules: z.array(z.lazy(() => UpdateFlagRules$inboundSchema)),
  fallthrough: smartUnion([
    z.lazy(() => UpdateFlagFallthrough2$inboundSchema),
    z.lazy(() => UpdateFlagFallthrough1$inboundSchema),
  ]),
  revision: types.optional(types.number()),
});
/** @internal */
export type UpdateFlagEnvironments$Outbound = {
  active: boolean;
  reuse?: UpdateFlagReuse$Outbound | undefined;
  targets?: {
    [k: string]: {
      [k: string]: { [k: string]: Array<UpdateFlagTargets$Outbound> };
    };
  } | undefined;
  pausedOutcome: UpdateFlagPausedOutcome$Outbound;
  rules: Array<UpdateFlagRules$Outbound>;
  fallthrough:
    | UpdateFlagFallthrough2$Outbound
    | UpdateFlagFallthrough1$Outbound;
  revision?: number | undefined;
};

/** @internal */
export const UpdateFlagEnvironments$outboundSchema: z.ZodType<
  UpdateFlagEnvironments$Outbound,
  z.ZodTypeDef,
  UpdateFlagEnvironments
> = z.object({
  active: z.boolean(),
  reuse: z.lazy(() => UpdateFlagReuse$outboundSchema).optional(),
  targets: z.record(
    z.record(z.record(z.array(z.lazy(() => UpdateFlagTargets$outboundSchema)))),
  ).optional(),
  pausedOutcome: z.lazy(() => UpdateFlagPausedOutcome$outboundSchema),
  rules: z.array(z.lazy(() => UpdateFlagRules$outboundSchema)),
  fallthrough: smartUnion([
    z.lazy(() => UpdateFlagFallthrough2$outboundSchema),
    z.lazy(() => UpdateFlagFallthrough1$outboundSchema),
  ]),
  revision: z.number().optional(),
});

export function updateFlagEnvironmentsToJSON(
  updateFlagEnvironments: UpdateFlagEnvironments,
): string {
  return JSON.stringify(
    UpdateFlagEnvironments$outboundSchema.parse(updateFlagEnvironments),
  );
}
export function updateFlagEnvironmentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagEnvironments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagEnvironments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagEnvironments' from JSON`,
  );
}

/** @internal */
export const UpdateFlagState$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagState
> = z.nativeEnum(UpdateFlagState);
/** @internal */
export const UpdateFlagState$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagState
> = UpdateFlagState$inboundSchema;

/** @internal */
export const UpdateFlagRequestBody$inboundSchema: z.ZodType<
  UpdateFlagRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdBy: types.optional(types.string()),
  message: types.optional(types.string()),
  variants: types.optional(
    z.array(z.lazy(() => UpdateFlagVariants$inboundSchema)),
  ),
  environments: types.optional(
    z.record(z.lazy(() => UpdateFlagEnvironments$inboundSchema)),
  ),
  seed: types.optional(types.number()),
  description: types.optional(types.string()),
  state: types.optional(UpdateFlagState$inboundSchema),
});
/** @internal */
export type UpdateFlagRequestBody$Outbound = {
  createdBy?: string | undefined;
  message?: string | undefined;
  variants?: Array<UpdateFlagVariants$Outbound> | undefined;
  environments?: { [k: string]: UpdateFlagEnvironments$Outbound } | undefined;
  seed?: number | undefined;
  description?: string | undefined;
  state?: string | undefined;
};

/** @internal */
export const UpdateFlagRequestBody$outboundSchema: z.ZodType<
  UpdateFlagRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateFlagRequestBody
> = z.object({
  createdBy: z.string().optional(),
  message: z.string().optional(),
  variants: z.array(z.lazy(() => UpdateFlagVariants$outboundSchema)).optional(),
  environments: z.record(z.lazy(() => UpdateFlagEnvironments$outboundSchema))
    .optional(),
  seed: z.number().optional(),
  description: z.string().optional(),
  state: UpdateFlagState$outboundSchema.optional(),
});

export function updateFlagRequestBodyToJSON(
  updateFlagRequestBody: UpdateFlagRequestBody,
): string {
  return JSON.stringify(
    UpdateFlagRequestBody$outboundSchema.parse(updateFlagRequestBody),
  );
}
export function updateFlagRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateFlagRequest$inboundSchema: z.ZodType<
  UpdateFlagRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: types.string(),
  flagIdOrSlug: types.string(),
  ifMatch: types.optional(types.string()),
  withMetadata: types.optional(types.boolean()),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: types.optional(
    z.lazy(() => UpdateFlagRequestBody$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateFlagRequest$Outbound = {
  projectIdOrName: string;
  flagIdOrSlug: string;
  ifMatch?: string | undefined;
  withMetadata?: boolean | undefined;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: UpdateFlagRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateFlagRequest$outboundSchema: z.ZodType<
  UpdateFlagRequest$Outbound,
  z.ZodTypeDef,
  UpdateFlagRequest
> = z.object({
  projectIdOrName: z.string(),
  flagIdOrSlug: z.string(),
  ifMatch: z.string().optional(),
  withMetadata: z.boolean().optional(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => UpdateFlagRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateFlagRequestToJSON(
  updateFlagRequest: UpdateFlagRequest,
): string {
  return JSON.stringify(
    UpdateFlagRequest$outboundSchema.parse(updateFlagRequest),
  );
}
export function updateFlagRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagRequest' from JSON`,
  );
}
