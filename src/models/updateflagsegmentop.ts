/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { smartUnion } from "../types/smartUnion.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export const UpdateFlagSegmentAction = {
  Add: "add",
  Remove: "remove",
} as const;
export type UpdateFlagSegmentAction = ClosedEnum<
  typeof UpdateFlagSegmentAction
>;

export const Field = {
  Include: "include",
  Exclude: "exclude",
} as const;
export type Field = ClosedEnum<typeof Field>;

export type UpdateFlagSegmentValue = {
  note?: string | undefined;
  value: string;
};

export type Operations = {
  action: UpdateFlagSegmentAction;
  field: Field;
  entity: string;
  attribute: string;
  value: UpdateFlagSegmentValue;
};

export type UpdateFlagSegmentLhs2 = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

export type UpdateFlagSegmentLhs1 = {
  type?: any | undefined;
};

export type UpdateFlagSegmentLhs =
  | UpdateFlagSegmentLhs2
  | UpdateFlagSegmentLhs1;

export const UpdateFlagSegmentCmp = {
  Eq: "eq",
  NotEq: "!eq",
  OneOf: "oneOf",
  NotOneOf: "!oneOf",
  ContainsAllOf: "containsAllOf",
  ContainsAnyOf: "containsAnyOf",
  ContainsNoneOf: "containsNoneOf",
  StartsWith: "startsWith",
  NotStartsWith: "!startsWith",
  EndsWith: "endsWith",
  NotEndsWith: "!endsWith",
  Ex: "ex",
  NotEx: "!ex",
  Gt: "gt",
  Gte: "gte",
  Lt: "lt",
  Lte: "lte",
  Regex: "regex",
  NotRegex: "!regex",
  Before: "before",
  After: "after",
} as const;
export type UpdateFlagSegmentCmp = ClosedEnum<typeof UpdateFlagSegmentCmp>;

export type UpdateFlagSegmentRhs2 = {
  type?: any | undefined;
  pattern: string;
  flags: string;
};

export const UpdateFlagSegmentRhsType = {
  ListInline: "list/inline",
  List: "list",
} as const;
export type UpdateFlagSegmentRhsType = ClosedEnum<
  typeof UpdateFlagSegmentRhsType
>;

export type UpdateFlagSegmentItems2 = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

export type UpdateFlagSegmentItems1 = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

export type UpdateFlagSegmentRhsItems =
  | UpdateFlagSegmentItems1
  | UpdateFlagSegmentItems2;

export type UpdateFlagSegmentRhs1 = {
  type: UpdateFlagSegmentRhsType;
  items: Array<UpdateFlagSegmentItems1 | UpdateFlagSegmentItems2>;
};

export type UpdateFlagSegmentRhs =
  | UpdateFlagSegmentRhs2
  | UpdateFlagSegmentRhs1
  | string
  | number
  | boolean;

export type UpdateFlagSegmentConditions = {
  lhs: UpdateFlagSegmentLhs2 | UpdateFlagSegmentLhs1;
  cmp: UpdateFlagSegmentCmp;
  rhs?:
    | UpdateFlagSegmentRhs2
    | UpdateFlagSegmentRhs1
    | string
    | number
    | boolean
    | undefined;
};

export type UpdateFlagSegmentOutcomeBase = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

export type UpdateFlagSegmentOutcome2 = {
  type?: any | undefined;
  base: UpdateFlagSegmentOutcomeBase;
  passPromille: number;
};

export type UpdateFlagSegmentOutcome1 = {
  type?: any | undefined;
};

export type UpdateFlagSegmentOutcome =
  | UpdateFlagSegmentOutcome2
  | UpdateFlagSegmentOutcome1;

export type UpdateFlagSegmentRules = {
  id: string;
  conditions: Array<UpdateFlagSegmentConditions>;
  outcome: UpdateFlagSegmentOutcome2 | UpdateFlagSegmentOutcome1;
};

export type UpdateFlagSegmentInclude = {
  note?: string | undefined;
  value: string;
};

export type UpdateFlagSegmentExclude = {
  note?: string | undefined;
  value: string;
};

/**
 * The data of the segment
 */
export type UpdateFlagSegmentData = {
  rules?: Array<UpdateFlagSegmentRules> | undefined;
  include?:
    | { [k: string]: { [k: string]: Array<UpdateFlagSegmentInclude> } }
    | undefined;
  exclude?:
    | { [k: string]: { [k: string]: Array<UpdateFlagSegmentExclude> } }
    | undefined;
};

export type UpdateFlagSegmentRequestBody = {
  operations?: Array<Operations> | undefined;
  label?: string | undefined;
  description?: string | undefined;
  /**
   * The data of the segment
   */
  data?: UpdateFlagSegmentData | undefined;
  hint?: string | undefined;
};

export type UpdateFlagSegmentRequest = {
  /**
   * The project id or name
   */
  projectIdOrName: string;
  /**
   * The segment slug
   */
  segmentIdOrSlug: string;
  /**
   * Whether to include metadata
   */
  withMetadata?: boolean | undefined;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: UpdateFlagSegmentRequestBody | undefined;
};

/** @internal */
export const UpdateFlagSegmentAction$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentAction
> = z.nativeEnum(UpdateFlagSegmentAction);
/** @internal */
export const UpdateFlagSegmentAction$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentAction
> = UpdateFlagSegmentAction$inboundSchema;

/** @internal */
export const Field$inboundSchema: z.ZodNativeEnum<typeof Field> = z.nativeEnum(
  Field,
);
/** @internal */
export const Field$outboundSchema: z.ZodNativeEnum<typeof Field> =
  Field$inboundSchema;

/** @internal */
export const UpdateFlagSegmentValue$inboundSchema: z.ZodType<
  UpdateFlagSegmentValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagSegmentValue$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagSegmentValue$outboundSchema: z.ZodType<
  UpdateFlagSegmentValue$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentValue
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagSegmentValueToJSON(
  updateFlagSegmentValue: UpdateFlagSegmentValue,
): string {
  return JSON.stringify(
    UpdateFlagSegmentValue$outboundSchema.parse(updateFlagSegmentValue),
  );
}
export function updateFlagSegmentValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentValue' from JSON`,
  );
}

/** @internal */
export const Operations$inboundSchema: z.ZodType<
  Operations,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: UpdateFlagSegmentAction$inboundSchema,
  field: Field$inboundSchema,
  entity: types.string(),
  attribute: types.string(),
  value: z.lazy(() => UpdateFlagSegmentValue$inboundSchema),
});
/** @internal */
export type Operations$Outbound = {
  action: string;
  field: string;
  entity: string;
  attribute: string;
  value: UpdateFlagSegmentValue$Outbound;
};

/** @internal */
export const Operations$outboundSchema: z.ZodType<
  Operations$Outbound,
  z.ZodTypeDef,
  Operations
> = z.object({
  action: UpdateFlagSegmentAction$outboundSchema,
  field: Field$outboundSchema,
  entity: z.string(),
  attribute: z.string(),
  value: z.lazy(() => UpdateFlagSegmentValue$outboundSchema),
});

export function operationsToJSON(operations: Operations): string {
  return JSON.stringify(Operations$outboundSchema.parse(operations));
}
export function operationsFromJSON(
  jsonString: string,
): SafeParseResult<Operations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Operations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Operations' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentLhs2$inboundSchema: z.ZodType<
  UpdateFlagSegmentLhs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type UpdateFlagSegmentLhs2$Outbound = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

/** @internal */
export const UpdateFlagSegmentLhs2$outboundSchema: z.ZodType<
  UpdateFlagSegmentLhs2$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentLhs2
> = z.object({
  type: z.any().optional(),
  kind: z.string(),
  attribute: z.string(),
});

export function updateFlagSegmentLhs2ToJSON(
  updateFlagSegmentLhs2: UpdateFlagSegmentLhs2,
): string {
  return JSON.stringify(
    UpdateFlagSegmentLhs2$outboundSchema.parse(updateFlagSegmentLhs2),
  );
}
export function updateFlagSegmentLhs2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentLhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentLhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentLhs2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentLhs1$inboundSchema: z.ZodType<
  UpdateFlagSegmentLhs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
});
/** @internal */
export type UpdateFlagSegmentLhs1$Outbound = {
  type?: any | undefined;
};

/** @internal */
export const UpdateFlagSegmentLhs1$outboundSchema: z.ZodType<
  UpdateFlagSegmentLhs1$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentLhs1
> = z.object({
  type: z.any().optional(),
});

export function updateFlagSegmentLhs1ToJSON(
  updateFlagSegmentLhs1: UpdateFlagSegmentLhs1,
): string {
  return JSON.stringify(
    UpdateFlagSegmentLhs1$outboundSchema.parse(updateFlagSegmentLhs1),
  );
}
export function updateFlagSegmentLhs1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentLhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentLhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentLhs1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentLhs$inboundSchema: z.ZodType<
  UpdateFlagSegmentLhs,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentLhs2$inboundSchema),
  z.lazy(() => UpdateFlagSegmentLhs1$inboundSchema),
]);
/** @internal */
export type UpdateFlagSegmentLhs$Outbound =
  | UpdateFlagSegmentLhs2$Outbound
  | UpdateFlagSegmentLhs1$Outbound;

/** @internal */
export const UpdateFlagSegmentLhs$outboundSchema: z.ZodType<
  UpdateFlagSegmentLhs$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentLhs
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentLhs2$outboundSchema),
  z.lazy(() => UpdateFlagSegmentLhs1$outboundSchema),
]);

export function updateFlagSegmentLhsToJSON(
  updateFlagSegmentLhs: UpdateFlagSegmentLhs,
): string {
  return JSON.stringify(
    UpdateFlagSegmentLhs$outboundSchema.parse(updateFlagSegmentLhs),
  );
}
export function updateFlagSegmentLhsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentLhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentLhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentLhs' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentCmp$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentCmp
> = z.nativeEnum(UpdateFlagSegmentCmp);
/** @internal */
export const UpdateFlagSegmentCmp$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentCmp
> = UpdateFlagSegmentCmp$inboundSchema;

/** @internal */
export const UpdateFlagSegmentRhs2$inboundSchema: z.ZodType<
  UpdateFlagSegmentRhs2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  pattern: types.string(),
  flags: types.string(),
});
/** @internal */
export type UpdateFlagSegmentRhs2$Outbound = {
  type?: any | undefined;
  pattern: string;
  flags: string;
};

/** @internal */
export const UpdateFlagSegmentRhs2$outboundSchema: z.ZodType<
  UpdateFlagSegmentRhs2$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRhs2
> = z.object({
  type: z.any().optional(),
  pattern: z.string(),
  flags: z.string(),
});

export function updateFlagSegmentRhs2ToJSON(
  updateFlagSegmentRhs2: UpdateFlagSegmentRhs2,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRhs2$outboundSchema.parse(updateFlagSegmentRhs2),
  );
}
export function updateFlagSegmentRhs2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRhs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRhs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRhs2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRhsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentRhsType
> = z.nativeEnum(UpdateFlagSegmentRhsType);
/** @internal */
export const UpdateFlagSegmentRhsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateFlagSegmentRhsType
> = UpdateFlagSegmentRhsType$inboundSchema;

/** @internal */
export const UpdateFlagSegmentItems2$inboundSchema: z.ZodType<
  UpdateFlagSegmentItems2,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagSegmentItems2$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagSegmentItems2$outboundSchema: z.ZodType<
  UpdateFlagSegmentItems2$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentItems2
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagSegmentItems2ToJSON(
  updateFlagSegmentItems2: UpdateFlagSegmentItems2,
): string {
  return JSON.stringify(
    UpdateFlagSegmentItems2$outboundSchema.parse(updateFlagSegmentItems2),
  );
}
export function updateFlagSegmentItems2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentItems2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentItems2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentItems2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentItems1$inboundSchema: z.ZodType<
  UpdateFlagSegmentItems1,
  z.ZodTypeDef,
  unknown
> = z.object({
  label: types.optional(types.string()),
  note: types.optional(types.string()),
  value: types.number(),
});
/** @internal */
export type UpdateFlagSegmentItems1$Outbound = {
  label?: string | undefined;
  note?: string | undefined;
  value: number;
};

/** @internal */
export const UpdateFlagSegmentItems1$outboundSchema: z.ZodType<
  UpdateFlagSegmentItems1$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentItems1
> = z.object({
  label: z.string().optional(),
  note: z.string().optional(),
  value: z.number(),
});

export function updateFlagSegmentItems1ToJSON(
  updateFlagSegmentItems1: UpdateFlagSegmentItems1,
): string {
  return JSON.stringify(
    UpdateFlagSegmentItems1$outboundSchema.parse(updateFlagSegmentItems1),
  );
}
export function updateFlagSegmentItems1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentItems1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentItems1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentItems1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRhsItems$inboundSchema: z.ZodType<
  UpdateFlagSegmentRhsItems,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentItems1$inboundSchema),
  z.lazy(() => UpdateFlagSegmentItems2$inboundSchema),
]);
/** @internal */
export type UpdateFlagSegmentRhsItems$Outbound =
  | UpdateFlagSegmentItems1$Outbound
  | UpdateFlagSegmentItems2$Outbound;

/** @internal */
export const UpdateFlagSegmentRhsItems$outboundSchema: z.ZodType<
  UpdateFlagSegmentRhsItems$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRhsItems
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentItems1$outboundSchema),
  z.lazy(() => UpdateFlagSegmentItems2$outboundSchema),
]);

export function updateFlagSegmentRhsItemsToJSON(
  updateFlagSegmentRhsItems: UpdateFlagSegmentRhsItems,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRhsItems$outboundSchema.parse(updateFlagSegmentRhsItems),
  );
}
export function updateFlagSegmentRhsItemsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRhsItems, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRhsItems$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRhsItems' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRhs1$inboundSchema: z.ZodType<
  UpdateFlagSegmentRhs1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateFlagSegmentRhsType$inboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => UpdateFlagSegmentItems1$inboundSchema),
      z.lazy(() => UpdateFlagSegmentItems2$inboundSchema),
    ]),
  ),
});
/** @internal */
export type UpdateFlagSegmentRhs1$Outbound = {
  type: string;
  items: Array<
    UpdateFlagSegmentItems1$Outbound | UpdateFlagSegmentItems2$Outbound
  >;
};

/** @internal */
export const UpdateFlagSegmentRhs1$outboundSchema: z.ZodType<
  UpdateFlagSegmentRhs1$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRhs1
> = z.object({
  type: UpdateFlagSegmentRhsType$outboundSchema,
  items: z.array(
    smartUnion([
      z.lazy(() => UpdateFlagSegmentItems1$outboundSchema),
      z.lazy(() => UpdateFlagSegmentItems2$outboundSchema),
    ]),
  ),
});

export function updateFlagSegmentRhs1ToJSON(
  updateFlagSegmentRhs1: UpdateFlagSegmentRhs1,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRhs1$outboundSchema.parse(updateFlagSegmentRhs1),
  );
}
export function updateFlagSegmentRhs1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRhs1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRhs1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRhs1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRhs$inboundSchema: z.ZodType<
  UpdateFlagSegmentRhs,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentRhs2$inboundSchema),
  z.lazy(() => UpdateFlagSegmentRhs1$inboundSchema),
  types.string(),
  types.number(),
  types.boolean(),
]);
/** @internal */
export type UpdateFlagSegmentRhs$Outbound =
  | UpdateFlagSegmentRhs2$Outbound
  | UpdateFlagSegmentRhs1$Outbound
  | string
  | number
  | boolean;

/** @internal */
export const UpdateFlagSegmentRhs$outboundSchema: z.ZodType<
  UpdateFlagSegmentRhs$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRhs
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentRhs2$outboundSchema),
  z.lazy(() => UpdateFlagSegmentRhs1$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
]);

export function updateFlagSegmentRhsToJSON(
  updateFlagSegmentRhs: UpdateFlagSegmentRhs,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRhs$outboundSchema.parse(updateFlagSegmentRhs),
  );
}
export function updateFlagSegmentRhsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRhs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRhs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRhs' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentConditions$inboundSchema: z.ZodType<
  UpdateFlagSegmentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  lhs: smartUnion([
    z.lazy(() => UpdateFlagSegmentLhs2$inboundSchema),
    z.lazy(() => UpdateFlagSegmentLhs1$inboundSchema),
  ]),
  cmp: UpdateFlagSegmentCmp$inboundSchema,
  rhs: types.optional(
    smartUnion([
      z.lazy(() => UpdateFlagSegmentRhs2$inboundSchema),
      z.lazy(() => UpdateFlagSegmentRhs1$inboundSchema),
      types.string(),
      types.number(),
      types.boolean(),
    ]),
  ),
});
/** @internal */
export type UpdateFlagSegmentConditions$Outbound = {
  lhs: UpdateFlagSegmentLhs2$Outbound | UpdateFlagSegmentLhs1$Outbound;
  cmp: string;
  rhs?:
    | UpdateFlagSegmentRhs2$Outbound
    | UpdateFlagSegmentRhs1$Outbound
    | string
    | number
    | boolean
    | undefined;
};

/** @internal */
export const UpdateFlagSegmentConditions$outboundSchema: z.ZodType<
  UpdateFlagSegmentConditions$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentConditions
> = z.object({
  lhs: smartUnion([
    z.lazy(() => UpdateFlagSegmentLhs2$outboundSchema),
    z.lazy(() => UpdateFlagSegmentLhs1$outboundSchema),
  ]),
  cmp: UpdateFlagSegmentCmp$outboundSchema,
  rhs: smartUnion([
    z.lazy(() => UpdateFlagSegmentRhs2$outboundSchema),
    z.lazy(() => UpdateFlagSegmentRhs1$outboundSchema),
    z.string(),
    z.number(),
    z.boolean(),
  ]).optional(),
});

export function updateFlagSegmentConditionsToJSON(
  updateFlagSegmentConditions: UpdateFlagSegmentConditions,
): string {
  return JSON.stringify(
    UpdateFlagSegmentConditions$outboundSchema.parse(
      updateFlagSegmentConditions,
    ),
  );
}
export function updateFlagSegmentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentConditions' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentOutcomeBase$inboundSchema: z.ZodType<
  UpdateFlagSegmentOutcomeBase,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  kind: types.string(),
  attribute: types.string(),
});
/** @internal */
export type UpdateFlagSegmentOutcomeBase$Outbound = {
  type?: any | undefined;
  kind: string;
  attribute: string;
};

/** @internal */
export const UpdateFlagSegmentOutcomeBase$outboundSchema: z.ZodType<
  UpdateFlagSegmentOutcomeBase$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentOutcomeBase
> = z.object({
  type: z.any().optional(),
  kind: z.string(),
  attribute: z.string(),
});

export function updateFlagSegmentOutcomeBaseToJSON(
  updateFlagSegmentOutcomeBase: UpdateFlagSegmentOutcomeBase,
): string {
  return JSON.stringify(
    UpdateFlagSegmentOutcomeBase$outboundSchema.parse(
      updateFlagSegmentOutcomeBase,
    ),
  );
}
export function updateFlagSegmentOutcomeBaseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentOutcomeBase, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentOutcomeBase$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentOutcomeBase' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentOutcome2$inboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
  base: z.lazy(() => UpdateFlagSegmentOutcomeBase$inboundSchema),
  passPromille: types.number(),
});
/** @internal */
export type UpdateFlagSegmentOutcome2$Outbound = {
  type?: any | undefined;
  base: UpdateFlagSegmentOutcomeBase$Outbound;
  passPromille: number;
};

/** @internal */
export const UpdateFlagSegmentOutcome2$outboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome2$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentOutcome2
> = z.object({
  type: z.any().optional(),
  base: z.lazy(() => UpdateFlagSegmentOutcomeBase$outboundSchema),
  passPromille: z.number(),
});

export function updateFlagSegmentOutcome2ToJSON(
  updateFlagSegmentOutcome2: UpdateFlagSegmentOutcome2,
): string {
  return JSON.stringify(
    UpdateFlagSegmentOutcome2$outboundSchema.parse(updateFlagSegmentOutcome2),
  );
}
export function updateFlagSegmentOutcome2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentOutcome2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentOutcome2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentOutcome2' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentOutcome1$inboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: types.optional(z.any()),
});
/** @internal */
export type UpdateFlagSegmentOutcome1$Outbound = {
  type?: any | undefined;
};

/** @internal */
export const UpdateFlagSegmentOutcome1$outboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome1$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentOutcome1
> = z.object({
  type: z.any().optional(),
});

export function updateFlagSegmentOutcome1ToJSON(
  updateFlagSegmentOutcome1: UpdateFlagSegmentOutcome1,
): string {
  return JSON.stringify(
    UpdateFlagSegmentOutcome1$outboundSchema.parse(updateFlagSegmentOutcome1),
  );
}
export function updateFlagSegmentOutcome1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentOutcome1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentOutcome1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentOutcome1' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentOutcome$inboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome,
  z.ZodTypeDef,
  unknown
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentOutcome2$inboundSchema),
  z.lazy(() => UpdateFlagSegmentOutcome1$inboundSchema),
]);
/** @internal */
export type UpdateFlagSegmentOutcome$Outbound =
  | UpdateFlagSegmentOutcome2$Outbound
  | UpdateFlagSegmentOutcome1$Outbound;

/** @internal */
export const UpdateFlagSegmentOutcome$outboundSchema: z.ZodType<
  UpdateFlagSegmentOutcome$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentOutcome
> = smartUnion([
  z.lazy(() => UpdateFlagSegmentOutcome2$outboundSchema),
  z.lazy(() => UpdateFlagSegmentOutcome1$outboundSchema),
]);

export function updateFlagSegmentOutcomeToJSON(
  updateFlagSegmentOutcome: UpdateFlagSegmentOutcome,
): string {
  return JSON.stringify(
    UpdateFlagSegmentOutcome$outboundSchema.parse(updateFlagSegmentOutcome),
  );
}
export function updateFlagSegmentOutcomeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentOutcome, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentOutcome$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentOutcome' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRules$inboundSchema: z.ZodType<
  UpdateFlagSegmentRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: types.string(),
  conditions: z.array(z.lazy(() => UpdateFlagSegmentConditions$inboundSchema)),
  outcome: smartUnion([
    z.lazy(() => UpdateFlagSegmentOutcome2$inboundSchema),
    z.lazy(() => UpdateFlagSegmentOutcome1$inboundSchema),
  ]),
});
/** @internal */
export type UpdateFlagSegmentRules$Outbound = {
  id: string;
  conditions: Array<UpdateFlagSegmentConditions$Outbound>;
  outcome:
    | UpdateFlagSegmentOutcome2$Outbound
    | UpdateFlagSegmentOutcome1$Outbound;
};

/** @internal */
export const UpdateFlagSegmentRules$outboundSchema: z.ZodType<
  UpdateFlagSegmentRules$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRules
> = z.object({
  id: z.string(),
  conditions: z.array(z.lazy(() => UpdateFlagSegmentConditions$outboundSchema)),
  outcome: smartUnion([
    z.lazy(() => UpdateFlagSegmentOutcome2$outboundSchema),
    z.lazy(() => UpdateFlagSegmentOutcome1$outboundSchema),
  ]),
});

export function updateFlagSegmentRulesToJSON(
  updateFlagSegmentRules: UpdateFlagSegmentRules,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRules$outboundSchema.parse(updateFlagSegmentRules),
  );
}
export function updateFlagSegmentRulesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRules' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentInclude$inboundSchema: z.ZodType<
  UpdateFlagSegmentInclude,
  z.ZodTypeDef,
  unknown
> = z.object({
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagSegmentInclude$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagSegmentInclude$outboundSchema: z.ZodType<
  UpdateFlagSegmentInclude$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentInclude
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagSegmentIncludeToJSON(
  updateFlagSegmentInclude: UpdateFlagSegmentInclude,
): string {
  return JSON.stringify(
    UpdateFlagSegmentInclude$outboundSchema.parse(updateFlagSegmentInclude),
  );
}
export function updateFlagSegmentIncludeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentInclude, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentInclude$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentInclude' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentExclude$inboundSchema: z.ZodType<
  UpdateFlagSegmentExclude,
  z.ZodTypeDef,
  unknown
> = z.object({
  note: types.optional(types.string()),
  value: types.string(),
});
/** @internal */
export type UpdateFlagSegmentExclude$Outbound = {
  note?: string | undefined;
  value: string;
};

/** @internal */
export const UpdateFlagSegmentExclude$outboundSchema: z.ZodType<
  UpdateFlagSegmentExclude$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentExclude
> = z.object({
  note: z.string().optional(),
  value: z.string(),
});

export function updateFlagSegmentExcludeToJSON(
  updateFlagSegmentExclude: UpdateFlagSegmentExclude,
): string {
  return JSON.stringify(
    UpdateFlagSegmentExclude$outboundSchema.parse(updateFlagSegmentExclude),
  );
}
export function updateFlagSegmentExcludeFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentExclude, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentExclude$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentExclude' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentData$inboundSchema: z.ZodType<
  UpdateFlagSegmentData,
  z.ZodTypeDef,
  unknown
> = z.object({
  rules: types.optional(
    z.array(z.lazy(() => UpdateFlagSegmentRules$inboundSchema)),
  ),
  include: types.optional(
    z.record(z.record(z.array(z.lazy(() =>
      UpdateFlagSegmentInclude$inboundSchema
    )))),
  ),
  exclude: types.optional(
    z.record(z.record(z.array(z.lazy(() =>
      UpdateFlagSegmentExclude$inboundSchema
    )))),
  ),
});
/** @internal */
export type UpdateFlagSegmentData$Outbound = {
  rules?: Array<UpdateFlagSegmentRules$Outbound> | undefined;
  include?: {
    [k: string]: { [k: string]: Array<UpdateFlagSegmentInclude$Outbound> };
  } | undefined;
  exclude?: {
    [k: string]: { [k: string]: Array<UpdateFlagSegmentExclude$Outbound> };
  } | undefined;
};

/** @internal */
export const UpdateFlagSegmentData$outboundSchema: z.ZodType<
  UpdateFlagSegmentData$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentData
> = z.object({
  rules: z.array(z.lazy(() => UpdateFlagSegmentRules$outboundSchema))
    .optional(),
  include: z.record(
    z.record(z.array(z.lazy(() => UpdateFlagSegmentInclude$outboundSchema))),
  ).optional(),
  exclude: z.record(
    z.record(z.array(z.lazy(() => UpdateFlagSegmentExclude$outboundSchema))),
  ).optional(),
});

export function updateFlagSegmentDataToJSON(
  updateFlagSegmentData: UpdateFlagSegmentData,
): string {
  return JSON.stringify(
    UpdateFlagSegmentData$outboundSchema.parse(updateFlagSegmentData),
  );
}
export function updateFlagSegmentDataFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentData' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRequestBody$inboundSchema: z.ZodType<
  UpdateFlagSegmentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  operations: types.optional(z.array(z.lazy(() => Operations$inboundSchema))),
  label: types.optional(types.string()),
  description: types.optional(types.string()),
  data: types.optional(z.lazy(() => UpdateFlagSegmentData$inboundSchema)),
  hint: types.optional(types.string()),
});
/** @internal */
export type UpdateFlagSegmentRequestBody$Outbound = {
  operations?: Array<Operations$Outbound> | undefined;
  label?: string | undefined;
  description?: string | undefined;
  data?: UpdateFlagSegmentData$Outbound | undefined;
  hint?: string | undefined;
};

/** @internal */
export const UpdateFlagSegmentRequestBody$outboundSchema: z.ZodType<
  UpdateFlagSegmentRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRequestBody
> = z.object({
  operations: z.array(z.lazy(() => Operations$outboundSchema)).optional(),
  label: z.string().optional(),
  description: z.string().optional(),
  data: z.lazy(() => UpdateFlagSegmentData$outboundSchema).optional(),
  hint: z.string().optional(),
});

export function updateFlagSegmentRequestBodyToJSON(
  updateFlagSegmentRequestBody: UpdateFlagSegmentRequestBody,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRequestBody$outboundSchema.parse(
      updateFlagSegmentRequestBody,
    ),
  );
}
export function updateFlagSegmentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateFlagSegmentRequest$inboundSchema: z.ZodType<
  UpdateFlagSegmentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectIdOrName: types.string(),
  segmentIdOrSlug: types.string(),
  withMetadata: types.boolean().default(false),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: types.optional(
    z.lazy(() => UpdateFlagSegmentRequestBody$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateFlagSegmentRequest$Outbound = {
  projectIdOrName: string;
  segmentIdOrSlug: string;
  withMetadata: boolean;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: UpdateFlagSegmentRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateFlagSegmentRequest$outboundSchema: z.ZodType<
  UpdateFlagSegmentRequest$Outbound,
  z.ZodTypeDef,
  UpdateFlagSegmentRequest
> = z.object({
  projectIdOrName: z.string(),
  segmentIdOrSlug: z.string(),
  withMetadata: z.boolean().default(false),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => UpdateFlagSegmentRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateFlagSegmentRequestToJSON(
  updateFlagSegmentRequest: UpdateFlagSegmentRequest,
): string {
  return JSON.stringify(
    UpdateFlagSegmentRequest$outboundSchema.parse(updateFlagSegmentRequest),
  );
}
export function updateFlagSegmentRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFlagSegmentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFlagSegmentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFlagSegmentRequest' from JSON`,
  );
}
