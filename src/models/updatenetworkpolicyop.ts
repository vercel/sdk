/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import {
  Sandbox,
  Sandbox$inboundSchema,
  Sandbox$Outbound,
  Sandbox$outboundSchema,
} from "./sandbox.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * The network access policy mode. Use \"allow-all\" to permit all outbound traffic. Use \"deny-all\" to block all outbound traffic. Use \"custom\" to specify explicit allow/deny rules.
 */
export const UpdateNetworkPolicyMode = {
  AllowAll: "allow-all",
  DenyAll: "deny-all",
  Custom: "custom",
  DefaultAllow: "default-allow",
  DefaultDeny: "default-deny",
} as const;
/**
 * The network access policy mode. Use \"allow-all\" to permit all outbound traffic. Use \"deny-all\" to block all outbound traffic. Use \"custom\" to specify explicit allow/deny rules.
 */
export type UpdateNetworkPolicyMode = ClosedEnum<
  typeof UpdateNetworkPolicyMode
>;

/**
 * Network access policy for the sandbox.\n    Controls which external hosts the sandbox can communicate with.\n    Use \"allow-all\" mode to allow all traffic, \"deny-all\" to block all traffic or \"custom\" to provide specific rules.
 */
export type UpdateNetworkPolicyRequestBody = {
  /**
   * The network access policy mode. Use \"allow-all\" to permit all outbound traffic. Use \"deny-all\" to block all outbound traffic. Use \"custom\" to specify explicit allow/deny rules.
   */
  mode: UpdateNetworkPolicyMode;
  /**
   * List of domain names the sandbox is allowed to connect to. Only applies when mode is \"custom\". Supports wildcard patterns (e.g., \"*.example.com\" matches all subdomains).
   */
  allowedDomains?: Array<string> | undefined;
  /**
   * List of IP address ranges (in CIDR notation) the sandbox is allowed to connect to. Traffic to these addresses bypasses domain-based restrictions.
   */
  allowedCIDRs?: Array<string> | undefined;
  /**
   * List of IP address ranges (in CIDR notation) the sandbox is blocked from connecting to. These rules take precedence over all allowed rules.
   */
  deniedCIDRs?: Array<string> | undefined;
};

export type UpdateNetworkPolicyRequest = {
  /**
   * The unique identifier of the sandbox to update the network policy for.
   */
  sandboxId: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody?: UpdateNetworkPolicyRequestBody | undefined;
};

/**
 * The sandbox network policy was updated successfully.
 */
export type UpdateNetworkPolicyResponseBody = {
  /**
   * This object contains information related to a Vercel Sandbox.
   */
  sandbox: Sandbox;
};

/** @internal */
export const UpdateNetworkPolicyMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdateNetworkPolicyMode
> = z.nativeEnum(UpdateNetworkPolicyMode);
/** @internal */
export const UpdateNetworkPolicyMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdateNetworkPolicyMode
> = UpdateNetworkPolicyMode$inboundSchema;

/** @internal */
export const UpdateNetworkPolicyRequestBody$inboundSchema: z.ZodType<
  UpdateNetworkPolicyRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  mode: UpdateNetworkPolicyMode$inboundSchema,
  allowedDomains: types.optional(z.array(types.string())),
  allowedCIDRs: types.optional(z.array(types.string())),
  deniedCIDRs: types.optional(z.array(types.string())),
});
/** @internal */
export type UpdateNetworkPolicyRequestBody$Outbound = {
  mode: string;
  allowedDomains?: Array<string> | undefined;
  allowedCIDRs?: Array<string> | undefined;
  deniedCIDRs?: Array<string> | undefined;
};

/** @internal */
export const UpdateNetworkPolicyRequestBody$outboundSchema: z.ZodType<
  UpdateNetworkPolicyRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateNetworkPolicyRequestBody
> = z.object({
  mode: UpdateNetworkPolicyMode$outboundSchema,
  allowedDomains: z.array(z.string()).optional(),
  allowedCIDRs: z.array(z.string()).optional(),
  deniedCIDRs: z.array(z.string()).optional(),
});

export function updateNetworkPolicyRequestBodyToJSON(
  updateNetworkPolicyRequestBody: UpdateNetworkPolicyRequestBody,
): string {
  return JSON.stringify(
    UpdateNetworkPolicyRequestBody$outboundSchema.parse(
      updateNetworkPolicyRequestBody,
    ),
  );
}
export function updateNetworkPolicyRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateNetworkPolicyRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateNetworkPolicyRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateNetworkPolicyRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateNetworkPolicyRequest$inboundSchema: z.ZodType<
  UpdateNetworkPolicyRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  sandboxId: types.string(),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: types.optional(
    z.lazy(() => UpdateNetworkPolicyRequestBody$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateNetworkPolicyRequest$Outbound = {
  sandboxId: string;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody?: UpdateNetworkPolicyRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateNetworkPolicyRequest$outboundSchema: z.ZodType<
  UpdateNetworkPolicyRequest$Outbound,
  z.ZodTypeDef,
  UpdateNetworkPolicyRequest
> = z.object({
  sandboxId: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => UpdateNetworkPolicyRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateNetworkPolicyRequestToJSON(
  updateNetworkPolicyRequest: UpdateNetworkPolicyRequest,
): string {
  return JSON.stringify(
    UpdateNetworkPolicyRequest$outboundSchema.parse(updateNetworkPolicyRequest),
  );
}
export function updateNetworkPolicyRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateNetworkPolicyRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateNetworkPolicyRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateNetworkPolicyRequest' from JSON`,
  );
}

/** @internal */
export const UpdateNetworkPolicyResponseBody$inboundSchema: z.ZodType<
  UpdateNetworkPolicyResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  sandbox: Sandbox$inboundSchema,
});
/** @internal */
export type UpdateNetworkPolicyResponseBody$Outbound = {
  sandbox: Sandbox$Outbound;
};

/** @internal */
export const UpdateNetworkPolicyResponseBody$outboundSchema: z.ZodType<
  UpdateNetworkPolicyResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateNetworkPolicyResponseBody
> = z.object({
  sandbox: Sandbox$outboundSchema,
});

export function updateNetworkPolicyResponseBodyToJSON(
  updateNetworkPolicyResponseBody: UpdateNetworkPolicyResponseBody,
): string {
  return JSON.stringify(
    UpdateNetworkPolicyResponseBody$outboundSchema.parse(
      updateNetworkPolicyResponseBody,
    ),
  );
}
export function updateNetworkPolicyResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateNetworkPolicyResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateNetworkPolicyResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateNetworkPolicyResponseBody' from JSON`,
  );
}
