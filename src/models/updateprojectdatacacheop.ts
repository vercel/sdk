/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { ClosedEnum } from "../types/enums.js";
import { Result as SafeParseResult } from "../types/fp.js";
import {
  ACLAction,
  ACLAction$inboundSchema,
  ACLAction$outboundSchema,
} from "./aclaction.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

export type UpdateProjectDataCacheRequestBody = {
  /**
   * Enable or disable data cache for the project - default: false
   */
  disabled?: boolean | undefined;
};

export type UpdateProjectDataCacheRequest = {
  /**
   * The unique project identifier
   */
  projectId: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody: UpdateProjectDataCacheRequestBody;
};

export type Analytics = {
  id: string;
  canceledAt?: number | null | undefined;
  disabledAt: number;
  enabledAt: number;
  paidAt?: number | undefined;
  sampleRatePercent?: number | null | undefined;
  spendLimitInDollars?: number | null | undefined;
};

export type SpeedInsights = {
  id: string;
  enabledAt?: number | undefined;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  hasData?: boolean | undefined;
  paidAt?: number | undefined;
};

export const UpdateProjectDataCacheEnvId2 = {
  Preview: "preview",
  Production: "production",
} as const;
export type UpdateProjectDataCacheEnvId2 = ClosedEnum<
  typeof UpdateProjectDataCacheEnvId2
>;

export type UpdateProjectDataCacheEnvId = string | UpdateProjectDataCacheEnvId2;

export type UpdateProjectDataCacheAws = {
  subnetIds: Array<string>;
  securityGroupId: string;
};

export type UpdateProjectDataCacheConnectConfigurations = {
  envId: string | UpdateProjectDataCacheEnvId2;
  connectConfigurationId: string;
  dc?: string | undefined;
  passive: boolean;
  buildsEnabled: boolean;
  aws?: UpdateProjectDataCacheAws | undefined;
  createdAt: number;
  updatedAt: number;
};

export type Definitions = {
  /**
   * The hostname that should be used.
   */
  host: string;
  /**
   * The path that should be called for the cronjob.
   */
  path: string;
  /**
   * The cron expression.
   */
  schedule: string;
};

export type Crons = {
  /**
   * The time the feature was enabled for this project. Note: It enables automatically with the first Deployment that outputs cronjobs.
   */
  enabledAt: number;
  /**
   * The time the feature was disabled for this project.
   */
  disabledAt: number | null;
  updatedAt: number;
  /**
   * The ID of the Deployment from which the definitions originated.
   */
  deploymentId: string | null;
  definitions: Array<Definitions>;
};

export type UpdateProjectDataCacheDataCache = {
  userDisabled: boolean;
  storageSizeBytes?: number | null | undefined;
  unlimited?: boolean | undefined;
};

/**
 * Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
 */
export type DeploymentExpiration = {
  /**
   * Number of days to keep non-production deployments (mostly preview deployments) before soft deletion.
   */
  expirationDays?: number | undefined;
  /**
   * Number of days to keep production deployments before soft deletion.
   */
  expirationDaysProduction?: number | undefined;
  /**
   * Number of days to keep canceled deployments before soft deletion.
   */
  expirationDaysCanceled?: number | undefined;
  /**
   * Number of days to keep errored deployments before soft deletion.
   */
  expirationDaysErrored?: number | undefined;
  /**
   * Minimum number of production deployments to keep for this project, even if they are over the production expiration limit.
   */
  deploymentsToKeep?: number | undefined;
};

export const UpdateProjectDataCacheTarget2 = {
  Production: "production",
  Preview: "preview",
  Development: "development",
} as const;
export type UpdateProjectDataCacheTarget2 = ClosedEnum<
  typeof UpdateProjectDataCacheTarget2
>;

export const UpdateProjectDataCacheTarget1 = {
  Production: "production",
  Preview: "preview",
  Development: "development",
} as const;
export type UpdateProjectDataCacheTarget1 = ClosedEnum<
  typeof UpdateProjectDataCacheTarget1
>;

export type UpdateProjectDataCacheTarget =
  | Array<UpdateProjectDataCacheTarget1>
  | UpdateProjectDataCacheTarget2;

export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONType = {
  Secret: "secret",
  System: "system",
  Encrypted: "encrypted",
  Plain: "plain",
  Sensitive: "sensitive",
} as const;
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONType
  >;

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type =
  {
    FlagsConnectionString: "flags-connection-string",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type
  >;

export type ContentHint15 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type;
  projectId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type =
  {
    IntegrationStoreSecret: "integration-store-secret",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type
  >;

export type ContentHint14 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type;
  storeId: string;
  integrationId: string;
  integrationProductId: string;
  integrationConfigurationId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type =
  {
    PostgresUrlNoSsl: "postgres-url-no-ssl",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type
  >;

export type ContentHint13 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type =
  {
    PostgresDatabase: "postgres-database",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type
  >;

export type ContentHint12 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type =
  {
    PostgresPassword: "postgres-password",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type
  >;

export type ContentHint11 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type =
  {
    PostgresHost: "postgres-host",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type
  >;

export type ContentHint10 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type =
  {
    PostgresUser: "postgres-user",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type
  >;

export type ContentHint9 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType =
  {
    PostgresPrismaUrl: "postgres-prisma-url",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType
  >;

export type ContentHint8 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType =
  {
    PostgresUrlNonPooling: "postgres-url-non-pooling",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType
  >;

export type ContentHint7 = {
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType =
  {
    PostgresUrl: "postgres-url",
  } as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType
  >;

export type ContentHint6 = {
  type: UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponse200Type = {
  BlobReadWriteToken: "blob-read-write-token",
} as const;
export type UpdateProjectDataCacheContentHintProjectsResponse200Type =
  ClosedEnum<typeof UpdateProjectDataCacheContentHintProjectsResponse200Type>;

export type ContentHint5 = {
  type: UpdateProjectDataCacheContentHintProjectsResponse200Type;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsResponseType = {
  RedisRestApiReadOnlyToken: "redis-rest-api-read-only-token",
} as const;
export type UpdateProjectDataCacheContentHintProjectsResponseType = ClosedEnum<
  typeof UpdateProjectDataCacheContentHintProjectsResponseType
>;

export type ContentHint4 = {
  type: UpdateProjectDataCacheContentHintProjectsResponseType;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintProjectsType = {
  RedisRestApiToken: "redis-rest-api-token",
} as const;
export type UpdateProjectDataCacheContentHintProjectsType = ClosedEnum<
  typeof UpdateProjectDataCacheContentHintProjectsType
>;

export type ContentHint3 = {
  type: UpdateProjectDataCacheContentHintProjectsType;
  storeId: string;
};

export const UpdateProjectDataCacheContentHintType = {
  RedisRestApiUrl: "redis-rest-api-url",
} as const;
export type UpdateProjectDataCacheContentHintType = ClosedEnum<
  typeof UpdateProjectDataCacheContentHintType
>;

export type ContentHint2 = {
  type: UpdateProjectDataCacheContentHintType;
  storeId: string;
};

export const ContentHintType = {
  RedisUrl: "redis-url",
} as const;
export type ContentHintType = ClosedEnum<typeof ContentHintType>;

export type ContentHint1 = {
  type: ContentHintType;
  storeId: string;
};

export type ContentHint =
  | ContentHint14
  | ContentHint1
  | ContentHint2
  | ContentHint3
  | ContentHint4
  | ContentHint5
  | ContentHint6
  | ContentHint7
  | ContentHint8
  | ContentHint9
  | ContentHint10
  | ContentHint11
  | ContentHint12
  | ContentHint13
  | ContentHint15;

export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType =
  {
    FlagsSecret: "flags-secret",
  } as const;
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType
  >;

/**
 * Similar to `contentHints`, but should not be exposed to the user.
 */
export type InternalContentHint = {
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType;
  /**
   * Contains the `value` of the env variable, encrypted with a special key to make decryption possible in the subscriber Lambda.
   */
  encryptedValue: string;
};

export type UpdateProjectDataCacheEnv = {
  target?:
    | Array<UpdateProjectDataCacheTarget1>
    | UpdateProjectDataCacheTarget2
    | undefined;
  type: UpdateProjectDataCacheProjectsResponse200ApplicationJSONType;
  /**
   * This is used to identiy variables that have been migrated from type secret to sensitive.
   */
  sunsetSecretId?: string | undefined;
  decrypted?: boolean | undefined;
  value: string;
  vsmValue?: string | undefined;
  id?: string | undefined;
  key: string;
  configurationId?: string | null | undefined;
  createdAt?: number | undefined;
  updatedAt?: number | undefined;
  createdBy?: string | null | undefined;
  updatedBy?: string | null | undefined;
  gitBranch?: string | undefined;
  edgeConfigId?: string | null | undefined;
  edgeConfigTokenId?: string | null | undefined;
  contentHint?:
    | ContentHint14
    | ContentHint1
    | ContentHint2
    | ContentHint3
    | ContentHint4
    | ContentHint5
    | ContentHint6
    | ContentHint7
    | ContentHint8
    | ContentHint9
    | ContentHint10
    | ContentHint11
    | ContentHint12
    | ContentHint13
    | ContentHint15
    | null
    | undefined;
  /**
   * Similar to `contentHints`, but should not be exposed to the user.
   */
  internalContentHint?: InternalContentHint | null | undefined;
  comment?: string | undefined;
  customEnvironmentIds?: Array<string> | undefined;
};

/**
 * The type of environment (production, preview, or development)
 */
export const UpdateProjectDataCacheType = {
  Preview: "preview",
  Production: "production",
  Development: "development",
} as const;
/**
 * The type of environment (production, preview, or development)
 */
export type UpdateProjectDataCacheType = ClosedEnum<
  typeof UpdateProjectDataCacheType
>;

/**
 * The type of matching to perform
 */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType =
  {
    EndsWith: "endsWith",
    StartsWith: "startsWith",
    Equals: "equals",
  } as const;
/**
 * The type of matching to perform
 */
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType
  >;

/**
 * Configuration for matching git branches to this environment
 */
export type UpdateProjectDataCacheProjectsResponseBranchMatcher = {
  /**
   * The type of matching to perform
   */
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType;
  /**
   * The pattern to match against branch names
   */
  pattern: string;
};

/**
 * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
 */
export type UpdateProjectDataCacheVerification = {
  type: string;
  domain: string;
  value: string;
  reason: string;
};

/**
 * List of domains associated with this environment
 */
export type UpdateProjectDataCacheDomains = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
  gitBranch?: string | null | undefined;
  customEnvironmentId?: string | null | undefined;
  updatedAt?: number | undefined;
  createdAt?: number | undefined;
  /**
   * `true` if the domain is verified for use with the project. If `false` it will not be used as an alias on this project until the challenge in `verification` is completed.
   */
  verified: boolean;
  /**
   * A list of verification challenges, one of which must be completed to verify the domain for use on the project. After the challenge is complete `POST /projects/:idOrName/domains/:domain/verify` to verify the domain. Possible challenges: - If `verification.type = TXT` the `verification.domain` will be checked for a TXT record matching `verification.value`.
   */
  verification?: Array<UpdateProjectDataCacheVerification> | undefined;
};

/**
 * Internal representation of a custom environment with all required properties
 */
export type CustomEnvironments = {
  /**
   * Unique identifier for the custom environment (format: env_*)
   */
  id: string;
  /**
   * URL-friendly name of the environment
   */
  slug: string;
  /**
   * The type of environment (production, preview, or development)
   */
  type: UpdateProjectDataCacheType;
  /**
   * Optional description of the environment's purpose
   */
  description?: string | undefined;
  /**
   * Configuration for matching git branches to this environment
   */
  branchMatcher?:
    | UpdateProjectDataCacheProjectsResponseBranchMatcher
    | undefined;
  /**
   * List of domains associated with this environment
   */
  domains?: Array<UpdateProjectDataCacheDomains> | undefined;
  /**
   * List of aliases for the current deployment
   */
  currentDeploymentAliases?: Array<string> | undefined;
  /**
   * Timestamp when the environment was created
   */
  createdAt: number;
  /**
   * Timestamp when the environment was last updated
   */
  updatedAt: number;
};

export const UpdateProjectDataCacheFramework = {
  Blitzjs: "blitzjs",
  Nextjs: "nextjs",
  Gatsby: "gatsby",
  Remix: "remix",
  ReactRouter: "react-router",
  Astro: "astro",
  Hexo: "hexo",
  Eleventy: "eleventy",
  Docusaurus2: "docusaurus-2",
  Docusaurus: "docusaurus",
  Preact: "preact",
  Solidstart1: "solidstart-1",
  Solidstart: "solidstart",
  Dojo: "dojo",
  Ember: "ember",
  Vue: "vue",
  Scully: "scully",
  IonicAngular: "ionic-angular",
  Angular: "angular",
  Polymer: "polymer",
  Svelte: "svelte",
  Sveltekit: "sveltekit",
  Sveltekit1: "sveltekit-1",
  IonicReact: "ionic-react",
  CreateReactApp: "create-react-app",
  Gridsome: "gridsome",
  Umijs: "umijs",
  Sapper: "sapper",
  Saber: "saber",
  Stencil: "stencil",
  Nuxtjs: "nuxtjs",
  Redwoodjs: "redwoodjs",
  Hugo: "hugo",
  Jekyll: "jekyll",
  Brunch: "brunch",
  Middleman: "middleman",
  Zola: "zola",
  Hydrogen: "hydrogen",
  Vite: "vite",
  TanstackStart: "tanstack-start",
  Vitepress: "vitepress",
  Vuepress: "vuepress",
  Parcel: "parcel",
  Fastapi: "fastapi",
  Flask: "flask",
  Fasthtml: "fasthtml",
  SanityV3: "sanity-v3",
  Sanity: "sanity",
  Storybook: "storybook",
  Nitro: "nitro",
  Hono: "hono",
  Express: "express",
  H3: "h3",
  Nestjs: "nestjs",
  Elysia: "elysia",
  Fastify: "fastify",
  Xmcp: "xmcp",
} as const;
export type UpdateProjectDataCacheFramework = ClosedEnum<
  typeof UpdateProjectDataCacheFramework
>;

export type UpdateProjectDataCacheIpBuckets = {
  bucket: string;
  supportUntil?: number | undefined;
};

export type AliasAssigned = number | boolean;

export type UpdateProjectDataCacheProjectsAliasError = {
  code: string;
  message: string;
};

/**
 * The type of matching to perform
 */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType =
  {
    EndsWith: "endsWith",
    StartsWith: "startsWith",
    Equals: "equals",
  } as const;
/**
 * The type of matching to perform
 */
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType
  >;

export type UpdateProjectDataCacheBranchMatcher = {
  /**
   * The type of matching to perform
   */
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType;
  /**
   * The pattern to match against branch names
   */
  pattern: string;
};

export type UpdateProjectDataCacheProjectsBuilds = {
  use: string;
  src?: string | undefined;
  dest?: string | undefined;
};

export const UpdateProjectDataCacheProjectsChecksConclusion = {
  Succeeded: "succeeded",
  Failed: "failed",
  Skipped: "skipped",
  Canceled: "canceled",
} as const;
export type UpdateProjectDataCacheProjectsChecksConclusion = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsChecksConclusion
>;

export const UpdateProjectDataCacheProjectsChecksState = {
  Registered: "registered",
  Running: "running",
  Completed: "completed",
} as const;
export type UpdateProjectDataCacheProjectsChecksState = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsChecksState
>;

export type UpdateProjectDataCacheProjectsCreator = {
  email: string;
  githubLogin?: string | undefined;
  gitlabLogin?: string | undefined;
  uid: string;
  username: string;
};

export type UpdateProjectDataCacheProjectsOidcTokenClaims = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  ownerId: string;
  project: string;
  projectId: string;
  environment: string;
  plan: string;
};

export const UpdateProjectDataCacheProjectsPlan = {
  Pro: "pro",
  Enterprise: "enterprise",
  Hobby: "hobby",
} as const;
export type UpdateProjectDataCacheProjectsPlan = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsPlan
>;

export const UpdateProjectDataCacheProjectsReadyState = {
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Queued: "QUEUED",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
export type UpdateProjectDataCacheProjectsReadyState = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsReadyState
>;

export const UpdateProjectDataCacheProjectsReadySubstate = {
  Staged: "STAGED",
  Rolling: "ROLLING",
  Promoted: "PROMOTED",
} as const;
export type UpdateProjectDataCacheProjectsReadySubstate = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsReadySubstate
>;

export const UpdateProjectDataCacheProjectsType = {
  Lambdas: "LAMBDAS",
} as const;
export type UpdateProjectDataCacheProjectsType = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsType
>;

export type LatestDeployments = {
  id: string;
  alias?: Array<string> | undefined;
  aliasAssigned?: number | boolean | null | undefined;
  aliasError?: UpdateProjectDataCacheProjectsAliasError | null | undefined;
  aliasFinal?: string | null | undefined;
  automaticAliases?: Array<string> | undefined;
  branchMatcher?: UpdateProjectDataCacheBranchMatcher | undefined;
  buildingAt?: number | undefined;
  builds?: Array<UpdateProjectDataCacheProjectsBuilds> | undefined;
  checksConclusion?: UpdateProjectDataCacheProjectsChecksConclusion | undefined;
  checksState?: UpdateProjectDataCacheProjectsChecksState | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdAt: number;
  createdIn: string;
  creator: UpdateProjectDataCacheProjectsCreator | null;
  deletedAt?: number | undefined;
  deploymentHostname: string;
  forced?: boolean | undefined;
  name: string;
  meta?: { [k: string]: string } | undefined;
  monorepoManager?: string | null | undefined;
  oidcTokenClaims?: UpdateProjectDataCacheProjectsOidcTokenClaims | undefined;
  plan: UpdateProjectDataCacheProjectsPlan;
  /**
   * Whether or not preview comments are enabled for the deployment
   */
  previewCommentsEnabled?: boolean | undefined;
  private: boolean;
  readyAt?: number | undefined;
  readyState: UpdateProjectDataCacheProjectsReadyState;
  readySubstate?: UpdateProjectDataCacheProjectsReadySubstate | undefined;
  requestedAt?: number | undefined;
  target?: string | null | undefined;
  teamId?: string | null | undefined;
  type: UpdateProjectDataCacheProjectsType;
  url: string;
  userId: string;
  withCache?: boolean | undefined;
};

export const UpdateProjectDataCacheLinkProjectsResponse200Type = {
  Bitbucket: "bitbucket",
} as const;
export type UpdateProjectDataCacheLinkProjectsResponse200Type = ClosedEnum<
  typeof UpdateProjectDataCacheLinkProjectsResponse200Type
>;

export type UpdateProjectDataCacheLinkProjectsResponseDeployHooks = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

export type Link5 = {
  name: string;
  slug: string;
  owner: string;
  type: UpdateProjectDataCacheLinkProjectsResponse200Type;
  uuid: string;
  workspaceUuid: string;
  createdAt?: number | undefined;
  deployHooks: Array<UpdateProjectDataCacheLinkProjectsResponseDeployHooks>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

export const UpdateProjectDataCacheLinkProjectsResponseType = {
  Gitlab: "gitlab",
} as const;
export type UpdateProjectDataCacheLinkProjectsResponseType = ClosedEnum<
  typeof UpdateProjectDataCacheLinkProjectsResponseType
>;

export type UpdateProjectDataCacheLinkProjectsDeployHooks = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

export type Link4 = {
  projectId: string;
  projectName: string;
  projectNameWithNamespace: string;
  projectNamespace: string;
  /**
   * A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes. This is the id of the top level group that a namespace belongs to. Gitlab supports group nesting (up to 20 levels).
   */
  projectOwnerId?: number | undefined;
  projectUrl: string;
  type: UpdateProjectDataCacheLinkProjectsResponseType;
  createdAt?: number | undefined;
  deployHooks: Array<UpdateProjectDataCacheLinkProjectsDeployHooks>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

export const UpdateProjectDataCacheLinkProjectsType = {
  GithubCustomHost: "github-custom-host",
} as const;
export type UpdateProjectDataCacheLinkProjectsType = ClosedEnum<
  typeof UpdateProjectDataCacheLinkProjectsType
>;

export type UpdateProjectDataCacheLinkDeployHooks = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

export type Link3 = {
  org: string;
  /**
   * A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
   */
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  type: UpdateProjectDataCacheLinkProjectsType;
  host: string;
  createdAt?: number | undefined;
  deployHooks: Array<UpdateProjectDataCacheLinkDeployHooks>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

export const UpdateProjectDataCacheLinkType = {
  GithubLimited: "github-limited",
} as const;
export type UpdateProjectDataCacheLinkType = ClosedEnum<
  typeof UpdateProjectDataCacheLinkType
>;

export type LinkDeployHooks = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

export type Link2 = {
  type: UpdateProjectDataCacheLinkType;
  createdAt?: number | undefined;
  updatedAt?: number | undefined;
  org: string;
  /**
   * A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
   */
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  deployHooks: Array<LinkDeployHooks>;
  gitCredentialId: string;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

export const LinkType = {
  Github: "github",
} as const;
export type LinkType = ClosedEnum<typeof LinkType>;

export type DeployHooks = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

export type Link1 = {
  org: string;
  /**
   * A new field, should be included in all new project links, is being added just in time when a deployment is created. This is needed for Protected Git scopes.
   */
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  type: LinkType;
  createdAt?: number | undefined;
  deployHooks: Array<DeployHooks>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

export type Link = Link4 | Link5 | Link3 | Link1 | Link2;

export type UpdateProjectDataCacheMicrofrontends3 = {
  updatedAt: number;
  groupIds: Array<any>;
  enabled: boolean;
  freeProjectForLegacyLimits?: boolean | undefined;
};

export type UpdateProjectDataCacheMicrofrontends2 = {
  isDefaultApp?: boolean | undefined;
  /**
   * Whether observability data should be routed to this microfrontend project or a root project.
   */
  routeObservabilityToThisProject?: boolean | undefined;
  /**
   * Whether to add microfrontends routing to aliases. This means domains in this project will route as a microfrontend.
   */
  doNotRouteWithMicrofrontendsRouting?: boolean | undefined;
  /**
   * Timestamp when the microfrontends settings were last updated.
   */
  updatedAt: number;
  /**
   * The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
  /**
   * Whether microfrontends are enabled for this project.
   */
  enabled: boolean;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`
   */
  defaultRoute?: string | undefined;
  /**
   * Whether the project was part of the legacy limits for hobby and pro-trial before billing was added. This field is only set when the team is upgraded to a paid plan and we are backfilling the subscription status. We cap the subscription to 2 projects and set this field for the 3rd project. When this field is set, the project is not charged for and we do not call any billing APIs for this project.
   */
  freeProjectForLegacyLimits?: boolean | undefined;
};

export type UpdateProjectDataCacheMicrofrontends1 = {
  isDefaultApp: boolean;
  /**
   * Timestamp when the microfrontends settings were last updated.
   */
  updatedAt: number;
  /**
   * The group IDs of microfrontends that this project belongs to. Each microfrontend project must belong to a microfrontends group that is the set of microfrontends that are used together.
   */
  groupIds: Array<string>;
  /**
   * Whether microfrontends are enabled for this project.
   */
  enabled: boolean;
  /**
   * A path that is used to take screenshots and as the default path in preview links when a domain for this microfrontend is shown in the UI. Includes the leading slash, e.g. `/docs`
   */
  defaultRoute?: string | undefined;
  /**
   * Whether the project was part of the legacy limits for hobby and pro-trial before billing was added. This field is only set when the team is upgraded to a paid plan and we are backfilling the subscription status. We cap the subscription to 2 projects and set this field for the 3rd project. When this field is set, the project is not charged for and we do not call any billing APIs for this project.
   */
  freeProjectForLegacyLimits?: boolean | undefined;
};

export type UpdateProjectDataCacheMicrofrontends =
  | UpdateProjectDataCacheMicrofrontends1
  | UpdateProjectDataCacheMicrofrontends2
  | UpdateProjectDataCacheMicrofrontends3;

export const UpdateProjectDataCacheNodeVersion = {
  TwentyFourDotX: "24.x",
  TwentyTwoDotX: "22.x",
  TwentyDotX: "20.x",
  EighteenDotX: "18.x",
  SixteenDotX: "16.x",
  FourteenDotX: "14.x",
  TwelveDotX: "12.x",
  TenDotX: "10.x",
  EightDot10DotX: "8.10.x",
} as const;
export type UpdateProjectDataCacheNodeVersion = ClosedEnum<
  typeof UpdateProjectDataCacheNodeVersion
>;

export type UpdateProjectDataCachePaths = {
  value: string;
};

export type UpdateProjectDataCacheOptionsAllowlist = {
  paths: Array<UpdateProjectDataCachePaths>;
};

export type UpdateProjectDataCachePasswordProtection = {};

export const UpdateProjectDataCacheProjectsFunctionDefaultMemoryType = {
  StandardLegacy: "standard_legacy",
  Standard: "standard",
  Performance: "performance",
} as const;
export type UpdateProjectDataCacheProjectsFunctionDefaultMemoryType =
  ClosedEnum<typeof UpdateProjectDataCacheProjectsFunctionDefaultMemoryType>;

export const UpdateProjectDataCacheProjectsBuildMachineType = {
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
export type UpdateProjectDataCacheProjectsBuildMachineType = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsBuildMachineType
>;

export type UpdateProjectDataCacheResourceConfig = {
  fluid?: boolean | undefined;
  functionDefaultRegions: Array<string>;
  functionDefaultTimeout?: number | undefined;
  functionDefaultMemoryType?:
    | UpdateProjectDataCacheProjectsFunctionDefaultMemoryType
    | undefined;
  functionZeroConfigFailover?: boolean | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  buildMachineType?: UpdateProjectDataCacheProjectsBuildMachineType | undefined;
  isNSNBDisabled?: boolean | undefined;
};

/**
 * Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.
 */
export type RollbackDescription = {
  /**
   * The user who rolled back the project.
   */
  userId: string;
  /**
   * The username of the user who rolled back the project.
   */
  username: string;
  /**
   * User-supplied explanation of why they rolled back the project. Limited to 250 characters.
   */
  description: string;
  /**
   * Timestamp of when the rollback was requested.
   */
  createdAt: number;
};

/**
 * An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
 */
export type Stages = {
  /**
   * The percentage of traffic to serve to the canary deployment (0-100)
   */
  targetPercentage: number;
  /**
   * Whether or not this stage requires manual approval to proceed
   */
  requireApproval?: boolean | undefined;
  /**
   * Duration in minutes for automatic advancement to the next stage
   */
  duration?: number | undefined;
  /**
   * Whether to linearly shift traffic over the duration of this stage
   */
  linearShift?: boolean | undefined;
};

/**
 * Project-level rolling release configuration that defines how deployments should be gradually rolled out
 */
export type RollingRelease = {
  /**
   * The environment that the release targets, currently only supports production. Adding in case we want to configure with alias groups or custom environments.
   */
  target: string;
  /**
   * An array of all the stages required during a deployment release. Each stage defines a target percentage and advancement rules. The final stage must always have targetPercentage: 100.
   */
  stages?: Array<Stages> | null | undefined;
  /**
   * Whether the request served by a canary deployment should return a header indicating a canary was served. Defaults to `false` when omitted.
   */
  canaryResponseHeader?: boolean | undefined;
};

export const UpdateProjectDataCacheFunctionDefaultMemoryType = {
  StandardLegacy: "standard_legacy",
  Standard: "standard",
  Performance: "performance",
} as const;
export type UpdateProjectDataCacheFunctionDefaultMemoryType = ClosedEnum<
  typeof UpdateProjectDataCacheFunctionDefaultMemoryType
>;

export const UpdateProjectDataCacheBuildMachineType = {
  Enhanced: "enhanced",
  Turbo: "turbo",
} as const;
export type UpdateProjectDataCacheBuildMachineType = ClosedEnum<
  typeof UpdateProjectDataCacheBuildMachineType
>;

export type DefaultResourceConfig = {
  fluid?: boolean | undefined;
  functionDefaultRegions: Array<string>;
  functionDefaultTimeout?: number | undefined;
  functionDefaultMemoryType?:
    | UpdateProjectDataCacheFunctionDefaultMemoryType
    | undefined;
  functionZeroConfigFailover?: boolean | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  buildMachineType?: UpdateProjectDataCacheBuildMachineType | undefined;
  isNSNBDisabled?: boolean | undefined;
};

export type UpdateProjectDataCacheStaticIps = {
  builds: boolean;
  enabled: boolean;
  regions: Array<string>;
};

export const UpdateProjectDataCacheDeploymentType = {
  Preview: "preview",
  All: "all",
  ProdDeploymentUrlsAndAllPreviews: "prod_deployment_urls_and_all_previews",
  AllExceptCustomDomains: "all_except_custom_domains",
} as const;
export type UpdateProjectDataCacheDeploymentType = ClosedEnum<
  typeof UpdateProjectDataCacheDeploymentType
>;

export type UpdateProjectDataCacheSsoProtection = {
  deploymentType: UpdateProjectDataCacheDeploymentType;
};

export type UpdateProjectDataCacheAliasAssigned = number | boolean;

export type UpdateProjectDataCacheAliasError = {
  code: string;
  message: string;
};

/**
 * The type of matching to perform
 */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType =
  {
    EndsWith: "endsWith",
    StartsWith: "startsWith",
    Equals: "equals",
  } as const;
/**
 * The type of matching to perform
 */
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType
  >;

export type UpdateProjectDataCacheProjectsBranchMatcher = {
  /**
   * The type of matching to perform
   */
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType;
  /**
   * The pattern to match against branch names
   */
  pattern: string;
};

export type UpdateProjectDataCacheBuilds = {
  use: string;
  src?: string | undefined;
  dest?: string | undefined;
};

export const UpdateProjectDataCacheChecksConclusion = {
  Succeeded: "succeeded",
  Failed: "failed",
  Skipped: "skipped",
  Canceled: "canceled",
} as const;
export type UpdateProjectDataCacheChecksConclusion = ClosedEnum<
  typeof UpdateProjectDataCacheChecksConclusion
>;

export const UpdateProjectDataCacheChecksState = {
  Registered: "registered",
  Running: "running",
  Completed: "completed",
} as const;
export type UpdateProjectDataCacheChecksState = ClosedEnum<
  typeof UpdateProjectDataCacheChecksState
>;

export type UpdateProjectDataCacheCreator = {
  email: string;
  githubLogin?: string | undefined;
  gitlabLogin?: string | undefined;
  uid: string;
  username: string;
};

export type UpdateProjectDataCacheOidcTokenClaims = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  ownerId: string;
  project: string;
  projectId: string;
  environment: string;
  plan: string;
};

export const UpdateProjectDataCachePlan = {
  Pro: "pro",
  Enterprise: "enterprise",
  Hobby: "hobby",
} as const;
export type UpdateProjectDataCachePlan = ClosedEnum<
  typeof UpdateProjectDataCachePlan
>;

export const UpdateProjectDataCacheReadyState = {
  Building: "BUILDING",
  Error: "ERROR",
  Initializing: "INITIALIZING",
  Queued: "QUEUED",
  Ready: "READY",
  Canceled: "CANCELED",
} as const;
export type UpdateProjectDataCacheReadyState = ClosedEnum<
  typeof UpdateProjectDataCacheReadyState
>;

export const UpdateProjectDataCacheReadySubstate = {
  Staged: "STAGED",
  Rolling: "ROLLING",
  Promoted: "PROMOTED",
} as const;
export type UpdateProjectDataCacheReadySubstate = ClosedEnum<
  typeof UpdateProjectDataCacheReadySubstate
>;

export const UpdateProjectDataCacheProjectsResponseType = {
  Lambdas: "LAMBDAS",
} as const;
export type UpdateProjectDataCacheProjectsResponseType = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsResponseType
>;

export type Targets = {
  id: string;
  alias?: Array<string> | undefined;
  aliasAssigned?: number | boolean | null | undefined;
  aliasError?: UpdateProjectDataCacheAliasError | null | undefined;
  aliasFinal?: string | null | undefined;
  automaticAliases?: Array<string> | undefined;
  branchMatcher?: UpdateProjectDataCacheProjectsBranchMatcher | undefined;
  buildingAt?: number | undefined;
  builds?: Array<UpdateProjectDataCacheBuilds> | undefined;
  checksConclusion?: UpdateProjectDataCacheChecksConclusion | undefined;
  checksState?: UpdateProjectDataCacheChecksState | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdAt: number;
  createdIn: string;
  creator: UpdateProjectDataCacheCreator | null;
  deletedAt?: number | undefined;
  deploymentHostname: string;
  forced?: boolean | undefined;
  name: string;
  meta?: { [k: string]: string } | undefined;
  monorepoManager?: string | null | undefined;
  oidcTokenClaims?: UpdateProjectDataCacheOidcTokenClaims | undefined;
  plan: UpdateProjectDataCachePlan;
  /**
   * Whether or not preview comments are enabled for the deployment
   */
  previewCommentsEnabled?: boolean | undefined;
  private: boolean;
  readyAt?: number | undefined;
  readyState: UpdateProjectDataCacheReadyState;
  readySubstate?: UpdateProjectDataCacheReadySubstate | undefined;
  requestedAt?: number | undefined;
  target?: string | null | undefined;
  teamId?: string | null | undefined;
  type: UpdateProjectDataCacheProjectsResponseType;
  url: string;
  userId: string;
  withCache?: boolean | undefined;
};

export type UpdateProjectDataCachePermissions = {
  oauth2Connection?: Array<ACLAction> | undefined;
  user?: Array<ACLAction> | undefined;
  userConnection?: Array<ACLAction> | undefined;
  userSudo?: Array<ACLAction> | undefined;
  webAuthn?: Array<ACLAction> | undefined;
  accessGroup?: Array<ACLAction> | undefined;
  agent?: Array<ACLAction> | undefined;
  alerts?: Array<ACLAction> | undefined;
  aliasGlobal?: Array<ACLAction> | undefined;
  analyticsSampling?: Array<ACLAction> | undefined;
  analyticsUsage?: Array<ACLAction> | undefined;
  apiKey?: Array<ACLAction> | undefined;
  apiKeyAiGateway?: Array<ACLAction> | undefined;
  apiKeyOwnedBySelf?: Array<ACLAction> | undefined;
  oauth2Application?: Array<ACLAction> | undefined;
  vercelAppInstallation?: Array<ACLAction> | undefined;
  vercelAppInstallationRequest?: Array<ACLAction> | undefined;
  auditLog?: Array<ACLAction> | undefined;
  billingAddress?: Array<ACLAction> | undefined;
  billingInformation?: Array<ACLAction> | undefined;
  billingInvoice?: Array<ACLAction> | undefined;
  billingInvoiceEmailRecipient?: Array<ACLAction> | undefined;
  billingInvoiceLanguage?: Array<ACLAction> | undefined;
  billingPlan?: Array<ACLAction> | undefined;
  billingPurchaseOrder?: Array<ACLAction> | undefined;
  billingRefund?: Array<ACLAction> | undefined;
  billingTaxId?: Array<ACLAction> | undefined;
  blob?: Array<ACLAction> | undefined;
  blobStoreTokenSet?: Array<ACLAction> | undefined;
  budget?: Array<ACLAction> | undefined;
  cacheArtifact?: Array<ACLAction> | undefined;
  cacheArtifactUsageEvent?: Array<ACLAction> | undefined;
  codeChecks?: Array<ACLAction> | undefined;
  concurrentBuilds?: Array<ACLAction> | undefined;
  connect?: Array<ACLAction> | undefined;
  connectConfiguration?: Array<ACLAction> | undefined;
  dataCacheBillingSettings?: Array<ACLAction> | undefined;
  defaultDeploymentProtection?: Array<ACLAction> | undefined;
  domain?: Array<ACLAction> | undefined;
  domainAcceptDelegation?: Array<ACLAction> | undefined;
  domainAuthCodes?: Array<ACLAction> | undefined;
  domainCertificate?: Array<ACLAction> | undefined;
  domainCheckConfig?: Array<ACLAction> | undefined;
  domainMove?: Array<ACLAction> | undefined;
  domainPurchase?: Array<ACLAction> | undefined;
  domainRecord?: Array<ACLAction> | undefined;
  domainTransferIn?: Array<ACLAction> | undefined;
  drain?: Array<ACLAction> | undefined;
  edgeConfig?: Array<ACLAction> | undefined;
  edgeConfigItem?: Array<ACLAction> | undefined;
  edgeConfigSchema?: Array<ACLAction> | undefined;
  edgeConfigToken?: Array<ACLAction> | undefined;
  endpointVerification?: Array<ACLAction> | undefined;
  event?: Array<ACLAction> | undefined;
  fileUpload?: Array<ACLAction> | undefined;
  flagsExplorerSubscription?: Array<ACLAction> | undefined;
  gitRepository?: Array<ACLAction> | undefined;
  imageOptimizationNewPrice?: Array<ACLAction> | undefined;
  integration?: Array<ACLAction> | undefined;
  integrationAccount?: Array<ACLAction> | undefined;
  integrationConfiguration?: Array<ACLAction> | undefined;
  integrationConfigurationProjects?: Array<ACLAction> | undefined;
  integrationConfigurationRole?: Array<ACLAction> | undefined;
  integrationConfigurationTransfer?: Array<ACLAction> | undefined;
  integrationDeploymentAction?: Array<ACLAction> | undefined;
  integrationEvent?: Array<ACLAction> | undefined;
  integrationLog?: Array<ACLAction> | undefined;
  integrationResource?: Array<ACLAction> | undefined;
  integrationResourceReplCommand?: Array<ACLAction> | undefined;
  integrationResourceSecrets?: Array<ACLAction> | undefined;
  integrationSSOSession?: Array<ACLAction> | undefined;
  integrationStoreTokenSet?: Array<ACLAction> | undefined;
  integrationVercelConfigurationOverride?: Array<ACLAction> | undefined;
  integrationPullRequest?: Array<ACLAction> | undefined;
  ipBlocking?: Array<ACLAction> | undefined;
  jobGlobal?: Array<ACLAction> | undefined;
  logDrain?: Array<ACLAction> | undefined;
  marketplaceBillingData?: Array<ACLAction> | undefined;
  marketplaceExperimentationEdgeConfigData?: Array<ACLAction> | undefined;
  marketplaceExperimentationItem?: Array<ACLAction> | undefined;
  marketplaceInstallationMember?: Array<ACLAction> | undefined;
  marketplaceInvoice?: Array<ACLAction> | undefined;
  marketplaceSettings?: Array<ACLAction> | undefined;
  monitoring?: Array<ACLAction> | undefined;
  monitoringAlert?: Array<ACLAction> | undefined;
  monitoringChart?: Array<ACLAction> | undefined;
  monitoringQuery?: Array<ACLAction> | undefined;
  monitoringSettings?: Array<ACLAction> | undefined;
  notificationCustomerBudget?: Array<ACLAction> | undefined;
  notificationDeploymentFailed?: Array<ACLAction> | undefined;
  notificationDomainConfiguration?: Array<ACLAction> | undefined;
  notificationDomainExpire?: Array<ACLAction> | undefined;
  notificationDomainMoved?: Array<ACLAction> | undefined;
  notificationDomainPurchase?: Array<ACLAction> | undefined;
  notificationDomainRenewal?: Array<ACLAction> | undefined;
  notificationDomainTransfer?: Array<ACLAction> | undefined;
  notificationDomainUnverified?: Array<ACLAction> | undefined;
  notificationMonitoringAlert?: Array<ACLAction> | undefined;
  notificationPaymentFailed?: Array<ACLAction> | undefined;
  notificationPreferences?: Array<ACLAction> | undefined;
  notificationStatementOfReasons?: Array<ACLAction> | undefined;
  notificationUsageAlert?: Array<ACLAction> | undefined;
  observabilityConfiguration?: Array<ACLAction> | undefined;
  observabilityFunnel?: Array<ACLAction> | undefined;
  observabilityNotebook?: Array<ACLAction> | undefined;
  openTelemetryEndpoint?: Array<ACLAction> | undefined;
  ownEvent?: Array<ACLAction> | undefined;
  organizationDomain?: Array<ACLAction> | undefined;
  passwordProtectionInvoiceItem?: Array<ACLAction> | undefined;
  paymentMethod?: Array<ACLAction> | undefined;
  permissions?: Array<ACLAction> | undefined;
  postgres?: Array<ACLAction> | undefined;
  postgresStoreTokenSet?: Array<ACLAction> | undefined;
  previewDeploymentSuffix?: Array<ACLAction> | undefined;
  projectTransferIn?: Array<ACLAction> | undefined;
  proTrialOnboarding?: Array<ACLAction> | undefined;
  rateLimit?: Array<ACLAction> | undefined;
  redis?: Array<ACLAction> | undefined;
  redisStoreTokenSet?: Array<ACLAction> | undefined;
  remoteCaching?: Array<ACLAction> | undefined;
  repository?: Array<ACLAction> | undefined;
  samlConfig?: Array<ACLAction> | undefined;
  secret?: Array<ACLAction> | undefined;
  securityPlusConfiguration?: Array<ACLAction> | undefined;
  sensitiveEnvironmentVariablePolicy?: Array<ACLAction> | undefined;
  sharedEnvVars?: Array<ACLAction> | undefined;
  sharedEnvVarsProduction?: Array<ACLAction> | undefined;
  space?: Array<ACLAction> | undefined;
  spaceRun?: Array<ACLAction> | undefined;
  storeTransfer?: Array<ACLAction> | undefined;
  supportCase?: Array<ACLAction> | undefined;
  supportCaseComment?: Array<ACLAction> | undefined;
  team?: Array<ACLAction> | undefined;
  teamAccessRequest?: Array<ACLAction> | undefined;
  teamFellowMembership?: Array<ACLAction> | undefined;
  teamGitExclusivity?: Array<ACLAction> | undefined;
  teamInvite?: Array<ACLAction> | undefined;
  teamInviteCode?: Array<ACLAction> | undefined;
  teamJoin?: Array<ACLAction> | undefined;
  teamMemberMfaStatus?: Array<ACLAction> | undefined;
  teamMicrofrontends?: Array<ACLAction> | undefined;
  teamOwnMembership?: Array<ACLAction> | undefined;
  teamOwnMembershipDisconnectSAML?: Array<ACLAction> | undefined;
  token?: Array<ACLAction> | undefined;
  usage?: Array<ACLAction> | undefined;
  usageCycle?: Array<ACLAction> | undefined;
  vercelRun?: Array<ACLAction> | undefined;
  vercelRunExec?: Array<ACLAction> | undefined;
  vpcPeeringConnection?: Array<ACLAction> | undefined;
  webAnalyticsPlan?: Array<ACLAction> | undefined;
  webhook?: Array<ACLAction> | undefined;
  webhookEvent?: Array<ACLAction> | undefined;
  aliasProject?: Array<ACLAction> | undefined;
  aliasProtectionBypass?: Array<ACLAction> | undefined;
  buildMachine?: Array<ACLAction> | undefined;
  connectConfigurationLink?: Array<ACLAction> | undefined;
  dataCacheNamespace?: Array<ACLAction> | undefined;
  deployment?: Array<ACLAction> | undefined;
  deploymentBuildLogs?: Array<ACLAction> | undefined;
  deploymentCheck?: Array<ACLAction> | undefined;
  deploymentCheckPreview?: Array<ACLAction> | undefined;
  deploymentCheckReRunFromProductionBranch?: Array<ACLAction> | undefined;
  deploymentProductionGit?: Array<ACLAction> | undefined;
  deploymentV0?: Array<ACLAction> | undefined;
  deploymentPreview?: Array<ACLAction> | undefined;
  deploymentPrivate?: Array<ACLAction> | undefined;
  deploymentPromote?: Array<ACLAction> | undefined;
  deploymentRollback?: Array<ACLAction> | undefined;
  edgeCacheNamespace?: Array<ACLAction> | undefined;
  environments?: Array<ACLAction> | undefined;
  job?: Array<ACLAction> | undefined;
  logs?: Array<ACLAction> | undefined;
  logsPreset?: Array<ACLAction> | undefined;
  observabilityData?: Array<ACLAction> | undefined;
  onDemandBuild?: Array<ACLAction> | undefined;
  onDemandConcurrency?: Array<ACLAction> | undefined;
  optionsAllowlist?: Array<ACLAction> | undefined;
  passwordProtection?: Array<ACLAction> | undefined;
  productionAliasProtectionBypass?: Array<ACLAction> | undefined;
  project?: Array<ACLAction> | undefined;
  projectAccessGroup?: Array<ACLAction> | undefined;
  projectAnalyticsSampling?: Array<ACLAction> | undefined;
  projectAnalyticsUsage?: Array<ACLAction> | undefined;
  projectCheck?: Array<ACLAction> | undefined;
  projectCheckRun?: Array<ACLAction> | undefined;
  projectDeploymentExpiration?: Array<ACLAction> | undefined;
  projectDeploymentHook?: Array<ACLAction> | undefined;
  projectDomain?: Array<ACLAction> | undefined;
  projectDomainCheckConfig?: Array<ACLAction> | undefined;
  projectDomainMove?: Array<ACLAction> | undefined;
  projectEnvVars?: Array<ACLAction> | undefined;
  projectEnvVarsProduction?: Array<ACLAction> | undefined;
  projectEnvVarsUnownedByIntegration?: Array<ACLAction> | undefined;
  projectFlags?: Array<ACLAction> | undefined;
  projectFlagsProduction?: Array<ACLAction> | undefined;
  projectFromV0?: Array<ACLAction> | undefined;
  projectId?: Array<ACLAction> | undefined;
  projectIntegrationConfiguration?: Array<ACLAction> | undefined;
  projectLink?: Array<ACLAction> | undefined;
  projectMember?: Array<ACLAction> | undefined;
  projectMonitoring?: Array<ACLAction> | undefined;
  projectOIDCToken?: Array<ACLAction> | undefined;
  projectPermissions?: Array<ACLAction> | undefined;
  projectProductionBranch?: Array<ACLAction> | undefined;
  projectProtectionBypass?: Array<ACLAction> | undefined;
  projectRollingRelease?: Array<ACLAction> | undefined;
  projectSupportCase?: Array<ACLAction> | undefined;
  projectSupportCaseComment?: Array<ACLAction> | undefined;
  projectTier?: Array<ACLAction> | undefined;
  projectTransfer?: Array<ACLAction> | undefined;
  projectTransferOut?: Array<ACLAction> | undefined;
  projectUsage?: Array<ACLAction> | undefined;
  seawallConfig?: Array<ACLAction> | undefined;
  sharedEnvVarConnection?: Array<ACLAction> | undefined;
  skewProtection?: Array<ACLAction> | undefined;
  analytics?: Array<ACLAction> | undefined;
  trustedIps?: Array<ACLAction> | undefined;
  v0Chat?: Array<ACLAction> | undefined;
  webAnalytics?: Array<ACLAction> | undefined;
};

export type LastRollbackTarget = {};

export const JobStatus = {
  Succeeded: "succeeded",
  Failed: "failed",
  Skipped: "skipped",
  Pending: "pending",
  InProgress: "in-progress",
} as const;
export type JobStatus = ClosedEnum<typeof JobStatus>;

export const UpdateProjectDataCacheProjectsResponse200Type = {
  Promote: "promote",
  Rollback: "rollback",
} as const;
export type UpdateProjectDataCacheProjectsResponse200Type = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsResponse200Type
>;

export type LastAliasRequest = {
  fromDeploymentId: string;
  toDeploymentId: string;
  /**
   * If rolling back from a rolling release, fromDeploymentId captures the "base" of that rolling release, and fromRollingReleaseId captures the "target" of that rolling release.
   */
  fromRollingReleaseId?: string | undefined;
  jobStatus: JobStatus;
  requestedAt: number;
  type: UpdateProjectDataCacheProjectsResponse200Type;
};

export const ProtectionBypassScope = {
  AutomationBypass: "automation-bypass",
} as const;
export type ProtectionBypassScope = ClosedEnum<typeof ProtectionBypassScope>;

export type ProtectionBypass2 = {
  createdAt: number;
  createdBy: string;
  scope: ProtectionBypassScope;
};

export const UpdateProjectDataCacheProtectionBypassScope = {
  IntegrationAutomationBypass: "integration-automation-bypass",
} as const;
export type UpdateProjectDataCacheProtectionBypassScope = ClosedEnum<
  typeof UpdateProjectDataCacheProtectionBypassScope
>;

export type ProtectionBypass1 = {
  createdAt: number;
  createdBy: string;
  scope: UpdateProjectDataCacheProtectionBypassScope;
  integrationId: string;
  configurationId: string;
};

export type ProtectionBypass = ProtectionBypass1 | ProtectionBypass2;

export const UpdateProjectDataCacheTrustedIpsDeploymentType = {
  Preview: "preview",
  Production: "production",
  All: "all",
  ProdDeploymentUrlsAndAllPreviews: "prod_deployment_urls_and_all_previews",
  AllExceptCustomDomains: "all_except_custom_domains",
} as const;
export type UpdateProjectDataCacheTrustedIpsDeploymentType = ClosedEnum<
  typeof UpdateProjectDataCacheTrustedIpsDeploymentType
>;

export type TrustedIps2 = {
  deploymentType: UpdateProjectDataCacheTrustedIpsDeploymentType;
};

export const TrustedIpsDeploymentType = {
  Preview: "preview",
  Production: "production",
  All: "all",
  ProdDeploymentUrlsAndAllPreviews: "prod_deployment_urls_and_all_previews",
  AllExceptCustomDomains: "all_except_custom_domains",
} as const;
export type TrustedIpsDeploymentType = ClosedEnum<
  typeof TrustedIpsDeploymentType
>;

export type UpdateProjectDataCacheTrustedIpsAddresses = {
  value: string;
  note?: string | undefined;
};

export const UpdateProjectDataCacheTrustedIpsProtectionMode = {
  Additional: "additional",
  Exclusive: "exclusive",
} as const;
export type UpdateProjectDataCacheTrustedIpsProtectionMode = ClosedEnum<
  typeof UpdateProjectDataCacheTrustedIpsProtectionMode
>;

export type TrustedIps1 = {
  deploymentType: TrustedIpsDeploymentType;
  addresses: Array<UpdateProjectDataCacheTrustedIpsAddresses>;
  protectionMode: UpdateProjectDataCacheTrustedIpsProtectionMode;
};

export type UpdateProjectDataCacheTrustedIps = TrustedIps1 | TrustedIps2;

export type GitComments = {
  /**
   * Whether the Vercel bot should comment on PRs
   */
  onPullRequest: boolean;
  /**
   * Whether the Vercel bot should comment on commits
   */
  onCommit: boolean;
};

/**
 * Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
 */
export const CreateDeployments = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
 */
export type CreateDeployments = ClosedEnum<typeof CreateDeployments>;

export type GitProviderOptions = {
  /**
   * Whether the Vercel bot should automatically create GitHub deployments https://docs.github.com/en/rest/deployments/deployments#about-deployments NOTE: repository-dispatch events should be used instead
   */
  createDeployments: CreateDeployments;
  /**
   * Whether the Vercel bot should not automatically create GitHub repository-dispatch events on deployment events. https://vercel.com/docs/git/vercel-for-github#repository-dispatch-events
   */
  disableRepositoryDispatchEvents?: boolean | undefined;
  /**
   * Whether the project requires commits to be signed before deployments will be created.
   */
  requireVerifiedCommits?: boolean | undefined;
};

export type UpdateProjectDataCacheWebAnalytics = {
  id: string;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  enabledAt?: number | undefined;
  hasData?: boolean | undefined;
};

export const UpdateProjectDataCacheProjectsResponseAction = {
  Log: "log",
  Challenge: "challenge",
  Deny: "deny",
} as const;
export type UpdateProjectDataCacheProjectsResponseAction = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsResponseAction
>;

export type BotFilter = {
  active: boolean;
  action?: UpdateProjectDataCacheProjectsResponseAction | undefined;
};

export const UpdateProjectDataCacheProjectsResponse200Action = {
  Log: "log",
  Challenge: "challenge",
  Deny: "deny",
} as const;
export type UpdateProjectDataCacheProjectsResponse200Action = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsResponse200Action
>;

export type UpdateProjectDataCacheAiBots = {
  active: boolean;
  action?: UpdateProjectDataCacheProjectsResponse200Action | undefined;
};

export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction = {
  Log: "log",
  Challenge: "challenge",
  Deny: "deny",
} as const;
export type UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction =
  ClosedEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction
  >;

export type UpdateProjectDataCacheOwasp = {
  active: boolean;
  action?:
    | UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction
    | undefined;
};

export type UpdateProjectDataCacheManagedRules = {
  botFilter: BotFilter;
  aiBots: UpdateProjectDataCacheAiBots;
  owasp: UpdateProjectDataCacheOwasp;
};

export type UpdateProjectDataCacheSecurity = {
  attackModeEnabled?: boolean | undefined;
  attackModeUpdatedAt?: number | undefined;
  firewallEnabled?: boolean | undefined;
  firewallUpdatedAt?: number | undefined;
  attackModeActiveUntil?: number | null | undefined;
  firewallConfigVersion?: number | undefined;
  firewallSeawallEnabled?: boolean | undefined;
  ja3Enabled?: boolean | undefined;
  ja4Enabled?: boolean | undefined;
  firewallBypassIps?: Array<string> | undefined;
  managedRules?: UpdateProjectDataCacheManagedRules | null | undefined;
  botIdEnabled?: boolean | undefined;
};

/**
 * - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
 */
export const UpdateProjectDataCacheIssuerMode = {
  Team: "team",
  Global: "global",
} as const;
/**
 * - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
 */
export type UpdateProjectDataCacheIssuerMode = ClosedEnum<
  typeof UpdateProjectDataCacheIssuerMode
>;

export type UpdateProjectDataCacheOidcTokenConfig = {
  /**
   * Whether or not to generate OpenID Connect JSON Web Tokens.
   */
  enabled?: boolean | undefined;
  /**
   * - team: `https://oidc.vercel.com/[team_slug]` - global: `https://oidc.vercel.com`
   */
  issuerMode?: UpdateProjectDataCacheIssuerMode | undefined;
};

export const UpdateProjectDataCacheTier = {
  Standard: "standard",
  Advanced: "advanced",
  Critical: "critical",
} as const;
export type UpdateProjectDataCacheTier = ClosedEnum<
  typeof UpdateProjectDataCacheTier
>;

export type Features = {
  webAnalytics?: boolean | undefined;
};

export type UpdateProjectDataCacheHistory = {
  scanner: string;
  reason: string;
  by: string;
  byId: string;
  at: number;
};

export const UpdateProjectDataCacheProjectsAction = {
  Blocked: "blocked",
} as const;
export type UpdateProjectDataCacheProjectsAction = ClosedEnum<
  typeof UpdateProjectDataCacheProjectsAction
>;

export type Block = {
  action: UpdateProjectDataCacheProjectsAction;
  reason: string;
  statusCode: number;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

export const UpdateProjectDataCacheBlockHistoryProjectsResponseAction = {
  RouteUnblocked: "route-unblocked",
} as const;
export type UpdateProjectDataCacheBlockHistoryProjectsResponseAction =
  ClosedEnum<typeof UpdateProjectDataCacheBlockHistoryProjectsResponseAction>;

export const UpdateProjectDataCacheHasProjectsResponseType = {
  Host: "host",
} as const;
export type UpdateProjectDataCacheHasProjectsResponseType = ClosedEnum<
  typeof UpdateProjectDataCacheHasProjectsResponseType
>;

export type UpdateProjectDataCacheHasProjectsValue = {
  eq: string;
};

export type UpdateProjectDataCacheHas2 = {
  type: UpdateProjectDataCacheHasProjectsResponseType;
  value: UpdateProjectDataCacheHasProjectsValue;
};

export const UpdateProjectDataCacheHasProjectsType = {
  Header: "header",
} as const;
export type UpdateProjectDataCacheHasProjectsType = ClosedEnum<
  typeof UpdateProjectDataCacheHasProjectsType
>;

export const UpdateProjectDataCacheHasProjectsKey = {
  XVercelIpCountry: "x-vercel-ip-country",
} as const;
export type UpdateProjectDataCacheHasProjectsKey = ClosedEnum<
  typeof UpdateProjectDataCacheHasProjectsKey
>;

export type UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue = {
  eq: string;
};

export type UpdateProjectDataCacheHas1 = {
  type: UpdateProjectDataCacheHasProjectsType;
  key: UpdateProjectDataCacheHasProjectsKey;
  value: UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue;
};

export type RouteHas = UpdateProjectDataCacheHas1 | UpdateProjectDataCacheHas2;

export const UpdateProjectDataCacheRouteAction = {
  BlockLegalCwc: "block_legal_cwc",
} as const;
export type UpdateProjectDataCacheRouteAction = ClosedEnum<
  typeof UpdateProjectDataCacheRouteAction
>;

export type RouteMitigate = {
  action: UpdateProjectDataCacheRouteAction;
};

export type UpdateProjectDataCacheRoute2 = {
  has: Array<UpdateProjectDataCacheHas1 | UpdateProjectDataCacheHas2>;
  mitigate: RouteMitigate;
  src?: string | undefined;
};

export type UpdateProjectDataCacheRoute1 = {
  src: string;
  status: number;
};

export type BlockHistoryRoute =
  | UpdateProjectDataCacheRoute1
  | UpdateProjectDataCacheRoute2;

export type BlockHistory4 = {
  action: UpdateProjectDataCacheBlockHistoryProjectsResponseAction;
  route: UpdateProjectDataCacheRoute1 | UpdateProjectDataCacheRoute2;
  statusCode?: number | undefined;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

export const UpdateProjectDataCacheBlockHistoryProjectsAction = {
  RouteBlocked: "route-blocked",
} as const;
export type UpdateProjectDataCacheBlockHistoryProjectsAction = ClosedEnum<
  typeof UpdateProjectDataCacheBlockHistoryProjectsAction
>;

export const UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType = {
  Host: "host",
} as const;
export type UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType
  >;

export type UpdateProjectDataCacheHasProjectsResponse200Value = {
  eq: string;
};

export type UpdateProjectDataCacheHasProjects2 = {
  type: UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType;
  value: UpdateProjectDataCacheHasProjectsResponse200Value;
};

export const UpdateProjectDataCacheHasProjectsResponse200Type = {
  Header: "header",
} as const;
export type UpdateProjectDataCacheHasProjectsResponse200Type = ClosedEnum<
  typeof UpdateProjectDataCacheHasProjectsResponse200Type
>;

export const UpdateProjectDataCacheHasKey = {
  XVercelIpCountry: "x-vercel-ip-country",
} as const;
export type UpdateProjectDataCacheHasKey = ClosedEnum<
  typeof UpdateProjectDataCacheHasKey
>;

export type UpdateProjectDataCacheHasProjectsResponseValue = {
  eq: string;
};

export type UpdateProjectDataCacheHasProjects1 = {
  type: UpdateProjectDataCacheHasProjectsResponse200Type;
  key: UpdateProjectDataCacheHasKey;
  value: UpdateProjectDataCacheHasProjectsResponseValue;
};

export type UpdateProjectDataCacheRouteHas =
  | UpdateProjectDataCacheHasProjects1
  | UpdateProjectDataCacheHasProjects2;

export const RouteAction = {
  BlockLegalCwc: "block_legal_cwc",
} as const;
export type RouteAction = ClosedEnum<typeof RouteAction>;

export type UpdateProjectDataCacheRouteMitigate = {
  action: RouteAction;
};

export type Route2 = {
  has: Array<
    UpdateProjectDataCacheHasProjects1 | UpdateProjectDataCacheHasProjects2
  >;
  mitigate: UpdateProjectDataCacheRouteMitigate;
  src?: string | undefined;
};

export type Route1 = {
  src: string;
  status: number;
};

export type Route = Route1 | Route2;

export type BlockHistory3 = {
  action: UpdateProjectDataCacheBlockHistoryProjectsAction;
  route: Route1 | Route2;
  reason: string;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

export const UpdateProjectDataCacheBlockHistoryAction = {
  Unblocked: "unblocked",
} as const;
export type UpdateProjectDataCacheBlockHistoryAction = ClosedEnum<
  typeof UpdateProjectDataCacheBlockHistoryAction
>;

export type BlockHistory2 = {
  action: UpdateProjectDataCacheBlockHistoryAction;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

export const BlockHistoryAction = {
  Blocked: "blocked",
} as const;
export type BlockHistoryAction = ClosedEnum<typeof BlockHistoryAction>;

export type BlockHistory1 = {
  action: BlockHistoryAction;
  reason: string;
  statusCode: number;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

export type UpdateProjectDataCacheBlockHistory =
  | BlockHistory1
  | BlockHistory3
  | BlockHistory4
  | BlockHistory2;

export type UpdateProjectDataCacheAbuse = {
  scanner?: string | undefined;
  history: Array<UpdateProjectDataCacheHistory>;
  updatedAt: number;
  block?: Block | undefined;
  blockHistory?:
    | Array<BlockHistory1 | BlockHistory3 | BlockHistory4 | BlockHistory2>
    | undefined;
  interstitial?: boolean | undefined;
};

export const UpdateProjectDataCacheHasType = {
  Host: "host",
} as const;
export type UpdateProjectDataCacheHasType = ClosedEnum<
  typeof UpdateProjectDataCacheHasType
>;

export type HasValue = {
  eq: string;
};

export type Has2 = {
  type: UpdateProjectDataCacheHasType;
  value: HasValue;
};

export const HasType = {
  Header: "header",
} as const;
export type HasType = ClosedEnum<typeof HasType>;

export const Key = {
  XVercelIpCountry: "x-vercel-ip-country",
} as const;
export type Key = ClosedEnum<typeof Key>;

export type UpdateProjectDataCacheHasValue = {
  eq: string;
};

export type Has1 = {
  type: HasType;
  key: Key;
  value: UpdateProjectDataCacheHasValue;
};

export type Has = Has1 | Has2;

export const InternalRoutesAction = {
  BlockLegalCwc: "block_legal_cwc",
} as const;
export type InternalRoutesAction = ClosedEnum<typeof InternalRoutesAction>;

export type UpdateProjectDataCacheInternalRoutesMitigate = {
  action: InternalRoutesAction;
};

export type InternalRoutes2 = {
  has: Array<Has1 | Has2>;
  mitigate: UpdateProjectDataCacheInternalRoutesMitigate;
  src?: string | undefined;
};

export type InternalRoutes1 = {
  src: string;
  status: number;
};

export type InternalRoutes = InternalRoutes1 | InternalRoutes2;

export const UpdateProjectDataCacheAction = {
  Cancel: "cancel",
  Accept: "accept",
  Delete: "delete",
} as const;
export type UpdateProjectDataCacheAction = ClosedEnum<
  typeof UpdateProjectDataCacheAction
>;

export type UpdateProjectDataCacheValuePreviousValue =
  | string
  | number
  | boolean;

export type UpdateProjectDataCacheValueCurrentValue = string | number | boolean;

export type Value4 = {
  previousValue: string | number | boolean;
  currentValue: string | number | boolean;
};

export type UpdateProjectDataCacheValue = Value4 | string | number | boolean;

export type UpdateProjectDataCacheDismissedToasts = {
  key: string;
  dismissedAt: number;
  action: UpdateProjectDataCacheAction;
  value: Value4 | string | number | boolean | null;
};

export type UpdateProjectDataCacheResponseBody = {
  accountId: string;
  analytics?: Analytics | undefined;
  speedInsights?: SpeedInsights | undefined;
  autoExposeSystemEnvs?: boolean | undefined;
  autoAssignCustomDomains?: boolean | undefined;
  autoAssignCustomDomainsUpdatedBy?: string | undefined;
  buildCommand?: string | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  connectConfigurations?:
    | Array<UpdateProjectDataCacheConnectConfigurations>
    | null
    | undefined;
  connectConfigurationId?: string | null | undefined;
  connectBuildsEnabled?: boolean | undefined;
  passiveConnectConfigurationId?: string | null | undefined;
  createdAt?: number | undefined;
  customerSupportCodeVisibility?: boolean | undefined;
  crons?: Crons | undefined;
  dataCache?: UpdateProjectDataCacheDataCache | undefined;
  /**
   * Retention policies for deployments. These are enforced at the project level, but we also maintain an instance of this at the team level as a default policy that gets applied to new projects.
   */
  deploymentExpiration?: DeploymentExpiration | null | undefined;
  devCommand?: string | null | undefined;
  directoryListing: boolean;
  installCommand?: string | null | undefined;
  env?: Array<UpdateProjectDataCacheEnv> | undefined;
  customEnvironments?: Array<CustomEnvironments> | undefined;
  framework?: UpdateProjectDataCacheFramework | null | undefined;
  gitForkProtection?: boolean | undefined;
  gitLFS?: boolean | undefined;
  id: string;
  ipBuckets?: Array<UpdateProjectDataCacheIpBuckets> | undefined;
  latestDeployments?: Array<LatestDeployments> | undefined;
  link?: Link4 | Link5 | Link3 | Link1 | Link2 | undefined;
  microfrontends?:
    | UpdateProjectDataCacheMicrofrontends1
    | UpdateProjectDataCacheMicrofrontends2
    | UpdateProjectDataCacheMicrofrontends3
    | undefined;
  name: string;
  nodeVersion: UpdateProjectDataCacheNodeVersion;
  optionsAllowlist?: UpdateProjectDataCacheOptionsAllowlist | null | undefined;
  outputDirectory?: string | null | undefined;
  passwordProtection?:
    | UpdateProjectDataCachePasswordProtection
    | null
    | undefined;
  productionDeploymentsFastLane?: boolean | undefined;
  publicSource?: boolean | null | undefined;
  resourceConfig: UpdateProjectDataCacheResourceConfig;
  /**
   * Description of why a project was rolled back, and by whom. Note that lastAliasRequest contains the from/to details of the rollback.
   */
  rollbackDescription?: RollbackDescription | undefined;
  /**
   * Project-level rolling release configuration that defines how deployments should be gradually rolled out
   */
  rollingRelease?: RollingRelease | null | undefined;
  defaultResourceConfig: DefaultResourceConfig;
  rootDirectory?: string | null | undefined;
  serverlessFunctionZeroConfigFailover?: boolean | undefined;
  skewProtectionBoundaryAt?: number | undefined;
  skewProtectionMaxAge?: number | undefined;
  skipGitConnectDuringLink?: boolean | undefined;
  staticIps?: UpdateProjectDataCacheStaticIps | undefined;
  sourceFilesOutsideRootDirectory?: boolean | undefined;
  enableAffectedProjectsDeployments?: boolean | undefined;
  ssoProtection?: UpdateProjectDataCacheSsoProtection | null | undefined;
  targets?: { [k: string]: Targets | null } | undefined;
  transferCompletedAt?: number | undefined;
  transferStartedAt?: number | undefined;
  transferToAccountId?: string | undefined;
  transferredFromAccountId?: string | undefined;
  updatedAt?: number | undefined;
  live?: boolean | undefined;
  enablePreviewFeedback?: boolean | null | undefined;
  enableProductionFeedback?: boolean | null | undefined;
  permissions?: UpdateProjectDataCachePermissions | undefined;
  lastRollbackTarget?: LastRollbackTarget | null | undefined;
  lastAliasRequest?: LastAliasRequest | null | undefined;
  protectionBypass?:
    | { [k: string]: ProtectionBypass1 | ProtectionBypass2 }
    | undefined;
  hasActiveBranches?: boolean | undefined;
  trustedIps?: TrustedIps1 | TrustedIps2 | null | undefined;
  gitComments?: GitComments | undefined;
  gitProviderOptions?: GitProviderOptions | undefined;
  paused?: boolean | undefined;
  concurrencyBucketName?: string | undefined;
  webAnalytics?: UpdateProjectDataCacheWebAnalytics | undefined;
  security?: UpdateProjectDataCacheSecurity | undefined;
  oidcTokenConfig?: UpdateProjectDataCacheOidcTokenConfig | undefined;
  tier?: UpdateProjectDataCacheTier | undefined;
  features?: Features | undefined;
  v0?: boolean | undefined;
  abuse?: UpdateProjectDataCacheAbuse | undefined;
  internalRoutes?: Array<InternalRoutes1 | InternalRoutes2> | undefined;
  hasDeployments?: boolean | undefined;
  dismissedToasts?: Array<UpdateProjectDataCacheDismissedToasts> | undefined;
};

/** @internal */
export const UpdateProjectDataCacheRequestBody$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  disabled: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheRequestBody$Outbound = {
  disabled?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheRequestBody$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRequestBody
> = z.object({
  disabled: z.boolean().optional(),
});

export function updateProjectDataCacheRequestBodyToJSON(
  updateProjectDataCacheRequestBody: UpdateProjectDataCacheRequestBody,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRequestBody$outboundSchema.parse(
      updateProjectDataCacheRequestBody,
    ),
  );
}
export function updateProjectDataCacheRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheRequest$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  projectId: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  RequestBody: z.lazy(() => UpdateProjectDataCacheRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateProjectDataCacheRequest$Outbound = {
  projectId: string;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody: UpdateProjectDataCacheRequestBody$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheRequest$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRequest$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRequest
> = z.object({
  projectId: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() => UpdateProjectDataCacheRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateProjectDataCacheRequestToJSON(
  updateProjectDataCacheRequest: UpdateProjectDataCacheRequest,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRequest$outboundSchema.parse(
      updateProjectDataCacheRequest,
    ),
  );
}
export function updateProjectDataCacheRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRequest' from JSON`,
  );
}

/** @internal */
export const Analytics$inboundSchema: z.ZodType<
  Analytics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  canceledAt: z.nullable(z.number()).optional(),
  disabledAt: z.number(),
  enabledAt: z.number(),
  paidAt: z.number().optional(),
  sampleRatePercent: z.nullable(z.number()).optional(),
  spendLimitInDollars: z.nullable(z.number()).optional(),
});
/** @internal */
export type Analytics$Outbound = {
  id: string;
  canceledAt?: number | null | undefined;
  disabledAt: number;
  enabledAt: number;
  paidAt?: number | undefined;
  sampleRatePercent?: number | null | undefined;
  spendLimitInDollars?: number | null | undefined;
};

/** @internal */
export const Analytics$outboundSchema: z.ZodType<
  Analytics$Outbound,
  z.ZodTypeDef,
  Analytics
> = z.object({
  id: z.string(),
  canceledAt: z.nullable(z.number()).optional(),
  disabledAt: z.number(),
  enabledAt: z.number(),
  paidAt: z.number().optional(),
  sampleRatePercent: z.nullable(z.number()).optional(),
  spendLimitInDollars: z.nullable(z.number()).optional(),
});

export function analyticsToJSON(analytics: Analytics): string {
  return JSON.stringify(Analytics$outboundSchema.parse(analytics));
}
export function analyticsFromJSON(
  jsonString: string,
): SafeParseResult<Analytics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Analytics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Analytics' from JSON`,
  );
}

/** @internal */
export const SpeedInsights$inboundSchema: z.ZodType<
  SpeedInsights,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  enabledAt: z.number().optional(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  hasData: z.boolean().optional(),
  paidAt: z.number().optional(),
});
/** @internal */
export type SpeedInsights$Outbound = {
  id: string;
  enabledAt?: number | undefined;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  hasData?: boolean | undefined;
  paidAt?: number | undefined;
};

/** @internal */
export const SpeedInsights$outboundSchema: z.ZodType<
  SpeedInsights$Outbound,
  z.ZodTypeDef,
  SpeedInsights
> = z.object({
  id: z.string(),
  enabledAt: z.number().optional(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  hasData: z.boolean().optional(),
  paidAt: z.number().optional(),
});

export function speedInsightsToJSON(speedInsights: SpeedInsights): string {
  return JSON.stringify(SpeedInsights$outboundSchema.parse(speedInsights));
}
export function speedInsightsFromJSON(
  jsonString: string,
): SafeParseResult<SpeedInsights, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SpeedInsights$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SpeedInsights' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheEnvId2$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheEnvId2
> = z.nativeEnum(UpdateProjectDataCacheEnvId2);
/** @internal */
export const UpdateProjectDataCacheEnvId2$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheEnvId2
> = UpdateProjectDataCacheEnvId2$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheEnvId$inboundSchema: z.ZodType<
  UpdateProjectDataCacheEnvId,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), UpdateProjectDataCacheEnvId2$inboundSchema]);
/** @internal */
export type UpdateProjectDataCacheEnvId$Outbound = string | string;

/** @internal */
export const UpdateProjectDataCacheEnvId$outboundSchema: z.ZodType<
  UpdateProjectDataCacheEnvId$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheEnvId
> = z.union([z.string(), UpdateProjectDataCacheEnvId2$outboundSchema]);

export function updateProjectDataCacheEnvIdToJSON(
  updateProjectDataCacheEnvId: UpdateProjectDataCacheEnvId,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheEnvId$outboundSchema.parse(
      updateProjectDataCacheEnvId,
    ),
  );
}
export function updateProjectDataCacheEnvIdFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheEnvId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheEnvId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheEnvId' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheAws$inboundSchema: z.ZodType<
  UpdateProjectDataCacheAws,
  z.ZodTypeDef,
  unknown
> = z.object({
  subnetIds: z.array(z.string()),
  securityGroupId: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheAws$Outbound = {
  subnetIds: Array<string>;
  securityGroupId: string;
};

/** @internal */
export const UpdateProjectDataCacheAws$outboundSchema: z.ZodType<
  UpdateProjectDataCacheAws$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheAws
> = z.object({
  subnetIds: z.array(z.string()),
  securityGroupId: z.string(),
});

export function updateProjectDataCacheAwsToJSON(
  updateProjectDataCacheAws: UpdateProjectDataCacheAws,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheAws$outboundSchema.parse(updateProjectDataCacheAws),
  );
}
export function updateProjectDataCacheAwsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheAws, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheAws$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheAws' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheConnectConfigurations$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheConnectConfigurations,
    z.ZodTypeDef,
    unknown
  > = z.object({
    envId: z.union([z.string(), UpdateProjectDataCacheEnvId2$inboundSchema]),
    connectConfigurationId: z.string(),
    dc: z.string().optional(),
    passive: z.boolean(),
    buildsEnabled: z.boolean(),
    aws: z.lazy(() => UpdateProjectDataCacheAws$inboundSchema).optional(),
    createdAt: z.number(),
    updatedAt: z.number(),
  });
/** @internal */
export type UpdateProjectDataCacheConnectConfigurations$Outbound = {
  envId: string | string;
  connectConfigurationId: string;
  dc?: string | undefined;
  passive: boolean;
  buildsEnabled: boolean;
  aws?: UpdateProjectDataCacheAws$Outbound | undefined;
  createdAt: number;
  updatedAt: number;
};

/** @internal */
export const UpdateProjectDataCacheConnectConfigurations$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheConnectConfigurations$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheConnectConfigurations
  > = z.object({
    envId: z.union([z.string(), UpdateProjectDataCacheEnvId2$outboundSchema]),
    connectConfigurationId: z.string(),
    dc: z.string().optional(),
    passive: z.boolean(),
    buildsEnabled: z.boolean(),
    aws: z.lazy(() => UpdateProjectDataCacheAws$outboundSchema).optional(),
    createdAt: z.number(),
    updatedAt: z.number(),
  });

export function updateProjectDataCacheConnectConfigurationsToJSON(
  updateProjectDataCacheConnectConfigurations:
    UpdateProjectDataCacheConnectConfigurations,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheConnectConfigurations$outboundSchema.parse(
      updateProjectDataCacheConnectConfigurations,
    ),
  );
}
export function updateProjectDataCacheConnectConfigurationsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheConnectConfigurations,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheConnectConfigurations$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheConnectConfigurations' from JSON`,
  );
}

/** @internal */
export const Definitions$inboundSchema: z.ZodType<
  Definitions,
  z.ZodTypeDef,
  unknown
> = z.object({
  host: z.string(),
  path: z.string(),
  schedule: z.string(),
});
/** @internal */
export type Definitions$Outbound = {
  host: string;
  path: string;
  schedule: string;
};

/** @internal */
export const Definitions$outboundSchema: z.ZodType<
  Definitions$Outbound,
  z.ZodTypeDef,
  Definitions
> = z.object({
  host: z.string(),
  path: z.string(),
  schedule: z.string(),
});

export function definitionsToJSON(definitions: Definitions): string {
  return JSON.stringify(Definitions$outboundSchema.parse(definitions));
}
export function definitionsFromJSON(
  jsonString: string,
): SafeParseResult<Definitions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Definitions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Definitions' from JSON`,
  );
}

/** @internal */
export const Crons$inboundSchema: z.ZodType<Crons, z.ZodTypeDef, unknown> = z
  .object({
    enabledAt: z.number(),
    disabledAt: z.nullable(z.number()),
    updatedAt: z.number(),
    deploymentId: z.nullable(z.string()),
    definitions: z.array(z.lazy(() => Definitions$inboundSchema)),
  });
/** @internal */
export type Crons$Outbound = {
  enabledAt: number;
  disabledAt: number | null;
  updatedAt: number;
  deploymentId: string | null;
  definitions: Array<Definitions$Outbound>;
};

/** @internal */
export const Crons$outboundSchema: z.ZodType<
  Crons$Outbound,
  z.ZodTypeDef,
  Crons
> = z.object({
  enabledAt: z.number(),
  disabledAt: z.nullable(z.number()),
  updatedAt: z.number(),
  deploymentId: z.nullable(z.string()),
  definitions: z.array(z.lazy(() => Definitions$outboundSchema)),
});

export function cronsToJSON(crons: Crons): string {
  return JSON.stringify(Crons$outboundSchema.parse(crons));
}
export function cronsFromJSON(
  jsonString: string,
): SafeParseResult<Crons, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Crons$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Crons' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheDataCache$inboundSchema: z.ZodType<
  UpdateProjectDataCacheDataCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  userDisabled: z.boolean(),
  storageSizeBytes: z.nullable(z.number()).optional(),
  unlimited: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheDataCache$Outbound = {
  userDisabled: boolean;
  storageSizeBytes?: number | null | undefined;
  unlimited?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheDataCache$outboundSchema: z.ZodType<
  UpdateProjectDataCacheDataCache$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheDataCache
> = z.object({
  userDisabled: z.boolean(),
  storageSizeBytes: z.nullable(z.number()).optional(),
  unlimited: z.boolean().optional(),
});

export function updateProjectDataCacheDataCacheToJSON(
  updateProjectDataCacheDataCache: UpdateProjectDataCacheDataCache,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheDataCache$outboundSchema.parse(
      updateProjectDataCacheDataCache,
    ),
  );
}
export function updateProjectDataCacheDataCacheFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheDataCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheDataCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheDataCache' from JSON`,
  );
}

/** @internal */
export const DeploymentExpiration$inboundSchema: z.ZodType<
  DeploymentExpiration,
  z.ZodTypeDef,
  unknown
> = z.object({
  expirationDays: z.number().optional(),
  expirationDaysProduction: z.number().optional(),
  expirationDaysCanceled: z.number().optional(),
  expirationDaysErrored: z.number().optional(),
  deploymentsToKeep: z.number().optional(),
});
/** @internal */
export type DeploymentExpiration$Outbound = {
  expirationDays?: number | undefined;
  expirationDaysProduction?: number | undefined;
  expirationDaysCanceled?: number | undefined;
  expirationDaysErrored?: number | undefined;
  deploymentsToKeep?: number | undefined;
};

/** @internal */
export const DeploymentExpiration$outboundSchema: z.ZodType<
  DeploymentExpiration$Outbound,
  z.ZodTypeDef,
  DeploymentExpiration
> = z.object({
  expirationDays: z.number().optional(),
  expirationDaysProduction: z.number().optional(),
  expirationDaysCanceled: z.number().optional(),
  expirationDaysErrored: z.number().optional(),
  deploymentsToKeep: z.number().optional(),
});

export function deploymentExpirationToJSON(
  deploymentExpiration: DeploymentExpiration,
): string {
  return JSON.stringify(
    DeploymentExpiration$outboundSchema.parse(deploymentExpiration),
  );
}
export function deploymentExpirationFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentExpiration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentExpiration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentExpiration' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheTarget2$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTarget2
> = z.nativeEnum(UpdateProjectDataCacheTarget2);
/** @internal */
export const UpdateProjectDataCacheTarget2$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTarget2
> = UpdateProjectDataCacheTarget2$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheTarget1$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTarget1
> = z.nativeEnum(UpdateProjectDataCacheTarget1);
/** @internal */
export const UpdateProjectDataCacheTarget1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTarget1
> = UpdateProjectDataCacheTarget1$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheTarget$inboundSchema: z.ZodType<
  UpdateProjectDataCacheTarget,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.array(UpdateProjectDataCacheTarget1$inboundSchema),
  UpdateProjectDataCacheTarget2$inboundSchema,
]);
/** @internal */
export type UpdateProjectDataCacheTarget$Outbound = Array<string> | string;

/** @internal */
export const UpdateProjectDataCacheTarget$outboundSchema: z.ZodType<
  UpdateProjectDataCacheTarget$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheTarget
> = z.union([
  z.array(UpdateProjectDataCacheTarget1$outboundSchema),
  UpdateProjectDataCacheTarget2$outboundSchema,
]);

export function updateProjectDataCacheTargetToJSON(
  updateProjectDataCacheTarget: UpdateProjectDataCacheTarget,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheTarget$outboundSchema.parse(
      updateProjectDataCacheTarget,
    ),
  );
}
export function updateProjectDataCacheTargetFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheTarget, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheTarget$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheTarget' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONType
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONType,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONType
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type$inboundSchema;

/** @internal */
export const ContentHint15$inboundSchema: z.ZodType<
  ContentHint15,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type$inboundSchema,
  projectId: z.string(),
});
/** @internal */
export type ContentHint15$Outbound = {
  type: string;
  projectId: string;
};

/** @internal */
export const ContentHint15$outboundSchema: z.ZodType<
  ContentHint15$Outbound,
  z.ZodTypeDef,
  ContentHint15
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv15Type$outboundSchema,
  projectId: z.string(),
});

export function contentHint15ToJSON(contentHint15: ContentHint15): string {
  return JSON.stringify(ContentHint15$outboundSchema.parse(contentHint15));
}
export function contentHint15FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint15, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint15$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint15' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type$inboundSchema;

/** @internal */
export const ContentHint14$inboundSchema: z.ZodType<
  ContentHint14,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type$inboundSchema,
  storeId: z.string(),
  integrationId: z.string(),
  integrationProductId: z.string(),
  integrationConfigurationId: z.string(),
});
/** @internal */
export type ContentHint14$Outbound = {
  type: string;
  storeId: string;
  integrationId: string;
  integrationProductId: string;
  integrationConfigurationId: string;
};

/** @internal */
export const ContentHint14$outboundSchema: z.ZodType<
  ContentHint14$Outbound,
  z.ZodTypeDef,
  ContentHint14
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv14Type$outboundSchema,
  storeId: z.string(),
  integrationId: z.string(),
  integrationProductId: z.string(),
  integrationConfigurationId: z.string(),
});

export function contentHint14ToJSON(contentHint14: ContentHint14): string {
  return JSON.stringify(ContentHint14$outboundSchema.parse(contentHint14));
}
export function contentHint14FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint14, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint14$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint14' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type$inboundSchema;

/** @internal */
export const ContentHint13$inboundSchema: z.ZodType<
  ContentHint13,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint13$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint13$outboundSchema: z.ZodType<
  ContentHint13$Outbound,
  z.ZodTypeDef,
  ContentHint13
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv13Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint13ToJSON(contentHint13: ContentHint13): string {
  return JSON.stringify(ContentHint13$outboundSchema.parse(contentHint13));
}
export function contentHint13FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint13, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint13$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint13' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type$inboundSchema;

/** @internal */
export const ContentHint12$inboundSchema: z.ZodType<
  ContentHint12,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint12$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint12$outboundSchema: z.ZodType<
  ContentHint12$Outbound,
  z.ZodTypeDef,
  ContentHint12
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv12Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint12ToJSON(contentHint12: ContentHint12): string {
  return JSON.stringify(ContentHint12$outboundSchema.parse(contentHint12));
}
export function contentHint12FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint12, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint12$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint12' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type$inboundSchema;

/** @internal */
export const ContentHint11$inboundSchema: z.ZodType<
  ContentHint11,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint11$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint11$outboundSchema: z.ZodType<
  ContentHint11$Outbound,
  z.ZodTypeDef,
  ContentHint11
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv11Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint11ToJSON(contentHint11: ContentHint11): string {
  return JSON.stringify(ContentHint11$outboundSchema.parse(contentHint11));
}
export function contentHint11FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint11, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint11$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint11' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type$inboundSchema;

/** @internal */
export const ContentHint10$inboundSchema: z.ZodType<
  ContentHint10,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint10$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint10$outboundSchema: z.ZodType<
  ContentHint10$Outbound,
  z.ZodTypeDef,
  ContentHint10
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv10Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint10ToJSON(contentHint10: ContentHint10): string {
  return JSON.stringify(ContentHint10$outboundSchema.parse(contentHint10));
}
export function contentHint10FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint10, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint10$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint10' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type$inboundSchema;

/** @internal */
export const ContentHint9$inboundSchema: z.ZodType<
  ContentHint9,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint9$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint9$outboundSchema: z.ZodType<
  ContentHint9$Outbound,
  z.ZodTypeDef,
  ContentHint9
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnv9Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint9ToJSON(contentHint9: ContentHint9): string {
  return JSON.stringify(ContentHint9$outboundSchema.parse(contentHint9));
}
export function contentHint9FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint9, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint9$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint9' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema;

/** @internal */
export const ContentHint8$inboundSchema: z.ZodType<
  ContentHint8,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint8$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint8$outboundSchema: z.ZodType<
  ContentHint8$Outbound,
  z.ZodTypeDef,
  ContentHint8
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyEnvType$outboundSchema,
  storeId: z.string(),
});

export function contentHint8ToJSON(contentHint8: ContentHint8): string {
  return JSON.stringify(ContentHint8$outboundSchema.parse(contentHint8));
}
export function contentHint8FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint8, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint8$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint8' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const ContentHint7$inboundSchema: z.ZodType<
  ContentHint7,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint7$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint7$outboundSchema: z.ZodType<
  ContentHint7$Outbound,
  z.ZodTypeDef,
  ContentHint7
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  storeId: z.string(),
});

export function contentHint7ToJSON(contentHint7: ContentHint7): string {
  return JSON.stringify(ContentHint7$outboundSchema.parse(contentHint7));
}
export function contentHint7FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint7, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint7$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint7' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType
  > = z.nativeEnum(
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType
  > =
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const ContentHint6$inboundSchema: z.ZodType<
  ContentHint6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint6$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint6$outboundSchema: z.ZodType<
  ContentHint6$Outbound,
  z.ZodTypeDef,
  ContentHint6
> = z.object({
  type:
    UpdateProjectDataCacheContentHintProjectsResponse200ApplicationJSONType$outboundSchema,
  storeId: z.string(),
});

export function contentHint6ToJSON(contentHint6: ContentHint6): string {
  return JSON.stringify(ContentHint6$outboundSchema.parse(contentHint6));
}
export function contentHint6FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint6' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200Type
  > = z.nativeEnum(UpdateProjectDataCacheContentHintProjectsResponse200Type);
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponse200Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponse200Type
  > = UpdateProjectDataCacheContentHintProjectsResponse200Type$inboundSchema;

/** @internal */
export const ContentHint5$inboundSchema: z.ZodType<
  ContentHint5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsResponse200Type$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint5$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint5$outboundSchema: z.ZodType<
  ContentHint5$Outbound,
  z.ZodTypeDef,
  ContentHint5
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsResponse200Type$outboundSchema,
  storeId: z.string(),
});

export function contentHint5ToJSON(contentHint5: ContentHint5): string {
  return JSON.stringify(ContentHint5$outboundSchema.parse(contentHint5));
}
export function contentHint5FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint5' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponseType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponseType
  > = z.nativeEnum(UpdateProjectDataCacheContentHintProjectsResponseType);
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsResponseType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheContentHintProjectsResponseType
  > = UpdateProjectDataCacheContentHintProjectsResponseType$inboundSchema;

/** @internal */
export const ContentHint4$inboundSchema: z.ZodType<
  ContentHint4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsResponseType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint4$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint4$outboundSchema: z.ZodType<
  ContentHint4$Outbound,
  z.ZodTypeDef,
  ContentHint4
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsResponseType$outboundSchema,
  storeId: z.string(),
});

export function contentHint4ToJSON(contentHint4: ContentHint4): string {
  return JSON.stringify(ContentHint4$outboundSchema.parse(contentHint4));
}
export function contentHint4FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint4' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintProjectsType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheContentHintProjectsType> = z
    .nativeEnum(UpdateProjectDataCacheContentHintProjectsType);
/** @internal */
export const UpdateProjectDataCacheContentHintProjectsType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheContentHintProjectsType> =
    UpdateProjectDataCacheContentHintProjectsType$inboundSchema;

/** @internal */
export const ContentHint3$inboundSchema: z.ZodType<
  ContentHint3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint3$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint3$outboundSchema: z.ZodType<
  ContentHint3$Outbound,
  z.ZodTypeDef,
  ContentHint3
> = z.object({
  type: UpdateProjectDataCacheContentHintProjectsType$outboundSchema,
  storeId: z.string(),
});

export function contentHint3ToJSON(contentHint3: ContentHint3): string {
  return JSON.stringify(ContentHint3$outboundSchema.parse(contentHint3));
}
export function contentHint3FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint3' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheContentHintType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheContentHintType> = z.nativeEnum(
    UpdateProjectDataCacheContentHintType,
  );
/** @internal */
export const UpdateProjectDataCacheContentHintType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheContentHintType> =
    UpdateProjectDataCacheContentHintType$inboundSchema;

/** @internal */
export const ContentHint2$inboundSchema: z.ZodType<
  ContentHint2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheContentHintType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint2$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint2$outboundSchema: z.ZodType<
  ContentHint2$Outbound,
  z.ZodTypeDef,
  ContentHint2
> = z.object({
  type: UpdateProjectDataCacheContentHintType$outboundSchema,
  storeId: z.string(),
});

export function contentHint2ToJSON(contentHint2: ContentHint2): string {
  return JSON.stringify(ContentHint2$outboundSchema.parse(contentHint2));
}
export function contentHint2FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint2' from JSON`,
  );
}

/** @internal */
export const ContentHintType$inboundSchema: z.ZodNativeEnum<
  typeof ContentHintType
> = z.nativeEnum(ContentHintType);
/** @internal */
export const ContentHintType$outboundSchema: z.ZodNativeEnum<
  typeof ContentHintType
> = ContentHintType$inboundSchema;

/** @internal */
export const ContentHint1$inboundSchema: z.ZodType<
  ContentHint1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ContentHintType$inboundSchema,
  storeId: z.string(),
});
/** @internal */
export type ContentHint1$Outbound = {
  type: string;
  storeId: string;
};

/** @internal */
export const ContentHint1$outboundSchema: z.ZodType<
  ContentHint1$Outbound,
  z.ZodTypeDef,
  ContentHint1
> = z.object({
  type: ContentHintType$outboundSchema,
  storeId: z.string(),
});

export function contentHint1ToJSON(contentHint1: ContentHint1): string {
  return JSON.stringify(ContentHint1$outboundSchema.parse(contentHint1));
}
export function contentHint1FromJSON(
  jsonString: string,
): SafeParseResult<ContentHint1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint1' from JSON`,
  );
}

/** @internal */
export const ContentHint$inboundSchema: z.ZodType<
  ContentHint,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ContentHint14$inboundSchema),
  z.lazy(() => ContentHint1$inboundSchema),
  z.lazy(() => ContentHint2$inboundSchema),
  z.lazy(() => ContentHint3$inboundSchema),
  z.lazy(() => ContentHint4$inboundSchema),
  z.lazy(() => ContentHint5$inboundSchema),
  z.lazy(() => ContentHint6$inboundSchema),
  z.lazy(() => ContentHint7$inboundSchema),
  z.lazy(() => ContentHint8$inboundSchema),
  z.lazy(() => ContentHint9$inboundSchema),
  z.lazy(() => ContentHint10$inboundSchema),
  z.lazy(() => ContentHint11$inboundSchema),
  z.lazy(() => ContentHint12$inboundSchema),
  z.lazy(() => ContentHint13$inboundSchema),
  z.lazy(() => ContentHint15$inboundSchema),
]);
/** @internal */
export type ContentHint$Outbound =
  | ContentHint14$Outbound
  | ContentHint1$Outbound
  | ContentHint2$Outbound
  | ContentHint3$Outbound
  | ContentHint4$Outbound
  | ContentHint5$Outbound
  | ContentHint6$Outbound
  | ContentHint7$Outbound
  | ContentHint8$Outbound
  | ContentHint9$Outbound
  | ContentHint10$Outbound
  | ContentHint11$Outbound
  | ContentHint12$Outbound
  | ContentHint13$Outbound
  | ContentHint15$Outbound;

/** @internal */
export const ContentHint$outboundSchema: z.ZodType<
  ContentHint$Outbound,
  z.ZodTypeDef,
  ContentHint
> = z.union([
  z.lazy(() => ContentHint14$outboundSchema),
  z.lazy(() => ContentHint1$outboundSchema),
  z.lazy(() => ContentHint2$outboundSchema),
  z.lazy(() => ContentHint3$outboundSchema),
  z.lazy(() => ContentHint4$outboundSchema),
  z.lazy(() => ContentHint5$outboundSchema),
  z.lazy(() => ContentHint6$outboundSchema),
  z.lazy(() => ContentHint7$outboundSchema),
  z.lazy(() => ContentHint8$outboundSchema),
  z.lazy(() => ContentHint9$outboundSchema),
  z.lazy(() => ContentHint10$outboundSchema),
  z.lazy(() => ContentHint11$outboundSchema),
  z.lazy(() => ContentHint12$outboundSchema),
  z.lazy(() => ContentHint13$outboundSchema),
  z.lazy(() => ContentHint15$outboundSchema),
]);

export function contentHintToJSON(contentHint: ContentHint): string {
  return JSON.stringify(ContentHint$outboundSchema.parse(contentHint));
}
export function contentHintFromJSON(
  jsonString: string,
): SafeParseResult<ContentHint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ContentHint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ContentHint' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema;

/** @internal */
export const InternalContentHint$inboundSchema: z.ZodType<
  InternalContentHint,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType$inboundSchema,
  encryptedValue: z.string(),
});
/** @internal */
export type InternalContentHint$Outbound = {
  type: string;
  encryptedValue: string;
};

/** @internal */
export const InternalContentHint$outboundSchema: z.ZodType<
  InternalContentHint$Outbound,
  z.ZodTypeDef,
  InternalContentHint
> = z.object({
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyEnvType$outboundSchema,
  encryptedValue: z.string(),
});

export function internalContentHintToJSON(
  internalContentHint: InternalContentHint,
): string {
  return JSON.stringify(
    InternalContentHint$outboundSchema.parse(internalContentHint),
  );
}
export function internalContentHintFromJSON(
  jsonString: string,
): SafeParseResult<InternalContentHint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InternalContentHint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InternalContentHint' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheEnv$inboundSchema: z.ZodType<
  UpdateProjectDataCacheEnv,
  z.ZodTypeDef,
  unknown
> = z.object({
  target: z.union([
    z.array(UpdateProjectDataCacheTarget1$inboundSchema),
    UpdateProjectDataCacheTarget2$inboundSchema,
  ]).optional(),
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONType$inboundSchema,
  sunsetSecretId: z.string().optional(),
  decrypted: z.boolean().optional(),
  value: z.string(),
  vsmValue: z.string().optional(),
  id: z.string().optional(),
  key: z.string(),
  configurationId: z.nullable(z.string()).optional(),
  createdAt: z.number().optional(),
  updatedAt: z.number().optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  gitBranch: z.string().optional(),
  edgeConfigId: z.nullable(z.string()).optional(),
  edgeConfigTokenId: z.nullable(z.string()).optional(),
  contentHint: z.nullable(
    z.union([
      z.lazy(() => ContentHint14$inboundSchema),
      z.lazy(() => ContentHint1$inboundSchema),
      z.lazy(() => ContentHint2$inboundSchema),
      z.lazy(() => ContentHint3$inboundSchema),
      z.lazy(() => ContentHint4$inboundSchema),
      z.lazy(() => ContentHint5$inboundSchema),
      z.lazy(() => ContentHint6$inboundSchema),
      z.lazy(() => ContentHint7$inboundSchema),
      z.lazy(() => ContentHint8$inboundSchema),
      z.lazy(() => ContentHint9$inboundSchema),
      z.lazy(() => ContentHint10$inboundSchema),
      z.lazy(() => ContentHint11$inboundSchema),
      z.lazy(() => ContentHint12$inboundSchema),
      z.lazy(() => ContentHint13$inboundSchema),
      z.lazy(() => ContentHint15$inboundSchema),
    ]),
  ).optional(),
  internalContentHint: z.nullable(
    z.lazy(() => InternalContentHint$inboundSchema),
  ).optional(),
  comment: z.string().optional(),
  customEnvironmentIds: z.array(z.string()).optional(),
});
/** @internal */
export type UpdateProjectDataCacheEnv$Outbound = {
  target?: Array<string> | string | undefined;
  type: string;
  sunsetSecretId?: string | undefined;
  decrypted?: boolean | undefined;
  value: string;
  vsmValue?: string | undefined;
  id?: string | undefined;
  key: string;
  configurationId?: string | null | undefined;
  createdAt?: number | undefined;
  updatedAt?: number | undefined;
  createdBy?: string | null | undefined;
  updatedBy?: string | null | undefined;
  gitBranch?: string | undefined;
  edgeConfigId?: string | null | undefined;
  edgeConfigTokenId?: string | null | undefined;
  contentHint?:
    | ContentHint14$Outbound
    | ContentHint1$Outbound
    | ContentHint2$Outbound
    | ContentHint3$Outbound
    | ContentHint4$Outbound
    | ContentHint5$Outbound
    | ContentHint6$Outbound
    | ContentHint7$Outbound
    | ContentHint8$Outbound
    | ContentHint9$Outbound
    | ContentHint10$Outbound
    | ContentHint11$Outbound
    | ContentHint12$Outbound
    | ContentHint13$Outbound
    | ContentHint15$Outbound
    | null
    | undefined;
  internalContentHint?: InternalContentHint$Outbound | null | undefined;
  comment?: string | undefined;
  customEnvironmentIds?: Array<string> | undefined;
};

/** @internal */
export const UpdateProjectDataCacheEnv$outboundSchema: z.ZodType<
  UpdateProjectDataCacheEnv$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheEnv
> = z.object({
  target: z.union([
    z.array(UpdateProjectDataCacheTarget1$outboundSchema),
    UpdateProjectDataCacheTarget2$outboundSchema,
  ]).optional(),
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONType$outboundSchema,
  sunsetSecretId: z.string().optional(),
  decrypted: z.boolean().optional(),
  value: z.string(),
  vsmValue: z.string().optional(),
  id: z.string().optional(),
  key: z.string(),
  configurationId: z.nullable(z.string()).optional(),
  createdAt: z.number().optional(),
  updatedAt: z.number().optional(),
  createdBy: z.nullable(z.string()).optional(),
  updatedBy: z.nullable(z.string()).optional(),
  gitBranch: z.string().optional(),
  edgeConfigId: z.nullable(z.string()).optional(),
  edgeConfigTokenId: z.nullable(z.string()).optional(),
  contentHint: z.nullable(
    z.union([
      z.lazy(() => ContentHint14$outboundSchema),
      z.lazy(() => ContentHint1$outboundSchema),
      z.lazy(() => ContentHint2$outboundSchema),
      z.lazy(() => ContentHint3$outboundSchema),
      z.lazy(() => ContentHint4$outboundSchema),
      z.lazy(() => ContentHint5$outboundSchema),
      z.lazy(() => ContentHint6$outboundSchema),
      z.lazy(() => ContentHint7$outboundSchema),
      z.lazy(() => ContentHint8$outboundSchema),
      z.lazy(() => ContentHint9$outboundSchema),
      z.lazy(() => ContentHint10$outboundSchema),
      z.lazy(() => ContentHint11$outboundSchema),
      z.lazy(() => ContentHint12$outboundSchema),
      z.lazy(() => ContentHint13$outboundSchema),
      z.lazy(() => ContentHint15$outboundSchema),
    ]),
  ).optional(),
  internalContentHint: z.nullable(
    z.lazy(() => InternalContentHint$outboundSchema),
  ).optional(),
  comment: z.string().optional(),
  customEnvironmentIds: z.array(z.string()).optional(),
});

export function updateProjectDataCacheEnvToJSON(
  updateProjectDataCacheEnv: UpdateProjectDataCacheEnv,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheEnv$outboundSchema.parse(updateProjectDataCacheEnv),
  );
}
export function updateProjectDataCacheEnvFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheEnv, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheEnv$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheEnv' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheType
> = z.nativeEnum(UpdateProjectDataCacheType);
/** @internal */
export const UpdateProjectDataCacheType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheType
> = UpdateProjectDataCacheType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsResponseBranchMatcher$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsResponseBranchMatcher,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType$inboundSchema,
    pattern: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheProjectsResponseBranchMatcher$Outbound = {
  type: string;
  pattern: string;
};

/** @internal */
export const UpdateProjectDataCacheProjectsResponseBranchMatcher$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsResponseBranchMatcher$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheProjectsResponseBranchMatcher
  > = z.object({
    type:
      UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyCustomEnvironmentsType$outboundSchema,
    pattern: z.string(),
  });

export function updateProjectDataCacheProjectsResponseBranchMatcherToJSON(
  updateProjectDataCacheProjectsResponseBranchMatcher:
    UpdateProjectDataCacheProjectsResponseBranchMatcher,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsResponseBranchMatcher$outboundSchema.parse(
      updateProjectDataCacheProjectsResponseBranchMatcher,
    ),
  );
}
export function updateProjectDataCacheProjectsResponseBranchMatcherFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheProjectsResponseBranchMatcher,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsResponseBranchMatcher$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheProjectsResponseBranchMatcher' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheVerification$inboundSchema: z.ZodType<
  UpdateProjectDataCacheVerification,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.string(),
  domain: z.string(),
  value: z.string(),
  reason: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheVerification$Outbound = {
  type: string;
  domain: string;
  value: string;
  reason: string;
};

/** @internal */
export const UpdateProjectDataCacheVerification$outboundSchema: z.ZodType<
  UpdateProjectDataCacheVerification$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheVerification
> = z.object({
  type: z.string(),
  domain: z.string(),
  value: z.string(),
  reason: z.string(),
});

export function updateProjectDataCacheVerificationToJSON(
  updateProjectDataCacheVerification: UpdateProjectDataCacheVerification,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheVerification$outboundSchema.parse(
      updateProjectDataCacheVerification,
    ),
  );
}
export function updateProjectDataCacheVerificationFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheVerification, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheVerification$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheVerification' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheDomains$inboundSchema: z.ZodType<
  UpdateProjectDataCacheDomains,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.nullable(z.string()).optional(),
  redirectStatusCode: z.nullable(z.number()).optional(),
  gitBranch: z.nullable(z.string()).optional(),
  customEnvironmentId: z.nullable(z.string()).optional(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z.boolean(),
  verification: z.array(
    z.lazy(() => UpdateProjectDataCacheVerification$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateProjectDataCacheDomains$Outbound = {
  name: string;
  apexName: string;
  projectId: string;
  redirect?: string | null | undefined;
  redirectStatusCode?: number | null | undefined;
  gitBranch?: string | null | undefined;
  customEnvironmentId?: string | null | undefined;
  updatedAt?: number | undefined;
  createdAt?: number | undefined;
  verified: boolean;
  verification?: Array<UpdateProjectDataCacheVerification$Outbound> | undefined;
};

/** @internal */
export const UpdateProjectDataCacheDomains$outboundSchema: z.ZodType<
  UpdateProjectDataCacheDomains$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheDomains
> = z.object({
  name: z.string(),
  apexName: z.string(),
  projectId: z.string(),
  redirect: z.nullable(z.string()).optional(),
  redirectStatusCode: z.nullable(z.number()).optional(),
  gitBranch: z.nullable(z.string()).optional(),
  customEnvironmentId: z.nullable(z.string()).optional(),
  updatedAt: z.number().optional(),
  createdAt: z.number().optional(),
  verified: z.boolean(),
  verification: z.array(
    z.lazy(() => UpdateProjectDataCacheVerification$outboundSchema),
  ).optional(),
});

export function updateProjectDataCacheDomainsToJSON(
  updateProjectDataCacheDomains: UpdateProjectDataCacheDomains,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheDomains$outboundSchema.parse(
      updateProjectDataCacheDomains,
    ),
  );
}
export function updateProjectDataCacheDomainsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheDomains, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheDomains$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheDomains' from JSON`,
  );
}

/** @internal */
export const CustomEnvironments$inboundSchema: z.ZodType<
  CustomEnvironments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  slug: z.string(),
  type: UpdateProjectDataCacheType$inboundSchema,
  description: z.string().optional(),
  branchMatcher: z.lazy(() =>
    UpdateProjectDataCacheProjectsResponseBranchMatcher$inboundSchema
  ).optional(),
  domains: z.array(z.lazy(() => UpdateProjectDataCacheDomains$inboundSchema))
    .optional(),
  currentDeploymentAliases: z.array(z.string()).optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
});
/** @internal */
export type CustomEnvironments$Outbound = {
  id: string;
  slug: string;
  type: string;
  description?: string | undefined;
  branchMatcher?:
    | UpdateProjectDataCacheProjectsResponseBranchMatcher$Outbound
    | undefined;
  domains?: Array<UpdateProjectDataCacheDomains$Outbound> | undefined;
  currentDeploymentAliases?: Array<string> | undefined;
  createdAt: number;
  updatedAt: number;
};

/** @internal */
export const CustomEnvironments$outboundSchema: z.ZodType<
  CustomEnvironments$Outbound,
  z.ZodTypeDef,
  CustomEnvironments
> = z.object({
  id: z.string(),
  slug: z.string(),
  type: UpdateProjectDataCacheType$outboundSchema,
  description: z.string().optional(),
  branchMatcher: z.lazy(() =>
    UpdateProjectDataCacheProjectsResponseBranchMatcher$outboundSchema
  ).optional(),
  domains: z.array(z.lazy(() => UpdateProjectDataCacheDomains$outboundSchema))
    .optional(),
  currentDeploymentAliases: z.array(z.string()).optional(),
  createdAt: z.number(),
  updatedAt: z.number(),
});

export function customEnvironmentsToJSON(
  customEnvironments: CustomEnvironments,
): string {
  return JSON.stringify(
    CustomEnvironments$outboundSchema.parse(customEnvironments),
  );
}
export function customEnvironmentsFromJSON(
  jsonString: string,
): SafeParseResult<CustomEnvironments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CustomEnvironments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CustomEnvironments' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheFramework$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheFramework
> = z.nativeEnum(UpdateProjectDataCacheFramework);
/** @internal */
export const UpdateProjectDataCacheFramework$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheFramework
> = UpdateProjectDataCacheFramework$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheIpBuckets$inboundSchema: z.ZodType<
  UpdateProjectDataCacheIpBuckets,
  z.ZodTypeDef,
  unknown
> = z.object({
  bucket: z.string(),
  supportUntil: z.number().optional(),
});
/** @internal */
export type UpdateProjectDataCacheIpBuckets$Outbound = {
  bucket: string;
  supportUntil?: number | undefined;
};

/** @internal */
export const UpdateProjectDataCacheIpBuckets$outboundSchema: z.ZodType<
  UpdateProjectDataCacheIpBuckets$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheIpBuckets
> = z.object({
  bucket: z.string(),
  supportUntil: z.number().optional(),
});

export function updateProjectDataCacheIpBucketsToJSON(
  updateProjectDataCacheIpBuckets: UpdateProjectDataCacheIpBuckets,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheIpBuckets$outboundSchema.parse(
      updateProjectDataCacheIpBuckets,
    ),
  );
}
export function updateProjectDataCacheIpBucketsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheIpBuckets, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheIpBuckets$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheIpBuckets' from JSON`,
  );
}

/** @internal */
export const AliasAssigned$inboundSchema: z.ZodType<
  AliasAssigned,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.boolean()]);
/** @internal */
export type AliasAssigned$Outbound = number | boolean;

/** @internal */
export const AliasAssigned$outboundSchema: z.ZodType<
  AliasAssigned$Outbound,
  z.ZodTypeDef,
  AliasAssigned
> = z.union([z.number(), z.boolean()]);

export function aliasAssignedToJSON(aliasAssigned: AliasAssigned): string {
  return JSON.stringify(AliasAssigned$outboundSchema.parse(aliasAssigned));
}
export function aliasAssignedFromJSON(
  jsonString: string,
): SafeParseResult<AliasAssigned, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AliasAssigned$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AliasAssigned' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsAliasError$inboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsAliasError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheProjectsAliasError$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const UpdateProjectDataCacheProjectsAliasError$outboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsAliasError$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheProjectsAliasError
> = z.object({
  code: z.string(),
  message: z.string(),
});

export function updateProjectDataCacheProjectsAliasErrorToJSON(
  updateProjectDataCacheProjectsAliasError:
    UpdateProjectDataCacheProjectsAliasError,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsAliasError$outboundSchema.parse(
      updateProjectDataCacheProjectsAliasError,
    ),
  );
}
export function updateProjectDataCacheProjectsAliasErrorFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheProjectsAliasError,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsAliasError$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheProjectsAliasError' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheBranchMatcher$inboundSchema: z.ZodType<
  UpdateProjectDataCacheBranchMatcher,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType$inboundSchema,
  pattern: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheBranchMatcher$Outbound = {
  type: string;
  pattern: string;
};

/** @internal */
export const UpdateProjectDataCacheBranchMatcher$outboundSchema: z.ZodType<
  UpdateProjectDataCacheBranchMatcher$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheBranchMatcher
> = z.object({
  type:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyLatestDeploymentsType$outboundSchema,
  pattern: z.string(),
});

export function updateProjectDataCacheBranchMatcherToJSON(
  updateProjectDataCacheBranchMatcher: UpdateProjectDataCacheBranchMatcher,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheBranchMatcher$outboundSchema.parse(
      updateProjectDataCacheBranchMatcher,
    ),
  );
}
export function updateProjectDataCacheBranchMatcherFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheBranchMatcher, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheBranchMatcher$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheBranchMatcher' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsBuilds$inboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsBuilds,
  z.ZodTypeDef,
  unknown
> = z.object({
  use: z.string(),
  src: z.string().optional(),
  dest: z.string().optional(),
});
/** @internal */
export type UpdateProjectDataCacheProjectsBuilds$Outbound = {
  use: string;
  src?: string | undefined;
  dest?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheProjectsBuilds$outboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsBuilds$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheProjectsBuilds
> = z.object({
  use: z.string(),
  src: z.string().optional(),
  dest: z.string().optional(),
});

export function updateProjectDataCacheProjectsBuildsToJSON(
  updateProjectDataCacheProjectsBuilds: UpdateProjectDataCacheProjectsBuilds,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsBuilds$outboundSchema.parse(
      updateProjectDataCacheProjectsBuilds,
    ),
  );
}
export function updateProjectDataCacheProjectsBuildsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheProjectsBuilds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsBuilds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheProjectsBuilds' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsChecksConclusion$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsChecksConclusion> = z
    .nativeEnum(UpdateProjectDataCacheProjectsChecksConclusion);
/** @internal */
export const UpdateProjectDataCacheProjectsChecksConclusion$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsChecksConclusion> =
    UpdateProjectDataCacheProjectsChecksConclusion$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsChecksState$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsChecksState> = z
    .nativeEnum(UpdateProjectDataCacheProjectsChecksState);
/** @internal */
export const UpdateProjectDataCacheProjectsChecksState$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsChecksState> =
    UpdateProjectDataCacheProjectsChecksState$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsCreator$inboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsCreator,
  z.ZodTypeDef,
  unknown
> = z.object({
  email: z.string(),
  githubLogin: z.string().optional(),
  gitlabLogin: z.string().optional(),
  uid: z.string(),
  username: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheProjectsCreator$Outbound = {
  email: string;
  githubLogin?: string | undefined;
  gitlabLogin?: string | undefined;
  uid: string;
  username: string;
};

/** @internal */
export const UpdateProjectDataCacheProjectsCreator$outboundSchema: z.ZodType<
  UpdateProjectDataCacheProjectsCreator$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheProjectsCreator
> = z.object({
  email: z.string(),
  githubLogin: z.string().optional(),
  gitlabLogin: z.string().optional(),
  uid: z.string(),
  username: z.string(),
});

export function updateProjectDataCacheProjectsCreatorToJSON(
  updateProjectDataCacheProjectsCreator: UpdateProjectDataCacheProjectsCreator,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsCreator$outboundSchema.parse(
      updateProjectDataCacheProjectsCreator,
    ),
  );
}
export function updateProjectDataCacheProjectsCreatorFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheProjectsCreator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsCreator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheProjectsCreator' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsOidcTokenClaims$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsOidcTokenClaims,
    z.ZodTypeDef,
    unknown
  > = z.object({
    iss: z.string(),
    sub: z.string(),
    scope: z.string(),
    aud: z.string(),
    owner: z.string(),
    owner_id: z.string(),
    project: z.string(),
    project_id: z.string(),
    environment: z.string(),
    plan: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "owner_id": "ownerId",
      "project_id": "projectId",
    });
  });
/** @internal */
export type UpdateProjectDataCacheProjectsOidcTokenClaims$Outbound = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  owner_id: string;
  project: string;
  project_id: string;
  environment: string;
  plan: string;
};

/** @internal */
export const UpdateProjectDataCacheProjectsOidcTokenClaims$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsOidcTokenClaims$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheProjectsOidcTokenClaims
  > = z.object({
    iss: z.string(),
    sub: z.string(),
    scope: z.string(),
    aud: z.string(),
    owner: z.string(),
    ownerId: z.string(),
    project: z.string(),
    projectId: z.string(),
    environment: z.string(),
    plan: z.string(),
  }).transform((v) => {
    return remap$(v, {
      ownerId: "owner_id",
      projectId: "project_id",
    });
  });

export function updateProjectDataCacheProjectsOidcTokenClaimsToJSON(
  updateProjectDataCacheProjectsOidcTokenClaims:
    UpdateProjectDataCacheProjectsOidcTokenClaims,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsOidcTokenClaims$outboundSchema.parse(
      updateProjectDataCacheProjectsOidcTokenClaims,
    ),
  );
}
export function updateProjectDataCacheProjectsOidcTokenClaimsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheProjectsOidcTokenClaims,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsOidcTokenClaims$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheProjectsOidcTokenClaims' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsPlan$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheProjectsPlan
> = z.nativeEnum(UpdateProjectDataCacheProjectsPlan);
/** @internal */
export const UpdateProjectDataCacheProjectsPlan$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheProjectsPlan
> = UpdateProjectDataCacheProjectsPlan$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsReadyState$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsReadyState> = z
    .nativeEnum(UpdateProjectDataCacheProjectsReadyState);
/** @internal */
export const UpdateProjectDataCacheProjectsReadyState$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsReadyState> =
    UpdateProjectDataCacheProjectsReadyState$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsReadySubstate$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsReadySubstate> = z
    .nativeEnum(UpdateProjectDataCacheProjectsReadySubstate);
/** @internal */
export const UpdateProjectDataCacheProjectsReadySubstate$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsReadySubstate> =
    UpdateProjectDataCacheProjectsReadySubstate$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheProjectsType
> = z.nativeEnum(UpdateProjectDataCacheProjectsType);
/** @internal */
export const UpdateProjectDataCacheProjectsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheProjectsType
> = UpdateProjectDataCacheProjectsType$inboundSchema;

/** @internal */
export const LatestDeployments$inboundSchema: z.ZodType<
  LatestDeployments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  alias: z.array(z.string()).optional(),
  aliasAssigned: z.nullable(z.union([z.number(), z.boolean()])).optional(),
  aliasError: z.nullable(
    z.lazy(() => UpdateProjectDataCacheProjectsAliasError$inboundSchema),
  ).optional(),
  aliasFinal: z.nullable(z.string()).optional(),
  automaticAliases: z.array(z.string()).optional(),
  branchMatcher: z.lazy(() => UpdateProjectDataCacheBranchMatcher$inboundSchema)
    .optional(),
  buildingAt: z.number().optional(),
  builds: z.array(
    z.lazy(() => UpdateProjectDataCacheProjectsBuilds$inboundSchema),
  ).optional(),
  checksConclusion: UpdateProjectDataCacheProjectsChecksConclusion$inboundSchema
    .optional(),
  checksState: UpdateProjectDataCacheProjectsChecksState$inboundSchema
    .optional(),
  connectBuildsEnabled: z.boolean().optional(),
  connectConfigurationId: z.string().optional(),
  createdAt: z.number(),
  createdIn: z.string(),
  creator: z.nullable(
    z.lazy(() => UpdateProjectDataCacheProjectsCreator$inboundSchema),
  ),
  deletedAt: z.number().optional(),
  deploymentHostname: z.string(),
  forced: z.boolean().optional(),
  name: z.string(),
  meta: z.record(z.string()).optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  oidcTokenClaims: z.lazy(() =>
    UpdateProjectDataCacheProjectsOidcTokenClaims$inboundSchema
  ).optional(),
  plan: UpdateProjectDataCacheProjectsPlan$inboundSchema,
  previewCommentsEnabled: z.boolean().optional(),
  private: z.boolean(),
  readyAt: z.number().optional(),
  readyState: UpdateProjectDataCacheProjectsReadyState$inboundSchema,
  readySubstate: UpdateProjectDataCacheProjectsReadySubstate$inboundSchema
    .optional(),
  requestedAt: z.number().optional(),
  target: z.nullable(z.string()).optional(),
  teamId: z.nullable(z.string()).optional(),
  type: UpdateProjectDataCacheProjectsType$inboundSchema,
  url: z.string(),
  userId: z.string(),
  withCache: z.boolean().optional(),
});
/** @internal */
export type LatestDeployments$Outbound = {
  id: string;
  alias?: Array<string> | undefined;
  aliasAssigned?: number | boolean | null | undefined;
  aliasError?:
    | UpdateProjectDataCacheProjectsAliasError$Outbound
    | null
    | undefined;
  aliasFinal?: string | null | undefined;
  automaticAliases?: Array<string> | undefined;
  branchMatcher?: UpdateProjectDataCacheBranchMatcher$Outbound | undefined;
  buildingAt?: number | undefined;
  builds?: Array<UpdateProjectDataCacheProjectsBuilds$Outbound> | undefined;
  checksConclusion?: string | undefined;
  checksState?: string | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdAt: number;
  createdIn: string;
  creator: UpdateProjectDataCacheProjectsCreator$Outbound | null;
  deletedAt?: number | undefined;
  deploymentHostname: string;
  forced?: boolean | undefined;
  name: string;
  meta?: { [k: string]: string } | undefined;
  monorepoManager?: string | null | undefined;
  oidcTokenClaims?:
    | UpdateProjectDataCacheProjectsOidcTokenClaims$Outbound
    | undefined;
  plan: string;
  previewCommentsEnabled?: boolean | undefined;
  private: boolean;
  readyAt?: number | undefined;
  readyState: string;
  readySubstate?: string | undefined;
  requestedAt?: number | undefined;
  target?: string | null | undefined;
  teamId?: string | null | undefined;
  type: string;
  url: string;
  userId: string;
  withCache?: boolean | undefined;
};

/** @internal */
export const LatestDeployments$outboundSchema: z.ZodType<
  LatestDeployments$Outbound,
  z.ZodTypeDef,
  LatestDeployments
> = z.object({
  id: z.string(),
  alias: z.array(z.string()).optional(),
  aliasAssigned: z.nullable(z.union([z.number(), z.boolean()])).optional(),
  aliasError: z.nullable(
    z.lazy(() => UpdateProjectDataCacheProjectsAliasError$outboundSchema),
  ).optional(),
  aliasFinal: z.nullable(z.string()).optional(),
  automaticAliases: z.array(z.string()).optional(),
  branchMatcher: z.lazy(() =>
    UpdateProjectDataCacheBranchMatcher$outboundSchema
  ).optional(),
  buildingAt: z.number().optional(),
  builds: z.array(
    z.lazy(() => UpdateProjectDataCacheProjectsBuilds$outboundSchema),
  ).optional(),
  checksConclusion:
    UpdateProjectDataCacheProjectsChecksConclusion$outboundSchema.optional(),
  checksState: UpdateProjectDataCacheProjectsChecksState$outboundSchema
    .optional(),
  connectBuildsEnabled: z.boolean().optional(),
  connectConfigurationId: z.string().optional(),
  createdAt: z.number(),
  createdIn: z.string(),
  creator: z.nullable(
    z.lazy(() => UpdateProjectDataCacheProjectsCreator$outboundSchema),
  ),
  deletedAt: z.number().optional(),
  deploymentHostname: z.string(),
  forced: z.boolean().optional(),
  name: z.string(),
  meta: z.record(z.string()).optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  oidcTokenClaims: z.lazy(() =>
    UpdateProjectDataCacheProjectsOidcTokenClaims$outboundSchema
  ).optional(),
  plan: UpdateProjectDataCacheProjectsPlan$outboundSchema,
  previewCommentsEnabled: z.boolean().optional(),
  private: z.boolean(),
  readyAt: z.number().optional(),
  readyState: UpdateProjectDataCacheProjectsReadyState$outboundSchema,
  readySubstate: UpdateProjectDataCacheProjectsReadySubstate$outboundSchema
    .optional(),
  requestedAt: z.number().optional(),
  target: z.nullable(z.string()).optional(),
  teamId: z.nullable(z.string()).optional(),
  type: UpdateProjectDataCacheProjectsType$outboundSchema,
  url: z.string(),
  userId: z.string(),
  withCache: z.boolean().optional(),
});

export function latestDeploymentsToJSON(
  latestDeployments: LatestDeployments,
): string {
  return JSON.stringify(
    LatestDeployments$outboundSchema.parse(latestDeployments),
  );
}
export function latestDeploymentsFromJSON(
  jsonString: string,
): SafeParseResult<LatestDeployments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LatestDeployments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LatestDeployments' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsResponse200Type> = z
    .nativeEnum(UpdateProjectDataCacheLinkProjectsResponse200Type);
/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsResponse200Type> =
    UpdateProjectDataCacheLinkProjectsResponse200Type$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponseDeployHooks$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    createdAt: z.number().optional(),
    id: z.string(),
    name: z.string(),
    ref: z.string(),
    url: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheLinkProjectsResponseDeployHooks$Outbound = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponseDeployHooks$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks
  > = z.object({
    createdAt: z.number().optional(),
    id: z.string(),
    name: z.string(),
    ref: z.string(),
    url: z.string(),
  });

export function updateProjectDataCacheLinkProjectsResponseDeployHooksToJSON(
  updateProjectDataCacheLinkProjectsResponseDeployHooks:
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks$outboundSchema.parse(
      updateProjectDataCacheLinkProjectsResponseDeployHooks,
    ),
  );
}
export function updateProjectDataCacheLinkProjectsResponseDeployHooksFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheLinkProjectsResponseDeployHooks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheLinkProjectsResponseDeployHooks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheLinkProjectsResponseDeployHooks' from JSON`,
  );
}

/** @internal */
export const Link5$inboundSchema: z.ZodType<Link5, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string(),
    slug: z.string(),
    owner: z.string(),
    type: UpdateProjectDataCacheLinkProjectsResponse200Type$inboundSchema,
    uuid: z.string(),
    workspaceUuid: z.string(),
    createdAt: z.number().optional(),
    deployHooks: z.array(
      z.lazy(() =>
        UpdateProjectDataCacheLinkProjectsResponseDeployHooks$inboundSchema
      ),
    ),
    gitCredentialId: z.string(),
    updatedAt: z.number().optional(),
    sourceless: z.boolean().optional(),
    productionBranch: z.string(),
  });
/** @internal */
export type Link5$Outbound = {
  name: string;
  slug: string;
  owner: string;
  type: string;
  uuid: string;
  workspaceUuid: string;
  createdAt?: number | undefined;
  deployHooks: Array<
    UpdateProjectDataCacheLinkProjectsResponseDeployHooks$Outbound
  >;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

/** @internal */
export const Link5$outboundSchema: z.ZodType<
  Link5$Outbound,
  z.ZodTypeDef,
  Link5
> = z.object({
  name: z.string(),
  slug: z.string(),
  owner: z.string(),
  type: UpdateProjectDataCacheLinkProjectsResponse200Type$outboundSchema,
  uuid: z.string(),
  workspaceUuid: z.string(),
  createdAt: z.number().optional(),
  deployHooks: z.array(
    z.lazy(() =>
      UpdateProjectDataCacheLinkProjectsResponseDeployHooks$outboundSchema
    ),
  ),
  gitCredentialId: z.string(),
  updatedAt: z.number().optional(),
  sourceless: z.boolean().optional(),
  productionBranch: z.string(),
});

export function link5ToJSON(link5: Link5): string {
  return JSON.stringify(Link5$outboundSchema.parse(link5));
}
export function link5FromJSON(
  jsonString: string,
): SafeParseResult<Link5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link5' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsResponseType> = z
    .nativeEnum(UpdateProjectDataCacheLinkProjectsResponseType);
/** @internal */
export const UpdateProjectDataCacheLinkProjectsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsResponseType> =
    UpdateProjectDataCacheLinkProjectsResponseType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheLinkProjectsDeployHooks$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheLinkProjectsDeployHooks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    createdAt: z.number().optional(),
    id: z.string(),
    name: z.string(),
    ref: z.string(),
    url: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheLinkProjectsDeployHooks$Outbound = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

/** @internal */
export const UpdateProjectDataCacheLinkProjectsDeployHooks$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheLinkProjectsDeployHooks$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheLinkProjectsDeployHooks
  > = z.object({
    createdAt: z.number().optional(),
    id: z.string(),
    name: z.string(),
    ref: z.string(),
    url: z.string(),
  });

export function updateProjectDataCacheLinkProjectsDeployHooksToJSON(
  updateProjectDataCacheLinkProjectsDeployHooks:
    UpdateProjectDataCacheLinkProjectsDeployHooks,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheLinkProjectsDeployHooks$outboundSchema.parse(
      updateProjectDataCacheLinkProjectsDeployHooks,
    ),
  );
}
export function updateProjectDataCacheLinkProjectsDeployHooksFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheLinkProjectsDeployHooks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheLinkProjectsDeployHooks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheLinkProjectsDeployHooks' from JSON`,
  );
}

/** @internal */
export const Link4$inboundSchema: z.ZodType<Link4, z.ZodTypeDef, unknown> = z
  .object({
    projectId: z.string(),
    projectName: z.string(),
    projectNameWithNamespace: z.string(),
    projectNamespace: z.string(),
    projectOwnerId: z.number().optional(),
    projectUrl: z.string(),
    type: UpdateProjectDataCacheLinkProjectsResponseType$inboundSchema,
    createdAt: z.number().optional(),
    deployHooks: z.array(
      z.lazy(() => UpdateProjectDataCacheLinkProjectsDeployHooks$inboundSchema),
    ),
    gitCredentialId: z.string(),
    updatedAt: z.number().optional(),
    sourceless: z.boolean().optional(),
    productionBranch: z.string(),
  });
/** @internal */
export type Link4$Outbound = {
  projectId: string;
  projectName: string;
  projectNameWithNamespace: string;
  projectNamespace: string;
  projectOwnerId?: number | undefined;
  projectUrl: string;
  type: string;
  createdAt?: number | undefined;
  deployHooks: Array<UpdateProjectDataCacheLinkProjectsDeployHooks$Outbound>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

/** @internal */
export const Link4$outboundSchema: z.ZodType<
  Link4$Outbound,
  z.ZodTypeDef,
  Link4
> = z.object({
  projectId: z.string(),
  projectName: z.string(),
  projectNameWithNamespace: z.string(),
  projectNamespace: z.string(),
  projectOwnerId: z.number().optional(),
  projectUrl: z.string(),
  type: UpdateProjectDataCacheLinkProjectsResponseType$outboundSchema,
  createdAt: z.number().optional(),
  deployHooks: z.array(
    z.lazy(() => UpdateProjectDataCacheLinkProjectsDeployHooks$outboundSchema),
  ),
  gitCredentialId: z.string(),
  updatedAt: z.number().optional(),
  sourceless: z.boolean().optional(),
  productionBranch: z.string(),
});

export function link4ToJSON(link4: Link4): string {
  return JSON.stringify(Link4$outboundSchema.parse(link4));
}
export function link4FromJSON(
  jsonString: string,
): SafeParseResult<Link4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link4' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheLinkProjectsType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsType> = z.nativeEnum(
    UpdateProjectDataCacheLinkProjectsType,
  );
/** @internal */
export const UpdateProjectDataCacheLinkProjectsType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheLinkProjectsType> =
    UpdateProjectDataCacheLinkProjectsType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheLinkDeployHooks$inboundSchema: z.ZodType<
  UpdateProjectDataCacheLinkDeployHooks,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheLinkDeployHooks$Outbound = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

/** @internal */
export const UpdateProjectDataCacheLinkDeployHooks$outboundSchema: z.ZodType<
  UpdateProjectDataCacheLinkDeployHooks$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheLinkDeployHooks
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});

export function updateProjectDataCacheLinkDeployHooksToJSON(
  updateProjectDataCacheLinkDeployHooks: UpdateProjectDataCacheLinkDeployHooks,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheLinkDeployHooks$outboundSchema.parse(
      updateProjectDataCacheLinkDeployHooks,
    ),
  );
}
export function updateProjectDataCacheLinkDeployHooksFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheLinkDeployHooks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheLinkDeployHooks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheLinkDeployHooks' from JSON`,
  );
}

/** @internal */
export const Link3$inboundSchema: z.ZodType<Link3, z.ZodTypeDef, unknown> = z
  .object({
    org: z.string(),
    repoOwnerId: z.number().optional(),
    repo: z.string().optional(),
    repoId: z.number().optional(),
    type: UpdateProjectDataCacheLinkProjectsType$inboundSchema,
    host: z.string(),
    createdAt: z.number().optional(),
    deployHooks: z.array(
      z.lazy(() => UpdateProjectDataCacheLinkDeployHooks$inboundSchema),
    ),
    gitCredentialId: z.string(),
    updatedAt: z.number().optional(),
    sourceless: z.boolean().optional(),
    productionBranch: z.string(),
  });
/** @internal */
export type Link3$Outbound = {
  org: string;
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  type: string;
  host: string;
  createdAt?: number | undefined;
  deployHooks: Array<UpdateProjectDataCacheLinkDeployHooks$Outbound>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

/** @internal */
export const Link3$outboundSchema: z.ZodType<
  Link3$Outbound,
  z.ZodTypeDef,
  Link3
> = z.object({
  org: z.string(),
  repoOwnerId: z.number().optional(),
  repo: z.string().optional(),
  repoId: z.number().optional(),
  type: UpdateProjectDataCacheLinkProjectsType$outboundSchema,
  host: z.string(),
  createdAt: z.number().optional(),
  deployHooks: z.array(
    z.lazy(() => UpdateProjectDataCacheLinkDeployHooks$outboundSchema),
  ),
  gitCredentialId: z.string(),
  updatedAt: z.number().optional(),
  sourceless: z.boolean().optional(),
  productionBranch: z.string(),
});

export function link3ToJSON(link3: Link3): string {
  return JSON.stringify(Link3$outboundSchema.parse(link3));
}
export function link3FromJSON(
  jsonString: string,
): SafeParseResult<Link3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link3' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheLinkType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheLinkType
> = z.nativeEnum(UpdateProjectDataCacheLinkType);
/** @internal */
export const UpdateProjectDataCacheLinkType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheLinkType
> = UpdateProjectDataCacheLinkType$inboundSchema;

/** @internal */
export const LinkDeployHooks$inboundSchema: z.ZodType<
  LinkDeployHooks,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});
/** @internal */
export type LinkDeployHooks$Outbound = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

/** @internal */
export const LinkDeployHooks$outboundSchema: z.ZodType<
  LinkDeployHooks$Outbound,
  z.ZodTypeDef,
  LinkDeployHooks
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});

export function linkDeployHooksToJSON(
  linkDeployHooks: LinkDeployHooks,
): string {
  return JSON.stringify(LinkDeployHooks$outboundSchema.parse(linkDeployHooks));
}
export function linkDeployHooksFromJSON(
  jsonString: string,
): SafeParseResult<LinkDeployHooks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LinkDeployHooks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LinkDeployHooks' from JSON`,
  );
}

/** @internal */
export const Link2$inboundSchema: z.ZodType<Link2, z.ZodTypeDef, unknown> = z
  .object({
    type: UpdateProjectDataCacheLinkType$inboundSchema,
    createdAt: z.number().optional(),
    updatedAt: z.number().optional(),
    org: z.string(),
    repoOwnerId: z.number().optional(),
    repo: z.string().optional(),
    repoId: z.number().optional(),
    deployHooks: z.array(z.lazy(() => LinkDeployHooks$inboundSchema)),
    gitCredentialId: z.string(),
    sourceless: z.boolean().optional(),
    productionBranch: z.string(),
  });
/** @internal */
export type Link2$Outbound = {
  type: string;
  createdAt?: number | undefined;
  updatedAt?: number | undefined;
  org: string;
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  deployHooks: Array<LinkDeployHooks$Outbound>;
  gitCredentialId: string;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

/** @internal */
export const Link2$outboundSchema: z.ZodType<
  Link2$Outbound,
  z.ZodTypeDef,
  Link2
> = z.object({
  type: UpdateProjectDataCacheLinkType$outboundSchema,
  createdAt: z.number().optional(),
  updatedAt: z.number().optional(),
  org: z.string(),
  repoOwnerId: z.number().optional(),
  repo: z.string().optional(),
  repoId: z.number().optional(),
  deployHooks: z.array(z.lazy(() => LinkDeployHooks$outboundSchema)),
  gitCredentialId: z.string(),
  sourceless: z.boolean().optional(),
  productionBranch: z.string(),
});

export function link2ToJSON(link2: Link2): string {
  return JSON.stringify(Link2$outboundSchema.parse(link2));
}
export function link2FromJSON(
  jsonString: string,
): SafeParseResult<Link2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link2' from JSON`,
  );
}

/** @internal */
export const LinkType$inboundSchema: z.ZodNativeEnum<typeof LinkType> = z
  .nativeEnum(LinkType);
/** @internal */
export const LinkType$outboundSchema: z.ZodNativeEnum<typeof LinkType> =
  LinkType$inboundSchema;

/** @internal */
export const DeployHooks$inboundSchema: z.ZodType<
  DeployHooks,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});
/** @internal */
export type DeployHooks$Outbound = {
  createdAt?: number | undefined;
  id: string;
  name: string;
  ref: string;
  url: string;
};

/** @internal */
export const DeployHooks$outboundSchema: z.ZodType<
  DeployHooks$Outbound,
  z.ZodTypeDef,
  DeployHooks
> = z.object({
  createdAt: z.number().optional(),
  id: z.string(),
  name: z.string(),
  ref: z.string(),
  url: z.string(),
});

export function deployHooksToJSON(deployHooks: DeployHooks): string {
  return JSON.stringify(DeployHooks$outboundSchema.parse(deployHooks));
}
export function deployHooksFromJSON(
  jsonString: string,
): SafeParseResult<DeployHooks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeployHooks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeployHooks' from JSON`,
  );
}

/** @internal */
export const Link1$inboundSchema: z.ZodType<Link1, z.ZodTypeDef, unknown> = z
  .object({
    org: z.string(),
    repoOwnerId: z.number().optional(),
    repo: z.string().optional(),
    repoId: z.number().optional(),
    type: LinkType$inboundSchema,
    createdAt: z.number().optional(),
    deployHooks: z.array(z.lazy(() => DeployHooks$inboundSchema)),
    gitCredentialId: z.string(),
    updatedAt: z.number().optional(),
    sourceless: z.boolean().optional(),
    productionBranch: z.string(),
  });
/** @internal */
export type Link1$Outbound = {
  org: string;
  repoOwnerId?: number | undefined;
  repo?: string | undefined;
  repoId?: number | undefined;
  type: string;
  createdAt?: number | undefined;
  deployHooks: Array<DeployHooks$Outbound>;
  gitCredentialId: string;
  updatedAt?: number | undefined;
  sourceless?: boolean | undefined;
  productionBranch: string;
};

/** @internal */
export const Link1$outboundSchema: z.ZodType<
  Link1$Outbound,
  z.ZodTypeDef,
  Link1
> = z.object({
  org: z.string(),
  repoOwnerId: z.number().optional(),
  repo: z.string().optional(),
  repoId: z.number().optional(),
  type: LinkType$outboundSchema,
  createdAt: z.number().optional(),
  deployHooks: z.array(z.lazy(() => DeployHooks$outboundSchema)),
  gitCredentialId: z.string(),
  updatedAt: z.number().optional(),
  sourceless: z.boolean().optional(),
  productionBranch: z.string(),
});

export function link1ToJSON(link1: Link1): string {
  return JSON.stringify(Link1$outboundSchema.parse(link1));
}
export function link1FromJSON(
  jsonString: string,
): SafeParseResult<Link1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link1' from JSON`,
  );
}

/** @internal */
export const Link$inboundSchema: z.ZodType<Link, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Link4$inboundSchema),
    z.lazy(() => Link5$inboundSchema),
    z.lazy(() => Link3$inboundSchema),
    z.lazy(() => Link1$inboundSchema),
    z.lazy(() => Link2$inboundSchema),
  ]);
/** @internal */
export type Link$Outbound =
  | Link4$Outbound
  | Link5$Outbound
  | Link3$Outbound
  | Link1$Outbound
  | Link2$Outbound;

/** @internal */
export const Link$outboundSchema: z.ZodType<Link$Outbound, z.ZodTypeDef, Link> =
  z.union([
    z.lazy(() => Link4$outboundSchema),
    z.lazy(() => Link5$outboundSchema),
    z.lazy(() => Link3$outboundSchema),
    z.lazy(() => Link1$outboundSchema),
    z.lazy(() => Link2$outboundSchema),
  ]);

export function linkToJSON(link: Link): string {
  return JSON.stringify(Link$outboundSchema.parse(link));
}
export function linkFromJSON(
  jsonString: string,
): SafeParseResult<Link, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Link$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Link' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheMicrofrontends3$inboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends3,
  z.ZodTypeDef,
  unknown
> = z.object({
  updatedAt: z.number(),
  groupIds: z.array(z.any()),
  enabled: z.boolean(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheMicrofrontends3$Outbound = {
  updatedAt: number;
  groupIds: Array<any>;
  enabled: boolean;
  freeProjectForLegacyLimits?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheMicrofrontends3$outboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends3$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheMicrofrontends3
> = z.object({
  updatedAt: z.number(),
  groupIds: z.array(z.any()),
  enabled: z.boolean(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});

export function updateProjectDataCacheMicrofrontends3ToJSON(
  updateProjectDataCacheMicrofrontends3: UpdateProjectDataCacheMicrofrontends3,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheMicrofrontends3$outboundSchema.parse(
      updateProjectDataCacheMicrofrontends3,
    ),
  );
}
export function updateProjectDataCacheMicrofrontends3FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheMicrofrontends3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheMicrofrontends3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheMicrofrontends3' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheMicrofrontends2$inboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends2,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: z.boolean().optional(),
  routeObservabilityToThisProject: z.boolean().optional(),
  doNotRouteWithMicrofrontendsRouting: z.boolean().optional(),
  updatedAt: z.number(),
  groupIds: z.array(z.string()),
  enabled: z.boolean(),
  defaultRoute: z.string().optional(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheMicrofrontends2$Outbound = {
  isDefaultApp?: boolean | undefined;
  routeObservabilityToThisProject?: boolean | undefined;
  doNotRouteWithMicrofrontendsRouting?: boolean | undefined;
  updatedAt: number;
  groupIds: Array<string>;
  enabled: boolean;
  defaultRoute?: string | undefined;
  freeProjectForLegacyLimits?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheMicrofrontends2$outboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends2$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheMicrofrontends2
> = z.object({
  isDefaultApp: z.boolean().optional(),
  routeObservabilityToThisProject: z.boolean().optional(),
  doNotRouteWithMicrofrontendsRouting: z.boolean().optional(),
  updatedAt: z.number(),
  groupIds: z.array(z.string()),
  enabled: z.boolean(),
  defaultRoute: z.string().optional(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});

export function updateProjectDataCacheMicrofrontends2ToJSON(
  updateProjectDataCacheMicrofrontends2: UpdateProjectDataCacheMicrofrontends2,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheMicrofrontends2$outboundSchema.parse(
      updateProjectDataCacheMicrofrontends2,
    ),
  );
}
export function updateProjectDataCacheMicrofrontends2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheMicrofrontends2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheMicrofrontends2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheMicrofrontends2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheMicrofrontends1$inboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends1,
  z.ZodTypeDef,
  unknown
> = z.object({
  isDefaultApp: z.boolean(),
  updatedAt: z.number(),
  groupIds: z.array(z.string()),
  enabled: z.boolean(),
  defaultRoute: z.string().optional(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheMicrofrontends1$Outbound = {
  isDefaultApp: boolean;
  updatedAt: number;
  groupIds: Array<string>;
  enabled: boolean;
  defaultRoute?: string | undefined;
  freeProjectForLegacyLimits?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheMicrofrontends1$outboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends1$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheMicrofrontends1
> = z.object({
  isDefaultApp: z.boolean(),
  updatedAt: z.number(),
  groupIds: z.array(z.string()),
  enabled: z.boolean(),
  defaultRoute: z.string().optional(),
  freeProjectForLegacyLimits: z.boolean().optional(),
});

export function updateProjectDataCacheMicrofrontends1ToJSON(
  updateProjectDataCacheMicrofrontends1: UpdateProjectDataCacheMicrofrontends1,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheMicrofrontends1$outboundSchema.parse(
      updateProjectDataCacheMicrofrontends1,
    ),
  );
}
export function updateProjectDataCacheMicrofrontends1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheMicrofrontends1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheMicrofrontends1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheMicrofrontends1' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheMicrofrontends$inboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateProjectDataCacheMicrofrontends1$inboundSchema),
  z.lazy(() => UpdateProjectDataCacheMicrofrontends2$inboundSchema),
  z.lazy(() => UpdateProjectDataCacheMicrofrontends3$inboundSchema),
]);
/** @internal */
export type UpdateProjectDataCacheMicrofrontends$Outbound =
  | UpdateProjectDataCacheMicrofrontends1$Outbound
  | UpdateProjectDataCacheMicrofrontends2$Outbound
  | UpdateProjectDataCacheMicrofrontends3$Outbound;

/** @internal */
export const UpdateProjectDataCacheMicrofrontends$outboundSchema: z.ZodType<
  UpdateProjectDataCacheMicrofrontends$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheMicrofrontends
> = z.union([
  z.lazy(() => UpdateProjectDataCacheMicrofrontends1$outboundSchema),
  z.lazy(() => UpdateProjectDataCacheMicrofrontends2$outboundSchema),
  z.lazy(() => UpdateProjectDataCacheMicrofrontends3$outboundSchema),
]);

export function updateProjectDataCacheMicrofrontendsToJSON(
  updateProjectDataCacheMicrofrontends: UpdateProjectDataCacheMicrofrontends,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheMicrofrontends$outboundSchema.parse(
      updateProjectDataCacheMicrofrontends,
    ),
  );
}
export function updateProjectDataCacheMicrofrontendsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheMicrofrontends, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheMicrofrontends$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheMicrofrontends' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheNodeVersion$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheNodeVersion
> = z.nativeEnum(UpdateProjectDataCacheNodeVersion);
/** @internal */
export const UpdateProjectDataCacheNodeVersion$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheNodeVersion
> = UpdateProjectDataCacheNodeVersion$inboundSchema;

/** @internal */
export const UpdateProjectDataCachePaths$inboundSchema: z.ZodType<
  UpdateProjectDataCachePaths,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
});
/** @internal */
export type UpdateProjectDataCachePaths$Outbound = {
  value: string;
};

/** @internal */
export const UpdateProjectDataCachePaths$outboundSchema: z.ZodType<
  UpdateProjectDataCachePaths$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCachePaths
> = z.object({
  value: z.string(),
});

export function updateProjectDataCachePathsToJSON(
  updateProjectDataCachePaths: UpdateProjectDataCachePaths,
): string {
  return JSON.stringify(
    UpdateProjectDataCachePaths$outboundSchema.parse(
      updateProjectDataCachePaths,
    ),
  );
}
export function updateProjectDataCachePathsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCachePaths, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCachePaths$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCachePaths' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheOptionsAllowlist$inboundSchema: z.ZodType<
  UpdateProjectDataCacheOptionsAllowlist,
  z.ZodTypeDef,
  unknown
> = z.object({
  paths: z.array(z.lazy(() => UpdateProjectDataCachePaths$inboundSchema)),
});
/** @internal */
export type UpdateProjectDataCacheOptionsAllowlist$Outbound = {
  paths: Array<UpdateProjectDataCachePaths$Outbound>;
};

/** @internal */
export const UpdateProjectDataCacheOptionsAllowlist$outboundSchema: z.ZodType<
  UpdateProjectDataCacheOptionsAllowlist$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheOptionsAllowlist
> = z.object({
  paths: z.array(z.lazy(() => UpdateProjectDataCachePaths$outboundSchema)),
});

export function updateProjectDataCacheOptionsAllowlistToJSON(
  updateProjectDataCacheOptionsAllowlist:
    UpdateProjectDataCacheOptionsAllowlist,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheOptionsAllowlist$outboundSchema.parse(
      updateProjectDataCacheOptionsAllowlist,
    ),
  );
}
export function updateProjectDataCacheOptionsAllowlistFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheOptionsAllowlist, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheOptionsAllowlist$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheOptionsAllowlist' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCachePasswordProtection$inboundSchema: z.ZodType<
  UpdateProjectDataCachePasswordProtection,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type UpdateProjectDataCachePasswordProtection$Outbound = {};

/** @internal */
export const UpdateProjectDataCachePasswordProtection$outboundSchema: z.ZodType<
  UpdateProjectDataCachePasswordProtection$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCachePasswordProtection
> = z.object({});

export function updateProjectDataCachePasswordProtectionToJSON(
  updateProjectDataCachePasswordProtection:
    UpdateProjectDataCachePasswordProtection,
): string {
  return JSON.stringify(
    UpdateProjectDataCachePasswordProtection$outboundSchema.parse(
      updateProjectDataCachePasswordProtection,
    ),
  );
}
export function updateProjectDataCachePasswordProtectionFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCachePasswordProtection,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCachePasswordProtection$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCachePasswordProtection' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsFunctionDefaultMemoryType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsFunctionDefaultMemoryType
  > = z.nativeEnum(UpdateProjectDataCacheProjectsFunctionDefaultMemoryType);
/** @internal */
export const UpdateProjectDataCacheProjectsFunctionDefaultMemoryType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsFunctionDefaultMemoryType
  > = UpdateProjectDataCacheProjectsFunctionDefaultMemoryType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsBuildMachineType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsBuildMachineType> = z
    .nativeEnum(UpdateProjectDataCacheProjectsBuildMachineType);
/** @internal */
export const UpdateProjectDataCacheProjectsBuildMachineType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsBuildMachineType> =
    UpdateProjectDataCacheProjectsBuildMachineType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheResourceConfig$inboundSchema: z.ZodType<
  UpdateProjectDataCacheResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  fluid: z.boolean().optional(),
  functionDefaultRegions: z.array(z.string()),
  functionDefaultTimeout: z.number().optional(),
  functionDefaultMemoryType:
    UpdateProjectDataCacheProjectsFunctionDefaultMemoryType$inboundSchema
      .optional(),
  functionZeroConfigFailover: z.boolean().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildMachineType: UpdateProjectDataCacheProjectsBuildMachineType$inboundSchema
    .optional(),
  isNSNBDisabled: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheResourceConfig$Outbound = {
  fluid?: boolean | undefined;
  functionDefaultRegions: Array<string>;
  functionDefaultTimeout?: number | undefined;
  functionDefaultMemoryType?: string | undefined;
  functionZeroConfigFailover?: boolean | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  buildMachineType?: string | undefined;
  isNSNBDisabled?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheResourceConfig$outboundSchema: z.ZodType<
  UpdateProjectDataCacheResourceConfig$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheResourceConfig
> = z.object({
  fluid: z.boolean().optional(),
  functionDefaultRegions: z.array(z.string()),
  functionDefaultTimeout: z.number().optional(),
  functionDefaultMemoryType:
    UpdateProjectDataCacheProjectsFunctionDefaultMemoryType$outboundSchema
      .optional(),
  functionZeroConfigFailover: z.boolean().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildMachineType:
    UpdateProjectDataCacheProjectsBuildMachineType$outboundSchema.optional(),
  isNSNBDisabled: z.boolean().optional(),
});

export function updateProjectDataCacheResourceConfigToJSON(
  updateProjectDataCacheResourceConfig: UpdateProjectDataCacheResourceConfig,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheResourceConfig$outboundSchema.parse(
      updateProjectDataCacheResourceConfig,
    ),
  );
}
export function updateProjectDataCacheResourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheResourceConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheResourceConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheResourceConfig' from JSON`,
  );
}

/** @internal */
export const RollbackDescription$inboundSchema: z.ZodType<
  RollbackDescription,
  z.ZodTypeDef,
  unknown
> = z.object({
  userId: z.string(),
  username: z.string(),
  description: z.string(),
  createdAt: z.number(),
});
/** @internal */
export type RollbackDescription$Outbound = {
  userId: string;
  username: string;
  description: string;
  createdAt: number;
};

/** @internal */
export const RollbackDescription$outboundSchema: z.ZodType<
  RollbackDescription$Outbound,
  z.ZodTypeDef,
  RollbackDescription
> = z.object({
  userId: z.string(),
  username: z.string(),
  description: z.string(),
  createdAt: z.number(),
});

export function rollbackDescriptionToJSON(
  rollbackDescription: RollbackDescription,
): string {
  return JSON.stringify(
    RollbackDescription$outboundSchema.parse(rollbackDescription),
  );
}
export function rollbackDescriptionFromJSON(
  jsonString: string,
): SafeParseResult<RollbackDescription, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RollbackDescription$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RollbackDescription' from JSON`,
  );
}

/** @internal */
export const Stages$inboundSchema: z.ZodType<Stages, z.ZodTypeDef, unknown> = z
  .object({
    targetPercentage: z.number(),
    requireApproval: z.boolean().optional(),
    duration: z.number().optional(),
    linearShift: z.boolean().optional(),
  });
/** @internal */
export type Stages$Outbound = {
  targetPercentage: number;
  requireApproval?: boolean | undefined;
  duration?: number | undefined;
  linearShift?: boolean | undefined;
};

/** @internal */
export const Stages$outboundSchema: z.ZodType<
  Stages$Outbound,
  z.ZodTypeDef,
  Stages
> = z.object({
  targetPercentage: z.number(),
  requireApproval: z.boolean().optional(),
  duration: z.number().optional(),
  linearShift: z.boolean().optional(),
});

export function stagesToJSON(stages: Stages): string {
  return JSON.stringify(Stages$outboundSchema.parse(stages));
}
export function stagesFromJSON(
  jsonString: string,
): SafeParseResult<Stages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stages' from JSON`,
  );
}

/** @internal */
export const RollingRelease$inboundSchema: z.ZodType<
  RollingRelease,
  z.ZodTypeDef,
  unknown
> = z.object({
  target: z.string(),
  stages: z.nullable(z.array(z.lazy(() => Stages$inboundSchema))).optional(),
  canaryResponseHeader: z.boolean().optional(),
});
/** @internal */
export type RollingRelease$Outbound = {
  target: string;
  stages?: Array<Stages$Outbound> | null | undefined;
  canaryResponseHeader?: boolean | undefined;
};

/** @internal */
export const RollingRelease$outboundSchema: z.ZodType<
  RollingRelease$Outbound,
  z.ZodTypeDef,
  RollingRelease
> = z.object({
  target: z.string(),
  stages: z.nullable(z.array(z.lazy(() => Stages$outboundSchema))).optional(),
  canaryResponseHeader: z.boolean().optional(),
});

export function rollingReleaseToJSON(rollingRelease: RollingRelease): string {
  return JSON.stringify(RollingRelease$outboundSchema.parse(rollingRelease));
}
export function rollingReleaseFromJSON(
  jsonString: string,
): SafeParseResult<RollingRelease, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RollingRelease$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RollingRelease' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheFunctionDefaultMemoryType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheFunctionDefaultMemoryType> = z
    .nativeEnum(UpdateProjectDataCacheFunctionDefaultMemoryType);
/** @internal */
export const UpdateProjectDataCacheFunctionDefaultMemoryType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheFunctionDefaultMemoryType> =
    UpdateProjectDataCacheFunctionDefaultMemoryType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheBuildMachineType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBuildMachineType> = z.nativeEnum(
    UpdateProjectDataCacheBuildMachineType,
  );
/** @internal */
export const UpdateProjectDataCacheBuildMachineType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBuildMachineType> =
    UpdateProjectDataCacheBuildMachineType$inboundSchema;

/** @internal */
export const DefaultResourceConfig$inboundSchema: z.ZodType<
  DefaultResourceConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  fluid: z.boolean().optional(),
  functionDefaultRegions: z.array(z.string()),
  functionDefaultTimeout: z.number().optional(),
  functionDefaultMemoryType:
    UpdateProjectDataCacheFunctionDefaultMemoryType$inboundSchema.optional(),
  functionZeroConfigFailover: z.boolean().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildMachineType: UpdateProjectDataCacheBuildMachineType$inboundSchema
    .optional(),
  isNSNBDisabled: z.boolean().optional(),
});
/** @internal */
export type DefaultResourceConfig$Outbound = {
  fluid?: boolean | undefined;
  functionDefaultRegions: Array<string>;
  functionDefaultTimeout?: number | undefined;
  functionDefaultMemoryType?: string | undefined;
  functionZeroConfigFailover?: boolean | undefined;
  elasticConcurrencyEnabled?: boolean | undefined;
  buildMachineType?: string | undefined;
  isNSNBDisabled?: boolean | undefined;
};

/** @internal */
export const DefaultResourceConfig$outboundSchema: z.ZodType<
  DefaultResourceConfig$Outbound,
  z.ZodTypeDef,
  DefaultResourceConfig
> = z.object({
  fluid: z.boolean().optional(),
  functionDefaultRegions: z.array(z.string()),
  functionDefaultTimeout: z.number().optional(),
  functionDefaultMemoryType:
    UpdateProjectDataCacheFunctionDefaultMemoryType$outboundSchema.optional(),
  functionZeroConfigFailover: z.boolean().optional(),
  elasticConcurrencyEnabled: z.boolean().optional(),
  buildMachineType: UpdateProjectDataCacheBuildMachineType$outboundSchema
    .optional(),
  isNSNBDisabled: z.boolean().optional(),
});

export function defaultResourceConfigToJSON(
  defaultResourceConfig: DefaultResourceConfig,
): string {
  return JSON.stringify(
    DefaultResourceConfig$outboundSchema.parse(defaultResourceConfig),
  );
}
export function defaultResourceConfigFromJSON(
  jsonString: string,
): SafeParseResult<DefaultResourceConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultResourceConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultResourceConfig' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheStaticIps$inboundSchema: z.ZodType<
  UpdateProjectDataCacheStaticIps,
  z.ZodTypeDef,
  unknown
> = z.object({
  builds: z.boolean(),
  enabled: z.boolean(),
  regions: z.array(z.string()),
});
/** @internal */
export type UpdateProjectDataCacheStaticIps$Outbound = {
  builds: boolean;
  enabled: boolean;
  regions: Array<string>;
};

/** @internal */
export const UpdateProjectDataCacheStaticIps$outboundSchema: z.ZodType<
  UpdateProjectDataCacheStaticIps$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheStaticIps
> = z.object({
  builds: z.boolean(),
  enabled: z.boolean(),
  regions: z.array(z.string()),
});

export function updateProjectDataCacheStaticIpsToJSON(
  updateProjectDataCacheStaticIps: UpdateProjectDataCacheStaticIps,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheStaticIps$outboundSchema.parse(
      updateProjectDataCacheStaticIps,
    ),
  );
}
export function updateProjectDataCacheStaticIpsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheStaticIps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheStaticIps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheStaticIps' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheDeploymentType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheDeploymentType> = z.nativeEnum(
    UpdateProjectDataCacheDeploymentType,
  );
/** @internal */
export const UpdateProjectDataCacheDeploymentType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheDeploymentType> =
    UpdateProjectDataCacheDeploymentType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheSsoProtection$inboundSchema: z.ZodType<
  UpdateProjectDataCacheSsoProtection,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: UpdateProjectDataCacheDeploymentType$inboundSchema,
});
/** @internal */
export type UpdateProjectDataCacheSsoProtection$Outbound = {
  deploymentType: string;
};

/** @internal */
export const UpdateProjectDataCacheSsoProtection$outboundSchema: z.ZodType<
  UpdateProjectDataCacheSsoProtection$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheSsoProtection
> = z.object({
  deploymentType: UpdateProjectDataCacheDeploymentType$outboundSchema,
});

export function updateProjectDataCacheSsoProtectionToJSON(
  updateProjectDataCacheSsoProtection: UpdateProjectDataCacheSsoProtection,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheSsoProtection$outboundSchema.parse(
      updateProjectDataCacheSsoProtection,
    ),
  );
}
export function updateProjectDataCacheSsoProtectionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheSsoProtection, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheSsoProtection$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheSsoProtection' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheAliasAssigned$inboundSchema: z.ZodType<
  UpdateProjectDataCacheAliasAssigned,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.boolean()]);
/** @internal */
export type UpdateProjectDataCacheAliasAssigned$Outbound = number | boolean;

/** @internal */
export const UpdateProjectDataCacheAliasAssigned$outboundSchema: z.ZodType<
  UpdateProjectDataCacheAliasAssigned$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheAliasAssigned
> = z.union([z.number(), z.boolean()]);

export function updateProjectDataCacheAliasAssignedToJSON(
  updateProjectDataCacheAliasAssigned: UpdateProjectDataCacheAliasAssigned,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheAliasAssigned$outboundSchema.parse(
      updateProjectDataCacheAliasAssigned,
    ),
  );
}
export function updateProjectDataCacheAliasAssignedFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheAliasAssigned, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheAliasAssigned$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheAliasAssigned' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheAliasError$inboundSchema: z.ZodType<
  UpdateProjectDataCacheAliasError,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string(),
  message: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheAliasError$Outbound = {
  code: string;
  message: string;
};

/** @internal */
export const UpdateProjectDataCacheAliasError$outboundSchema: z.ZodType<
  UpdateProjectDataCacheAliasError$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheAliasError
> = z.object({
  code: z.string(),
  message: z.string(),
});

export function updateProjectDataCacheAliasErrorToJSON(
  updateProjectDataCacheAliasError: UpdateProjectDataCacheAliasError,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheAliasError$outboundSchema.parse(
      updateProjectDataCacheAliasError,
    ),
  );
}
export function updateProjectDataCacheAliasErrorFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheAliasError, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheAliasError$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheAliasError' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsBranchMatcher$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsBranchMatcher,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType$inboundSchema,
    pattern: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheProjectsBranchMatcher$Outbound = {
  type: string;
  pattern: string;
};

/** @internal */
export const UpdateProjectDataCacheProjectsBranchMatcher$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheProjectsBranchMatcher$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheProjectsBranchMatcher
  > = z.object({
    type:
      UpdateProjectDataCacheProjectsResponse200ApplicationJSONResponseBodyType$outboundSchema,
    pattern: z.string(),
  });

export function updateProjectDataCacheProjectsBranchMatcherToJSON(
  updateProjectDataCacheProjectsBranchMatcher:
    UpdateProjectDataCacheProjectsBranchMatcher,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheProjectsBranchMatcher$outboundSchema.parse(
      updateProjectDataCacheProjectsBranchMatcher,
    ),
  );
}
export function updateProjectDataCacheProjectsBranchMatcherFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheProjectsBranchMatcher,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheProjectsBranchMatcher$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheProjectsBranchMatcher' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheBuilds$inboundSchema: z.ZodType<
  UpdateProjectDataCacheBuilds,
  z.ZodTypeDef,
  unknown
> = z.object({
  use: z.string(),
  src: z.string().optional(),
  dest: z.string().optional(),
});
/** @internal */
export type UpdateProjectDataCacheBuilds$Outbound = {
  use: string;
  src?: string | undefined;
  dest?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheBuilds$outboundSchema: z.ZodType<
  UpdateProjectDataCacheBuilds$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheBuilds
> = z.object({
  use: z.string(),
  src: z.string().optional(),
  dest: z.string().optional(),
});

export function updateProjectDataCacheBuildsToJSON(
  updateProjectDataCacheBuilds: UpdateProjectDataCacheBuilds,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheBuilds$outboundSchema.parse(
      updateProjectDataCacheBuilds,
    ),
  );
}
export function updateProjectDataCacheBuildsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheBuilds, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheBuilds$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheBuilds' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheChecksConclusion$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheChecksConclusion> = z.nativeEnum(
    UpdateProjectDataCacheChecksConclusion,
  );
/** @internal */
export const UpdateProjectDataCacheChecksConclusion$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheChecksConclusion> =
    UpdateProjectDataCacheChecksConclusion$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheChecksState$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheChecksState
> = z.nativeEnum(UpdateProjectDataCacheChecksState);
/** @internal */
export const UpdateProjectDataCacheChecksState$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheChecksState
> = UpdateProjectDataCacheChecksState$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheCreator$inboundSchema: z.ZodType<
  UpdateProjectDataCacheCreator,
  z.ZodTypeDef,
  unknown
> = z.object({
  email: z.string(),
  githubLogin: z.string().optional(),
  gitlabLogin: z.string().optional(),
  uid: z.string(),
  username: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheCreator$Outbound = {
  email: string;
  githubLogin?: string | undefined;
  gitlabLogin?: string | undefined;
  uid: string;
  username: string;
};

/** @internal */
export const UpdateProjectDataCacheCreator$outboundSchema: z.ZodType<
  UpdateProjectDataCacheCreator$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheCreator
> = z.object({
  email: z.string(),
  githubLogin: z.string().optional(),
  gitlabLogin: z.string().optional(),
  uid: z.string(),
  username: z.string(),
});

export function updateProjectDataCacheCreatorToJSON(
  updateProjectDataCacheCreator: UpdateProjectDataCacheCreator,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheCreator$outboundSchema.parse(
      updateProjectDataCacheCreator,
    ),
  );
}
export function updateProjectDataCacheCreatorFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheCreator, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheCreator$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheCreator' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheOidcTokenClaims$inboundSchema: z.ZodType<
  UpdateProjectDataCacheOidcTokenClaims,
  z.ZodTypeDef,
  unknown
> = z.object({
  iss: z.string(),
  sub: z.string(),
  scope: z.string(),
  aud: z.string(),
  owner: z.string(),
  owner_id: z.string(),
  project: z.string(),
  project_id: z.string(),
  environment: z.string(),
  plan: z.string(),
}).transform((v) => {
  return remap$(v, {
    "owner_id": "ownerId",
    "project_id": "projectId",
  });
});
/** @internal */
export type UpdateProjectDataCacheOidcTokenClaims$Outbound = {
  iss: string;
  sub: string;
  scope: string;
  aud: string;
  owner: string;
  owner_id: string;
  project: string;
  project_id: string;
  environment: string;
  plan: string;
};

/** @internal */
export const UpdateProjectDataCacheOidcTokenClaims$outboundSchema: z.ZodType<
  UpdateProjectDataCacheOidcTokenClaims$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheOidcTokenClaims
> = z.object({
  iss: z.string(),
  sub: z.string(),
  scope: z.string(),
  aud: z.string(),
  owner: z.string(),
  ownerId: z.string(),
  project: z.string(),
  projectId: z.string(),
  environment: z.string(),
  plan: z.string(),
}).transform((v) => {
  return remap$(v, {
    ownerId: "owner_id",
    projectId: "project_id",
  });
});

export function updateProjectDataCacheOidcTokenClaimsToJSON(
  updateProjectDataCacheOidcTokenClaims: UpdateProjectDataCacheOidcTokenClaims,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheOidcTokenClaims$outboundSchema.parse(
      updateProjectDataCacheOidcTokenClaims,
    ),
  );
}
export function updateProjectDataCacheOidcTokenClaimsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheOidcTokenClaims, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheOidcTokenClaims$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheOidcTokenClaims' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCachePlan$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCachePlan
> = z.nativeEnum(UpdateProjectDataCachePlan);
/** @internal */
export const UpdateProjectDataCachePlan$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCachePlan
> = UpdateProjectDataCachePlan$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheReadyState$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheReadyState
> = z.nativeEnum(UpdateProjectDataCacheReadyState);
/** @internal */
export const UpdateProjectDataCacheReadyState$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheReadyState
> = UpdateProjectDataCacheReadyState$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheReadySubstate$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheReadySubstate
> = z.nativeEnum(UpdateProjectDataCacheReadySubstate);
/** @internal */
export const UpdateProjectDataCacheReadySubstate$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheReadySubstate> =
    UpdateProjectDataCacheReadySubstate$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponseType> = z
    .nativeEnum(UpdateProjectDataCacheProjectsResponseType);
/** @internal */
export const UpdateProjectDataCacheProjectsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponseType> =
    UpdateProjectDataCacheProjectsResponseType$inboundSchema;

/** @internal */
export const Targets$inboundSchema: z.ZodType<Targets, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    alias: z.array(z.string()).optional(),
    aliasAssigned: z.nullable(z.union([z.number(), z.boolean()])).optional(),
    aliasError: z.nullable(
      z.lazy(() => UpdateProjectDataCacheAliasError$inboundSchema),
    ).optional(),
    aliasFinal: z.nullable(z.string()).optional(),
    automaticAliases: z.array(z.string()).optional(),
    branchMatcher: z.lazy(() =>
      UpdateProjectDataCacheProjectsBranchMatcher$inboundSchema
    ).optional(),
    buildingAt: z.number().optional(),
    builds: z.array(z.lazy(() => UpdateProjectDataCacheBuilds$inboundSchema))
      .optional(),
    checksConclusion: UpdateProjectDataCacheChecksConclusion$inboundSchema
      .optional(),
    checksState: UpdateProjectDataCacheChecksState$inboundSchema.optional(),
    connectBuildsEnabled: z.boolean().optional(),
    connectConfigurationId: z.string().optional(),
    createdAt: z.number(),
    createdIn: z.string(),
    creator: z.nullable(
      z.lazy(() => UpdateProjectDataCacheCreator$inboundSchema),
    ),
    deletedAt: z.number().optional(),
    deploymentHostname: z.string(),
    forced: z.boolean().optional(),
    name: z.string(),
    meta: z.record(z.string()).optional(),
    monorepoManager: z.nullable(z.string()).optional(),
    oidcTokenClaims: z.lazy(() =>
      UpdateProjectDataCacheOidcTokenClaims$inboundSchema
    ).optional(),
    plan: UpdateProjectDataCachePlan$inboundSchema,
    previewCommentsEnabled: z.boolean().optional(),
    private: z.boolean(),
    readyAt: z.number().optional(),
    readyState: UpdateProjectDataCacheReadyState$inboundSchema,
    readySubstate: UpdateProjectDataCacheReadySubstate$inboundSchema.optional(),
    requestedAt: z.number().optional(),
    target: z.nullable(z.string()).optional(),
    teamId: z.nullable(z.string()).optional(),
    type: UpdateProjectDataCacheProjectsResponseType$inboundSchema,
    url: z.string(),
    userId: z.string(),
    withCache: z.boolean().optional(),
  });
/** @internal */
export type Targets$Outbound = {
  id: string;
  alias?: Array<string> | undefined;
  aliasAssigned?: number | boolean | null | undefined;
  aliasError?: UpdateProjectDataCacheAliasError$Outbound | null | undefined;
  aliasFinal?: string | null | undefined;
  automaticAliases?: Array<string> | undefined;
  branchMatcher?:
    | UpdateProjectDataCacheProjectsBranchMatcher$Outbound
    | undefined;
  buildingAt?: number | undefined;
  builds?: Array<UpdateProjectDataCacheBuilds$Outbound> | undefined;
  checksConclusion?: string | undefined;
  checksState?: string | undefined;
  connectBuildsEnabled?: boolean | undefined;
  connectConfigurationId?: string | undefined;
  createdAt: number;
  createdIn: string;
  creator: UpdateProjectDataCacheCreator$Outbound | null;
  deletedAt?: number | undefined;
  deploymentHostname: string;
  forced?: boolean | undefined;
  name: string;
  meta?: { [k: string]: string } | undefined;
  monorepoManager?: string | null | undefined;
  oidcTokenClaims?: UpdateProjectDataCacheOidcTokenClaims$Outbound | undefined;
  plan: string;
  previewCommentsEnabled?: boolean | undefined;
  private: boolean;
  readyAt?: number | undefined;
  readyState: string;
  readySubstate?: string | undefined;
  requestedAt?: number | undefined;
  target?: string | null | undefined;
  teamId?: string | null | undefined;
  type: string;
  url: string;
  userId: string;
  withCache?: boolean | undefined;
};

/** @internal */
export const Targets$outboundSchema: z.ZodType<
  Targets$Outbound,
  z.ZodTypeDef,
  Targets
> = z.object({
  id: z.string(),
  alias: z.array(z.string()).optional(),
  aliasAssigned: z.nullable(z.union([z.number(), z.boolean()])).optional(),
  aliasError: z.nullable(
    z.lazy(() => UpdateProjectDataCacheAliasError$outboundSchema),
  ).optional(),
  aliasFinal: z.nullable(z.string()).optional(),
  automaticAliases: z.array(z.string()).optional(),
  branchMatcher: z.lazy(() =>
    UpdateProjectDataCacheProjectsBranchMatcher$outboundSchema
  ).optional(),
  buildingAt: z.number().optional(),
  builds: z.array(z.lazy(() => UpdateProjectDataCacheBuilds$outboundSchema))
    .optional(),
  checksConclusion: UpdateProjectDataCacheChecksConclusion$outboundSchema
    .optional(),
  checksState: UpdateProjectDataCacheChecksState$outboundSchema.optional(),
  connectBuildsEnabled: z.boolean().optional(),
  connectConfigurationId: z.string().optional(),
  createdAt: z.number(),
  createdIn: z.string(),
  creator: z.nullable(
    z.lazy(() => UpdateProjectDataCacheCreator$outboundSchema),
  ),
  deletedAt: z.number().optional(),
  deploymentHostname: z.string(),
  forced: z.boolean().optional(),
  name: z.string(),
  meta: z.record(z.string()).optional(),
  monorepoManager: z.nullable(z.string()).optional(),
  oidcTokenClaims: z.lazy(() =>
    UpdateProjectDataCacheOidcTokenClaims$outboundSchema
  ).optional(),
  plan: UpdateProjectDataCachePlan$outboundSchema,
  previewCommentsEnabled: z.boolean().optional(),
  private: z.boolean(),
  readyAt: z.number().optional(),
  readyState: UpdateProjectDataCacheReadyState$outboundSchema,
  readySubstate: UpdateProjectDataCacheReadySubstate$outboundSchema.optional(),
  requestedAt: z.number().optional(),
  target: z.nullable(z.string()).optional(),
  teamId: z.nullable(z.string()).optional(),
  type: UpdateProjectDataCacheProjectsResponseType$outboundSchema,
  url: z.string(),
  userId: z.string(),
  withCache: z.boolean().optional(),
});

export function targetsToJSON(targets: Targets): string {
  return JSON.stringify(Targets$outboundSchema.parse(targets));
}
export function targetsFromJSON(
  jsonString: string,
): SafeParseResult<Targets, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Targets$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Targets' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCachePermissions$inboundSchema: z.ZodType<
  UpdateProjectDataCachePermissions,
  z.ZodTypeDef,
  unknown
> = z.object({
  oauth2Connection: z.array(ACLAction$inboundSchema).optional(),
  user: z.array(ACLAction$inboundSchema).optional(),
  userConnection: z.array(ACLAction$inboundSchema).optional(),
  userSudo: z.array(ACLAction$inboundSchema).optional(),
  webAuthn: z.array(ACLAction$inboundSchema).optional(),
  accessGroup: z.array(ACLAction$inboundSchema).optional(),
  agent: z.array(ACLAction$inboundSchema).optional(),
  alerts: z.array(ACLAction$inboundSchema).optional(),
  aliasGlobal: z.array(ACLAction$inboundSchema).optional(),
  analyticsSampling: z.array(ACLAction$inboundSchema).optional(),
  analyticsUsage: z.array(ACLAction$inboundSchema).optional(),
  apiKey: z.array(ACLAction$inboundSchema).optional(),
  apiKeyAiGateway: z.array(ACLAction$inboundSchema).optional(),
  apiKeyOwnedBySelf: z.array(ACLAction$inboundSchema).optional(),
  oauth2Application: z.array(ACLAction$inboundSchema).optional(),
  vercelAppInstallation: z.array(ACLAction$inboundSchema).optional(),
  vercelAppInstallationRequest: z.array(ACLAction$inboundSchema).optional(),
  auditLog: z.array(ACLAction$inboundSchema).optional(),
  billingAddress: z.array(ACLAction$inboundSchema).optional(),
  billingInformation: z.array(ACLAction$inboundSchema).optional(),
  billingInvoice: z.array(ACLAction$inboundSchema).optional(),
  billingInvoiceEmailRecipient: z.array(ACLAction$inboundSchema).optional(),
  billingInvoiceLanguage: z.array(ACLAction$inboundSchema).optional(),
  billingPlan: z.array(ACLAction$inboundSchema).optional(),
  billingPurchaseOrder: z.array(ACLAction$inboundSchema).optional(),
  billingRefund: z.array(ACLAction$inboundSchema).optional(),
  billingTaxId: z.array(ACLAction$inboundSchema).optional(),
  blob: z.array(ACLAction$inboundSchema).optional(),
  blobStoreTokenSet: z.array(ACLAction$inboundSchema).optional(),
  budget: z.array(ACLAction$inboundSchema).optional(),
  cacheArtifact: z.array(ACLAction$inboundSchema).optional(),
  cacheArtifactUsageEvent: z.array(ACLAction$inboundSchema).optional(),
  codeChecks: z.array(ACLAction$inboundSchema).optional(),
  concurrentBuilds: z.array(ACLAction$inboundSchema).optional(),
  connect: z.array(ACLAction$inboundSchema).optional(),
  connectConfiguration: z.array(ACLAction$inboundSchema).optional(),
  dataCacheBillingSettings: z.array(ACLAction$inboundSchema).optional(),
  defaultDeploymentProtection: z.array(ACLAction$inboundSchema).optional(),
  domain: z.array(ACLAction$inboundSchema).optional(),
  domainAcceptDelegation: z.array(ACLAction$inboundSchema).optional(),
  domainAuthCodes: z.array(ACLAction$inboundSchema).optional(),
  domainCertificate: z.array(ACLAction$inboundSchema).optional(),
  domainCheckConfig: z.array(ACLAction$inboundSchema).optional(),
  domainMove: z.array(ACLAction$inboundSchema).optional(),
  domainPurchase: z.array(ACLAction$inboundSchema).optional(),
  domainRecord: z.array(ACLAction$inboundSchema).optional(),
  domainTransferIn: z.array(ACLAction$inboundSchema).optional(),
  drain: z.array(ACLAction$inboundSchema).optional(),
  edgeConfig: z.array(ACLAction$inboundSchema).optional(),
  edgeConfigItem: z.array(ACLAction$inboundSchema).optional(),
  edgeConfigSchema: z.array(ACLAction$inboundSchema).optional(),
  edgeConfigToken: z.array(ACLAction$inboundSchema).optional(),
  endpointVerification: z.array(ACLAction$inboundSchema).optional(),
  event: z.array(ACLAction$inboundSchema).optional(),
  fileUpload: z.array(ACLAction$inboundSchema).optional(),
  flagsExplorerSubscription: z.array(ACLAction$inboundSchema).optional(),
  gitRepository: z.array(ACLAction$inboundSchema).optional(),
  imageOptimizationNewPrice: z.array(ACLAction$inboundSchema).optional(),
  integration: z.array(ACLAction$inboundSchema).optional(),
  integrationAccount: z.array(ACLAction$inboundSchema).optional(),
  integrationConfiguration: z.array(ACLAction$inboundSchema).optional(),
  integrationConfigurationProjects: z.array(ACLAction$inboundSchema).optional(),
  integrationConfigurationRole: z.array(ACLAction$inboundSchema).optional(),
  integrationConfigurationTransfer: z.array(ACLAction$inboundSchema).optional(),
  integrationDeploymentAction: z.array(ACLAction$inboundSchema).optional(),
  integrationEvent: z.array(ACLAction$inboundSchema).optional(),
  integrationLog: z.array(ACLAction$inboundSchema).optional(),
  integrationResource: z.array(ACLAction$inboundSchema).optional(),
  integrationResourceReplCommand: z.array(ACLAction$inboundSchema).optional(),
  integrationResourceSecrets: z.array(ACLAction$inboundSchema).optional(),
  integrationSSOSession: z.array(ACLAction$inboundSchema).optional(),
  integrationStoreTokenSet: z.array(ACLAction$inboundSchema).optional(),
  integrationVercelConfigurationOverride: z.array(ACLAction$inboundSchema)
    .optional(),
  integrationPullRequest: z.array(ACLAction$inboundSchema).optional(),
  ipBlocking: z.array(ACLAction$inboundSchema).optional(),
  jobGlobal: z.array(ACLAction$inboundSchema).optional(),
  logDrain: z.array(ACLAction$inboundSchema).optional(),
  marketplaceBillingData: z.array(ACLAction$inboundSchema).optional(),
  marketplaceExperimentationEdgeConfigData: z.array(ACLAction$inboundSchema)
    .optional(),
  marketplaceExperimentationItem: z.array(ACLAction$inboundSchema).optional(),
  marketplaceInstallationMember: z.array(ACLAction$inboundSchema).optional(),
  marketplaceInvoice: z.array(ACLAction$inboundSchema).optional(),
  marketplaceSettings: z.array(ACLAction$inboundSchema).optional(),
  Monitoring: z.array(ACLAction$inboundSchema).optional(),
  monitoringAlert: z.array(ACLAction$inboundSchema).optional(),
  monitoringChart: z.array(ACLAction$inboundSchema).optional(),
  monitoringQuery: z.array(ACLAction$inboundSchema).optional(),
  monitoringSettings: z.array(ACLAction$inboundSchema).optional(),
  notificationCustomerBudget: z.array(ACLAction$inboundSchema).optional(),
  notificationDeploymentFailed: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainConfiguration: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainExpire: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainMoved: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainPurchase: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainRenewal: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainTransfer: z.array(ACLAction$inboundSchema).optional(),
  notificationDomainUnverified: z.array(ACLAction$inboundSchema).optional(),
  NotificationMonitoringAlert: z.array(ACLAction$inboundSchema).optional(),
  notificationPaymentFailed: z.array(ACLAction$inboundSchema).optional(),
  notificationPreferences: z.array(ACLAction$inboundSchema).optional(),
  notificationStatementOfReasons: z.array(ACLAction$inboundSchema).optional(),
  notificationUsageAlert: z.array(ACLAction$inboundSchema).optional(),
  observabilityConfiguration: z.array(ACLAction$inboundSchema).optional(),
  observabilityFunnel: z.array(ACLAction$inboundSchema).optional(),
  observabilityNotebook: z.array(ACLAction$inboundSchema).optional(),
  openTelemetryEndpoint: z.array(ACLAction$inboundSchema).optional(),
  ownEvent: z.array(ACLAction$inboundSchema).optional(),
  organizationDomain: z.array(ACLAction$inboundSchema).optional(),
  passwordProtectionInvoiceItem: z.array(ACLAction$inboundSchema).optional(),
  paymentMethod: z.array(ACLAction$inboundSchema).optional(),
  permissions: z.array(ACLAction$inboundSchema).optional(),
  postgres: z.array(ACLAction$inboundSchema).optional(),
  postgresStoreTokenSet: z.array(ACLAction$inboundSchema).optional(),
  previewDeploymentSuffix: z.array(ACLAction$inboundSchema).optional(),
  projectTransferIn: z.array(ACLAction$inboundSchema).optional(),
  proTrialOnboarding: z.array(ACLAction$inboundSchema).optional(),
  rateLimit: z.array(ACLAction$inboundSchema).optional(),
  redis: z.array(ACLAction$inboundSchema).optional(),
  redisStoreTokenSet: z.array(ACLAction$inboundSchema).optional(),
  remoteCaching: z.array(ACLAction$inboundSchema).optional(),
  repository: z.array(ACLAction$inboundSchema).optional(),
  samlConfig: z.array(ACLAction$inboundSchema).optional(),
  secret: z.array(ACLAction$inboundSchema).optional(),
  securityPlusConfiguration: z.array(ACLAction$inboundSchema).optional(),
  sensitiveEnvironmentVariablePolicy: z.array(ACLAction$inboundSchema)
    .optional(),
  sharedEnvVars: z.array(ACLAction$inboundSchema).optional(),
  sharedEnvVarsProduction: z.array(ACLAction$inboundSchema).optional(),
  space: z.array(ACLAction$inboundSchema).optional(),
  spaceRun: z.array(ACLAction$inboundSchema).optional(),
  storeTransfer: z.array(ACLAction$inboundSchema).optional(),
  supportCase: z.array(ACLAction$inboundSchema).optional(),
  supportCaseComment: z.array(ACLAction$inboundSchema).optional(),
  team: z.array(ACLAction$inboundSchema).optional(),
  teamAccessRequest: z.array(ACLAction$inboundSchema).optional(),
  teamFellowMembership: z.array(ACLAction$inboundSchema).optional(),
  teamGitExclusivity: z.array(ACLAction$inboundSchema).optional(),
  teamInvite: z.array(ACLAction$inboundSchema).optional(),
  teamInviteCode: z.array(ACLAction$inboundSchema).optional(),
  teamJoin: z.array(ACLAction$inboundSchema).optional(),
  teamMemberMfaStatus: z.array(ACLAction$inboundSchema).optional(),
  teamMicrofrontends: z.array(ACLAction$inboundSchema).optional(),
  teamOwnMembership: z.array(ACLAction$inboundSchema).optional(),
  teamOwnMembershipDisconnectSAML: z.array(ACLAction$inboundSchema).optional(),
  token: z.array(ACLAction$inboundSchema).optional(),
  usage: z.array(ACLAction$inboundSchema).optional(),
  usageCycle: z.array(ACLAction$inboundSchema).optional(),
  vercelRun: z.array(ACLAction$inboundSchema).optional(),
  vercelRunExec: z.array(ACLAction$inboundSchema).optional(),
  vpcPeeringConnection: z.array(ACLAction$inboundSchema).optional(),
  webAnalyticsPlan: z.array(ACLAction$inboundSchema).optional(),
  webhook: z.array(ACLAction$inboundSchema).optional(),
  "webhook-event": z.array(ACLAction$inboundSchema).optional(),
  aliasProject: z.array(ACLAction$inboundSchema).optional(),
  aliasProtectionBypass: z.array(ACLAction$inboundSchema).optional(),
  buildMachine: z.array(ACLAction$inboundSchema).optional(),
  connectConfigurationLink: z.array(ACLAction$inboundSchema).optional(),
  dataCacheNamespace: z.array(ACLAction$inboundSchema).optional(),
  deployment: z.array(ACLAction$inboundSchema).optional(),
  deploymentBuildLogs: z.array(ACLAction$inboundSchema).optional(),
  deploymentCheck: z.array(ACLAction$inboundSchema).optional(),
  deploymentCheckPreview: z.array(ACLAction$inboundSchema).optional(),
  deploymentCheckReRunFromProductionBranch: z.array(ACLAction$inboundSchema)
    .optional(),
  deploymentProductionGit: z.array(ACLAction$inboundSchema).optional(),
  deploymentV0: z.array(ACLAction$inboundSchema).optional(),
  deploymentPreview: z.array(ACLAction$inboundSchema).optional(),
  deploymentPrivate: z.array(ACLAction$inboundSchema).optional(),
  deploymentPromote: z.array(ACLAction$inboundSchema).optional(),
  deploymentRollback: z.array(ACLAction$inboundSchema).optional(),
  edgeCacheNamespace: z.array(ACLAction$inboundSchema).optional(),
  environments: z.array(ACLAction$inboundSchema).optional(),
  job: z.array(ACLAction$inboundSchema).optional(),
  logs: z.array(ACLAction$inboundSchema).optional(),
  logsPreset: z.array(ACLAction$inboundSchema).optional(),
  observabilityData: z.array(ACLAction$inboundSchema).optional(),
  onDemandBuild: z.array(ACLAction$inboundSchema).optional(),
  onDemandConcurrency: z.array(ACLAction$inboundSchema).optional(),
  optionsAllowlist: z.array(ACLAction$inboundSchema).optional(),
  passwordProtection: z.array(ACLAction$inboundSchema).optional(),
  productionAliasProtectionBypass: z.array(ACLAction$inboundSchema).optional(),
  project: z.array(ACLAction$inboundSchema).optional(),
  projectAccessGroup: z.array(ACLAction$inboundSchema).optional(),
  projectAnalyticsSampling: z.array(ACLAction$inboundSchema).optional(),
  projectAnalyticsUsage: z.array(ACLAction$inboundSchema).optional(),
  projectCheck: z.array(ACLAction$inboundSchema).optional(),
  projectCheckRun: z.array(ACLAction$inboundSchema).optional(),
  projectDeploymentExpiration: z.array(ACLAction$inboundSchema).optional(),
  projectDeploymentHook: z.array(ACLAction$inboundSchema).optional(),
  projectDomain: z.array(ACLAction$inboundSchema).optional(),
  projectDomainCheckConfig: z.array(ACLAction$inboundSchema).optional(),
  projectDomainMove: z.array(ACLAction$inboundSchema).optional(),
  projectEnvVars: z.array(ACLAction$inboundSchema).optional(),
  projectEnvVarsProduction: z.array(ACLAction$inboundSchema).optional(),
  projectEnvVarsUnownedByIntegration: z.array(ACLAction$inboundSchema)
    .optional(),
  projectFlags: z.array(ACLAction$inboundSchema).optional(),
  projectFlagsProduction: z.array(ACLAction$inboundSchema).optional(),
  projectFromV0: z.array(ACLAction$inboundSchema).optional(),
  projectId: z.array(ACLAction$inboundSchema).optional(),
  projectIntegrationConfiguration: z.array(ACLAction$inboundSchema).optional(),
  projectLink: z.array(ACLAction$inboundSchema).optional(),
  projectMember: z.array(ACLAction$inboundSchema).optional(),
  projectMonitoring: z.array(ACLAction$inboundSchema).optional(),
  projectOIDCToken: z.array(ACLAction$inboundSchema).optional(),
  projectPermissions: z.array(ACLAction$inboundSchema).optional(),
  projectProductionBranch: z.array(ACLAction$inboundSchema).optional(),
  projectProtectionBypass: z.array(ACLAction$inboundSchema).optional(),
  projectRollingRelease: z.array(ACLAction$inboundSchema).optional(),
  projectSupportCase: z.array(ACLAction$inboundSchema).optional(),
  projectSupportCaseComment: z.array(ACLAction$inboundSchema).optional(),
  projectTier: z.array(ACLAction$inboundSchema).optional(),
  projectTransfer: z.array(ACLAction$inboundSchema).optional(),
  projectTransferOut: z.array(ACLAction$inboundSchema).optional(),
  projectUsage: z.array(ACLAction$inboundSchema).optional(),
  seawallConfig: z.array(ACLAction$inboundSchema).optional(),
  sharedEnvVarConnection: z.array(ACLAction$inboundSchema).optional(),
  skewProtection: z.array(ACLAction$inboundSchema).optional(),
  analytics: z.array(ACLAction$inboundSchema).optional(),
  trustedIps: z.array(ACLAction$inboundSchema).optional(),
  v0Chat: z.array(ACLAction$inboundSchema).optional(),
  webAnalytics: z.array(ACLAction$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "Monitoring": "monitoring",
    "NotificationMonitoringAlert": "notificationMonitoringAlert",
    "webhook-event": "webhookEvent",
  });
});
/** @internal */
export type UpdateProjectDataCachePermissions$Outbound = {
  oauth2Connection?: Array<string> | undefined;
  user?: Array<string> | undefined;
  userConnection?: Array<string> | undefined;
  userSudo?: Array<string> | undefined;
  webAuthn?: Array<string> | undefined;
  accessGroup?: Array<string> | undefined;
  agent?: Array<string> | undefined;
  alerts?: Array<string> | undefined;
  aliasGlobal?: Array<string> | undefined;
  analyticsSampling?: Array<string> | undefined;
  analyticsUsage?: Array<string> | undefined;
  apiKey?: Array<string> | undefined;
  apiKeyAiGateway?: Array<string> | undefined;
  apiKeyOwnedBySelf?: Array<string> | undefined;
  oauth2Application?: Array<string> | undefined;
  vercelAppInstallation?: Array<string> | undefined;
  vercelAppInstallationRequest?: Array<string> | undefined;
  auditLog?: Array<string> | undefined;
  billingAddress?: Array<string> | undefined;
  billingInformation?: Array<string> | undefined;
  billingInvoice?: Array<string> | undefined;
  billingInvoiceEmailRecipient?: Array<string> | undefined;
  billingInvoiceLanguage?: Array<string> | undefined;
  billingPlan?: Array<string> | undefined;
  billingPurchaseOrder?: Array<string> | undefined;
  billingRefund?: Array<string> | undefined;
  billingTaxId?: Array<string> | undefined;
  blob?: Array<string> | undefined;
  blobStoreTokenSet?: Array<string> | undefined;
  budget?: Array<string> | undefined;
  cacheArtifact?: Array<string> | undefined;
  cacheArtifactUsageEvent?: Array<string> | undefined;
  codeChecks?: Array<string> | undefined;
  concurrentBuilds?: Array<string> | undefined;
  connect?: Array<string> | undefined;
  connectConfiguration?: Array<string> | undefined;
  dataCacheBillingSettings?: Array<string> | undefined;
  defaultDeploymentProtection?: Array<string> | undefined;
  domain?: Array<string> | undefined;
  domainAcceptDelegation?: Array<string> | undefined;
  domainAuthCodes?: Array<string> | undefined;
  domainCertificate?: Array<string> | undefined;
  domainCheckConfig?: Array<string> | undefined;
  domainMove?: Array<string> | undefined;
  domainPurchase?: Array<string> | undefined;
  domainRecord?: Array<string> | undefined;
  domainTransferIn?: Array<string> | undefined;
  drain?: Array<string> | undefined;
  edgeConfig?: Array<string> | undefined;
  edgeConfigItem?: Array<string> | undefined;
  edgeConfigSchema?: Array<string> | undefined;
  edgeConfigToken?: Array<string> | undefined;
  endpointVerification?: Array<string> | undefined;
  event?: Array<string> | undefined;
  fileUpload?: Array<string> | undefined;
  flagsExplorerSubscription?: Array<string> | undefined;
  gitRepository?: Array<string> | undefined;
  imageOptimizationNewPrice?: Array<string> | undefined;
  integration?: Array<string> | undefined;
  integrationAccount?: Array<string> | undefined;
  integrationConfiguration?: Array<string> | undefined;
  integrationConfigurationProjects?: Array<string> | undefined;
  integrationConfigurationRole?: Array<string> | undefined;
  integrationConfigurationTransfer?: Array<string> | undefined;
  integrationDeploymentAction?: Array<string> | undefined;
  integrationEvent?: Array<string> | undefined;
  integrationLog?: Array<string> | undefined;
  integrationResource?: Array<string> | undefined;
  integrationResourceReplCommand?: Array<string> | undefined;
  integrationResourceSecrets?: Array<string> | undefined;
  integrationSSOSession?: Array<string> | undefined;
  integrationStoreTokenSet?: Array<string> | undefined;
  integrationVercelConfigurationOverride?: Array<string> | undefined;
  integrationPullRequest?: Array<string> | undefined;
  ipBlocking?: Array<string> | undefined;
  jobGlobal?: Array<string> | undefined;
  logDrain?: Array<string> | undefined;
  marketplaceBillingData?: Array<string> | undefined;
  marketplaceExperimentationEdgeConfigData?: Array<string> | undefined;
  marketplaceExperimentationItem?: Array<string> | undefined;
  marketplaceInstallationMember?: Array<string> | undefined;
  marketplaceInvoice?: Array<string> | undefined;
  marketplaceSettings?: Array<string> | undefined;
  Monitoring?: Array<string> | undefined;
  monitoringAlert?: Array<string> | undefined;
  monitoringChart?: Array<string> | undefined;
  monitoringQuery?: Array<string> | undefined;
  monitoringSettings?: Array<string> | undefined;
  notificationCustomerBudget?: Array<string> | undefined;
  notificationDeploymentFailed?: Array<string> | undefined;
  notificationDomainConfiguration?: Array<string> | undefined;
  notificationDomainExpire?: Array<string> | undefined;
  notificationDomainMoved?: Array<string> | undefined;
  notificationDomainPurchase?: Array<string> | undefined;
  notificationDomainRenewal?: Array<string> | undefined;
  notificationDomainTransfer?: Array<string> | undefined;
  notificationDomainUnverified?: Array<string> | undefined;
  NotificationMonitoringAlert?: Array<string> | undefined;
  notificationPaymentFailed?: Array<string> | undefined;
  notificationPreferences?: Array<string> | undefined;
  notificationStatementOfReasons?: Array<string> | undefined;
  notificationUsageAlert?: Array<string> | undefined;
  observabilityConfiguration?: Array<string> | undefined;
  observabilityFunnel?: Array<string> | undefined;
  observabilityNotebook?: Array<string> | undefined;
  openTelemetryEndpoint?: Array<string> | undefined;
  ownEvent?: Array<string> | undefined;
  organizationDomain?: Array<string> | undefined;
  passwordProtectionInvoiceItem?: Array<string> | undefined;
  paymentMethod?: Array<string> | undefined;
  permissions?: Array<string> | undefined;
  postgres?: Array<string> | undefined;
  postgresStoreTokenSet?: Array<string> | undefined;
  previewDeploymentSuffix?: Array<string> | undefined;
  projectTransferIn?: Array<string> | undefined;
  proTrialOnboarding?: Array<string> | undefined;
  rateLimit?: Array<string> | undefined;
  redis?: Array<string> | undefined;
  redisStoreTokenSet?: Array<string> | undefined;
  remoteCaching?: Array<string> | undefined;
  repository?: Array<string> | undefined;
  samlConfig?: Array<string> | undefined;
  secret?: Array<string> | undefined;
  securityPlusConfiguration?: Array<string> | undefined;
  sensitiveEnvironmentVariablePolicy?: Array<string> | undefined;
  sharedEnvVars?: Array<string> | undefined;
  sharedEnvVarsProduction?: Array<string> | undefined;
  space?: Array<string> | undefined;
  spaceRun?: Array<string> | undefined;
  storeTransfer?: Array<string> | undefined;
  supportCase?: Array<string> | undefined;
  supportCaseComment?: Array<string> | undefined;
  team?: Array<string> | undefined;
  teamAccessRequest?: Array<string> | undefined;
  teamFellowMembership?: Array<string> | undefined;
  teamGitExclusivity?: Array<string> | undefined;
  teamInvite?: Array<string> | undefined;
  teamInviteCode?: Array<string> | undefined;
  teamJoin?: Array<string> | undefined;
  teamMemberMfaStatus?: Array<string> | undefined;
  teamMicrofrontends?: Array<string> | undefined;
  teamOwnMembership?: Array<string> | undefined;
  teamOwnMembershipDisconnectSAML?: Array<string> | undefined;
  token?: Array<string> | undefined;
  usage?: Array<string> | undefined;
  usageCycle?: Array<string> | undefined;
  vercelRun?: Array<string> | undefined;
  vercelRunExec?: Array<string> | undefined;
  vpcPeeringConnection?: Array<string> | undefined;
  webAnalyticsPlan?: Array<string> | undefined;
  webhook?: Array<string> | undefined;
  "webhook-event"?: Array<string> | undefined;
  aliasProject?: Array<string> | undefined;
  aliasProtectionBypass?: Array<string> | undefined;
  buildMachine?: Array<string> | undefined;
  connectConfigurationLink?: Array<string> | undefined;
  dataCacheNamespace?: Array<string> | undefined;
  deployment?: Array<string> | undefined;
  deploymentBuildLogs?: Array<string> | undefined;
  deploymentCheck?: Array<string> | undefined;
  deploymentCheckPreview?: Array<string> | undefined;
  deploymentCheckReRunFromProductionBranch?: Array<string> | undefined;
  deploymentProductionGit?: Array<string> | undefined;
  deploymentV0?: Array<string> | undefined;
  deploymentPreview?: Array<string> | undefined;
  deploymentPrivate?: Array<string> | undefined;
  deploymentPromote?: Array<string> | undefined;
  deploymentRollback?: Array<string> | undefined;
  edgeCacheNamespace?: Array<string> | undefined;
  environments?: Array<string> | undefined;
  job?: Array<string> | undefined;
  logs?: Array<string> | undefined;
  logsPreset?: Array<string> | undefined;
  observabilityData?: Array<string> | undefined;
  onDemandBuild?: Array<string> | undefined;
  onDemandConcurrency?: Array<string> | undefined;
  optionsAllowlist?: Array<string> | undefined;
  passwordProtection?: Array<string> | undefined;
  productionAliasProtectionBypass?: Array<string> | undefined;
  project?: Array<string> | undefined;
  projectAccessGroup?: Array<string> | undefined;
  projectAnalyticsSampling?: Array<string> | undefined;
  projectAnalyticsUsage?: Array<string> | undefined;
  projectCheck?: Array<string> | undefined;
  projectCheckRun?: Array<string> | undefined;
  projectDeploymentExpiration?: Array<string> | undefined;
  projectDeploymentHook?: Array<string> | undefined;
  projectDomain?: Array<string> | undefined;
  projectDomainCheckConfig?: Array<string> | undefined;
  projectDomainMove?: Array<string> | undefined;
  projectEnvVars?: Array<string> | undefined;
  projectEnvVarsProduction?: Array<string> | undefined;
  projectEnvVarsUnownedByIntegration?: Array<string> | undefined;
  projectFlags?: Array<string> | undefined;
  projectFlagsProduction?: Array<string> | undefined;
  projectFromV0?: Array<string> | undefined;
  projectId?: Array<string> | undefined;
  projectIntegrationConfiguration?: Array<string> | undefined;
  projectLink?: Array<string> | undefined;
  projectMember?: Array<string> | undefined;
  projectMonitoring?: Array<string> | undefined;
  projectOIDCToken?: Array<string> | undefined;
  projectPermissions?: Array<string> | undefined;
  projectProductionBranch?: Array<string> | undefined;
  projectProtectionBypass?: Array<string> | undefined;
  projectRollingRelease?: Array<string> | undefined;
  projectSupportCase?: Array<string> | undefined;
  projectSupportCaseComment?: Array<string> | undefined;
  projectTier?: Array<string> | undefined;
  projectTransfer?: Array<string> | undefined;
  projectTransferOut?: Array<string> | undefined;
  projectUsage?: Array<string> | undefined;
  seawallConfig?: Array<string> | undefined;
  sharedEnvVarConnection?: Array<string> | undefined;
  skewProtection?: Array<string> | undefined;
  analytics?: Array<string> | undefined;
  trustedIps?: Array<string> | undefined;
  v0Chat?: Array<string> | undefined;
  webAnalytics?: Array<string> | undefined;
};

/** @internal */
export const UpdateProjectDataCachePermissions$outboundSchema: z.ZodType<
  UpdateProjectDataCachePermissions$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCachePermissions
> = z.object({
  oauth2Connection: z.array(ACLAction$outboundSchema).optional(),
  user: z.array(ACLAction$outboundSchema).optional(),
  userConnection: z.array(ACLAction$outboundSchema).optional(),
  userSudo: z.array(ACLAction$outboundSchema).optional(),
  webAuthn: z.array(ACLAction$outboundSchema).optional(),
  accessGroup: z.array(ACLAction$outboundSchema).optional(),
  agent: z.array(ACLAction$outboundSchema).optional(),
  alerts: z.array(ACLAction$outboundSchema).optional(),
  aliasGlobal: z.array(ACLAction$outboundSchema).optional(),
  analyticsSampling: z.array(ACLAction$outboundSchema).optional(),
  analyticsUsage: z.array(ACLAction$outboundSchema).optional(),
  apiKey: z.array(ACLAction$outboundSchema).optional(),
  apiKeyAiGateway: z.array(ACLAction$outboundSchema).optional(),
  apiKeyOwnedBySelf: z.array(ACLAction$outboundSchema).optional(),
  oauth2Application: z.array(ACLAction$outboundSchema).optional(),
  vercelAppInstallation: z.array(ACLAction$outboundSchema).optional(),
  vercelAppInstallationRequest: z.array(ACLAction$outboundSchema).optional(),
  auditLog: z.array(ACLAction$outboundSchema).optional(),
  billingAddress: z.array(ACLAction$outboundSchema).optional(),
  billingInformation: z.array(ACLAction$outboundSchema).optional(),
  billingInvoice: z.array(ACLAction$outboundSchema).optional(),
  billingInvoiceEmailRecipient: z.array(ACLAction$outboundSchema).optional(),
  billingInvoiceLanguage: z.array(ACLAction$outboundSchema).optional(),
  billingPlan: z.array(ACLAction$outboundSchema).optional(),
  billingPurchaseOrder: z.array(ACLAction$outboundSchema).optional(),
  billingRefund: z.array(ACLAction$outboundSchema).optional(),
  billingTaxId: z.array(ACLAction$outboundSchema).optional(),
  blob: z.array(ACLAction$outboundSchema).optional(),
  blobStoreTokenSet: z.array(ACLAction$outboundSchema).optional(),
  budget: z.array(ACLAction$outboundSchema).optional(),
  cacheArtifact: z.array(ACLAction$outboundSchema).optional(),
  cacheArtifactUsageEvent: z.array(ACLAction$outboundSchema).optional(),
  codeChecks: z.array(ACLAction$outboundSchema).optional(),
  concurrentBuilds: z.array(ACLAction$outboundSchema).optional(),
  connect: z.array(ACLAction$outboundSchema).optional(),
  connectConfiguration: z.array(ACLAction$outboundSchema).optional(),
  dataCacheBillingSettings: z.array(ACLAction$outboundSchema).optional(),
  defaultDeploymentProtection: z.array(ACLAction$outboundSchema).optional(),
  domain: z.array(ACLAction$outboundSchema).optional(),
  domainAcceptDelegation: z.array(ACLAction$outboundSchema).optional(),
  domainAuthCodes: z.array(ACLAction$outboundSchema).optional(),
  domainCertificate: z.array(ACLAction$outboundSchema).optional(),
  domainCheckConfig: z.array(ACLAction$outboundSchema).optional(),
  domainMove: z.array(ACLAction$outboundSchema).optional(),
  domainPurchase: z.array(ACLAction$outboundSchema).optional(),
  domainRecord: z.array(ACLAction$outboundSchema).optional(),
  domainTransferIn: z.array(ACLAction$outboundSchema).optional(),
  drain: z.array(ACLAction$outboundSchema).optional(),
  edgeConfig: z.array(ACLAction$outboundSchema).optional(),
  edgeConfigItem: z.array(ACLAction$outboundSchema).optional(),
  edgeConfigSchema: z.array(ACLAction$outboundSchema).optional(),
  edgeConfigToken: z.array(ACLAction$outboundSchema).optional(),
  endpointVerification: z.array(ACLAction$outboundSchema).optional(),
  event: z.array(ACLAction$outboundSchema).optional(),
  fileUpload: z.array(ACLAction$outboundSchema).optional(),
  flagsExplorerSubscription: z.array(ACLAction$outboundSchema).optional(),
  gitRepository: z.array(ACLAction$outboundSchema).optional(),
  imageOptimizationNewPrice: z.array(ACLAction$outboundSchema).optional(),
  integration: z.array(ACLAction$outboundSchema).optional(),
  integrationAccount: z.array(ACLAction$outboundSchema).optional(),
  integrationConfiguration: z.array(ACLAction$outboundSchema).optional(),
  integrationConfigurationProjects: z.array(ACLAction$outboundSchema)
    .optional(),
  integrationConfigurationRole: z.array(ACLAction$outboundSchema).optional(),
  integrationConfigurationTransfer: z.array(ACLAction$outboundSchema)
    .optional(),
  integrationDeploymentAction: z.array(ACLAction$outboundSchema).optional(),
  integrationEvent: z.array(ACLAction$outboundSchema).optional(),
  integrationLog: z.array(ACLAction$outboundSchema).optional(),
  integrationResource: z.array(ACLAction$outboundSchema).optional(),
  integrationResourceReplCommand: z.array(ACLAction$outboundSchema).optional(),
  integrationResourceSecrets: z.array(ACLAction$outboundSchema).optional(),
  integrationSSOSession: z.array(ACLAction$outboundSchema).optional(),
  integrationStoreTokenSet: z.array(ACLAction$outboundSchema).optional(),
  integrationVercelConfigurationOverride: z.array(ACLAction$outboundSchema)
    .optional(),
  integrationPullRequest: z.array(ACLAction$outboundSchema).optional(),
  ipBlocking: z.array(ACLAction$outboundSchema).optional(),
  jobGlobal: z.array(ACLAction$outboundSchema).optional(),
  logDrain: z.array(ACLAction$outboundSchema).optional(),
  marketplaceBillingData: z.array(ACLAction$outboundSchema).optional(),
  marketplaceExperimentationEdgeConfigData: z.array(ACLAction$outboundSchema)
    .optional(),
  marketplaceExperimentationItem: z.array(ACLAction$outboundSchema).optional(),
  marketplaceInstallationMember: z.array(ACLAction$outboundSchema).optional(),
  marketplaceInvoice: z.array(ACLAction$outboundSchema).optional(),
  marketplaceSettings: z.array(ACLAction$outboundSchema).optional(),
  monitoring: z.array(ACLAction$outboundSchema).optional(),
  monitoringAlert: z.array(ACLAction$outboundSchema).optional(),
  monitoringChart: z.array(ACLAction$outboundSchema).optional(),
  monitoringQuery: z.array(ACLAction$outboundSchema).optional(),
  monitoringSettings: z.array(ACLAction$outboundSchema).optional(),
  notificationCustomerBudget: z.array(ACLAction$outboundSchema).optional(),
  notificationDeploymentFailed: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainConfiguration: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainExpire: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainMoved: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainPurchase: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainRenewal: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainTransfer: z.array(ACLAction$outboundSchema).optional(),
  notificationDomainUnverified: z.array(ACLAction$outboundSchema).optional(),
  notificationMonitoringAlert: z.array(ACLAction$outboundSchema).optional(),
  notificationPaymentFailed: z.array(ACLAction$outboundSchema).optional(),
  notificationPreferences: z.array(ACLAction$outboundSchema).optional(),
  notificationStatementOfReasons: z.array(ACLAction$outboundSchema).optional(),
  notificationUsageAlert: z.array(ACLAction$outboundSchema).optional(),
  observabilityConfiguration: z.array(ACLAction$outboundSchema).optional(),
  observabilityFunnel: z.array(ACLAction$outboundSchema).optional(),
  observabilityNotebook: z.array(ACLAction$outboundSchema).optional(),
  openTelemetryEndpoint: z.array(ACLAction$outboundSchema).optional(),
  ownEvent: z.array(ACLAction$outboundSchema).optional(),
  organizationDomain: z.array(ACLAction$outboundSchema).optional(),
  passwordProtectionInvoiceItem: z.array(ACLAction$outboundSchema).optional(),
  paymentMethod: z.array(ACLAction$outboundSchema).optional(),
  permissions: z.array(ACLAction$outboundSchema).optional(),
  postgres: z.array(ACLAction$outboundSchema).optional(),
  postgresStoreTokenSet: z.array(ACLAction$outboundSchema).optional(),
  previewDeploymentSuffix: z.array(ACLAction$outboundSchema).optional(),
  projectTransferIn: z.array(ACLAction$outboundSchema).optional(),
  proTrialOnboarding: z.array(ACLAction$outboundSchema).optional(),
  rateLimit: z.array(ACLAction$outboundSchema).optional(),
  redis: z.array(ACLAction$outboundSchema).optional(),
  redisStoreTokenSet: z.array(ACLAction$outboundSchema).optional(),
  remoteCaching: z.array(ACLAction$outboundSchema).optional(),
  repository: z.array(ACLAction$outboundSchema).optional(),
  samlConfig: z.array(ACLAction$outboundSchema).optional(),
  secret: z.array(ACLAction$outboundSchema).optional(),
  securityPlusConfiguration: z.array(ACLAction$outboundSchema).optional(),
  sensitiveEnvironmentVariablePolicy: z.array(ACLAction$outboundSchema)
    .optional(),
  sharedEnvVars: z.array(ACLAction$outboundSchema).optional(),
  sharedEnvVarsProduction: z.array(ACLAction$outboundSchema).optional(),
  space: z.array(ACLAction$outboundSchema).optional(),
  spaceRun: z.array(ACLAction$outboundSchema).optional(),
  storeTransfer: z.array(ACLAction$outboundSchema).optional(),
  supportCase: z.array(ACLAction$outboundSchema).optional(),
  supportCaseComment: z.array(ACLAction$outboundSchema).optional(),
  team: z.array(ACLAction$outboundSchema).optional(),
  teamAccessRequest: z.array(ACLAction$outboundSchema).optional(),
  teamFellowMembership: z.array(ACLAction$outboundSchema).optional(),
  teamGitExclusivity: z.array(ACLAction$outboundSchema).optional(),
  teamInvite: z.array(ACLAction$outboundSchema).optional(),
  teamInviteCode: z.array(ACLAction$outboundSchema).optional(),
  teamJoin: z.array(ACLAction$outboundSchema).optional(),
  teamMemberMfaStatus: z.array(ACLAction$outboundSchema).optional(),
  teamMicrofrontends: z.array(ACLAction$outboundSchema).optional(),
  teamOwnMembership: z.array(ACLAction$outboundSchema).optional(),
  teamOwnMembershipDisconnectSAML: z.array(ACLAction$outboundSchema).optional(),
  token: z.array(ACLAction$outboundSchema).optional(),
  usage: z.array(ACLAction$outboundSchema).optional(),
  usageCycle: z.array(ACLAction$outboundSchema).optional(),
  vercelRun: z.array(ACLAction$outboundSchema).optional(),
  vercelRunExec: z.array(ACLAction$outboundSchema).optional(),
  vpcPeeringConnection: z.array(ACLAction$outboundSchema).optional(),
  webAnalyticsPlan: z.array(ACLAction$outboundSchema).optional(),
  webhook: z.array(ACLAction$outboundSchema).optional(),
  webhookEvent: z.array(ACLAction$outboundSchema).optional(),
  aliasProject: z.array(ACLAction$outboundSchema).optional(),
  aliasProtectionBypass: z.array(ACLAction$outboundSchema).optional(),
  buildMachine: z.array(ACLAction$outboundSchema).optional(),
  connectConfigurationLink: z.array(ACLAction$outboundSchema).optional(),
  dataCacheNamespace: z.array(ACLAction$outboundSchema).optional(),
  deployment: z.array(ACLAction$outboundSchema).optional(),
  deploymentBuildLogs: z.array(ACLAction$outboundSchema).optional(),
  deploymentCheck: z.array(ACLAction$outboundSchema).optional(),
  deploymentCheckPreview: z.array(ACLAction$outboundSchema).optional(),
  deploymentCheckReRunFromProductionBranch: z.array(ACLAction$outboundSchema)
    .optional(),
  deploymentProductionGit: z.array(ACLAction$outboundSchema).optional(),
  deploymentV0: z.array(ACLAction$outboundSchema).optional(),
  deploymentPreview: z.array(ACLAction$outboundSchema).optional(),
  deploymentPrivate: z.array(ACLAction$outboundSchema).optional(),
  deploymentPromote: z.array(ACLAction$outboundSchema).optional(),
  deploymentRollback: z.array(ACLAction$outboundSchema).optional(),
  edgeCacheNamespace: z.array(ACLAction$outboundSchema).optional(),
  environments: z.array(ACLAction$outboundSchema).optional(),
  job: z.array(ACLAction$outboundSchema).optional(),
  logs: z.array(ACLAction$outboundSchema).optional(),
  logsPreset: z.array(ACLAction$outboundSchema).optional(),
  observabilityData: z.array(ACLAction$outboundSchema).optional(),
  onDemandBuild: z.array(ACLAction$outboundSchema).optional(),
  onDemandConcurrency: z.array(ACLAction$outboundSchema).optional(),
  optionsAllowlist: z.array(ACLAction$outboundSchema).optional(),
  passwordProtection: z.array(ACLAction$outboundSchema).optional(),
  productionAliasProtectionBypass: z.array(ACLAction$outboundSchema).optional(),
  project: z.array(ACLAction$outboundSchema).optional(),
  projectAccessGroup: z.array(ACLAction$outboundSchema).optional(),
  projectAnalyticsSampling: z.array(ACLAction$outboundSchema).optional(),
  projectAnalyticsUsage: z.array(ACLAction$outboundSchema).optional(),
  projectCheck: z.array(ACLAction$outboundSchema).optional(),
  projectCheckRun: z.array(ACLAction$outboundSchema).optional(),
  projectDeploymentExpiration: z.array(ACLAction$outboundSchema).optional(),
  projectDeploymentHook: z.array(ACLAction$outboundSchema).optional(),
  projectDomain: z.array(ACLAction$outboundSchema).optional(),
  projectDomainCheckConfig: z.array(ACLAction$outboundSchema).optional(),
  projectDomainMove: z.array(ACLAction$outboundSchema).optional(),
  projectEnvVars: z.array(ACLAction$outboundSchema).optional(),
  projectEnvVarsProduction: z.array(ACLAction$outboundSchema).optional(),
  projectEnvVarsUnownedByIntegration: z.array(ACLAction$outboundSchema)
    .optional(),
  projectFlags: z.array(ACLAction$outboundSchema).optional(),
  projectFlagsProduction: z.array(ACLAction$outboundSchema).optional(),
  projectFromV0: z.array(ACLAction$outboundSchema).optional(),
  projectId: z.array(ACLAction$outboundSchema).optional(),
  projectIntegrationConfiguration: z.array(ACLAction$outboundSchema).optional(),
  projectLink: z.array(ACLAction$outboundSchema).optional(),
  projectMember: z.array(ACLAction$outboundSchema).optional(),
  projectMonitoring: z.array(ACLAction$outboundSchema).optional(),
  projectOIDCToken: z.array(ACLAction$outboundSchema).optional(),
  projectPermissions: z.array(ACLAction$outboundSchema).optional(),
  projectProductionBranch: z.array(ACLAction$outboundSchema).optional(),
  projectProtectionBypass: z.array(ACLAction$outboundSchema).optional(),
  projectRollingRelease: z.array(ACLAction$outboundSchema).optional(),
  projectSupportCase: z.array(ACLAction$outboundSchema).optional(),
  projectSupportCaseComment: z.array(ACLAction$outboundSchema).optional(),
  projectTier: z.array(ACLAction$outboundSchema).optional(),
  projectTransfer: z.array(ACLAction$outboundSchema).optional(),
  projectTransferOut: z.array(ACLAction$outboundSchema).optional(),
  projectUsage: z.array(ACLAction$outboundSchema).optional(),
  seawallConfig: z.array(ACLAction$outboundSchema).optional(),
  sharedEnvVarConnection: z.array(ACLAction$outboundSchema).optional(),
  skewProtection: z.array(ACLAction$outboundSchema).optional(),
  analytics: z.array(ACLAction$outboundSchema).optional(),
  trustedIps: z.array(ACLAction$outboundSchema).optional(),
  v0Chat: z.array(ACLAction$outboundSchema).optional(),
  webAnalytics: z.array(ACLAction$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    monitoring: "Monitoring",
    notificationMonitoringAlert: "NotificationMonitoringAlert",
    webhookEvent: "webhook-event",
  });
});

export function updateProjectDataCachePermissionsToJSON(
  updateProjectDataCachePermissions: UpdateProjectDataCachePermissions,
): string {
  return JSON.stringify(
    UpdateProjectDataCachePermissions$outboundSchema.parse(
      updateProjectDataCachePermissions,
    ),
  );
}
export function updateProjectDataCachePermissionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCachePermissions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCachePermissions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCachePermissions' from JSON`,
  );
}

/** @internal */
export const LastRollbackTarget$inboundSchema: z.ZodType<
  LastRollbackTarget,
  z.ZodTypeDef,
  unknown
> = z.object({});
/** @internal */
export type LastRollbackTarget$Outbound = {};

/** @internal */
export const LastRollbackTarget$outboundSchema: z.ZodType<
  LastRollbackTarget$Outbound,
  z.ZodTypeDef,
  LastRollbackTarget
> = z.object({});

export function lastRollbackTargetToJSON(
  lastRollbackTarget: LastRollbackTarget,
): string {
  return JSON.stringify(
    LastRollbackTarget$outboundSchema.parse(lastRollbackTarget),
  );
}
export function lastRollbackTargetFromJSON(
  jsonString: string,
): SafeParseResult<LastRollbackTarget, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastRollbackTarget$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastRollbackTarget' from JSON`,
  );
}

/** @internal */
export const JobStatus$inboundSchema: z.ZodNativeEnum<typeof JobStatus> = z
  .nativeEnum(JobStatus);
/** @internal */
export const JobStatus$outboundSchema: z.ZodNativeEnum<typeof JobStatus> =
  JobStatus$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponse200Type> = z
    .nativeEnum(UpdateProjectDataCacheProjectsResponse200Type);
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponse200Type> =
    UpdateProjectDataCacheProjectsResponse200Type$inboundSchema;

/** @internal */
export const LastAliasRequest$inboundSchema: z.ZodType<
  LastAliasRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  fromDeploymentId: z.string(),
  toDeploymentId: z.string(),
  fromRollingReleaseId: z.string().optional(),
  jobStatus: JobStatus$inboundSchema,
  requestedAt: z.number(),
  type: UpdateProjectDataCacheProjectsResponse200Type$inboundSchema,
});
/** @internal */
export type LastAliasRequest$Outbound = {
  fromDeploymentId: string;
  toDeploymentId: string;
  fromRollingReleaseId?: string | undefined;
  jobStatus: string;
  requestedAt: number;
  type: string;
};

/** @internal */
export const LastAliasRequest$outboundSchema: z.ZodType<
  LastAliasRequest$Outbound,
  z.ZodTypeDef,
  LastAliasRequest
> = z.object({
  fromDeploymentId: z.string(),
  toDeploymentId: z.string(),
  fromRollingReleaseId: z.string().optional(),
  jobStatus: JobStatus$outboundSchema,
  requestedAt: z.number(),
  type: UpdateProjectDataCacheProjectsResponse200Type$outboundSchema,
});

export function lastAliasRequestToJSON(
  lastAliasRequest: LastAliasRequest,
): string {
  return JSON.stringify(
    LastAliasRequest$outboundSchema.parse(lastAliasRequest),
  );
}
export function lastAliasRequestFromJSON(
  jsonString: string,
): SafeParseResult<LastAliasRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastAliasRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastAliasRequest' from JSON`,
  );
}

/** @internal */
export const ProtectionBypassScope$inboundSchema: z.ZodNativeEnum<
  typeof ProtectionBypassScope
> = z.nativeEnum(ProtectionBypassScope);
/** @internal */
export const ProtectionBypassScope$outboundSchema: z.ZodNativeEnum<
  typeof ProtectionBypassScope
> = ProtectionBypassScope$inboundSchema;

/** @internal */
export const ProtectionBypass2$inboundSchema: z.ZodType<
  ProtectionBypass2,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number(),
  createdBy: z.string(),
  scope: ProtectionBypassScope$inboundSchema,
});
/** @internal */
export type ProtectionBypass2$Outbound = {
  createdAt: number;
  createdBy: string;
  scope: string;
};

/** @internal */
export const ProtectionBypass2$outboundSchema: z.ZodType<
  ProtectionBypass2$Outbound,
  z.ZodTypeDef,
  ProtectionBypass2
> = z.object({
  createdAt: z.number(),
  createdBy: z.string(),
  scope: ProtectionBypassScope$outboundSchema,
});

export function protectionBypass2ToJSON(
  protectionBypass2: ProtectionBypass2,
): string {
  return JSON.stringify(
    ProtectionBypass2$outboundSchema.parse(protectionBypass2),
  );
}
export function protectionBypass2FromJSON(
  jsonString: string,
): SafeParseResult<ProtectionBypass2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProtectionBypass2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProtectionBypass2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProtectionBypassScope$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProtectionBypassScope> = z
    .nativeEnum(UpdateProjectDataCacheProtectionBypassScope);
/** @internal */
export const UpdateProjectDataCacheProtectionBypassScope$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProtectionBypassScope> =
    UpdateProjectDataCacheProtectionBypassScope$inboundSchema;

/** @internal */
export const ProtectionBypass1$inboundSchema: z.ZodType<
  ProtectionBypass1,
  z.ZodTypeDef,
  unknown
> = z.object({
  createdAt: z.number(),
  createdBy: z.string(),
  scope: UpdateProjectDataCacheProtectionBypassScope$inboundSchema,
  integrationId: z.string(),
  configurationId: z.string(),
});
/** @internal */
export type ProtectionBypass1$Outbound = {
  createdAt: number;
  createdBy: string;
  scope: string;
  integrationId: string;
  configurationId: string;
};

/** @internal */
export const ProtectionBypass1$outboundSchema: z.ZodType<
  ProtectionBypass1$Outbound,
  z.ZodTypeDef,
  ProtectionBypass1
> = z.object({
  createdAt: z.number(),
  createdBy: z.string(),
  scope: UpdateProjectDataCacheProtectionBypassScope$outboundSchema,
  integrationId: z.string(),
  configurationId: z.string(),
});

export function protectionBypass1ToJSON(
  protectionBypass1: ProtectionBypass1,
): string {
  return JSON.stringify(
    ProtectionBypass1$outboundSchema.parse(protectionBypass1),
  );
}
export function protectionBypass1FromJSON(
  jsonString: string,
): SafeParseResult<ProtectionBypass1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProtectionBypass1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProtectionBypass1' from JSON`,
  );
}

/** @internal */
export const ProtectionBypass$inboundSchema: z.ZodType<
  ProtectionBypass,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ProtectionBypass1$inboundSchema),
  z.lazy(() => ProtectionBypass2$inboundSchema),
]);
/** @internal */
export type ProtectionBypass$Outbound =
  | ProtectionBypass1$Outbound
  | ProtectionBypass2$Outbound;

/** @internal */
export const ProtectionBypass$outboundSchema: z.ZodType<
  ProtectionBypass$Outbound,
  z.ZodTypeDef,
  ProtectionBypass
> = z.union([
  z.lazy(() => ProtectionBypass1$outboundSchema),
  z.lazy(() => ProtectionBypass2$outboundSchema),
]);

export function protectionBypassToJSON(
  protectionBypass: ProtectionBypass,
): string {
  return JSON.stringify(
    ProtectionBypass$outboundSchema.parse(protectionBypass),
  );
}
export function protectionBypassFromJSON(
  jsonString: string,
): SafeParseResult<ProtectionBypass, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ProtectionBypass$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ProtectionBypass' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheTrustedIpsDeploymentType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheTrustedIpsDeploymentType> = z
    .nativeEnum(UpdateProjectDataCacheTrustedIpsDeploymentType);
/** @internal */
export const UpdateProjectDataCacheTrustedIpsDeploymentType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheTrustedIpsDeploymentType> =
    UpdateProjectDataCacheTrustedIpsDeploymentType$inboundSchema;

/** @internal */
export const TrustedIps2$inboundSchema: z.ZodType<
  TrustedIps2,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: UpdateProjectDataCacheTrustedIpsDeploymentType$inboundSchema,
});
/** @internal */
export type TrustedIps2$Outbound = {
  deploymentType: string;
};

/** @internal */
export const TrustedIps2$outboundSchema: z.ZodType<
  TrustedIps2$Outbound,
  z.ZodTypeDef,
  TrustedIps2
> = z.object({
  deploymentType: UpdateProjectDataCacheTrustedIpsDeploymentType$outboundSchema,
});

export function trustedIps2ToJSON(trustedIps2: TrustedIps2): string {
  return JSON.stringify(TrustedIps2$outboundSchema.parse(trustedIps2));
}
export function trustedIps2FromJSON(
  jsonString: string,
): SafeParseResult<TrustedIps2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrustedIps2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrustedIps2' from JSON`,
  );
}

/** @internal */
export const TrustedIpsDeploymentType$inboundSchema: z.ZodNativeEnum<
  typeof TrustedIpsDeploymentType
> = z.nativeEnum(TrustedIpsDeploymentType);
/** @internal */
export const TrustedIpsDeploymentType$outboundSchema: z.ZodNativeEnum<
  typeof TrustedIpsDeploymentType
> = TrustedIpsDeploymentType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheTrustedIpsAddresses$inboundSchema: z.ZodType<
  UpdateProjectDataCacheTrustedIpsAddresses,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  note: z.string().optional(),
});
/** @internal */
export type UpdateProjectDataCacheTrustedIpsAddresses$Outbound = {
  value: string;
  note?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheTrustedIpsAddresses$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheTrustedIpsAddresses$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheTrustedIpsAddresses
  > = z.object({
    value: z.string(),
    note: z.string().optional(),
  });

export function updateProjectDataCacheTrustedIpsAddressesToJSON(
  updateProjectDataCacheTrustedIpsAddresses:
    UpdateProjectDataCacheTrustedIpsAddresses,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheTrustedIpsAddresses$outboundSchema.parse(
      updateProjectDataCacheTrustedIpsAddresses,
    ),
  );
}
export function updateProjectDataCacheTrustedIpsAddressesFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheTrustedIpsAddresses,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheTrustedIpsAddresses$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheTrustedIpsAddresses' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheTrustedIpsProtectionMode$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheTrustedIpsProtectionMode> = z
    .nativeEnum(UpdateProjectDataCacheTrustedIpsProtectionMode);
/** @internal */
export const UpdateProjectDataCacheTrustedIpsProtectionMode$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheTrustedIpsProtectionMode> =
    UpdateProjectDataCacheTrustedIpsProtectionMode$inboundSchema;

/** @internal */
export const TrustedIps1$inboundSchema: z.ZodType<
  TrustedIps1,
  z.ZodTypeDef,
  unknown
> = z.object({
  deploymentType: TrustedIpsDeploymentType$inboundSchema,
  addresses: z.array(
    z.lazy(() => UpdateProjectDataCacheTrustedIpsAddresses$inboundSchema),
  ),
  protectionMode: UpdateProjectDataCacheTrustedIpsProtectionMode$inboundSchema,
});
/** @internal */
export type TrustedIps1$Outbound = {
  deploymentType: string;
  addresses: Array<UpdateProjectDataCacheTrustedIpsAddresses$Outbound>;
  protectionMode: string;
};

/** @internal */
export const TrustedIps1$outboundSchema: z.ZodType<
  TrustedIps1$Outbound,
  z.ZodTypeDef,
  TrustedIps1
> = z.object({
  deploymentType: TrustedIpsDeploymentType$outboundSchema,
  addresses: z.array(
    z.lazy(() => UpdateProjectDataCacheTrustedIpsAddresses$outboundSchema),
  ),
  protectionMode: UpdateProjectDataCacheTrustedIpsProtectionMode$outboundSchema,
});

export function trustedIps1ToJSON(trustedIps1: TrustedIps1): string {
  return JSON.stringify(TrustedIps1$outboundSchema.parse(trustedIps1));
}
export function trustedIps1FromJSON(
  jsonString: string,
): SafeParseResult<TrustedIps1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TrustedIps1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TrustedIps1' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheTrustedIps$inboundSchema: z.ZodType<
  UpdateProjectDataCacheTrustedIps,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TrustedIps1$inboundSchema),
  z.lazy(() => TrustedIps2$inboundSchema),
]);
/** @internal */
export type UpdateProjectDataCacheTrustedIps$Outbound =
  | TrustedIps1$Outbound
  | TrustedIps2$Outbound;

/** @internal */
export const UpdateProjectDataCacheTrustedIps$outboundSchema: z.ZodType<
  UpdateProjectDataCacheTrustedIps$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheTrustedIps
> = z.union([
  z.lazy(() => TrustedIps1$outboundSchema),
  z.lazy(() => TrustedIps2$outboundSchema),
]);

export function updateProjectDataCacheTrustedIpsToJSON(
  updateProjectDataCacheTrustedIps: UpdateProjectDataCacheTrustedIps,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheTrustedIps$outboundSchema.parse(
      updateProjectDataCacheTrustedIps,
    ),
  );
}
export function updateProjectDataCacheTrustedIpsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheTrustedIps, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheTrustedIps$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheTrustedIps' from JSON`,
  );
}

/** @internal */
export const GitComments$inboundSchema: z.ZodType<
  GitComments,
  z.ZodTypeDef,
  unknown
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});
/** @internal */
export type GitComments$Outbound = {
  onPullRequest: boolean;
  onCommit: boolean;
};

/** @internal */
export const GitComments$outboundSchema: z.ZodType<
  GitComments$Outbound,
  z.ZodTypeDef,
  GitComments
> = z.object({
  onPullRequest: z.boolean(),
  onCommit: z.boolean(),
});

export function gitCommentsToJSON(gitComments: GitComments): string {
  return JSON.stringify(GitComments$outboundSchema.parse(gitComments));
}
export function gitCommentsFromJSON(
  jsonString: string,
): SafeParseResult<GitComments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitComments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitComments' from JSON`,
  );
}

/** @internal */
export const CreateDeployments$inboundSchema: z.ZodNativeEnum<
  typeof CreateDeployments
> = z.nativeEnum(CreateDeployments);
/** @internal */
export const CreateDeployments$outboundSchema: z.ZodNativeEnum<
  typeof CreateDeployments
> = CreateDeployments$inboundSchema;

/** @internal */
export const GitProviderOptions$inboundSchema: z.ZodType<
  GitProviderOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  createDeployments: CreateDeployments$inboundSchema,
  disableRepositoryDispatchEvents: z.boolean().optional(),
  requireVerifiedCommits: z.boolean().optional(),
});
/** @internal */
export type GitProviderOptions$Outbound = {
  createDeployments: string;
  disableRepositoryDispatchEvents?: boolean | undefined;
  requireVerifiedCommits?: boolean | undefined;
};

/** @internal */
export const GitProviderOptions$outboundSchema: z.ZodType<
  GitProviderOptions$Outbound,
  z.ZodTypeDef,
  GitProviderOptions
> = z.object({
  createDeployments: CreateDeployments$outboundSchema,
  disableRepositoryDispatchEvents: z.boolean().optional(),
  requireVerifiedCommits: z.boolean().optional(),
});

export function gitProviderOptionsToJSON(
  gitProviderOptions: GitProviderOptions,
): string {
  return JSON.stringify(
    GitProviderOptions$outboundSchema.parse(gitProviderOptions),
  );
}
export function gitProviderOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GitProviderOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GitProviderOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GitProviderOptions' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheWebAnalytics$inboundSchema: z.ZodType<
  UpdateProjectDataCacheWebAnalytics,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  enabledAt: z.number().optional(),
  hasData: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheWebAnalytics$Outbound = {
  id: string;
  disabledAt?: number | undefined;
  canceledAt?: number | undefined;
  enabledAt?: number | undefined;
  hasData?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheWebAnalytics$outboundSchema: z.ZodType<
  UpdateProjectDataCacheWebAnalytics$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheWebAnalytics
> = z.object({
  id: z.string(),
  disabledAt: z.number().optional(),
  canceledAt: z.number().optional(),
  enabledAt: z.number().optional(),
  hasData: z.boolean().optional(),
});

export function updateProjectDataCacheWebAnalyticsToJSON(
  updateProjectDataCacheWebAnalytics: UpdateProjectDataCacheWebAnalytics,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheWebAnalytics$outboundSchema.parse(
      updateProjectDataCacheWebAnalytics,
    ),
  );
}
export function updateProjectDataCacheWebAnalyticsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheWebAnalytics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheWebAnalytics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheWebAnalytics' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponseAction$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponseAction> = z
    .nativeEnum(UpdateProjectDataCacheProjectsResponseAction);
/** @internal */
export const UpdateProjectDataCacheProjectsResponseAction$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponseAction> =
    UpdateProjectDataCacheProjectsResponseAction$inboundSchema;

/** @internal */
export const BotFilter$inboundSchema: z.ZodType<
  BotFilter,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: z.boolean(),
  action: UpdateProjectDataCacheProjectsResponseAction$inboundSchema.optional(),
});
/** @internal */
export type BotFilter$Outbound = {
  active: boolean;
  action?: string | undefined;
};

/** @internal */
export const BotFilter$outboundSchema: z.ZodType<
  BotFilter$Outbound,
  z.ZodTypeDef,
  BotFilter
> = z.object({
  active: z.boolean(),
  action: UpdateProjectDataCacheProjectsResponseAction$outboundSchema
    .optional(),
});

export function botFilterToJSON(botFilter: BotFilter): string {
  return JSON.stringify(BotFilter$outboundSchema.parse(botFilter));
}
export function botFilterFromJSON(
  jsonString: string,
): SafeParseResult<BotFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BotFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BotFilter' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200Action$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponse200Action> = z
    .nativeEnum(UpdateProjectDataCacheProjectsResponse200Action);
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200Action$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsResponse200Action> =
    UpdateProjectDataCacheProjectsResponse200Action$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheAiBots$inboundSchema: z.ZodType<
  UpdateProjectDataCacheAiBots,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: z.boolean(),
  action: UpdateProjectDataCacheProjectsResponse200Action$inboundSchema
    .optional(),
});
/** @internal */
export type UpdateProjectDataCacheAiBots$Outbound = {
  active: boolean;
  action?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheAiBots$outboundSchema: z.ZodType<
  UpdateProjectDataCacheAiBots$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheAiBots
> = z.object({
  active: z.boolean(),
  action: UpdateProjectDataCacheProjectsResponse200Action$outboundSchema
    .optional(),
});

export function updateProjectDataCacheAiBotsToJSON(
  updateProjectDataCacheAiBots: UpdateProjectDataCacheAiBots,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheAiBots$outboundSchema.parse(
      updateProjectDataCacheAiBots,
    ),
  );
}
export function updateProjectDataCacheAiBotsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheAiBots, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheAiBots$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheAiBots' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction
  > = z.nativeEnum(
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction
  > =
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheOwasp$inboundSchema: z.ZodType<
  UpdateProjectDataCacheOwasp,
  z.ZodTypeDef,
  unknown
> = z.object({
  active: z.boolean(),
  action:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction$inboundSchema
      .optional(),
});
/** @internal */
export type UpdateProjectDataCacheOwasp$Outbound = {
  active: boolean;
  action?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheOwasp$outboundSchema: z.ZodType<
  UpdateProjectDataCacheOwasp$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheOwasp
> = z.object({
  active: z.boolean(),
  action:
    UpdateProjectDataCacheProjectsResponse200ApplicationJSONAction$outboundSchema
      .optional(),
});

export function updateProjectDataCacheOwaspToJSON(
  updateProjectDataCacheOwasp: UpdateProjectDataCacheOwasp,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheOwasp$outboundSchema.parse(
      updateProjectDataCacheOwasp,
    ),
  );
}
export function updateProjectDataCacheOwaspFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheOwasp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheOwasp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheOwasp' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheManagedRules$inboundSchema: z.ZodType<
  UpdateProjectDataCacheManagedRules,
  z.ZodTypeDef,
  unknown
> = z.object({
  bot_filter: z.lazy(() => BotFilter$inboundSchema),
  ai_bots: z.lazy(() => UpdateProjectDataCacheAiBots$inboundSchema),
  owasp: z.lazy(() => UpdateProjectDataCacheOwasp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "bot_filter": "botFilter",
    "ai_bots": "aiBots",
  });
});
/** @internal */
export type UpdateProjectDataCacheManagedRules$Outbound = {
  bot_filter: BotFilter$Outbound;
  ai_bots: UpdateProjectDataCacheAiBots$Outbound;
  owasp: UpdateProjectDataCacheOwasp$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheManagedRules$outboundSchema: z.ZodType<
  UpdateProjectDataCacheManagedRules$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheManagedRules
> = z.object({
  botFilter: z.lazy(() => BotFilter$outboundSchema),
  aiBots: z.lazy(() => UpdateProjectDataCacheAiBots$outboundSchema),
  owasp: z.lazy(() => UpdateProjectDataCacheOwasp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    botFilter: "bot_filter",
    aiBots: "ai_bots",
  });
});

export function updateProjectDataCacheManagedRulesToJSON(
  updateProjectDataCacheManagedRules: UpdateProjectDataCacheManagedRules,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheManagedRules$outboundSchema.parse(
      updateProjectDataCacheManagedRules,
    ),
  );
}
export function updateProjectDataCacheManagedRulesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheManagedRules, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheManagedRules$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheManagedRules' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheSecurity$inboundSchema: z.ZodType<
  UpdateProjectDataCacheSecurity,
  z.ZodTypeDef,
  unknown
> = z.object({
  attackModeEnabled: z.boolean().optional(),
  attackModeUpdatedAt: z.number().optional(),
  firewallEnabled: z.boolean().optional(),
  firewallUpdatedAt: z.number().optional(),
  attackModeActiveUntil: z.nullable(z.number()).optional(),
  firewallConfigVersion: z.number().optional(),
  firewallSeawallEnabled: z.boolean().optional(),
  ja3Enabled: z.boolean().optional(),
  ja4Enabled: z.boolean().optional(),
  firewallBypassIps: z.array(z.string()).optional(),
  managedRules: z.nullable(
    z.lazy(() => UpdateProjectDataCacheManagedRules$inboundSchema),
  ).optional(),
  botIdEnabled: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheSecurity$Outbound = {
  attackModeEnabled?: boolean | undefined;
  attackModeUpdatedAt?: number | undefined;
  firewallEnabled?: boolean | undefined;
  firewallUpdatedAt?: number | undefined;
  attackModeActiveUntil?: number | null | undefined;
  firewallConfigVersion?: number | undefined;
  firewallSeawallEnabled?: boolean | undefined;
  ja3Enabled?: boolean | undefined;
  ja4Enabled?: boolean | undefined;
  firewallBypassIps?: Array<string> | undefined;
  managedRules?: UpdateProjectDataCacheManagedRules$Outbound | null | undefined;
  botIdEnabled?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheSecurity$outboundSchema: z.ZodType<
  UpdateProjectDataCacheSecurity$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheSecurity
> = z.object({
  attackModeEnabled: z.boolean().optional(),
  attackModeUpdatedAt: z.number().optional(),
  firewallEnabled: z.boolean().optional(),
  firewallUpdatedAt: z.number().optional(),
  attackModeActiveUntil: z.nullable(z.number()).optional(),
  firewallConfigVersion: z.number().optional(),
  firewallSeawallEnabled: z.boolean().optional(),
  ja3Enabled: z.boolean().optional(),
  ja4Enabled: z.boolean().optional(),
  firewallBypassIps: z.array(z.string()).optional(),
  managedRules: z.nullable(
    z.lazy(() => UpdateProjectDataCacheManagedRules$outboundSchema),
  ).optional(),
  botIdEnabled: z.boolean().optional(),
});

export function updateProjectDataCacheSecurityToJSON(
  updateProjectDataCacheSecurity: UpdateProjectDataCacheSecurity,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheSecurity$outboundSchema.parse(
      updateProjectDataCacheSecurity,
    ),
  );
}
export function updateProjectDataCacheSecurityFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheSecurity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheSecurity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheSecurity' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheIssuerMode$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheIssuerMode
> = z.nativeEnum(UpdateProjectDataCacheIssuerMode);
/** @internal */
export const UpdateProjectDataCacheIssuerMode$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheIssuerMode
> = UpdateProjectDataCacheIssuerMode$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheOidcTokenConfig$inboundSchema: z.ZodType<
  UpdateProjectDataCacheOidcTokenConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
  issuerMode: UpdateProjectDataCacheIssuerMode$inboundSchema.optional(),
});
/** @internal */
export type UpdateProjectDataCacheOidcTokenConfig$Outbound = {
  enabled?: boolean | undefined;
  issuerMode?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheOidcTokenConfig$outboundSchema: z.ZodType<
  UpdateProjectDataCacheOidcTokenConfig$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheOidcTokenConfig
> = z.object({
  enabled: z.boolean().optional(),
  issuerMode: UpdateProjectDataCacheIssuerMode$outboundSchema.optional(),
});

export function updateProjectDataCacheOidcTokenConfigToJSON(
  updateProjectDataCacheOidcTokenConfig: UpdateProjectDataCacheOidcTokenConfig,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheOidcTokenConfig$outboundSchema.parse(
      updateProjectDataCacheOidcTokenConfig,
    ),
  );
}
export function updateProjectDataCacheOidcTokenConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheOidcTokenConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheOidcTokenConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheOidcTokenConfig' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheTier$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTier
> = z.nativeEnum(UpdateProjectDataCacheTier);
/** @internal */
export const UpdateProjectDataCacheTier$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheTier
> = UpdateProjectDataCacheTier$inboundSchema;

/** @internal */
export const Features$inboundSchema: z.ZodType<
  Features,
  z.ZodTypeDef,
  unknown
> = z.object({
  webAnalytics: z.boolean().optional(),
});
/** @internal */
export type Features$Outbound = {
  webAnalytics?: boolean | undefined;
};

/** @internal */
export const Features$outboundSchema: z.ZodType<
  Features$Outbound,
  z.ZodTypeDef,
  Features
> = z.object({
  webAnalytics: z.boolean().optional(),
});

export function featuresToJSON(features: Features): string {
  return JSON.stringify(Features$outboundSchema.parse(features));
}
export function featuresFromJSON(
  jsonString: string,
): SafeParseResult<Features, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Features$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Features' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHistory$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHistory,
  z.ZodTypeDef,
  unknown
> = z.object({
  scanner: z.string(),
  reason: z.string(),
  by: z.string(),
  byId: z.string(),
  at: z.number(),
});
/** @internal */
export type UpdateProjectDataCacheHistory$Outbound = {
  scanner: string;
  reason: string;
  by: string;
  byId: string;
  at: number;
};

/** @internal */
export const UpdateProjectDataCacheHistory$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHistory$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHistory
> = z.object({
  scanner: z.string(),
  reason: z.string(),
  by: z.string(),
  byId: z.string(),
  at: z.number(),
});

export function updateProjectDataCacheHistoryToJSON(
  updateProjectDataCacheHistory: UpdateProjectDataCacheHistory,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHistory$outboundSchema.parse(
      updateProjectDataCacheHistory,
    ),
  );
}
export function updateProjectDataCacheHistoryFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHistory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheHistory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHistory' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheProjectsAction$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsAction> = z.nativeEnum(
    UpdateProjectDataCacheProjectsAction,
  );
/** @internal */
export const UpdateProjectDataCacheProjectsAction$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheProjectsAction> =
    UpdateProjectDataCacheProjectsAction$inboundSchema;

/** @internal */
export const Block$inboundSchema: z.ZodType<Block, z.ZodTypeDef, unknown> = z
  .object({
    action: UpdateProjectDataCacheProjectsAction$inboundSchema,
    reason: z.string(),
    statusCode: z.number(),
    createdAt: z.number(),
    caseId: z.string().optional(),
    actor: z.string().optional(),
    comment: z.string().optional(),
    isCascading: z.boolean().optional(),
  });
/** @internal */
export type Block$Outbound = {
  action: string;
  reason: string;
  statusCode: number;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

/** @internal */
export const Block$outboundSchema: z.ZodType<
  Block$Outbound,
  z.ZodTypeDef,
  Block
> = z.object({
  action: UpdateProjectDataCacheProjectsAction$outboundSchema,
  reason: z.string(),
  statusCode: z.number(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});

export function blockToJSON(block: Block): string {
  return JSON.stringify(Block$outboundSchema.parse(block));
}
export function blockFromJSON(
  jsonString: string,
): SafeParseResult<Block, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Block$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Block' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheBlockHistoryProjectsResponseAction$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheBlockHistoryProjectsResponseAction
  > = z.nativeEnum(UpdateProjectDataCacheBlockHistoryProjectsResponseAction);
/** @internal */
export const UpdateProjectDataCacheBlockHistoryProjectsResponseAction$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheBlockHistoryProjectsResponseAction
  > = UpdateProjectDataCacheBlockHistoryProjectsResponseAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsResponseType> = z
    .nativeEnum(UpdateProjectDataCacheHasProjectsResponseType);
/** @internal */
export const UpdateProjectDataCacheHasProjectsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsResponseType> =
    UpdateProjectDataCacheHasProjectsResponseType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsValue$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjectsValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheHasProjectsValue$Outbound = {
  eq: string;
};

/** @internal */
export const UpdateProjectDataCacheHasProjectsValue$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjectsValue$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHasProjectsValue
> = z.object({
  eq: z.string(),
});

export function updateProjectDataCacheHasProjectsValueToJSON(
  updateProjectDataCacheHasProjectsValue:
    UpdateProjectDataCacheHasProjectsValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjectsValue$outboundSchema.parse(
      updateProjectDataCacheHasProjectsValue,
    ),
  );
}
export function updateProjectDataCacheHasProjectsValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHasProjectsValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjectsValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHasProjectsValue' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHas2$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHas2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheHasProjectsResponseType$inboundSchema,
  value: z.lazy(() => UpdateProjectDataCacheHasProjectsValue$inboundSchema),
});
/** @internal */
export type UpdateProjectDataCacheHas2$Outbound = {
  type: string;
  value: UpdateProjectDataCacheHasProjectsValue$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheHas2$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHas2$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHas2
> = z.object({
  type: UpdateProjectDataCacheHasProjectsResponseType$outboundSchema,
  value: z.lazy(() => UpdateProjectDataCacheHasProjectsValue$outboundSchema),
});

export function updateProjectDataCacheHas2ToJSON(
  updateProjectDataCacheHas2: UpdateProjectDataCacheHas2,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHas2$outboundSchema.parse(updateProjectDataCacheHas2),
  );
}
export function updateProjectDataCacheHas2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHas2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheHas2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHas2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHasProjectsType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsType> = z.nativeEnum(
    UpdateProjectDataCacheHasProjectsType,
  );
/** @internal */
export const UpdateProjectDataCacheHasProjectsType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsType> =
    UpdateProjectDataCacheHasProjectsType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsKey$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsKey> = z.nativeEnum(
    UpdateProjectDataCacheHasProjectsKey,
  );
/** @internal */
export const UpdateProjectDataCacheHasProjectsKey$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsKey> =
    UpdateProjectDataCacheHasProjectsKey$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    eq: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$Outbound =
  {
    eq: string;
  };

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue
  > = z.object({
    eq: z.string(),
  });

export function updateProjectDataCacheHasProjectsResponse200ApplicationJSONValueToJSON(
  updateProjectDataCacheHasProjectsResponse200ApplicationJSONValue:
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$outboundSchema
      .parse(updateProjectDataCacheHasProjectsResponse200ApplicationJSONValue),
  );
}
export function updateProjectDataCacheHasProjectsResponse200ApplicationJSONValueFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHas1$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHas1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheHasProjectsType$inboundSchema,
  key: UpdateProjectDataCacheHasProjectsKey$inboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$inboundSchema
  ),
});
/** @internal */
export type UpdateProjectDataCacheHas1$Outbound = {
  type: string;
  key: string;
  value:
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheHas1$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHas1$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHas1
> = z.object({
  type: UpdateProjectDataCacheHasProjectsType$outboundSchema,
  key: UpdateProjectDataCacheHasProjectsKey$outboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONValue$outboundSchema
  ),
});

export function updateProjectDataCacheHas1ToJSON(
  updateProjectDataCacheHas1: UpdateProjectDataCacheHas1,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHas1$outboundSchema.parse(updateProjectDataCacheHas1),
  );
}
export function updateProjectDataCacheHas1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHas1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheHas1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHas1' from JSON`,
  );
}

/** @internal */
export const RouteHas$inboundSchema: z.ZodType<
  RouteHas,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateProjectDataCacheHas1$inboundSchema),
  z.lazy(() => UpdateProjectDataCacheHas2$inboundSchema),
]);
/** @internal */
export type RouteHas$Outbound =
  | UpdateProjectDataCacheHas1$Outbound
  | UpdateProjectDataCacheHas2$Outbound;

/** @internal */
export const RouteHas$outboundSchema: z.ZodType<
  RouteHas$Outbound,
  z.ZodTypeDef,
  RouteHas
> = z.union([
  z.lazy(() => UpdateProjectDataCacheHas1$outboundSchema),
  z.lazy(() => UpdateProjectDataCacheHas2$outboundSchema),
]);

export function routeHasToJSON(routeHas: RouteHas): string {
  return JSON.stringify(RouteHas$outboundSchema.parse(routeHas));
}
export function routeHasFromJSON(
  jsonString: string,
): SafeParseResult<RouteHas, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouteHas$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouteHas' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheRouteAction$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheRouteAction
> = z.nativeEnum(UpdateProjectDataCacheRouteAction);
/** @internal */
export const UpdateProjectDataCacheRouteAction$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheRouteAction
> = UpdateProjectDataCacheRouteAction$inboundSchema;

/** @internal */
export const RouteMitigate$inboundSchema: z.ZodType<
  RouteMitigate,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: UpdateProjectDataCacheRouteAction$inboundSchema,
});
/** @internal */
export type RouteMitigate$Outbound = {
  action: string;
};

/** @internal */
export const RouteMitigate$outboundSchema: z.ZodType<
  RouteMitigate$Outbound,
  z.ZodTypeDef,
  RouteMitigate
> = z.object({
  action: UpdateProjectDataCacheRouteAction$outboundSchema,
});

export function routeMitigateToJSON(routeMitigate: RouteMitigate): string {
  return JSON.stringify(RouteMitigate$outboundSchema.parse(routeMitigate));
}
export function routeMitigateFromJSON(
  jsonString: string,
): SafeParseResult<RouteMitigate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RouteMitigate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RouteMitigate' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheRoute2$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRoute2,
  z.ZodTypeDef,
  unknown
> = z.object({
  has: z.array(
    z.union([
      z.lazy(() => UpdateProjectDataCacheHas1$inboundSchema),
      z.lazy(() => UpdateProjectDataCacheHas2$inboundSchema),
    ]),
  ),
  mitigate: z.lazy(() => RouteMitigate$inboundSchema),
  src: z.string().optional(),
});
/** @internal */
export type UpdateProjectDataCacheRoute2$Outbound = {
  has: Array<
    UpdateProjectDataCacheHas1$Outbound | UpdateProjectDataCacheHas2$Outbound
  >;
  mitigate: RouteMitigate$Outbound;
  src?: string | undefined;
};

/** @internal */
export const UpdateProjectDataCacheRoute2$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRoute2$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRoute2
> = z.object({
  has: z.array(
    z.union([
      z.lazy(() => UpdateProjectDataCacheHas1$outboundSchema),
      z.lazy(() => UpdateProjectDataCacheHas2$outboundSchema),
    ]),
  ),
  mitigate: z.lazy(() => RouteMitigate$outboundSchema),
  src: z.string().optional(),
});

export function updateProjectDataCacheRoute2ToJSON(
  updateProjectDataCacheRoute2: UpdateProjectDataCacheRoute2,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRoute2$outboundSchema.parse(
      updateProjectDataCacheRoute2,
    ),
  );
}
export function updateProjectDataCacheRoute2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRoute2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheRoute2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRoute2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheRoute1$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRoute1,
  z.ZodTypeDef,
  unknown
> = z.object({
  src: z.string(),
  status: z.number(),
});
/** @internal */
export type UpdateProjectDataCacheRoute1$Outbound = {
  src: string;
  status: number;
};

/** @internal */
export const UpdateProjectDataCacheRoute1$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRoute1$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRoute1
> = z.object({
  src: z.string(),
  status: z.number(),
});

export function updateProjectDataCacheRoute1ToJSON(
  updateProjectDataCacheRoute1: UpdateProjectDataCacheRoute1,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRoute1$outboundSchema.parse(
      updateProjectDataCacheRoute1,
    ),
  );
}
export function updateProjectDataCacheRoute1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRoute1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheRoute1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRoute1' from JSON`,
  );
}

/** @internal */
export const BlockHistoryRoute$inboundSchema: z.ZodType<
  BlockHistoryRoute,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateProjectDataCacheRoute1$inboundSchema),
  z.lazy(() => UpdateProjectDataCacheRoute2$inboundSchema),
]);
/** @internal */
export type BlockHistoryRoute$Outbound =
  | UpdateProjectDataCacheRoute1$Outbound
  | UpdateProjectDataCacheRoute2$Outbound;

/** @internal */
export const BlockHistoryRoute$outboundSchema: z.ZodType<
  BlockHistoryRoute$Outbound,
  z.ZodTypeDef,
  BlockHistoryRoute
> = z.union([
  z.lazy(() => UpdateProjectDataCacheRoute1$outboundSchema),
  z.lazy(() => UpdateProjectDataCacheRoute2$outboundSchema),
]);

export function blockHistoryRouteToJSON(
  blockHistoryRoute: BlockHistoryRoute,
): string {
  return JSON.stringify(
    BlockHistoryRoute$outboundSchema.parse(blockHistoryRoute),
  );
}
export function blockHistoryRouteFromJSON(
  jsonString: string,
): SafeParseResult<BlockHistoryRoute, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockHistoryRoute$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockHistoryRoute' from JSON`,
  );
}

/** @internal */
export const BlockHistory4$inboundSchema: z.ZodType<
  BlockHistory4,
  z.ZodTypeDef,
  unknown
> = z.object({
  action:
    UpdateProjectDataCacheBlockHistoryProjectsResponseAction$inboundSchema,
  route: z.union([
    z.lazy(() => UpdateProjectDataCacheRoute1$inboundSchema),
    z.lazy(() => UpdateProjectDataCacheRoute2$inboundSchema),
  ]),
  statusCode: z.number().optional(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});
/** @internal */
export type BlockHistory4$Outbound = {
  action: string;
  route:
    | UpdateProjectDataCacheRoute1$Outbound
    | UpdateProjectDataCacheRoute2$Outbound;
  statusCode?: number | undefined;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

/** @internal */
export const BlockHistory4$outboundSchema: z.ZodType<
  BlockHistory4$Outbound,
  z.ZodTypeDef,
  BlockHistory4
> = z.object({
  action:
    UpdateProjectDataCacheBlockHistoryProjectsResponseAction$outboundSchema,
  route: z.union([
    z.lazy(() => UpdateProjectDataCacheRoute1$outboundSchema),
    z.lazy(() => UpdateProjectDataCacheRoute2$outboundSchema),
  ]),
  statusCode: z.number().optional(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});

export function blockHistory4ToJSON(blockHistory4: BlockHistory4): string {
  return JSON.stringify(BlockHistory4$outboundSchema.parse(blockHistory4));
}
export function blockHistory4FromJSON(
  jsonString: string,
): SafeParseResult<BlockHistory4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockHistory4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockHistory4' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheBlockHistoryProjectsAction$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBlockHistoryProjectsAction> = z
    .nativeEnum(UpdateProjectDataCacheBlockHistoryProjectsAction);
/** @internal */
export const UpdateProjectDataCacheBlockHistoryProjectsAction$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBlockHistoryProjectsAction> =
    UpdateProjectDataCacheBlockHistoryProjectsAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType
  > = z.nativeEnum(
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType,
  );
/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType
  > =
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200Value$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponse200Value,
    z.ZodTypeDef,
    unknown
  > = z.object({
    eq: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheHasProjectsResponse200Value$Outbound = {
  eq: string;
};

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200Value$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponse200Value$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheHasProjectsResponse200Value
  > = z.object({
    eq: z.string(),
  });

export function updateProjectDataCacheHasProjectsResponse200ValueToJSON(
  updateProjectDataCacheHasProjectsResponse200Value:
    UpdateProjectDataCacheHasProjectsResponse200Value,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjectsResponse200Value$outboundSchema.parse(
      updateProjectDataCacheHasProjectsResponse200Value,
    ),
  );
}
export function updateProjectDataCacheHasProjectsResponse200ValueFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheHasProjectsResponse200Value,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjectsResponse200Value$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheHasProjectsResponse200Value' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHasProjects2$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjects2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType$inboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponse200Value$inboundSchema
  ),
});
/** @internal */
export type UpdateProjectDataCacheHasProjects2$Outbound = {
  type: string;
  value: UpdateProjectDataCacheHasProjectsResponse200Value$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheHasProjects2$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjects2$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHasProjects2
> = z.object({
  type:
    UpdateProjectDataCacheHasProjectsResponse200ApplicationJSONType$outboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponse200Value$outboundSchema
  ),
});

export function updateProjectDataCacheHasProjects2ToJSON(
  updateProjectDataCacheHasProjects2: UpdateProjectDataCacheHasProjects2,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjects2$outboundSchema.parse(
      updateProjectDataCacheHasProjects2,
    ),
  );
}
export function updateProjectDataCacheHasProjects2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHasProjects2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjects2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHasProjects2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsResponse200Type> = z
    .nativeEnum(UpdateProjectDataCacheHasProjectsResponse200Type);
/** @internal */
export const UpdateProjectDataCacheHasProjectsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheHasProjectsResponse200Type> =
    UpdateProjectDataCacheHasProjectsResponse200Type$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasKey$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheHasKey
> = z.nativeEnum(UpdateProjectDataCacheHasKey);
/** @internal */
export const UpdateProjectDataCacheHasKey$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheHasKey
> = UpdateProjectDataCacheHasKey$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponseValue$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponseValue,
    z.ZodTypeDef,
    unknown
  > = z.object({
    eq: z.string(),
  });
/** @internal */
export type UpdateProjectDataCacheHasProjectsResponseValue$Outbound = {
  eq: string;
};

/** @internal */
export const UpdateProjectDataCacheHasProjectsResponseValue$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheHasProjectsResponseValue$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheHasProjectsResponseValue
  > = z.object({
    eq: z.string(),
  });

export function updateProjectDataCacheHasProjectsResponseValueToJSON(
  updateProjectDataCacheHasProjectsResponseValue:
    UpdateProjectDataCacheHasProjectsResponseValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjectsResponseValue$outboundSchema.parse(
      updateProjectDataCacheHasProjectsResponseValue,
    ),
  );
}
export function updateProjectDataCacheHasProjectsResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheHasProjectsResponseValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjectsResponseValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheHasProjectsResponseValue' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHasProjects1$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjects1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateProjectDataCacheHasProjectsResponse200Type$inboundSchema,
  key: UpdateProjectDataCacheHasKey$inboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponseValue$inboundSchema
  ),
});
/** @internal */
export type UpdateProjectDataCacheHasProjects1$Outbound = {
  type: string;
  key: string;
  value: UpdateProjectDataCacheHasProjectsResponseValue$Outbound;
};

/** @internal */
export const UpdateProjectDataCacheHasProjects1$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHasProjects1$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHasProjects1
> = z.object({
  type: UpdateProjectDataCacheHasProjectsResponse200Type$outboundSchema,
  key: UpdateProjectDataCacheHasKey$outboundSchema,
  value: z.lazy(() =>
    UpdateProjectDataCacheHasProjectsResponseValue$outboundSchema
  ),
});

export function updateProjectDataCacheHasProjects1ToJSON(
  updateProjectDataCacheHasProjects1: UpdateProjectDataCacheHasProjects1,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasProjects1$outboundSchema.parse(
      updateProjectDataCacheHasProjects1,
    ),
  );
}
export function updateProjectDataCacheHasProjects1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHasProjects1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheHasProjects1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHasProjects1' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheRouteHas$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRouteHas,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateProjectDataCacheHasProjects1$inboundSchema),
  z.lazy(() => UpdateProjectDataCacheHasProjects2$inboundSchema),
]);
/** @internal */
export type UpdateProjectDataCacheRouteHas$Outbound =
  | UpdateProjectDataCacheHasProjects1$Outbound
  | UpdateProjectDataCacheHasProjects2$Outbound;

/** @internal */
export const UpdateProjectDataCacheRouteHas$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRouteHas$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRouteHas
> = z.union([
  z.lazy(() => UpdateProjectDataCacheHasProjects1$outboundSchema),
  z.lazy(() => UpdateProjectDataCacheHasProjects2$outboundSchema),
]);

export function updateProjectDataCacheRouteHasToJSON(
  updateProjectDataCacheRouteHas: UpdateProjectDataCacheRouteHas,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRouteHas$outboundSchema.parse(
      updateProjectDataCacheRouteHas,
    ),
  );
}
export function updateProjectDataCacheRouteHasFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRouteHas, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheRouteHas$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRouteHas' from JSON`,
  );
}

/** @internal */
export const RouteAction$inboundSchema: z.ZodNativeEnum<typeof RouteAction> = z
  .nativeEnum(RouteAction);
/** @internal */
export const RouteAction$outboundSchema: z.ZodNativeEnum<typeof RouteAction> =
  RouteAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheRouteMitigate$inboundSchema: z.ZodType<
  UpdateProjectDataCacheRouteMitigate,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: RouteAction$inboundSchema,
});
/** @internal */
export type UpdateProjectDataCacheRouteMitigate$Outbound = {
  action: string;
};

/** @internal */
export const UpdateProjectDataCacheRouteMitigate$outboundSchema: z.ZodType<
  UpdateProjectDataCacheRouteMitigate$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheRouteMitigate
> = z.object({
  action: RouteAction$outboundSchema,
});

export function updateProjectDataCacheRouteMitigateToJSON(
  updateProjectDataCacheRouteMitigate: UpdateProjectDataCacheRouteMitigate,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheRouteMitigate$outboundSchema.parse(
      updateProjectDataCacheRouteMitigate,
    ),
  );
}
export function updateProjectDataCacheRouteMitigateFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheRouteMitigate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheRouteMitigate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheRouteMitigate' from JSON`,
  );
}

/** @internal */
export const Route2$inboundSchema: z.ZodType<Route2, z.ZodTypeDef, unknown> = z
  .object({
    has: z.array(
      z.union([
        z.lazy(() => UpdateProjectDataCacheHasProjects1$inboundSchema),
        z.lazy(() => UpdateProjectDataCacheHasProjects2$inboundSchema),
      ]),
    ),
    mitigate: z.lazy(() => UpdateProjectDataCacheRouteMitigate$inboundSchema),
    src: z.string().optional(),
  });
/** @internal */
export type Route2$Outbound = {
  has: Array<
    | UpdateProjectDataCacheHasProjects1$Outbound
    | UpdateProjectDataCacheHasProjects2$Outbound
  >;
  mitigate: UpdateProjectDataCacheRouteMitigate$Outbound;
  src?: string | undefined;
};

/** @internal */
export const Route2$outboundSchema: z.ZodType<
  Route2$Outbound,
  z.ZodTypeDef,
  Route2
> = z.object({
  has: z.array(
    z.union([
      z.lazy(() => UpdateProjectDataCacheHasProjects1$outboundSchema),
      z.lazy(() => UpdateProjectDataCacheHasProjects2$outboundSchema),
    ]),
  ),
  mitigate: z.lazy(() => UpdateProjectDataCacheRouteMitigate$outboundSchema),
  src: z.string().optional(),
});

export function route2ToJSON(route2: Route2): string {
  return JSON.stringify(Route2$outboundSchema.parse(route2));
}
export function route2FromJSON(
  jsonString: string,
): SafeParseResult<Route2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Route2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Route2' from JSON`,
  );
}

/** @internal */
export const Route1$inboundSchema: z.ZodType<Route1, z.ZodTypeDef, unknown> = z
  .object({
    src: z.string(),
    status: z.number(),
  });
/** @internal */
export type Route1$Outbound = {
  src: string;
  status: number;
};

/** @internal */
export const Route1$outboundSchema: z.ZodType<
  Route1$Outbound,
  z.ZodTypeDef,
  Route1
> = z.object({
  src: z.string(),
  status: z.number(),
});

export function route1ToJSON(route1: Route1): string {
  return JSON.stringify(Route1$outboundSchema.parse(route1));
}
export function route1FromJSON(
  jsonString: string,
): SafeParseResult<Route1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Route1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Route1' from JSON`,
  );
}

/** @internal */
export const Route$inboundSchema: z.ZodType<Route, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Route1$inboundSchema),
    z.lazy(() => Route2$inboundSchema),
  ]);
/** @internal */
export type Route$Outbound = Route1$Outbound | Route2$Outbound;

/** @internal */
export const Route$outboundSchema: z.ZodType<
  Route$Outbound,
  z.ZodTypeDef,
  Route
> = z.union([
  z.lazy(() => Route1$outboundSchema),
  z.lazy(() => Route2$outboundSchema),
]);

export function routeToJSON(route: Route): string {
  return JSON.stringify(Route$outboundSchema.parse(route));
}
export function routeFromJSON(
  jsonString: string,
): SafeParseResult<Route, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Route$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Route' from JSON`,
  );
}

/** @internal */
export const BlockHistory3$inboundSchema: z.ZodType<
  BlockHistory3,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: UpdateProjectDataCacheBlockHistoryProjectsAction$inboundSchema,
  route: z.union([
    z.lazy(() => Route1$inboundSchema),
    z.lazy(() => Route2$inboundSchema),
  ]),
  reason: z.string(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});
/** @internal */
export type BlockHistory3$Outbound = {
  action: string;
  route: Route1$Outbound | Route2$Outbound;
  reason: string;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

/** @internal */
export const BlockHistory3$outboundSchema: z.ZodType<
  BlockHistory3$Outbound,
  z.ZodTypeDef,
  BlockHistory3
> = z.object({
  action: UpdateProjectDataCacheBlockHistoryProjectsAction$outboundSchema,
  route: z.union([
    z.lazy(() => Route1$outboundSchema),
    z.lazy(() => Route2$outboundSchema),
  ]),
  reason: z.string(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});

export function blockHistory3ToJSON(blockHistory3: BlockHistory3): string {
  return JSON.stringify(BlockHistory3$outboundSchema.parse(blockHistory3));
}
export function blockHistory3FromJSON(
  jsonString: string,
): SafeParseResult<BlockHistory3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockHistory3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockHistory3' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheBlockHistoryAction$inboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBlockHistoryAction> = z
    .nativeEnum(UpdateProjectDataCacheBlockHistoryAction);
/** @internal */
export const UpdateProjectDataCacheBlockHistoryAction$outboundSchema:
  z.ZodNativeEnum<typeof UpdateProjectDataCacheBlockHistoryAction> =
    UpdateProjectDataCacheBlockHistoryAction$inboundSchema;

/** @internal */
export const BlockHistory2$inboundSchema: z.ZodType<
  BlockHistory2,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: UpdateProjectDataCacheBlockHistoryAction$inboundSchema,
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});
/** @internal */
export type BlockHistory2$Outbound = {
  action: string;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

/** @internal */
export const BlockHistory2$outboundSchema: z.ZodType<
  BlockHistory2$Outbound,
  z.ZodTypeDef,
  BlockHistory2
> = z.object({
  action: UpdateProjectDataCacheBlockHistoryAction$outboundSchema,
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});

export function blockHistory2ToJSON(blockHistory2: BlockHistory2): string {
  return JSON.stringify(BlockHistory2$outboundSchema.parse(blockHistory2));
}
export function blockHistory2FromJSON(
  jsonString: string,
): SafeParseResult<BlockHistory2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockHistory2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockHistory2' from JSON`,
  );
}

/** @internal */
export const BlockHistoryAction$inboundSchema: z.ZodNativeEnum<
  typeof BlockHistoryAction
> = z.nativeEnum(BlockHistoryAction);
/** @internal */
export const BlockHistoryAction$outboundSchema: z.ZodNativeEnum<
  typeof BlockHistoryAction
> = BlockHistoryAction$inboundSchema;

/** @internal */
export const BlockHistory1$inboundSchema: z.ZodType<
  BlockHistory1,
  z.ZodTypeDef,
  unknown
> = z.object({
  action: BlockHistoryAction$inboundSchema,
  reason: z.string(),
  statusCode: z.number(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});
/** @internal */
export type BlockHistory1$Outbound = {
  action: string;
  reason: string;
  statusCode: number;
  createdAt: number;
  caseId?: string | undefined;
  actor?: string | undefined;
  comment?: string | undefined;
  isCascading?: boolean | undefined;
};

/** @internal */
export const BlockHistory1$outboundSchema: z.ZodType<
  BlockHistory1$Outbound,
  z.ZodTypeDef,
  BlockHistory1
> = z.object({
  action: BlockHistoryAction$outboundSchema,
  reason: z.string(),
  statusCode: z.number(),
  createdAt: z.number(),
  caseId: z.string().optional(),
  actor: z.string().optional(),
  comment: z.string().optional(),
  isCascading: z.boolean().optional(),
});

export function blockHistory1ToJSON(blockHistory1: BlockHistory1): string {
  return JSON.stringify(BlockHistory1$outboundSchema.parse(blockHistory1));
}
export function blockHistory1FromJSON(
  jsonString: string,
): SafeParseResult<BlockHistory1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BlockHistory1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BlockHistory1' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheBlockHistory$inboundSchema: z.ZodType<
  UpdateProjectDataCacheBlockHistory,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => BlockHistory1$inboundSchema),
  z.lazy(() => BlockHistory3$inboundSchema),
  z.lazy(() => BlockHistory4$inboundSchema),
  z.lazy(() => BlockHistory2$inboundSchema),
]);
/** @internal */
export type UpdateProjectDataCacheBlockHistory$Outbound =
  | BlockHistory1$Outbound
  | BlockHistory3$Outbound
  | BlockHistory4$Outbound
  | BlockHistory2$Outbound;

/** @internal */
export const UpdateProjectDataCacheBlockHistory$outboundSchema: z.ZodType<
  UpdateProjectDataCacheBlockHistory$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheBlockHistory
> = z.union([
  z.lazy(() => BlockHistory1$outboundSchema),
  z.lazy(() => BlockHistory3$outboundSchema),
  z.lazy(() => BlockHistory4$outboundSchema),
  z.lazy(() => BlockHistory2$outboundSchema),
]);

export function updateProjectDataCacheBlockHistoryToJSON(
  updateProjectDataCacheBlockHistory: UpdateProjectDataCacheBlockHistory,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheBlockHistory$outboundSchema.parse(
      updateProjectDataCacheBlockHistory,
    ),
  );
}
export function updateProjectDataCacheBlockHistoryFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheBlockHistory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheBlockHistory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheBlockHistory' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheAbuse$inboundSchema: z.ZodType<
  UpdateProjectDataCacheAbuse,
  z.ZodTypeDef,
  unknown
> = z.object({
  scanner: z.string().optional(),
  history: z.array(z.lazy(() => UpdateProjectDataCacheHistory$inboundSchema)),
  updatedAt: z.number(),
  block: z.lazy(() => Block$inboundSchema).optional(),
  blockHistory: z.array(
    z.union([
      z.lazy(() => BlockHistory1$inboundSchema),
      z.lazy(() => BlockHistory3$inboundSchema),
      z.lazy(() => BlockHistory4$inboundSchema),
      z.lazy(() => BlockHistory2$inboundSchema),
    ]),
  ).optional(),
  interstitial: z.boolean().optional(),
});
/** @internal */
export type UpdateProjectDataCacheAbuse$Outbound = {
  scanner?: string | undefined;
  history: Array<UpdateProjectDataCacheHistory$Outbound>;
  updatedAt: number;
  block?: Block$Outbound | undefined;
  blockHistory?:
    | Array<
      | BlockHistory1$Outbound
      | BlockHistory3$Outbound
      | BlockHistory4$Outbound
      | BlockHistory2$Outbound
    >
    | undefined;
  interstitial?: boolean | undefined;
};

/** @internal */
export const UpdateProjectDataCacheAbuse$outboundSchema: z.ZodType<
  UpdateProjectDataCacheAbuse$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheAbuse
> = z.object({
  scanner: z.string().optional(),
  history: z.array(z.lazy(() => UpdateProjectDataCacheHistory$outboundSchema)),
  updatedAt: z.number(),
  block: z.lazy(() => Block$outboundSchema).optional(),
  blockHistory: z.array(
    z.union([
      z.lazy(() => BlockHistory1$outboundSchema),
      z.lazy(() => BlockHistory3$outboundSchema),
      z.lazy(() => BlockHistory4$outboundSchema),
      z.lazy(() => BlockHistory2$outboundSchema),
    ]),
  ).optional(),
  interstitial: z.boolean().optional(),
});

export function updateProjectDataCacheAbuseToJSON(
  updateProjectDataCacheAbuse: UpdateProjectDataCacheAbuse,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheAbuse$outboundSchema.parse(
      updateProjectDataCacheAbuse,
    ),
  );
}
export function updateProjectDataCacheAbuseFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheAbuse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheAbuse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheAbuse' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheHasType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheHasType
> = z.nativeEnum(UpdateProjectDataCacheHasType);
/** @internal */
export const UpdateProjectDataCacheHasType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheHasType
> = UpdateProjectDataCacheHasType$inboundSchema;

/** @internal */
export const HasValue$inboundSchema: z.ZodType<
  HasValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.string(),
});
/** @internal */
export type HasValue$Outbound = {
  eq: string;
};

/** @internal */
export const HasValue$outboundSchema: z.ZodType<
  HasValue$Outbound,
  z.ZodTypeDef,
  HasValue
> = z.object({
  eq: z.string(),
});

export function hasValueToJSON(hasValue: HasValue): string {
  return JSON.stringify(HasValue$outboundSchema.parse(hasValue));
}
export function hasValueFromJSON(
  jsonString: string,
): SafeParseResult<HasValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HasValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HasValue' from JSON`,
  );
}

/** @internal */
export const Has2$inboundSchema: z.ZodType<Has2, z.ZodTypeDef, unknown> = z
  .object({
    type: UpdateProjectDataCacheHasType$inboundSchema,
    value: z.lazy(() => HasValue$inboundSchema),
  });
/** @internal */
export type Has2$Outbound = {
  type: string;
  value: HasValue$Outbound;
};

/** @internal */
export const Has2$outboundSchema: z.ZodType<Has2$Outbound, z.ZodTypeDef, Has2> =
  z.object({
    type: UpdateProjectDataCacheHasType$outboundSchema,
    value: z.lazy(() => HasValue$outboundSchema),
  });

export function has2ToJSON(has2: Has2): string {
  return JSON.stringify(Has2$outboundSchema.parse(has2));
}
export function has2FromJSON(
  jsonString: string,
): SafeParseResult<Has2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has2' from JSON`,
  );
}

/** @internal */
export const HasType$inboundSchema: z.ZodNativeEnum<typeof HasType> = z
  .nativeEnum(HasType);
/** @internal */
export const HasType$outboundSchema: z.ZodNativeEnum<typeof HasType> =
  HasType$inboundSchema;

/** @internal */
export const Key$inboundSchema: z.ZodNativeEnum<typeof Key> = z.nativeEnum(Key);
/** @internal */
export const Key$outboundSchema: z.ZodNativeEnum<typeof Key> =
  Key$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheHasValue$inboundSchema: z.ZodType<
  UpdateProjectDataCacheHasValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.string(),
});
/** @internal */
export type UpdateProjectDataCacheHasValue$Outbound = {
  eq: string;
};

/** @internal */
export const UpdateProjectDataCacheHasValue$outboundSchema: z.ZodType<
  UpdateProjectDataCacheHasValue$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheHasValue
> = z.object({
  eq: z.string(),
});

export function updateProjectDataCacheHasValueToJSON(
  updateProjectDataCacheHasValue: UpdateProjectDataCacheHasValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheHasValue$outboundSchema.parse(
      updateProjectDataCacheHasValue,
    ),
  );
}
export function updateProjectDataCacheHasValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheHasValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheHasValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheHasValue' from JSON`,
  );
}

/** @internal */
export const Has1$inboundSchema: z.ZodType<Has1, z.ZodTypeDef, unknown> = z
  .object({
    type: HasType$inboundSchema,
    key: Key$inboundSchema,
    value: z.lazy(() => UpdateProjectDataCacheHasValue$inboundSchema),
  });
/** @internal */
export type Has1$Outbound = {
  type: string;
  key: string;
  value: UpdateProjectDataCacheHasValue$Outbound;
};

/** @internal */
export const Has1$outboundSchema: z.ZodType<Has1$Outbound, z.ZodTypeDef, Has1> =
  z.object({
    type: HasType$outboundSchema,
    key: Key$outboundSchema,
    value: z.lazy(() => UpdateProjectDataCacheHasValue$outboundSchema),
  });

export function has1ToJSON(has1: Has1): string {
  return JSON.stringify(Has1$outboundSchema.parse(has1));
}
export function has1FromJSON(
  jsonString: string,
): SafeParseResult<Has1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has1' from JSON`,
  );
}

/** @internal */
export const Has$inboundSchema: z.ZodType<Has, z.ZodTypeDef, unknown> = z.union(
  [z.lazy(() => Has1$inboundSchema), z.lazy(() => Has2$inboundSchema)],
);
/** @internal */
export type Has$Outbound = Has1$Outbound | Has2$Outbound;

/** @internal */
export const Has$outboundSchema: z.ZodType<Has$Outbound, z.ZodTypeDef, Has> = z
  .union([
    z.lazy(() => Has1$outboundSchema),
    z.lazy(() => Has2$outboundSchema),
  ]);

export function hasToJSON(has: Has): string {
  return JSON.stringify(Has$outboundSchema.parse(has));
}
export function hasFromJSON(
  jsonString: string,
): SafeParseResult<Has, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Has$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Has' from JSON`,
  );
}

/** @internal */
export const InternalRoutesAction$inboundSchema: z.ZodNativeEnum<
  typeof InternalRoutesAction
> = z.nativeEnum(InternalRoutesAction);
/** @internal */
export const InternalRoutesAction$outboundSchema: z.ZodNativeEnum<
  typeof InternalRoutesAction
> = InternalRoutesAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheInternalRoutesMitigate$inboundSchema:
  z.ZodType<
    UpdateProjectDataCacheInternalRoutesMitigate,
    z.ZodTypeDef,
    unknown
  > = z.object({
    action: InternalRoutesAction$inboundSchema,
  });
/** @internal */
export type UpdateProjectDataCacheInternalRoutesMitigate$Outbound = {
  action: string;
};

/** @internal */
export const UpdateProjectDataCacheInternalRoutesMitigate$outboundSchema:
  z.ZodType<
    UpdateProjectDataCacheInternalRoutesMitigate$Outbound,
    z.ZodTypeDef,
    UpdateProjectDataCacheInternalRoutesMitigate
  > = z.object({
    action: InternalRoutesAction$outboundSchema,
  });

export function updateProjectDataCacheInternalRoutesMitigateToJSON(
  updateProjectDataCacheInternalRoutesMitigate:
    UpdateProjectDataCacheInternalRoutesMitigate,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheInternalRoutesMitigate$outboundSchema.parse(
      updateProjectDataCacheInternalRoutesMitigate,
    ),
  );
}
export function updateProjectDataCacheInternalRoutesMitigateFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheInternalRoutesMitigate,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheInternalRoutesMitigate$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheInternalRoutesMitigate' from JSON`,
  );
}

/** @internal */
export const InternalRoutes2$inboundSchema: z.ZodType<
  InternalRoutes2,
  z.ZodTypeDef,
  unknown
> = z.object({
  has: z.array(
    z.union([
      z.lazy(() => Has1$inboundSchema),
      z.lazy(() => Has2$inboundSchema),
    ]),
  ),
  mitigate: z.lazy(() =>
    UpdateProjectDataCacheInternalRoutesMitigate$inboundSchema
  ),
  src: z.string().optional(),
});
/** @internal */
export type InternalRoutes2$Outbound = {
  has: Array<Has1$Outbound | Has2$Outbound>;
  mitigate: UpdateProjectDataCacheInternalRoutesMitigate$Outbound;
  src?: string | undefined;
};

/** @internal */
export const InternalRoutes2$outboundSchema: z.ZodType<
  InternalRoutes2$Outbound,
  z.ZodTypeDef,
  InternalRoutes2
> = z.object({
  has: z.array(
    z.union([
      z.lazy(() => Has1$outboundSchema),
      z.lazy(() => Has2$outboundSchema),
    ]),
  ),
  mitigate: z.lazy(() =>
    UpdateProjectDataCacheInternalRoutesMitigate$outboundSchema
  ),
  src: z.string().optional(),
});

export function internalRoutes2ToJSON(
  internalRoutes2: InternalRoutes2,
): string {
  return JSON.stringify(InternalRoutes2$outboundSchema.parse(internalRoutes2));
}
export function internalRoutes2FromJSON(
  jsonString: string,
): SafeParseResult<InternalRoutes2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InternalRoutes2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InternalRoutes2' from JSON`,
  );
}

/** @internal */
export const InternalRoutes1$inboundSchema: z.ZodType<
  InternalRoutes1,
  z.ZodTypeDef,
  unknown
> = z.object({
  src: z.string(),
  status: z.number(),
});
/** @internal */
export type InternalRoutes1$Outbound = {
  src: string;
  status: number;
};

/** @internal */
export const InternalRoutes1$outboundSchema: z.ZodType<
  InternalRoutes1$Outbound,
  z.ZodTypeDef,
  InternalRoutes1
> = z.object({
  src: z.string(),
  status: z.number(),
});

export function internalRoutes1ToJSON(
  internalRoutes1: InternalRoutes1,
): string {
  return JSON.stringify(InternalRoutes1$outboundSchema.parse(internalRoutes1));
}
export function internalRoutes1FromJSON(
  jsonString: string,
): SafeParseResult<InternalRoutes1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InternalRoutes1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InternalRoutes1' from JSON`,
  );
}

/** @internal */
export const InternalRoutes$inboundSchema: z.ZodType<
  InternalRoutes,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InternalRoutes1$inboundSchema),
  z.lazy(() => InternalRoutes2$inboundSchema),
]);
/** @internal */
export type InternalRoutes$Outbound =
  | InternalRoutes1$Outbound
  | InternalRoutes2$Outbound;

/** @internal */
export const InternalRoutes$outboundSchema: z.ZodType<
  InternalRoutes$Outbound,
  z.ZodTypeDef,
  InternalRoutes
> = z.union([
  z.lazy(() => InternalRoutes1$outboundSchema),
  z.lazy(() => InternalRoutes2$outboundSchema),
]);

export function internalRoutesToJSON(internalRoutes: InternalRoutes): string {
  return JSON.stringify(InternalRoutes$outboundSchema.parse(internalRoutes));
}
export function internalRoutesFromJSON(
  jsonString: string,
): SafeParseResult<InternalRoutes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InternalRoutes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InternalRoutes' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheAction$inboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheAction
> = z.nativeEnum(UpdateProjectDataCacheAction);
/** @internal */
export const UpdateProjectDataCacheAction$outboundSchema: z.ZodNativeEnum<
  typeof UpdateProjectDataCacheAction
> = UpdateProjectDataCacheAction$inboundSchema;

/** @internal */
export const UpdateProjectDataCacheValuePreviousValue$inboundSchema: z.ZodType<
  UpdateProjectDataCacheValuePreviousValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateProjectDataCacheValuePreviousValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateProjectDataCacheValuePreviousValue$outboundSchema: z.ZodType<
  UpdateProjectDataCacheValuePreviousValue$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheValuePreviousValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateProjectDataCacheValuePreviousValueToJSON(
  updateProjectDataCacheValuePreviousValue:
    UpdateProjectDataCacheValuePreviousValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheValuePreviousValue$outboundSchema.parse(
      updateProjectDataCacheValuePreviousValue,
    ),
  );
}
export function updateProjectDataCacheValuePreviousValueFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheValuePreviousValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheValuePreviousValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheValuePreviousValue' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheValueCurrentValue$inboundSchema: z.ZodType<
  UpdateProjectDataCacheValueCurrentValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateProjectDataCacheValueCurrentValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateProjectDataCacheValueCurrentValue$outboundSchema: z.ZodType<
  UpdateProjectDataCacheValueCurrentValue$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheValueCurrentValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateProjectDataCacheValueCurrentValueToJSON(
  updateProjectDataCacheValueCurrentValue:
    UpdateProjectDataCacheValueCurrentValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheValueCurrentValue$outboundSchema.parse(
      updateProjectDataCacheValueCurrentValue,
    ),
  );
}
export function updateProjectDataCacheValueCurrentValueFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectDataCacheValueCurrentValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheValueCurrentValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectDataCacheValueCurrentValue' from JSON`,
  );
}

/** @internal */
export const Value4$inboundSchema: z.ZodType<Value4, z.ZodTypeDef, unknown> = z
  .object({
    previousValue: z.union([z.string(), z.number(), z.boolean()]),
    currentValue: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type Value4$Outbound = {
  previousValue: string | number | boolean;
  currentValue: string | number | boolean;
};

/** @internal */
export const Value4$outboundSchema: z.ZodType<
  Value4$Outbound,
  z.ZodTypeDef,
  Value4
> = z.object({
  previousValue: z.union([z.string(), z.number(), z.boolean()]),
  currentValue: z.union([z.string(), z.number(), z.boolean()]),
});

export function value4ToJSON(value4: Value4): string {
  return JSON.stringify(Value4$outboundSchema.parse(value4));
}
export function value4FromJSON(
  jsonString: string,
): SafeParseResult<Value4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Value4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Value4' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheValue$inboundSchema: z.ZodType<
  UpdateProjectDataCacheValue,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Value4$inboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
]);
/** @internal */
export type UpdateProjectDataCacheValue$Outbound =
  | Value4$Outbound
  | string
  | number
  | boolean;

/** @internal */
export const UpdateProjectDataCacheValue$outboundSchema: z.ZodType<
  UpdateProjectDataCacheValue$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheValue
> = z.union([
  z.lazy(() => Value4$outboundSchema),
  z.string(),
  z.number(),
  z.boolean(),
]);

export function updateProjectDataCacheValueToJSON(
  updateProjectDataCacheValue: UpdateProjectDataCacheValue,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheValue$outboundSchema.parse(
      updateProjectDataCacheValue,
    ),
  );
}
export function updateProjectDataCacheValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateProjectDataCacheValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheValue' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheDismissedToasts$inboundSchema: z.ZodType<
  UpdateProjectDataCacheDismissedToasts,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  dismissedAt: z.number(),
  action: UpdateProjectDataCacheAction$inboundSchema,
  value: z.nullable(
    z.union([
      z.lazy(() => Value4$inboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
    ]),
  ),
});
/** @internal */
export type UpdateProjectDataCacheDismissedToasts$Outbound = {
  key: string;
  dismissedAt: number;
  action: string;
  value: Value4$Outbound | string | number | boolean | null;
};

/** @internal */
export const UpdateProjectDataCacheDismissedToasts$outboundSchema: z.ZodType<
  UpdateProjectDataCacheDismissedToasts$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheDismissedToasts
> = z.object({
  key: z.string(),
  dismissedAt: z.number(),
  action: UpdateProjectDataCacheAction$outboundSchema,
  value: z.nullable(
    z.union([
      z.lazy(() => Value4$outboundSchema),
      z.string(),
      z.number(),
      z.boolean(),
    ]),
  ),
});

export function updateProjectDataCacheDismissedToastsToJSON(
  updateProjectDataCacheDismissedToasts: UpdateProjectDataCacheDismissedToasts,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheDismissedToasts$outboundSchema.parse(
      updateProjectDataCacheDismissedToasts,
    ),
  );
}
export function updateProjectDataCacheDismissedToastsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheDismissedToasts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheDismissedToasts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheDismissedToasts' from JSON`,
  );
}

/** @internal */
export const UpdateProjectDataCacheResponseBody$inboundSchema: z.ZodType<
  UpdateProjectDataCacheResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  accountId: z.string(),
  analytics: z.lazy(() => Analytics$inboundSchema).optional(),
  speedInsights: z.lazy(() => SpeedInsights$inboundSchema).optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.nullable(z.string()).optional(),
  commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
  connectConfigurations: z.nullable(
    z.array(z.lazy(() =>
      UpdateProjectDataCacheConnectConfigurations$inboundSchema
    )),
  ).optional(),
  connectConfigurationId: z.nullable(z.string()).optional(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.nullable(z.string()).optional(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z.lazy(() => Crons$inboundSchema).optional(),
  dataCache: z.lazy(() => UpdateProjectDataCacheDataCache$inboundSchema)
    .optional(),
  deploymentExpiration: z.nullable(
    z.lazy(() => DeploymentExpiration$inboundSchema),
  ).optional(),
  devCommand: z.nullable(z.string()).optional(),
  directoryListing: z.boolean(),
  installCommand: z.nullable(z.string()).optional(),
  env: z.array(z.lazy(() => UpdateProjectDataCacheEnv$inboundSchema))
    .optional(),
  customEnvironments: z.array(z.lazy(() => CustomEnvironments$inboundSchema))
    .optional(),
  framework: z.nullable(UpdateProjectDataCacheFramework$inboundSchema)
    .optional(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z.array(
    z.lazy(() => UpdateProjectDataCacheIpBuckets$inboundSchema),
  ).optional(),
  latestDeployments: z.array(z.lazy(() => LatestDeployments$inboundSchema))
    .optional(),
  link: z.union([
    z.lazy(() => Link4$inboundSchema),
    z.lazy(() => Link5$inboundSchema),
    z.lazy(() => Link3$inboundSchema),
    z.lazy(() => Link1$inboundSchema),
    z.lazy(() => Link2$inboundSchema),
  ]).optional(),
  microfrontends: z.union([
    z.lazy(() => UpdateProjectDataCacheMicrofrontends1$inboundSchema),
    z.lazy(() => UpdateProjectDataCacheMicrofrontends2$inboundSchema),
    z.lazy(() => UpdateProjectDataCacheMicrofrontends3$inboundSchema),
  ]).optional(),
  name: z.string(),
  nodeVersion: UpdateProjectDataCacheNodeVersion$inboundSchema,
  optionsAllowlist: z.nullable(
    z.lazy(() => UpdateProjectDataCacheOptionsAllowlist$inboundSchema),
  ).optional(),
  outputDirectory: z.nullable(z.string()).optional(),
  passwordProtection: z.nullable(
    z.lazy(() => UpdateProjectDataCachePasswordProtection$inboundSchema),
  ).optional(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.nullable(z.boolean()).optional(),
  resourceConfig: z.lazy(() =>
    UpdateProjectDataCacheResourceConfig$inboundSchema
  ),
  rollbackDescription: z.lazy(() => RollbackDescription$inboundSchema)
    .optional(),
  rollingRelease: z.nullable(z.lazy(() => RollingRelease$inboundSchema))
    .optional(),
  defaultResourceConfig: z.lazy(() => DefaultResourceConfig$inboundSchema),
  rootDirectory: z.nullable(z.string()).optional(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  staticIps: z.lazy(() => UpdateProjectDataCacheStaticIps$inboundSchema)
    .optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z.nullable(
    z.lazy(() => UpdateProjectDataCacheSsoProtection$inboundSchema),
  ).optional(),
  targets: z.record(z.nullable(z.lazy(() => Targets$inboundSchema))).optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.nullable(z.boolean()).optional(),
  enableProductionFeedback: z.nullable(z.boolean()).optional(),
  permissions: z.lazy(() => UpdateProjectDataCachePermissions$inboundSchema)
    .optional(),
  lastRollbackTarget: z.nullable(z.lazy(() => LastRollbackTarget$inboundSchema))
    .optional(),
  lastAliasRequest: z.nullable(z.lazy(() => LastAliasRequest$inboundSchema))
    .optional(),
  protectionBypass: z.record(
    z.union([
      z.lazy(() => ProtectionBypass1$inboundSchema),
      z.lazy(() => ProtectionBypass2$inboundSchema),
    ]),
  ).optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z.nullable(
    z.union([
      z.lazy(() => TrustedIps1$inboundSchema),
      z.lazy(() => TrustedIps2$inboundSchema),
    ]),
  ).optional(),
  gitComments: z.lazy(() => GitComments$inboundSchema).optional(),
  gitProviderOptions: z.lazy(() => GitProviderOptions$inboundSchema).optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z.lazy(() => UpdateProjectDataCacheWebAnalytics$inboundSchema)
    .optional(),
  security: z.lazy(() => UpdateProjectDataCacheSecurity$inboundSchema)
    .optional(),
  oidcTokenConfig: z.lazy(() =>
    UpdateProjectDataCacheOidcTokenConfig$inboundSchema
  ).optional(),
  tier: UpdateProjectDataCacheTier$inboundSchema.optional(),
  features: z.lazy(() => Features$inboundSchema).optional(),
  v0: z.boolean().optional(),
  abuse: z.lazy(() => UpdateProjectDataCacheAbuse$inboundSchema).optional(),
  internalRoutes: z.array(
    z.union([
      z.lazy(() => InternalRoutes1$inboundSchema),
      z.lazy(() => InternalRoutes2$inboundSchema),
    ]),
  ).optional(),
  hasDeployments: z.boolean().optional(),
  dismissedToasts: z.array(
    z.lazy(() => UpdateProjectDataCacheDismissedToasts$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateProjectDataCacheResponseBody$Outbound = {
  accountId: string;
  analytics?: Analytics$Outbound | undefined;
  speedInsights?: SpeedInsights$Outbound | undefined;
  autoExposeSystemEnvs?: boolean | undefined;
  autoAssignCustomDomains?: boolean | undefined;
  autoAssignCustomDomainsUpdatedBy?: string | undefined;
  buildCommand?: string | null | undefined;
  commandForIgnoringBuildStep?: string | null | undefined;
  connectConfigurations?:
    | Array<UpdateProjectDataCacheConnectConfigurations$Outbound>
    | null
    | undefined;
  connectConfigurationId?: string | null | undefined;
  connectBuildsEnabled?: boolean | undefined;
  passiveConnectConfigurationId?: string | null | undefined;
  createdAt?: number | undefined;
  customerSupportCodeVisibility?: boolean | undefined;
  crons?: Crons$Outbound | undefined;
  dataCache?: UpdateProjectDataCacheDataCache$Outbound | undefined;
  deploymentExpiration?: DeploymentExpiration$Outbound | null | undefined;
  devCommand?: string | null | undefined;
  directoryListing: boolean;
  installCommand?: string | null | undefined;
  env?: Array<UpdateProjectDataCacheEnv$Outbound> | undefined;
  customEnvironments?: Array<CustomEnvironments$Outbound> | undefined;
  framework?: string | null | undefined;
  gitForkProtection?: boolean | undefined;
  gitLFS?: boolean | undefined;
  id: string;
  ipBuckets?: Array<UpdateProjectDataCacheIpBuckets$Outbound> | undefined;
  latestDeployments?: Array<LatestDeployments$Outbound> | undefined;
  link?:
    | Link4$Outbound
    | Link5$Outbound
    | Link3$Outbound
    | Link1$Outbound
    | Link2$Outbound
    | undefined;
  microfrontends?:
    | UpdateProjectDataCacheMicrofrontends1$Outbound
    | UpdateProjectDataCacheMicrofrontends2$Outbound
    | UpdateProjectDataCacheMicrofrontends3$Outbound
    | undefined;
  name: string;
  nodeVersion: string;
  optionsAllowlist?:
    | UpdateProjectDataCacheOptionsAllowlist$Outbound
    | null
    | undefined;
  outputDirectory?: string | null | undefined;
  passwordProtection?:
    | UpdateProjectDataCachePasswordProtection$Outbound
    | null
    | undefined;
  productionDeploymentsFastLane?: boolean | undefined;
  publicSource?: boolean | null | undefined;
  resourceConfig: UpdateProjectDataCacheResourceConfig$Outbound;
  rollbackDescription?: RollbackDescription$Outbound | undefined;
  rollingRelease?: RollingRelease$Outbound | null | undefined;
  defaultResourceConfig: DefaultResourceConfig$Outbound;
  rootDirectory?: string | null | undefined;
  serverlessFunctionZeroConfigFailover?: boolean | undefined;
  skewProtectionBoundaryAt?: number | undefined;
  skewProtectionMaxAge?: number | undefined;
  skipGitConnectDuringLink?: boolean | undefined;
  staticIps?: UpdateProjectDataCacheStaticIps$Outbound | undefined;
  sourceFilesOutsideRootDirectory?: boolean | undefined;
  enableAffectedProjectsDeployments?: boolean | undefined;
  ssoProtection?:
    | UpdateProjectDataCacheSsoProtection$Outbound
    | null
    | undefined;
  targets?: { [k: string]: Targets$Outbound | null } | undefined;
  transferCompletedAt?: number | undefined;
  transferStartedAt?: number | undefined;
  transferToAccountId?: string | undefined;
  transferredFromAccountId?: string | undefined;
  updatedAt?: number | undefined;
  live?: boolean | undefined;
  enablePreviewFeedback?: boolean | null | undefined;
  enableProductionFeedback?: boolean | null | undefined;
  permissions?: UpdateProjectDataCachePermissions$Outbound | undefined;
  lastRollbackTarget?: LastRollbackTarget$Outbound | null | undefined;
  lastAliasRequest?: LastAliasRequest$Outbound | null | undefined;
  protectionBypass?: {
    [k: string]: ProtectionBypass1$Outbound | ProtectionBypass2$Outbound;
  } | undefined;
  hasActiveBranches?: boolean | undefined;
  trustedIps?: TrustedIps1$Outbound | TrustedIps2$Outbound | null | undefined;
  gitComments?: GitComments$Outbound | undefined;
  gitProviderOptions?: GitProviderOptions$Outbound | undefined;
  paused?: boolean | undefined;
  concurrencyBucketName?: string | undefined;
  webAnalytics?: UpdateProjectDataCacheWebAnalytics$Outbound | undefined;
  security?: UpdateProjectDataCacheSecurity$Outbound | undefined;
  oidcTokenConfig?: UpdateProjectDataCacheOidcTokenConfig$Outbound | undefined;
  tier?: string | undefined;
  features?: Features$Outbound | undefined;
  v0?: boolean | undefined;
  abuse?: UpdateProjectDataCacheAbuse$Outbound | undefined;
  internalRoutes?:
    | Array<InternalRoutes1$Outbound | InternalRoutes2$Outbound>
    | undefined;
  hasDeployments?: boolean | undefined;
  dismissedToasts?:
    | Array<UpdateProjectDataCacheDismissedToasts$Outbound>
    | undefined;
};

/** @internal */
export const UpdateProjectDataCacheResponseBody$outboundSchema: z.ZodType<
  UpdateProjectDataCacheResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateProjectDataCacheResponseBody
> = z.object({
  accountId: z.string(),
  analytics: z.lazy(() => Analytics$outboundSchema).optional(),
  speedInsights: z.lazy(() => SpeedInsights$outboundSchema).optional(),
  autoExposeSystemEnvs: z.boolean().optional(),
  autoAssignCustomDomains: z.boolean().optional(),
  autoAssignCustomDomainsUpdatedBy: z.string().optional(),
  buildCommand: z.nullable(z.string()).optional(),
  commandForIgnoringBuildStep: z.nullable(z.string()).optional(),
  connectConfigurations: z.nullable(
    z.array(z.lazy(() =>
      UpdateProjectDataCacheConnectConfigurations$outboundSchema
    )),
  ).optional(),
  connectConfigurationId: z.nullable(z.string()).optional(),
  connectBuildsEnabled: z.boolean().optional(),
  passiveConnectConfigurationId: z.nullable(z.string()).optional(),
  createdAt: z.number().optional(),
  customerSupportCodeVisibility: z.boolean().optional(),
  crons: z.lazy(() => Crons$outboundSchema).optional(),
  dataCache: z.lazy(() => UpdateProjectDataCacheDataCache$outboundSchema)
    .optional(),
  deploymentExpiration: z.nullable(
    z.lazy(() => DeploymentExpiration$outboundSchema),
  ).optional(),
  devCommand: z.nullable(z.string()).optional(),
  directoryListing: z.boolean(),
  installCommand: z.nullable(z.string()).optional(),
  env: z.array(z.lazy(() => UpdateProjectDataCacheEnv$outboundSchema))
    .optional(),
  customEnvironments: z.array(z.lazy(() => CustomEnvironments$outboundSchema))
    .optional(),
  framework: z.nullable(UpdateProjectDataCacheFramework$outboundSchema)
    .optional(),
  gitForkProtection: z.boolean().optional(),
  gitLFS: z.boolean().optional(),
  id: z.string(),
  ipBuckets: z.array(
    z.lazy(() => UpdateProjectDataCacheIpBuckets$outboundSchema),
  ).optional(),
  latestDeployments: z.array(z.lazy(() => LatestDeployments$outboundSchema))
    .optional(),
  link: z.union([
    z.lazy(() => Link4$outboundSchema),
    z.lazy(() => Link5$outboundSchema),
    z.lazy(() => Link3$outboundSchema),
    z.lazy(() => Link1$outboundSchema),
    z.lazy(() => Link2$outboundSchema),
  ]).optional(),
  microfrontends: z.union([
    z.lazy(() => UpdateProjectDataCacheMicrofrontends1$outboundSchema),
    z.lazy(() => UpdateProjectDataCacheMicrofrontends2$outboundSchema),
    z.lazy(() => UpdateProjectDataCacheMicrofrontends3$outboundSchema),
  ]).optional(),
  name: z.string(),
  nodeVersion: UpdateProjectDataCacheNodeVersion$outboundSchema,
  optionsAllowlist: z.nullable(
    z.lazy(() => UpdateProjectDataCacheOptionsAllowlist$outboundSchema),
  ).optional(),
  outputDirectory: z.nullable(z.string()).optional(),
  passwordProtection: z.nullable(
    z.lazy(() => UpdateProjectDataCachePasswordProtection$outboundSchema),
  ).optional(),
  productionDeploymentsFastLane: z.boolean().optional(),
  publicSource: z.nullable(z.boolean()).optional(),
  resourceConfig: z.lazy(() =>
    UpdateProjectDataCacheResourceConfig$outboundSchema
  ),
  rollbackDescription: z.lazy(() => RollbackDescription$outboundSchema)
    .optional(),
  rollingRelease: z.nullable(z.lazy(() => RollingRelease$outboundSchema))
    .optional(),
  defaultResourceConfig: z.lazy(() => DefaultResourceConfig$outboundSchema),
  rootDirectory: z.nullable(z.string()).optional(),
  serverlessFunctionZeroConfigFailover: z.boolean().optional(),
  skewProtectionBoundaryAt: z.number().optional(),
  skewProtectionMaxAge: z.number().optional(),
  skipGitConnectDuringLink: z.boolean().optional(),
  staticIps: z.lazy(() => UpdateProjectDataCacheStaticIps$outboundSchema)
    .optional(),
  sourceFilesOutsideRootDirectory: z.boolean().optional(),
  enableAffectedProjectsDeployments: z.boolean().optional(),
  ssoProtection: z.nullable(
    z.lazy(() => UpdateProjectDataCacheSsoProtection$outboundSchema),
  ).optional(),
  targets: z.record(z.nullable(z.lazy(() => Targets$outboundSchema)))
    .optional(),
  transferCompletedAt: z.number().optional(),
  transferStartedAt: z.number().optional(),
  transferToAccountId: z.string().optional(),
  transferredFromAccountId: z.string().optional(),
  updatedAt: z.number().optional(),
  live: z.boolean().optional(),
  enablePreviewFeedback: z.nullable(z.boolean()).optional(),
  enableProductionFeedback: z.nullable(z.boolean()).optional(),
  permissions: z.lazy(() => UpdateProjectDataCachePermissions$outboundSchema)
    .optional(),
  lastRollbackTarget: z.nullable(
    z.lazy(() => LastRollbackTarget$outboundSchema),
  ).optional(),
  lastAliasRequest: z.nullable(z.lazy(() => LastAliasRequest$outboundSchema))
    .optional(),
  protectionBypass: z.record(
    z.union([
      z.lazy(() => ProtectionBypass1$outboundSchema),
      z.lazy(() => ProtectionBypass2$outboundSchema),
    ]),
  ).optional(),
  hasActiveBranches: z.boolean().optional(),
  trustedIps: z.nullable(
    z.union([
      z.lazy(() => TrustedIps1$outboundSchema),
      z.lazy(() => TrustedIps2$outboundSchema),
    ]),
  ).optional(),
  gitComments: z.lazy(() => GitComments$outboundSchema).optional(),
  gitProviderOptions: z.lazy(() => GitProviderOptions$outboundSchema)
    .optional(),
  paused: z.boolean().optional(),
  concurrencyBucketName: z.string().optional(),
  webAnalytics: z.lazy(() => UpdateProjectDataCacheWebAnalytics$outboundSchema)
    .optional(),
  security: z.lazy(() => UpdateProjectDataCacheSecurity$outboundSchema)
    .optional(),
  oidcTokenConfig: z.lazy(() =>
    UpdateProjectDataCacheOidcTokenConfig$outboundSchema
  ).optional(),
  tier: UpdateProjectDataCacheTier$outboundSchema.optional(),
  features: z.lazy(() => Features$outboundSchema).optional(),
  v0: z.boolean().optional(),
  abuse: z.lazy(() => UpdateProjectDataCacheAbuse$outboundSchema).optional(),
  internalRoutes: z.array(
    z.union([
      z.lazy(() => InternalRoutes1$outboundSchema),
      z.lazy(() => InternalRoutes2$outboundSchema),
    ]),
  ).optional(),
  hasDeployments: z.boolean().optional(),
  dismissedToasts: z.array(
    z.lazy(() => UpdateProjectDataCacheDismissedToasts$outboundSchema),
  ).optional(),
});

export function updateProjectDataCacheResponseBodyToJSON(
  updateProjectDataCacheResponseBody: UpdateProjectDataCacheResponseBody,
): string {
  return JSON.stringify(
    UpdateProjectDataCacheResponseBody$outboundSchema.parse(
      updateProjectDataCacheResponseBody,
    ),
  );
}
export function updateProjectDataCacheResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectDataCacheResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectDataCacheResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectDataCacheResponseBody' from JSON`,
  );
}
