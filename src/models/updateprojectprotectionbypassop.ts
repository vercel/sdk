/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../lib/primitives.js";
import { safeParse } from "../lib/schemas.js";
import { Result as SafeParseResult } from "../types/fp.js";
import * as types from "../types/primitives.js";
import { SDKValidationError } from "./sdkvalidationerror.js";

/**
 * Optional instructions for revoking and regenerating a automation bypass
 */
export type Revoke = {
  /**
   * Automation bypass to revoked
   */
  secret: string;
  /**
   * Whether or not a new automation bypass should be created after the provided secret is revoked
   */
  regenerate: boolean;
};

/**
 * Generate a new secret. If neither generate or revoke are provided, a new random secret will be generated.
 */
export type Generate = {
  /**
   * Optional value of the secret to generate, don't send it for oauth2 tokens
   */
  secret?: string | undefined;
  /**
   * Note to be displayed in the UI for this bypass
   */
  note?: string | undefined;
};

/**
 * Update an existing bypass
 */
export type Update = {
  /**
   * Automation bypass to updated
   */
  secret: string;
  /**
   * Whether or not this bypass is set as the VERCEL_AUTOMATION_BYPASS_SECRET environment variable on deployments
   */
  isEnvVar?: boolean | undefined;
  /**
   * Note to be displayed in the UI for this bypass
   */
  note?: string | undefined;
};

export type UpdateProjectProtectionBypassRequestBody = {
  /**
   * Optional instructions for revoking and regenerating a automation bypass
   */
  revoke?: Revoke | undefined;
  /**
   * Generate a new secret. If neither generate or revoke are provided, a new random secret will be generated.
   */
  generate?: Generate | undefined;
  /**
   * Update an existing bypass
   */
  update?: Update | undefined;
};

export type UpdateProjectProtectionBypassRequest = {
  /**
   * The unique project identifier or the project name
   */
  idOrName: string;
  /**
   * The Team identifier to perform the request on behalf of.
   */
  teamId?: string | undefined;
  /**
   * The Team slug to perform the request on behalf of.
   */
  slug?: string | undefined;
  requestBody: UpdateProjectProtectionBypassRequestBody;
};

export type UpdateProjectProtectionBypassProtectionBypass2 = {
  createdAt: number;
  createdBy: string;
  scope: "automation-bypass";
  /**
   * When there was only one bypass, it was automatically set as an env var on deployments. With multiple bypasses, there is always one bypass that is selected as the default, and gets set as an env var on deployments. As this is a new field, undefined means that the bypass is the env var. If there are any automation bypasses, exactly one must be the env var.
   */
  isEnvVar?: boolean | undefined;
  /**
   * Optional note about the bypass to be displayed in the UI
   */
  note?: string | undefined;
};

export type UpdateProjectProtectionBypassProtectionBypass1 = {
  createdAt: number;
  createdBy: string;
  scope: "integration-automation-bypass";
  integrationId: string;
  configurationId: string;
};

export type UpdateProjectProtectionBypassProtectionBypass =
  | UpdateProjectProtectionBypassProtectionBypass1
  | UpdateProjectProtectionBypassProtectionBypass2;

export type UpdateProjectProtectionBypassResponseBody = {
  protectionBypass?: {
    [k: string]:
      | UpdateProjectProtectionBypassProtectionBypass1
      | UpdateProjectProtectionBypassProtectionBypass2;
  } | undefined;
};

/** @internal */
export const Revoke$inboundSchema: z.ZodType<Revoke, z.ZodTypeDef, unknown> = z
  .object({
    secret: types.string(),
    regenerate: types.boolean(),
  });
/** @internal */
export type Revoke$Outbound = {
  secret: string;
  regenerate: boolean;
};

/** @internal */
export const Revoke$outboundSchema: z.ZodType<
  Revoke$Outbound,
  z.ZodTypeDef,
  Revoke
> = z.object({
  secret: z.string(),
  regenerate: z.boolean(),
});

export function revokeToJSON(revoke: Revoke): string {
  return JSON.stringify(Revoke$outboundSchema.parse(revoke));
}
export function revokeFromJSON(
  jsonString: string,
): SafeParseResult<Revoke, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Revoke$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Revoke' from JSON`,
  );
}

/** @internal */
export const Generate$inboundSchema: z.ZodType<
  Generate,
  z.ZodTypeDef,
  unknown
> = z.object({
  secret: types.optional(types.string()),
  note: types.optional(types.string()),
});
/** @internal */
export type Generate$Outbound = {
  secret?: string | undefined;
  note?: string | undefined;
};

/** @internal */
export const Generate$outboundSchema: z.ZodType<
  Generate$Outbound,
  z.ZodTypeDef,
  Generate
> = z.object({
  secret: z.string().optional(),
  note: z.string().optional(),
});

export function generateToJSON(generate: Generate): string {
  return JSON.stringify(Generate$outboundSchema.parse(generate));
}
export function generateFromJSON(
  jsonString: string,
): SafeParseResult<Generate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Generate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Generate' from JSON`,
  );
}

/** @internal */
export const Update$inboundSchema: z.ZodType<Update, z.ZodTypeDef, unknown> = z
  .object({
    secret: types.string(),
    isEnvVar: types.optional(types.boolean()),
    note: types.optional(types.string()),
  });
/** @internal */
export type Update$Outbound = {
  secret: string;
  isEnvVar?: boolean | undefined;
  note?: string | undefined;
};

/** @internal */
export const Update$outboundSchema: z.ZodType<
  Update$Outbound,
  z.ZodTypeDef,
  Update
> = z.object({
  secret: z.string(),
  isEnvVar: z.boolean().optional(),
  note: z.string().optional(),
});

export function updateToJSON(update: Update): string {
  return JSON.stringify(Update$outboundSchema.parse(update));
}
export function updateFromJSON(
  jsonString: string,
): SafeParseResult<Update, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Update$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Update' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassRequestBody$inboundSchema: z.ZodType<
  UpdateProjectProtectionBypassRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  revoke: types.optional(z.lazy(() => Revoke$inboundSchema)),
  generate: types.optional(z.lazy(() => Generate$inboundSchema)),
  update: types.optional(z.lazy(() => Update$inboundSchema)),
});
/** @internal */
export type UpdateProjectProtectionBypassRequestBody$Outbound = {
  revoke?: Revoke$Outbound | undefined;
  generate?: Generate$Outbound | undefined;
  update?: Update$Outbound | undefined;
};

/** @internal */
export const UpdateProjectProtectionBypassRequestBody$outboundSchema: z.ZodType<
  UpdateProjectProtectionBypassRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateProjectProtectionBypassRequestBody
> = z.object({
  revoke: z.lazy(() => Revoke$outboundSchema).optional(),
  generate: z.lazy(() => Generate$outboundSchema).optional(),
  update: z.lazy(() => Update$outboundSchema).optional(),
});

export function updateProjectProtectionBypassRequestBodyToJSON(
  updateProjectProtectionBypassRequestBody:
    UpdateProjectProtectionBypassRequestBody,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassRequestBody$outboundSchema.parse(
      updateProjectProtectionBypassRequestBody,
    ),
  );
}
export function updateProjectProtectionBypassRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectProtectionBypassRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectProtectionBypassRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassRequest$inboundSchema: z.ZodType<
  UpdateProjectProtectionBypassRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  idOrName: types.string(),
  teamId: types.optional(types.string()),
  slug: types.optional(types.string()),
  RequestBody: z.lazy(() =>
    UpdateProjectProtectionBypassRequestBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateProjectProtectionBypassRequest$Outbound = {
  idOrName: string;
  teamId?: string | undefined;
  slug?: string | undefined;
  RequestBody: UpdateProjectProtectionBypassRequestBody$Outbound;
};

/** @internal */
export const UpdateProjectProtectionBypassRequest$outboundSchema: z.ZodType<
  UpdateProjectProtectionBypassRequest$Outbound,
  z.ZodTypeDef,
  UpdateProjectProtectionBypassRequest
> = z.object({
  idOrName: z.string(),
  teamId: z.string().optional(),
  slug: z.string().optional(),
  requestBody: z.lazy(() =>
    UpdateProjectProtectionBypassRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updateProjectProtectionBypassRequestToJSON(
  updateProjectProtectionBypassRequest: UpdateProjectProtectionBypassRequest,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassRequest$outboundSchema.parse(
      updateProjectProtectionBypassRequest,
    ),
  );
}
export function updateProjectProtectionBypassRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateProjectProtectionBypassRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateProjectProtectionBypassRequest' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass2$inboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    createdAt: types.number(),
    createdBy: types.string(),
    scope: types.literal("automation-bypass"),
    isEnvVar: types.optional(types.boolean()),
    note: types.optional(types.string()),
  });
/** @internal */
export type UpdateProjectProtectionBypassProtectionBypass2$Outbound = {
  createdAt: number;
  createdBy: string;
  scope: "automation-bypass";
  isEnvVar?: boolean | undefined;
  note?: string | undefined;
};

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass2$outboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass2$Outbound,
    z.ZodTypeDef,
    UpdateProjectProtectionBypassProtectionBypass2
  > = z.object({
    createdAt: z.number(),
    createdBy: z.string(),
    scope: z.literal("automation-bypass"),
    isEnvVar: z.boolean().optional(),
    note: z.string().optional(),
  });

export function updateProjectProtectionBypassProtectionBypass2ToJSON(
  updateProjectProtectionBypassProtectionBypass2:
    UpdateProjectProtectionBypassProtectionBypass2,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassProtectionBypass2$outboundSchema.parse(
      updateProjectProtectionBypassProtectionBypass2,
    ),
  );
}
export function updateProjectProtectionBypassProtectionBypass2FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectProtectionBypassProtectionBypass2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassProtectionBypass2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectProtectionBypassProtectionBypass2' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass1$inboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    createdAt: types.number(),
    createdBy: types.string(),
    scope: types.literal("integration-automation-bypass"),
    integrationId: types.string(),
    configurationId: types.string(),
  });
/** @internal */
export type UpdateProjectProtectionBypassProtectionBypass1$Outbound = {
  createdAt: number;
  createdBy: string;
  scope: "integration-automation-bypass";
  integrationId: string;
  configurationId: string;
};

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass1$outboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass1$Outbound,
    z.ZodTypeDef,
    UpdateProjectProtectionBypassProtectionBypass1
  > = z.object({
    createdAt: z.number(),
    createdBy: z.string(),
    scope: z.literal("integration-automation-bypass"),
    integrationId: z.string(),
    configurationId: z.string(),
  });

export function updateProjectProtectionBypassProtectionBypass1ToJSON(
  updateProjectProtectionBypassProtectionBypass1:
    UpdateProjectProtectionBypassProtectionBypass1,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassProtectionBypass1$outboundSchema.parse(
      updateProjectProtectionBypassProtectionBypass1,
    ),
  );
}
export function updateProjectProtectionBypassProtectionBypass1FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectProtectionBypassProtectionBypass1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassProtectionBypass1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectProtectionBypassProtectionBypass1' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass$inboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateProjectProtectionBypassProtectionBypass1$inboundSchema),
    z.lazy(() => UpdateProjectProtectionBypassProtectionBypass2$inboundSchema),
  ]);
/** @internal */
export type UpdateProjectProtectionBypassProtectionBypass$Outbound =
  | UpdateProjectProtectionBypassProtectionBypass1$Outbound
  | UpdateProjectProtectionBypassProtectionBypass2$Outbound;

/** @internal */
export const UpdateProjectProtectionBypassProtectionBypass$outboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassProtectionBypass$Outbound,
    z.ZodTypeDef,
    UpdateProjectProtectionBypassProtectionBypass
  > = z.union([
    z.lazy(() => UpdateProjectProtectionBypassProtectionBypass1$outboundSchema),
    z.lazy(() => UpdateProjectProtectionBypassProtectionBypass2$outboundSchema),
  ]);

export function updateProjectProtectionBypassProtectionBypassToJSON(
  updateProjectProtectionBypassProtectionBypass:
    UpdateProjectProtectionBypassProtectionBypass,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassProtectionBypass$outboundSchema.parse(
      updateProjectProtectionBypassProtectionBypass,
    ),
  );
}
export function updateProjectProtectionBypassProtectionBypassFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectProtectionBypassProtectionBypass,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassProtectionBypass$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectProtectionBypassProtectionBypass' from JSON`,
  );
}

/** @internal */
export const UpdateProjectProtectionBypassResponseBody$inboundSchema: z.ZodType<
  UpdateProjectProtectionBypassResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  protectionBypass: types.optional(
    z.record(z.union([
      z.lazy(() =>
        UpdateProjectProtectionBypassProtectionBypass1$inboundSchema
      ),
      z.lazy(() =>
        UpdateProjectProtectionBypassProtectionBypass2$inboundSchema
      ),
    ])),
  ),
});
/** @internal */
export type UpdateProjectProtectionBypassResponseBody$Outbound = {
  protectionBypass?: {
    [k: string]:
      | UpdateProjectProtectionBypassProtectionBypass1$Outbound
      | UpdateProjectProtectionBypassProtectionBypass2$Outbound;
  } | undefined;
};

/** @internal */
export const UpdateProjectProtectionBypassResponseBody$outboundSchema:
  z.ZodType<
    UpdateProjectProtectionBypassResponseBody$Outbound,
    z.ZodTypeDef,
    UpdateProjectProtectionBypassResponseBody
  > = z.object({
    protectionBypass: z.record(
      z.union([
        z.lazy(() =>
          UpdateProjectProtectionBypassProtectionBypass1$outboundSchema
        ),
        z.lazy(() =>
          UpdateProjectProtectionBypassProtectionBypass2$outboundSchema
        ),
      ]),
    ).optional(),
  });

export function updateProjectProtectionBypassResponseBodyToJSON(
  updateProjectProtectionBypassResponseBody:
    UpdateProjectProtectionBypassResponseBody,
): string {
  return JSON.stringify(
    UpdateProjectProtectionBypassResponseBody$outboundSchema.parse(
      updateProjectProtectionBypassResponseBody,
    ),
  );
}
export function updateProjectProtectionBypassResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateProjectProtectionBypassResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateProjectProtectionBypassResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateProjectProtectionBypassResponseBody' from JSON`,
  );
}
